var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x4) => x4.done ? resolve(x4.value) : Promise.resolve(x4.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/@angular/core/fesm2022/primitives/signals.mjs
function defaultEquals(a, b) {
  return Object.is(a, b);
}
var activeConsumer = null;
var inNotificationPhase = false;
var epoch = 1;
var SIGNAL = /* @__PURE__ */ Symbol("SIGNAL");
function setActiveConsumer(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
function getActiveConsumer() {
  return activeConsumer;
}
var REACTIVE_NODE = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: false,
  producerNode: void 0,
  producerLastReadVersion: void 0,
  producerIndexOfThis: void 0,
  nextProducerIndex: 0,
  liveConsumerNode: void 0,
  liveConsumerIndexOfThis: void 0,
  consumerAllowSignalWrites: false,
  consumerIsAlwaysLive: false,
  producerMustRecompute: () => false,
  producerRecomputeValue: () => {
  },
  consumerMarkedDirty: () => {
  },
  consumerOnSignalRead: () => {
  }
};
function producerAccessed(node) {
  if (inNotificationPhase) {
    throw new Error(typeof ngDevMode !== "undefined" && ngDevMode ? `Assertion error: signal read during notification phase` : "");
  }
  if (activeConsumer === null) {
    return;
  }
  activeConsumer.consumerOnSignalRead(node);
  const idx = activeConsumer.nextProducerIndex++;
  assertConsumerNode(activeConsumer);
  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {
    if (consumerIsLive(activeConsumer)) {
      const staleProducer = activeConsumer.producerNode[idx];
      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);
    }
  }
  if (activeConsumer.producerNode[idx] !== node) {
    activeConsumer.producerNode[idx] = node;
    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;
  }
  activeConsumer.producerLastReadVersion[idx] = node.version;
}
function producerIncrementEpoch() {
  epoch++;
}
function producerUpdateValueVersion(node) {
  if (consumerIsLive(node) && !node.dirty) {
    return;
  }
  if (!node.dirty && node.lastCleanEpoch === epoch) {
    return;
  }
  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
    producerMarkClean(node);
    return;
  }
  node.producerRecomputeValue(node);
  producerMarkClean(node);
}
function producerNotifyConsumers(node) {
  if (node.liveConsumerNode === void 0) {
    return;
  }
  const prev = inNotificationPhase;
  inNotificationPhase = true;
  try {
    for (const consumer of node.liveConsumerNode) {
      if (!consumer.dirty) {
        consumerMarkDirty(consumer);
      }
    }
  } finally {
    inNotificationPhase = prev;
  }
}
function producerUpdatesAllowed() {
  return activeConsumer?.consumerAllowSignalWrites !== false;
}
function consumerMarkDirty(node) {
  node.dirty = true;
  producerNotifyConsumers(node);
  node.consumerMarkedDirty?.(node);
}
function producerMarkClean(node) {
  node.dirty = false;
  node.lastCleanEpoch = epoch;
}
function consumerBeforeComputation(node) {
  node && (node.nextProducerIndex = 0);
  return setActiveConsumer(node);
}
function consumerAfterComputation(node, prevConsumer) {
  setActiveConsumer(prevConsumer);
  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {
    return;
  }
  if (consumerIsLive(node)) {
    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  while (node.producerNode.length > node.nextProducerIndex) {
    node.producerNode.pop();
    node.producerLastReadVersion.pop();
    node.producerIndexOfThis.pop();
  }
}
function consumerPollProducersForChange(node) {
  assertConsumerNode(node);
  for (let i = 0; i < node.producerNode.length; i++) {
    const producer = node.producerNode[i];
    const seenVersion = node.producerLastReadVersion[i];
    if (seenVersion !== producer.version) {
      return true;
    }
    producerUpdateValueVersion(producer);
    if (seenVersion !== producer.version) {
      return true;
    }
  }
  return false;
}
function consumerDestroy(node) {
  assertConsumerNode(node);
  if (consumerIsLive(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;
  if (node.liveConsumerNode) {
    node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;
  }
}
function producerAddLiveConsumer(node, consumer, indexOfThis) {
  assertProducerNode(node);
  if (node.liveConsumerNode.length === 0 && isConsumerNode(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);
    }
  }
  node.liveConsumerIndexOfThis.push(indexOfThis);
  return node.liveConsumerNode.push(consumer) - 1;
}
function producerRemoveLiveConsumerAtIndex(node, idx) {
  assertProducerNode(node);
  if (typeof ngDevMode !== "undefined" && ngDevMode && idx >= node.liveConsumerNode.length) {
    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);
  }
  if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {
    for (let i = 0; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  const lastIdx = node.liveConsumerNode.length - 1;
  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];
  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];
  node.liveConsumerNode.length--;
  node.liveConsumerIndexOfThis.length--;
  if (idx < node.liveConsumerNode.length) {
    const idxProducer = node.liveConsumerIndexOfThis[idx];
    const consumer = node.liveConsumerNode[idx];
    assertConsumerNode(consumer);
    consumer.producerIndexOfThis[idxProducer] = idx;
  }
}
function consumerIsLive(node) {
  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;
}
function assertConsumerNode(node) {
  node.producerNode ??= [];
  node.producerIndexOfThis ??= [];
  node.producerLastReadVersion ??= [];
}
function assertProducerNode(node) {
  node.liveConsumerNode ??= [];
  node.liveConsumerIndexOfThis ??= [];
}
function isConsumerNode(node) {
  return node.producerNode !== void 0;
}
function createComputed(computation) {
  const node = Object.create(COMPUTED_NODE);
  node.computation = computation;
  const computed2 = () => {
    producerUpdateValueVersion(node);
    producerAccessed(node);
    if (node.value === ERRORED) {
      throw node.error;
    }
    return node.value;
  };
  computed2[SIGNAL] = node;
  return computed2;
}
var UNSET = /* @__PURE__ */ Symbol("UNSET");
var COMPUTING = /* @__PURE__ */ Symbol("COMPUTING");
var ERRORED = /* @__PURE__ */ Symbol("ERRORED");
var COMPUTED_NODE = /* @__PURE__ */ (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
    value: UNSET,
    dirty: true,
    error: null,
    equal: defaultEquals,
    producerMustRecompute(node) {
      return node.value === UNSET || node.value === COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === COMPUTING) {
        throw new Error("Detected cycle in computations.");
      }
      const oldValue = node.value;
      node.value = COMPUTING;
      const prevConsumer = consumerBeforeComputation(node);
      let newValue;
      try {
        newValue = node.computation();
      } catch (err) {
        newValue = ERRORED;
        node.error = err;
      } finally {
        consumerAfterComputation(node, prevConsumer);
      }
      if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue)) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  });
})();
function defaultThrowError() {
  throw new Error();
}
var throwInvalidWriteToSignalErrorFn = defaultThrowError;
function throwInvalidWriteToSignalError() {
  throwInvalidWriteToSignalErrorFn();
}
function setThrowInvalidWriteToSignalError(fn) {
  throwInvalidWriteToSignalErrorFn = fn;
}
var postSignalSetFn = null;
function createSignal(initialValue) {
  const node = Object.create(SIGNAL_NODE);
  node.value = initialValue;
  const getter = () => {
    producerAccessed(node);
    return node.value;
  };
  getter[SIGNAL] = node;
  return getter;
}
function signalSetFn(node, newValue) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError();
  }
  if (!node.equal(node.value, newValue)) {
    node.value = newValue;
    signalValueChanged(node);
  }
}
function signalUpdateFn(node, updater) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError();
  }
  signalSetFn(node, updater(node.value));
}
var SIGNAL_NODE = /* @__PURE__ */ (() => {
  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {
    equal: defaultEquals,
    value: void 0
  });
})();
function signalValueChanged(node) {
  node.version++;
  producerIncrementEpoch();
  producerNotifyConsumers(node);
  postSignalSetFn?.();
}

// node_modules/rxjs/dist/esm/internal/util/isFunction.js
function isFunction(value2) {
  return typeof value2 === "function";
}

// node_modules/rxjs/dist/esm/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  const _super = (instance) => {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  const ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {
  _super(this);
  this.message = errors ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join("\n  ")}` : "";
  this.name = "UnsubscriptionError";
  this.errors = errors;
});

// node_modules/rxjs/dist/esm/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    const index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm/internal/Subscription.js
var Subscription = class _Subscription {
  constructor(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  unsubscribe() {
    let errors;
    if (!this.closed) {
      this.closed = true;
      const {
        _parentage
      } = this;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          for (const parent of _parentage) {
            parent.remove(this);
          }
        } else {
          _parentage.remove(this);
        }
      }
      const {
        initialTeardown: initialFinalizer
      } = this;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      const {
        _finalizers
      } = this;
      if (_finalizers) {
        this._finalizers = null;
        for (const finalizer of _finalizers) {
          try {
            execFinalizer(finalizer);
          } catch (err) {
            errors = errors !== null && errors !== void 0 ? errors : [];
            if (err instanceof UnsubscriptionError) {
              errors = [...errors, ...err.errors];
            } else {
              errors.push(err);
            }
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  }
  add(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof _Subscription) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  }
  _hasParent(parent) {
    const {
      _parentage
    } = this;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  }
  _addParent(parent) {
    const {
      _parentage
    } = this;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  }
  _removeParent(parent) {
    const {
      _parentage
    } = this;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  }
  remove(teardown) {
    const {
      _finalizers
    } = this;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof _Subscription) {
      teardown._removeParent(this);
    }
  }
};
Subscription.EMPTY = (() => {
  const empty3 = new Subscription();
  empty3.closed = true;
  return empty3;
})();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value2) {
  return value2 instanceof Subscription || value2 && "closed" in value2 && isFunction(value2.remove) && isFunction(value2.add) && isFunction(value2.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout(handler, timeout2, ...args) {
    const {
      delegate
    } = timeoutProvider;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout(handler, timeout2, ...args);
    }
    return setTimeout(handler, timeout2, ...args);
  },
  clearTimeout(handle) {
    const {
      delegate
    } = timeoutProvider;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(() => {
    const {
      onUnhandledError
    } = config;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = (() => createNotification("C", void 0, void 0))();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value2) {
  return createNotification("N", value2, void 0);
}
function createNotification(kind, value2, error) {
  return {
    kind,
    value: value2,
    error
  };
}

// node_modules/rxjs/dist/esm/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    const isRoot = !context;
    if (isRoot) {
      context = {
        errorThrown: false,
        error: null
      };
    }
    cb();
    if (isRoot) {
      const {
        errorThrown,
        error
      } = context;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm/internal/Subscriber.js
var Subscriber = class extends Subscription {
  constructor(destination) {
    super();
    this.isStopped = false;
    if (destination) {
      this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(this);
      }
    } else {
      this.destination = EMPTY_OBSERVER;
    }
  }
  static create(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  }
  next(value2) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value2), this);
    } else {
      this._next(value2);
    }
  }
  error(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  }
  complete() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  }
  unsubscribe() {
    if (!this.closed) {
      this.isStopped = true;
      super.unsubscribe();
      this.destination = null;
    }
  }
  _next(value2) {
    this.destination.next(value2);
  }
  _error(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  }
  _complete() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }
};
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = class {
  constructor(partialObserver) {
    this.partialObserver = partialObserver;
  }
  next(value2) {
    const {
      partialObserver
    } = this;
    if (partialObserver.next) {
      try {
        partialObserver.next(value2);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  }
  error(err) {
    const {
      partialObserver
    } = this;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  }
  complete() {
    const {
      partialObserver
    } = this;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  }
};
var SafeSubscriber = class extends Subscriber {
  constructor(observerOrNext, error, complete) {
    super();
    let partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      let context2;
      if (this && config.useDeprecatedNextContext) {
        context2 = Object.create(observerOrNext);
        context2.unsubscribe = () => this.unsubscribe();
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context2),
          error: observerOrNext.error && bind(observerOrNext.error, context2),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context2)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    this.destination = new ConsumerObserver(partialObserver);
  }
};
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  const {
    onStoppedNotification
  } = config;
  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm/internal/symbol/observable.js
var observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();

// node_modules/rxjs/dist/esm/internal/util/identity.js
function identity(x4) {
  return x4;
}

// node_modules/rxjs/dist/esm/internal/util/pipe.js
function pipe(...fns) {
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input2) {
    return fns.reduce((prev, fn) => fn(prev), input2);
  };
}

// node_modules/rxjs/dist/esm/internal/Observable.js
var Observable = class _Observable {
  constructor(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  lift(operator) {
    const observable2 = new _Observable();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  }
  subscribe(observerOrNext, error, complete) {
    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(() => {
      const {
        operator,
        source
      } = this;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));
    });
    return subscriber;
  }
  _trySubscribe(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  }
  forEach(next, promiseCtor) {
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor((resolve, reject) => {
      const subscriber = new SafeSubscriber({
        next: (value2) => {
          try {
            next(value2);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      this.subscribe(subscriber);
    });
  }
  _subscribe(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  }
  [observable]() {
    return this;
  }
  pipe(...operations) {
    return pipeFromArray(operations)(this);
  }
  toPromise(promiseCtor) {
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor((resolve, reject) => {
      let value2;
      this.subscribe((x4) => value2 = x4, (err) => reject(err), () => resolve(value2));
    });
  }
};
Observable.create = (subscribe) => {
  return new Observable(subscribe);
};
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value2) {
  return value2 && isFunction(value2.next) && isFunction(value2.error) && isFunction(value2.complete);
}
function isSubscriber(value2) {
  return value2 && value2 instanceof Subscriber || isObserver(value2) && isSubscription(value2);
}

// node_modules/rxjs/dist/esm/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init2) {
  return (source) => {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init2(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = class extends Subscriber {
  constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    super(destination);
    this.onFinalize = onFinalize;
    this.shouldUnsubscribe = shouldUnsubscribe;
    this._next = onNext ? function(value2) {
      try {
        onNext(value2);
      } catch (err) {
        destination.error(err);
      }
    } : super._next;
    this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : super._error;
    this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : super._complete;
  }
  unsubscribe() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      const {
        closed
      } = this;
      super.unsubscribe();
      !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  }
};

// node_modules/rxjs/dist/esm/internal/operators/refCount.js
function refCount() {
  return operate((source, subscriber) => {
    let connection = null;
    source._refCount++;
    const refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, () => {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      const sharedConnection = source._connection;
      const conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm/internal/observable/ConnectableObservable.js
var ConnectableObservable = class extends Observable {
  constructor(source, subjectFactory) {
    super();
    this.source = source;
    this.subjectFactory = subjectFactory;
    this._subject = null;
    this._refCount = 0;
    this._connection = null;
    if (hasLift(source)) {
      this.lift = source.lift;
    }
  }
  _subscribe(subscriber) {
    return this.getSubject().subscribe(subscriber);
  }
  getSubject() {
    const subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  }
  _teardown() {
    this._refCount = 0;
    const {
      _connection
    } = this;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  }
  connect() {
    let connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      const subject = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject, void 0, () => {
        this._teardown();
        subject.complete();
      }, (err) => {
        this._teardown();
        subject.error(err);
      }, () => this._teardown())));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  }
  refCount() {
    return refCount()(this);
  }
};

// node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {
  _super(this);
  this.name = "ObjectUnsubscribedError";
  this.message = "object unsubscribed";
});

// node_modules/rxjs/dist/esm/internal/Subject.js
var Subject = class extends Observable {
  constructor() {
    super();
    this.closed = false;
    this.currentObservers = null;
    this.observers = [];
    this.isStopped = false;
    this.hasError = false;
    this.thrownError = null;
  }
  lift(operator) {
    const subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  }
  _throwIfClosed() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  }
  next(value2) {
    errorContext(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        if (!this.currentObservers) {
          this.currentObservers = Array.from(this.observers);
        }
        for (const observer of this.currentObservers) {
          observer.next(value2);
        }
      }
    });
  }
  error(err) {
    errorContext(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        this.hasError = this.isStopped = true;
        this.thrownError = err;
        const {
          observers
        } = this;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  }
  complete() {
    errorContext(() => {
      this._throwIfClosed();
      if (!this.isStopped) {
        this.isStopped = true;
        const {
          observers
        } = this;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  }
  unsubscribe() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  }
  get observed() {
    var _a;
    return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
  }
  _trySubscribe(subscriber) {
    this._throwIfClosed();
    return super._trySubscribe(subscriber);
  }
  _subscribe(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  }
  _innerSubscribe(subscriber) {
    const {
      hasError,
      isStopped,
      observers
    } = this;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(() => {
      this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  }
  _checkFinalizedStatuses(subscriber) {
    const {
      hasError,
      thrownError,
      isStopped
    } = this;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  }
  asObservable() {
    const observable2 = new Observable();
    observable2.source = this;
    return observable2;
  }
};
Subject.create = (destination, source) => {
  return new AnonymousSubject(destination, source);
};
var AnonymousSubject = class extends Subject {
  constructor(destination, source) {
    super();
    this.destination = destination;
    this.source = source;
  }
  next(value2) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value2);
  }
  error(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  }
  complete() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  _subscribe(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  }
};

// node_modules/rxjs/dist/esm/internal/BehaviorSubject.js
var BehaviorSubject = class extends Subject {
  constructor(_value) {
    super();
    this._value = _value;
  }
  get value() {
    return this.getValue();
  }
  _subscribe(subscriber) {
    const subscription = super._subscribe(subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  }
  getValue() {
    const {
      hasError,
      thrownError,
      _value
    } = this;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  }
  next(value2) {
    super.next(this._value = value2);
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/scheduler/Action.js
var Action = class extends Subscription {
  constructor(scheduler, work) {
    super();
  }
  schedule(state2, delay = 0) {
    return this;
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval(handler, timeout2, ...args) {
    const {
      delegate
    } = intervalProvider;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval(handler, timeout2, ...args);
    }
    return setInterval(handler, timeout2, ...args);
  },
  clearInterval(handle) {
    const {
      delegate
    } = intervalProvider;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm/internal/scheduler/AsyncAction.js
var AsyncAction = class extends Action {
  constructor(scheduler, work) {
    super(scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
    this.pending = false;
  }
  schedule(state2, delay = 0) {
    var _a;
    if (this.closed) {
      return this;
    }
    this.state = state2;
    const id3 = this.id;
    const scheduler = this.scheduler;
    if (id3 != null) {
      this.id = this.recycleAsyncId(scheduler, id3, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
    return this;
  }
  requestAsyncId(scheduler, _id, delay = 0) {
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
  }
  recycleAsyncId(_scheduler, id3, delay = 0) {
    if (delay != null && this.delay === delay && this.pending === false) {
      return id3;
    }
    if (id3 != null) {
      intervalProvider.clearInterval(id3);
    }
    return void 0;
  }
  execute(state2, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    const error = this._execute(state2, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  }
  _execute(state2, _delay) {
    let errored = false;
    let errorValue;
    try {
      this.work(state2);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  }
  unsubscribe() {
    if (!this.closed) {
      const {
        id: id3,
        scheduler
      } = this;
      const {
        actions
      } = scheduler;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id3 != null) {
        this.id = this.recycleAsyncId(scheduler, id3, null);
      }
      this.delay = null;
      super.unsubscribe();
    }
  }
};

// node_modules/rxjs/dist/esm/internal/Scheduler.js
var Scheduler = class _Scheduler {
  constructor(schedulerActionCtor, now2 = _Scheduler.now) {
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  schedule(work, delay = 0, state2) {
    return new this.schedulerActionCtor(this, work).schedule(state2, delay);
  }
};
Scheduler.now = dateTimestampProvider.now;

// node_modules/rxjs/dist/esm/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = class extends Scheduler {
  constructor(SchedulerAction, now2 = Scheduler.now) {
    super(SchedulerAction, now2);
    this.actions = [];
    this._active = false;
  }
  flush(action) {
    const {
      actions
    } = this;
    if (this._active) {
      actions.push(action);
      return;
    }
    let error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  }
};

// node_modules/rxjs/dist/esm/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm/internal/observable/empty.js
var EMPTY = new Observable((subscriber) => subscriber.complete());

// node_modules/rxjs/dist/esm/internal/util/isScheduler.js
function isScheduler(value2) {
  return value2 && isFunction(value2.schedule);
}

// node_modules/rxjs/dist/esm/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// node_modules/tslib/tslib.es6.mjs
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o2[s2], i = 0;
  if (m) return m.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i >= o2.length) o2 = void 0;
      return {
        value: o2 && o2[i++],
        done: !o2
      };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g2[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g2[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value2) {
    resume("next", value2);
  }
  function reject(value2) {
    resume("throw", value2);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o2[Symbol.asyncIterator], i;
  return m ? m.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o2[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o2[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({
        value: v2,
        done: d
      });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm/internal/util/isArrayLike.js
var isArrayLike = (x4) => x4 && typeof x4.length === "number" && typeof x4 !== "function";

// node_modules/rxjs/dist/esm/internal/util/isPromise.js
function isPromise(value2) {
  return isFunction(value2 === null || value2 === void 0 ? void 0 : value2.then);
}

// node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js
function isInteropObservable(input2) {
  return isFunction(input2[observable]);
}

// node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input2) {
  return new TypeError(`You provided ${input2 !== null && typeof input2 === "object" ? "an invalid object" : `'${input2}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);
}

// node_modules/rxjs/dist/esm/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm/internal/util/isIterable.js
function isIterable(input2) {
  return isFunction(input2 === null || input2 === void 0 ? void 0 : input2[iterator]);
}

// node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {
    const reader = readableStream.getReader();
    try {
      while (true) {
        const {
          value: value2,
          done
        } = yield __await(reader.read());
        if (done) {
          return yield __await(void 0);
        }
        yield yield __await(value2);
      }
    } finally {
      reader.releaseLock();
    }
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm/internal/observable/innerFrom.js
function innerFrom(input2) {
  if (input2 instanceof Observable) {
    return input2;
  }
  if (input2 != null) {
    if (isInteropObservable(input2)) {
      return fromInteropObservable(input2);
    }
    if (isArrayLike(input2)) {
      return fromArrayLike(input2);
    }
    if (isPromise(input2)) {
      return fromPromise(input2);
    }
    if (isAsyncIterable(input2)) {
      return fromAsyncIterable(input2);
    }
    if (isIterable(input2)) {
      return fromIterable(input2);
    }
    if (isReadableStreamLike(input2)) {
      return fromReadableStreamLike(input2);
    }
  }
  throw createInvalidObservableTypeError(input2);
}
function fromInteropObservable(obj) {
  return new Observable((subscriber) => {
    const obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array2) {
  return new Observable((subscriber) => {
    for (let i = 0; i < array2.length && !subscriber.closed; i++) {
      subscriber.next(array2[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable((subscriber) => {
    promise.then((value2) => {
      if (!subscriber.closed) {
        subscriber.next(value2);
        subscriber.complete();
      }
    }, (err) => subscriber.error(err)).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable((subscriber) => {
    for (const value2 of iterable) {
      subscriber.next(value2);
      if (subscriber.closed) {
        return;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable((subscriber) => {
    process2(asyncIterable, subscriber).catch((err) => subscriber.error(err));
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_1, _a;
  return __awaiter(this, void 0, void 0, function* () {
    try {
      for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done; ) {
        const value2 = asyncIterable_1_1.value;
        subscriber.next(value2);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)) yield _a.call(asyncIterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}

// node_modules/rxjs/dist/esm/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {
  const scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm/internal/operators/observeOn.js
function observeOn(scheduler, delay = 0) {
  return operate((source, subscriber) => {
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => executeSchedule(subscriber, scheduler, () => subscriber.next(value2), delay), () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay), (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay = 0) {
  return operate((source, subscriber) => {
    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js
function scheduleObservable(input2, scheduler) {
  return innerFrom(input2).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js
function schedulePromise(input2, scheduler) {
  return innerFrom(input2).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js
function scheduleArray(input2, scheduler) {
  return new Observable((subscriber) => {
    let i = 0;
    return scheduler.schedule(function() {
      if (i === input2.length) {
        subscriber.complete();
      } else {
        subscriber.next(input2[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js
function scheduleIterable(input2, scheduler) {
  return new Observable((subscriber) => {
    let iterator2;
    executeSchedule(subscriber, scheduler, () => {
      iterator2 = input2[iterator]();
      executeSchedule(subscriber, scheduler, () => {
        let value2;
        let done;
        try {
          ({
            value: value2,
            done
          } = iterator2.next());
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value2);
        }
      }, 0, true);
    });
    return () => isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input2, scheduler) {
  if (!input2) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable((subscriber) => {
    executeSchedule(subscriber, scheduler, () => {
      const iterator2 = input2[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, () => {
        iterator2.next().then((result) => {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input2, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input2), scheduler);
}

// node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js
function scheduled(input2, scheduler) {
  if (input2 != null) {
    if (isInteropObservable(input2)) {
      return scheduleObservable(input2, scheduler);
    }
    if (isArrayLike(input2)) {
      return scheduleArray(input2, scheduler);
    }
    if (isPromise(input2)) {
      return schedulePromise(input2, scheduler);
    }
    if (isAsyncIterable(input2)) {
      return scheduleAsyncIterable(input2, scheduler);
    }
    if (isIterable(input2)) {
      return scheduleIterable(input2, scheduler);
    }
    if (isReadableStreamLike(input2)) {
      return scheduleReadableStreamLike(input2, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input2);
}

// node_modules/rxjs/dist/esm/internal/observable/from.js
function from(input2, scheduler) {
  return scheduler ? scheduled(input2, scheduler) : innerFrom(input2);
}

// node_modules/rxjs/dist/esm/internal/observable/of.js
function of(...args) {
  const scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;
  const init2 = (subscriber) => subscriber.error(errorFactory());
  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init2, 0, subscriber) : init2);
}

// node_modules/rxjs/dist/esm/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
}

// node_modules/rxjs/dist/esm/internal/util/EmptyError.js
var EmptyError = createErrorClass((_super) => function EmptyErrorImpl() {
  _super(this);
  this.name = "EmptyError";
  this.message = "no elements in sequence";
});

// node_modules/rxjs/dist/esm/internal/util/isDate.js
function isValidDate(value2) {
  return value2 instanceof Date && !isNaN(value2);
}

// node_modules/rxjs/dist/esm/internal/operators/map.js
function map(project, thisArg) {
  return operate((source, subscriber) => {
    let index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
      subscriber.next(project.call(thisArg, value2, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js
var {
  isArray
} = Array;
function callOrApply(fn, args) {
  return isArray(args) ? fn(...args) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map((args) => callOrApply(fn, args));
}

// node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js
var {
  isArray: isArray2
} = Array;
var {
  getPrototypeOf,
  prototype: objectProto,
  keys: getKeys
} = Object;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    const first2 = args[0];
    if (isArray2(first2)) {
      return {
        args: first2,
        keys: null
      };
    }
    if (isPOJO(first2)) {
      const keys = getKeys(first2);
      return {
        args: keys.map((key) => first2[key]),
        keys
      };
    }
  }
  return {
    args,
    keys: null
  };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce((result, key, i) => (result[key] = values[i], result), {});
}

// node_modules/rxjs/dist/esm/internal/observable/combineLatest.js
function combineLatest(...args) {
  const scheduler = popScheduler(args);
  const resultSelector = popResultSelector(args);
  const {
    args: observables,
    keys
  } = argsArgArrayOrObject(args);
  if (observables.length === 0) {
    return from([], scheduler);
  }
  const result = new Observable(combineLatestInit(observables, scheduler, keys ? (values) => createObject(keys, values) : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform = identity) {
  return (subscriber) => {
    maybeSchedule(scheduler, () => {
      const {
        length
      } = observables;
      const values = new Array(length);
      let active = length;
      let remainingFirstValues = length;
      for (let i = 0; i < length; i++) {
        maybeSchedule(scheduler, () => {
          const source = from(observables[i], scheduler);
          let hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
            values[i] = value2;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, () => {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  const buffer = [];
  let active = 0;
  let index = 0;
  let isComplete = false;
  const checkComplete = () => {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  const outerNext = (value2) => active < concurrent ? doInnerSub(value2) : buffer.push(value2);
  const doInnerSub = (value2) => {
    expand && subscriber.next(value2);
    active++;
    let innerComplete = false;
    innerFrom(project(value2, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, () => {
      innerComplete = true;
    }, void 0, () => {
      if (innerComplete) {
        try {
          active--;
          while (buffer.length && active < concurrent) {
            const bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));
            } else {
              doInnerSub(bufferedValue);
            }
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {
    isComplete = true;
    checkComplete();
  }));
  return () => {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent = Infinity) {
  if (isFunction(resultSelector)) {
    return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));
}

// node_modules/rxjs/dist/esm/internal/operators/mergeAll.js
function mergeAll(concurrent = Infinity) {
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm/internal/observable/concat.js
function concat(...args) {
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable((subscriber) => {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm/internal/observable/forkJoin.js
function forkJoin(...args) {
  const resultSelector = popResultSelector(args);
  const {
    args: sources,
    keys
  } = argsArgArrayOrObject(args);
  const result = new Observable((subscriber) => {
    const {
      length
    } = sources;
    if (!length) {
      subscriber.complete();
      return;
    }
    const values = new Array(length);
    let remainingCompletions = length;
    let remainingEmissions = length;
    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      let hasValue = false;
      innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, (value2) => {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex] = value2;
      }, () => remainingCompletions--, void 0, () => {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? createObject(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}

// node_modules/rxjs/dist/esm/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  const [add, remove3] = isEventTarget(target) ? eventTargetMethods.map((methodName) => (handler) => target[methodName](eventName, handler, options)) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap((subTarget) => fromEvent(subTarget, eventName, options))(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable((subscriber) => {
    const handler = (...args) => subscriber.next(1 < args.length ? args : args[0]);
    add(handler);
    return () => remove3(handler);
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return (methodName) => (handler) => target[methodName](eventName, handler);
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

// node_modules/rxjs/dist/esm/internal/observable/timer.js
function timer(dueTime = 0, intervalOrScheduler, scheduler = async) {
  let intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable((subscriber) => {
    let due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    let n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate((source, subscriber) => {
    let index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => predicate.call(thisArg, value2, index++) && subscriber.next(value2)));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/catchError.js
function catchError(selector) {
  return operate((source, subscriber) => {
    let innerSub = null;
    let syncUnsub = false;
    let handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, (err) => {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return (source, subscriber) => {
    let hasState = hasSeed;
    let state2 = seed;
    let index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
      const i = index++;
      state2 = hasState ? accumulator(state2, value2, i) : (hasState = true, value2);
      emitOnNext && subscriber.next(state2);
    }, emitBeforeComplete && (() => {
      hasState && subscriber.next(state2);
      subscriber.complete();
    })));
  };
}

// node_modules/rxjs/dist/esm/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}

// node_modules/rxjs/dist/esm/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler = asyncScheduler) {
  return operate((source, subscriber) => {
    let activeTask = null;
    let lastValue = null;
    let lastTime = null;
    const emit = () => {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        const value2 = lastValue;
        lastValue = null;
        subscriber.next(value2);
      }
    };
    function emitWhenIdle() {
      const targetTime = lastTime + dueTime;
      const now2 = scheduler.now();
      if (now2 < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now2);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
      lastValue = value2;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, () => {
      emit();
      subscriber.complete();
    }, void 0, () => {
      lastValue = activeTask = null;
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  return operate((source, subscriber) => {
    let hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
      hasValue = true;
      subscriber.next(value2);
    }, () => {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/take.js
function take(count3) {
  return count3 <= 0 ? () => EMPTY : operate((source, subscriber) => {
    let seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
      if (++seen <= count3) {
        subscriber.next(value2);
        if (count3 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/mapTo.js
function mapTo(value2) {
  return map(() => value2);
}

// node_modules/rxjs/dist/esm/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory = defaultErrorFactory) {
  return operate((source, subscriber) => {
    let hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
      hasValue = true;
      subscriber.next(value2);
    }, () => hasValue ? subscriber.complete() : subscriber.error(errorFactory())));
  });
}
function defaultErrorFactory() {
  return new EmptyError();
}

// node_modules/rxjs/dist/esm/internal/operators/finalize.js
function finalize(callback) {
  return operate((source, subscriber) => {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

// node_modules/rxjs/dist/esm/internal/operators/first.js
function first(predicate, defaultValue) {
  const hasDefaultValue = arguments.length >= 2;
  return (source) => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));
}

// node_modules/rxjs/dist/esm/internal/operators/takeLast.js
function takeLast(count3) {
  return count3 <= 0 ? () => EMPTY : operate((source, subscriber) => {
    let buffer = [];
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
      buffer.push(value2);
      count3 < buffer.length && buffer.shift();
    }, () => {
      for (const value2 of buffer) {
        subscriber.next(value2);
      }
      subscriber.complete();
    }, void 0, () => {
      buffer = null;
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/last.js
function last2(predicate, defaultValue) {
  const hasDefaultValue = arguments.length >= 2;
  return (source) => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));
}

// node_modules/rxjs/dist/esm/internal/operators/retry.js
function retry(configOrCount = Infinity) {
  let config3;
  if (configOrCount && typeof configOrCount === "object") {
    config3 = configOrCount;
  } else {
    config3 = {
      count: configOrCount
    };
  }
  const {
    count: count3 = Infinity,
    delay,
    resetOnSuccess = false
  } = config3;
  return count3 <= 0 ? identity : operate((source, subscriber) => {
    let soFar = 0;
    let innerSub;
    const subscribeForRetry = () => {
      let syncUnsub = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value2);
      }, void 0, (err) => {
        if (soFar++ < count3) {
          const resub = () => {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay != null) {
            const notifier = typeof delay === "number" ? timer(delay) : innerFrom(delay(err, soFar));
            const notifierSubscriber = createOperatorSubscriber(subscriber, () => {
              notifierSubscriber.unsubscribe();
              resub();
            }, () => {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber);
          } else {
            resub();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}

// node_modules/rxjs/dist/esm/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

// node_modules/rxjs/dist/esm/internal/operators/startWith.js
function startWith(...values) {
  const scheduler = popScheduler(values);
  return operate((source, subscriber) => {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate((source, subscriber) => {
    let innerSubscriber = null;
    let index = 0;
    let isComplete = false;
    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      let innerIndex = 0;
      const outerIndex = index++;
      innerFrom(project(value2, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value2, innerValue, outerIndex, innerIndex++) : innerValue), () => {
        innerSubscriber = null;
        checkComplete();
      }));
    }, () => {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate((source, subscriber) => {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  const tapObserver = isFunction(observerOrNext) || error || complete ? {
    next: observerOrNext,
    error,
    complete
  } : observerOrNext;
  return tapObserver ? operate((source, subscriber) => {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    let isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, (value2) => {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value2);
      subscriber.next(value2);
    }, () => {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, (err) => {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, () => {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/@angular/core/fesm2022/core.mjs
var ERROR_DETAILS_PAGE_BASE_URL = "https://angular.dev/errors";
var XSS_SECURITY_URL = "https://g.co/ng/security#xss";
var RuntimeError = class extends Error {
  code;
  constructor(code, message) {
    super(formatRuntimeError(code, message));
    this.code = code;
  }
};
function formatRuntimeError(code, message) {
  const fullCode = `NG0${Math.abs(code)}`;
  let errorMessage = `${fullCode}${message ? ": " + message : ""}`;
  if (ngDevMode && code < 0) {
    const addPeriodSeparator = !errorMessage.match(/[.,;!?\n]$/);
    const separator = addPeriodSeparator ? "." : "";
    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;
  }
  return errorMessage;
}
var REQUIRED_UNSET_VALUE = /* @__PURE__ */ Symbol("InputSignalNode#UNSET");
var INPUT_SIGNAL_NODE = /* @__PURE__ */ (() => {
  return __spreadProps(__spreadValues({}, SIGNAL_NODE), {
    transformFn: void 0,
    applyValueToInputSignal(node, value2) {
      signalSetFn(node, value2);
    }
  });
})();
function createInputSignal(initialValue, options) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  node.value = initialValue;
  node.transformFn = options?.transform;
  function inputValueFn() {
    producerAccessed(node);
    if (node.value === REQUIRED_UNSET_VALUE) {
      throw new RuntimeError(-950, ngDevMode && "Input is required but no value is available yet.");
    }
    return node.value;
  }
  inputValueFn[SIGNAL] = node;
  if (ngDevMode) {
    inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;
    node.debugName = options?.debugName;
  }
  return inputValueFn;
}
function noSideEffects(fn) {
  return {
    toString: fn
  }.toString();
}
var ANNOTATIONS = "__annotations__";
var PARAMETERS = "__parameters__";
var PROP_METADATA = "__prop__metadata__";
function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
      if (this instanceof DecoratorFactory) {
        metaCtor.call(this, ...args);
        return this;
      }
      const annotationInstance = new DecoratorFactory(...args);
      return function TypeDecorator(cls) {
        if (typeFn) typeFn(cls, ...args);
        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {
          value: []
        })[ANNOTATIONS];
        annotations.push(annotationInstance);
        if (additionalProcessing) additionalProcessing(cls);
        return cls;
      };
    }
    if (parentClass) {
      DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
  });
}
function makeMetadataCtor(props) {
  return function ctor(...args) {
    if (props) {
      const values = props(...args);
      for (const propName in values) {
        this[propName] = values[propName];
      }
    }
  };
}
function makeParamDecorator(name, props, parentClass) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
      if (this instanceof ParamDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const annotationInstance = new ParamDecoratorFactory(...args);
      ParamDecorator.annotation = annotationInstance;
      return ParamDecorator;
      function ParamDecorator(cls, unusedKey, index) {
        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
          value: []
        })[PARAMETERS];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        (parameters[index] = parameters[index] || []).push(annotationInstance);
        return cls;
      }
    }
    if (parentClass) {
      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
  });
}
function makePropDecorator(name, props, parentClass, additionalProcessing) {
  return noSideEffects(() => {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
      if (this instanceof PropDecoratorFactory) {
        metaCtor.apply(this, args);
        return this;
      }
      const decoratorInstance = new PropDecoratorFactory(...args);
      function PropDecorator(target, name2) {
        if (target === void 0) {
          throw new Error("Standard Angular field decorators are not supported in JIT mode.");
        }
        const constructor = target.constructor;
        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {
          value: {}
        })[PROP_METADATA];
        meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
        meta[name2].unshift(decoratorInstance);
        if (additionalProcessing) additionalProcessing(target, name2, ...args);
      }
      return PropDecorator;
    }
    if (parentClass) {
      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
  });
}
var _global = globalThis;
function ngDevModeResetPerfCounters() {
  const locationString = typeof location !== "undefined" ? location.toString() : "";
  const newCounters = {
    namedConstructors: locationString.indexOf("ngDevMode=namedConstructors") != -1,
    firstCreatePass: 0,
    tNode: 0,
    tView: 0,
    rendererCreateTextNode: 0,
    rendererSetText: 0,
    rendererCreateElement: 0,
    rendererAddEventListener: 0,
    rendererSetAttribute: 0,
    rendererRemoveAttribute: 0,
    rendererSetProperty: 0,
    rendererSetClassName: 0,
    rendererAddClass: 0,
    rendererRemoveClass: 0,
    rendererSetStyle: 0,
    rendererRemoveStyle: 0,
    rendererDestroy: 0,
    rendererDestroyNode: 0,
    rendererMoveNode: 0,
    rendererRemoveNode: 0,
    rendererAppendChild: 0,
    rendererInsertBefore: 0,
    rendererCreateComment: 0,
    hydratedNodes: 0,
    hydratedComponents: 0,
    dehydratedViewsRemoved: 0,
    dehydratedViewsCleanupRuns: 0,
    componentsSkippedHydration: 0
  };
  const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
  if (!allowNgDevModeTrue) {
    _global["ngDevMode"] = false;
  } else {
    if (typeof _global["ngDevMode"] !== "object") {
      _global["ngDevMode"] = {};
    }
    Object.assign(_global["ngDevMode"], newCounters);
  }
  return newCounters;
}
function initNgDevMode() {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (typeof ngDevMode !== "object" || Object.keys(ngDevMode).length === 0) {
      ngDevModeResetPerfCounters();
    }
    return typeof ngDevMode !== "undefined" && !!ngDevMode;
  }
  return false;
}
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (let key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error("Could not find renamed property on target object.");
}
function fillProperties(target, source) {
  for (const key in source) {
    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
}
function stringify(token) {
  if (typeof token === "string") {
    return token;
  }
  if (Array.isArray(token)) {
    return "[" + token.map(stringify).join(", ") + "]";
  }
  if (token == null) {
    return "" + token;
  }
  if (token.overriddenName) {
    return `${token.overriddenName}`;
  }
  if (token.name) {
    return `${token.name}`;
  }
  const res = token.toString();
  if (res == null) {
    return "" + res;
  }
  const newLineIndex = res.indexOf("\n");
  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}
function concatStringsWithSpace(before, after) {
  return before == null || before === "" ? after === null ? "" : after : after == null || after === "" ? before : before + " " + after;
}
var __forward_ref__ = getClosureSafeProperty({
  __forward_ref__: getClosureSafeProperty
});
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function() {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type2) {
  return isForwardRef(type2) ? type2() : type2;
}
function isForwardRef(fn) {
  return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}
function assertNumber(actual, msg) {
  if (!(typeof actual === "number")) {
    throwError2(msg, typeof actual, "number", "===");
  }
}
function assertNumberInRange(actual, minInclusive, maxInclusive) {
  assertNumber(actual, "Expected a number");
  assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
  assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
}
function assertString(actual, msg) {
  if (!(typeof actual === "string")) {
    throwError2(msg, actual === null ? "null" : typeof actual, "string", "===");
  }
}
function assertFunction(actual, msg) {
  if (!(typeof actual === "function")) {
    throwError2(msg, actual === null ? "null" : typeof actual, "function", "===");
  }
}
function assertEqual(actual, expected, msg) {
  if (!(actual == expected)) {
    throwError2(msg, actual, expected, "==");
  }
}
function assertNotEqual(actual, expected, msg) {
  if (!(actual != expected)) {
    throwError2(msg, actual, expected, "!=");
  }
}
function assertSame(actual, expected, msg) {
  if (!(actual === expected)) {
    throwError2(msg, actual, expected, "===");
  }
}
function assertNotSame(actual, expected, msg) {
  if (!(actual !== expected)) {
    throwError2(msg, actual, expected, "!==");
  }
}
function assertLessThan(actual, expected, msg) {
  if (!(actual < expected)) {
    throwError2(msg, actual, expected, "<");
  }
}
function assertLessThanOrEqual(actual, expected, msg) {
  if (!(actual <= expected)) {
    throwError2(msg, actual, expected, "<=");
  }
}
function assertGreaterThan(actual, expected, msg) {
  if (!(actual > expected)) {
    throwError2(msg, actual, expected, ">");
  }
}
function assertGreaterThanOrEqual(actual, expected, msg) {
  if (!(actual >= expected)) {
    throwError2(msg, actual, expected, ">=");
  }
}
function assertDefined(actual, msg) {
  if (actual == null) {
    throwError2(msg, actual, null, "!=");
  }
}
function throwError2(msg, actual, expected, comparison) {
  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
}
function assertDomNode(node) {
  if (!(node instanceof Node)) {
    throwError2(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
  }
}
function assertElement(node) {
  if (!(node instanceof Element)) {
    throwError2(`The provided value must be an element but got ${stringify(node)}`);
  }
}
function assertIndexInRange(arr, index) {
  assertDefined(arr, "Array must be defined.");
  const maxLen = arr.length;
  if (index < 0 || index >= maxLen) {
    throwError2(`Index expected to be less than ${maxLen} but got ${index}`);
  }
}
function assertOneOf(value2, ...validValues) {
  if (validValues.indexOf(value2) !== -1) return true;
  throwError2(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value2)}.`);
}
function assertNotReactive(fn) {
  if (getActiveConsumer() !== null) {
    throwError2(`${fn}() should never be called in a reactive context.`);
  }
}
function \u0275\u0275defineInjectable(opts) {
  return {
    token: opts.token,
    providedIn: opts.providedIn || null,
    factory: opts.factory,
    value: void 0
  };
}
function \u0275\u0275defineInjector(options) {
  return {
    providers: options.providers || [],
    imports: options.imports || []
  };
}
function getInjectableDef(type2) {
  return getOwnDefinition(type2, NG_PROV_DEF) || getOwnDefinition(type2, NG_INJECTABLE_DEF);
}
function isInjectable(type2) {
  return getInjectableDef(type2) !== null;
}
function getOwnDefinition(type2, field) {
  return type2.hasOwnProperty(field) ? type2[field] : null;
}
function getInheritedInjectableDef(type2) {
  const def = type2 && (type2[NG_PROV_DEF] || type2[NG_INJECTABLE_DEF]);
  if (def) {
    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token "${type2.name}" that inherits its @Injectable decorator but does not provide one itself.
This will become an error in a future version of Angular. Please add @Injectable() to the "${type2.name}" class.`);
    return def;
  } else {
    return null;
  }
}
function getInjectorDef(type2) {
  return type2 && (type2.hasOwnProperty(NG_INJ_DEF) || type2.hasOwnProperty(NG_INJECTOR_DEF)) ? type2[NG_INJ_DEF] : null;
}
var NG_PROV_DEF = getClosureSafeProperty({
  \u0275prov: getClosureSafeProperty
});
var NG_INJ_DEF = getClosureSafeProperty({
  \u0275inj: getClosureSafeProperty
});
var NG_INJECTABLE_DEF = getClosureSafeProperty({
  ngInjectableDef: getClosureSafeProperty
});
var NG_INJECTOR_DEF = getClosureSafeProperty({
  ngInjectorDef: getClosureSafeProperty
});
var InjectionToken = class {
  _desc;
  /** @internal */
  ngMetadataName = "InjectionToken";
  \u0275prov;
  /**
   * @param _desc   Description for the token,
   *                used only for debugging purposes,
   *                it should but does not need to be unique
   * @param options Options for the token's usage, as described above
   */
  constructor(_desc, options) {
    this._desc = _desc;
    this.\u0275prov = void 0;
    if (typeof options == "number") {
      (typeof ngDevMode === "undefined" || ngDevMode) && assertLessThan(options, 0, "Only negative numbers are supported here");
      this.__NG_ELEMENT_ID__ = options;
    } else if (options !== void 0) {
      this.\u0275prov = \u0275\u0275defineInjectable({
        token: this,
        providedIn: options.providedIn || "root",
        factory: options.factory
      });
    }
  }
  /**
   * @internal
   */
  get multi() {
    return this;
  }
  toString() {
    return `InjectionToken ${this._desc}`;
  }
};
var _injectorProfilerContext;
function getInjectorProfilerContext() {
  !ngDevMode && throwError2("getInjectorProfilerContext should never be called in production mode");
  return _injectorProfilerContext;
}
function setInjectorProfilerContext(context2) {
  !ngDevMode && throwError2("setInjectorProfilerContext should never be called in production mode");
  const previous = _injectorProfilerContext;
  _injectorProfilerContext = context2;
  return previous;
}
var injectorProfilerCallback = null;
var setInjectorProfiler = (injectorProfiler2) => {
  !ngDevMode && throwError2("setInjectorProfiler should never be called in production mode");
  injectorProfilerCallback = injectorProfiler2;
};
function injectorProfiler(event) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  if (injectorProfilerCallback != null) {
    injectorProfilerCallback(event);
  }
}
function emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  let token;
  if (typeof eventProvider === "function") {
    token = eventProvider;
  } else if (eventProvider instanceof InjectionToken) {
    token = eventProvider;
  } else {
    token = resolveForwardRef(eventProvider.provide);
  }
  let provider = eventProvider;
  if (eventProvider instanceof InjectionToken) {
    provider = eventProvider.\u0275prov || eventProvider;
  }
  injectorProfiler({
    type: 2,
    context: getInjectorProfilerContext(),
    providerRecord: {
      token,
      provider,
      isViewProvider
    }
  });
}
function emitInstanceCreatedByInjectorEvent(instance) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 1,
    context: getInjectorProfilerContext(),
    instance: {
      value: instance
    }
  });
}
function emitInjectEvent(token, value2, flags) {
  !ngDevMode && throwError2("Injector profiler should never be called in production mode");
  injectorProfiler({
    type: 0,
    context: getInjectorProfilerContext(),
    service: {
      token,
      value: value2,
      flags
    }
  });
}
function runInInjectorProfilerContext(injector, token, callback) {
  !ngDevMode && throwError2("runInInjectorProfilerContext should never be called in production mode");
  const prevInjectContext = setInjectorProfilerContext({
    injector,
    token
  });
  try {
    callback();
  } finally {
    setInjectorProfilerContext(prevInjectContext);
  }
}
function isEnvironmentProviders(value2) {
  return value2 && !!value2.\u0275providers;
}
var NG_COMP_DEF = getClosureSafeProperty({
  \u0275cmp: getClosureSafeProperty
});
var NG_DIR_DEF = getClosureSafeProperty({
  \u0275dir: getClosureSafeProperty
});
var NG_PIPE_DEF = getClosureSafeProperty({
  \u0275pipe: getClosureSafeProperty
});
var NG_MOD_DEF = getClosureSafeProperty({
  \u0275mod: getClosureSafeProperty
});
var NG_FACTORY_DEF = getClosureSafeProperty({
  \u0275fac: getClosureSafeProperty
});
var NG_ELEMENT_ID = getClosureSafeProperty({
  __NG_ELEMENT_ID__: getClosureSafeProperty
});
var NG_ENV_ID = getClosureSafeProperty({
  __NG_ENV_ID__: getClosureSafeProperty
});
function renderStringify(value2) {
  if (typeof value2 === "string") return value2;
  if (value2 == null) return "";
  return String(value2);
}
function stringifyForError(value2) {
  if (typeof value2 === "function") return value2.name || value2.toString();
  if (typeof value2 === "object" && value2 != null && typeof value2.type === "function") {
    return value2.type.name || value2.type.toString();
  }
  return renderStringify(value2);
}
function throwCyclicDependencyError(token, path3) {
  const depPath = path3 ? `. Dependency path: ${path3.join(" > ")} > ${token}` : "";
  throw new RuntimeError(-200, ngDevMode ? `Circular dependency in DI detected for ${token}${depPath}` : token);
}
function throwMixedMultiProviderError() {
  throw new Error(`Cannot mix multi providers and regular providers`);
}
function throwInvalidProviderError(ngModuleType, providers2, provider) {
  if (ngModuleType && providers2) {
    const providerDetail = providers2.map((v) => v == provider ? "?" + provider + "?" : "...");
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`);
  } else if (isEnvironmentProviders(provider)) {
    if (provider.\u0275fromNgModule) {
      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);
    } else {
      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);
    }
  } else {
    throw new Error("Invalid provider");
  }
}
function throwProviderNotFoundError(token, injectorName) {
  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ""}`;
  throw new RuntimeError(-201, errorMessage);
}
var InjectFlags;
(function(InjectFlags2) {
  InjectFlags2[InjectFlags2["Default"] = 0] = "Default";
  InjectFlags2[InjectFlags2["Host"] = 1] = "Host";
  InjectFlags2[InjectFlags2["Self"] = 2] = "Self";
  InjectFlags2[InjectFlags2["SkipSelf"] = 4] = "SkipSelf";
  InjectFlags2[InjectFlags2["Optional"] = 8] = "Optional";
})(InjectFlags || (InjectFlags = {}));
var _injectImplementation;
function getInjectImplementation() {
  return _injectImplementation;
}
function setInjectImplementation(impl) {
  const previous = _injectImplementation;
  _injectImplementation = impl;
  return previous;
}
function injectRootLimpMode(token, notFoundValue, flags) {
  const injectableDef = getInjectableDef(token);
  if (injectableDef && injectableDef.providedIn == "root") {
    return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
  }
  if (flags & InjectFlags.Optional) return null;
  if (notFoundValue !== void 0) return notFoundValue;
  throwProviderNotFoundError(token, "Injector");
}
function assertInjectImplementationNotEqual(fn) {
  ngDevMode && assertNotEqual(_injectImplementation, fn, "Calling \u0275\u0275inject would cause infinite recursion");
}
var _THROW_IF_NOT_FOUND = {};
var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
var DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
var NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
var NG_TOKEN_PATH = "ngTokenPath";
var NEW_LINE = /\n/gm;
var NO_NEW_LINE = "\u0275";
var SOURCE = "__source";
var _currentInjector = void 0;
function getCurrentInjector() {
  return _currentInjector;
}
function setCurrentInjector(injector) {
  const former = _currentInjector;
  _currentInjector = injector;
  return former;
}
function injectInjectorOnly(token, flags = InjectFlags.Default) {
  if (_currentInjector === void 0) {
    throw new RuntimeError(-203, ngDevMode && `inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \`runInInjectionContext\`.`);
  } else if (_currentInjector === null) {
    return injectRootLimpMode(token, void 0, flags);
  } else {
    const value2 = _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
    ngDevMode && emitInjectEvent(token, value2, flags);
    return value2;
  }
}
function \u0275\u0275inject(token, flags = InjectFlags.Default) {
  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
}
function \u0275\u0275invalidFactoryDep(index) {
  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);
}
function inject(token, flags = InjectFlags.Default) {
  return \u0275\u0275inject(token, convertToBitFlags(flags));
}
function convertToBitFlags(flags) {
  if (typeof flags === "undefined" || typeof flags === "number") {
    return flags;
  }
  return 0 | // comment to force a line break in the formatter
  (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);
}
function injectArgs(types) {
  const args = [];
  for (let i = 0; i < types.length; i++) {
    const arg = resolveForwardRef(types[i]);
    if (Array.isArray(arg)) {
      if (arg.length === 0) {
        throw new RuntimeError(900, ngDevMode && "Arguments array must have arguments.");
      }
      let type2 = void 0;
      let flags = InjectFlags.Default;
      for (let j = 0; j < arg.length; j++) {
        const meta = arg[j];
        const flag = getInjectFlag(meta);
        if (typeof flag === "number") {
          if (flag === -1) {
            type2 = meta.token;
          } else {
            flags |= flag;
          }
        } else {
          type2 = meta;
        }
      }
      args.push(\u0275\u0275inject(type2, flags));
    } else {
      args.push(\u0275\u0275inject(arg));
    }
  }
  return args;
}
function attachInjectFlag(decorator, flag) {
  decorator[DI_DECORATOR_FLAG] = flag;
  decorator.prototype[DI_DECORATOR_FLAG] = flag;
  return decorator;
}
function getInjectFlag(token) {
  return token[DI_DECORATOR_FLAG];
}
function catchInjectorError(e, token, injectorErrorName, source) {
  const tokenPath = e[NG_TEMP_TOKEN_PATH];
  if (token[SOURCE]) {
    tokenPath.unshift(token[SOURCE]);
  }
  e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source);
  e[NG_TOKEN_PATH] = tokenPath;
  e[NG_TEMP_TOKEN_PATH] = null;
  throw e;
}
function formatError(text2, obj, injectorErrorName, source = null) {
  text2 = text2 && text2.charAt(0) === "\n" && text2.charAt(1) == NO_NEW_LINE ? text2.slice(2) : text2;
  let context2 = stringify(obj);
  if (Array.isArray(obj)) {
    context2 = obj.map(stringify).join(" -> ");
  } else if (typeof obj === "object") {
    let parts = [];
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        let value2 = obj[key];
        parts.push(key + ":" + (typeof value2 === "string" ? JSON.stringify(value2) : stringify(value2)));
      }
    }
    context2 = `{${parts.join(", ")}}`;
  }
  return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context2}]: ${text2.replace(NEW_LINE, "\n  ")}`;
}
var Inject = attachInjectFlag(
  // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.
  makeParamDecorator("Inject", (token) => ({
    token
  })),
  -1
  /* DecoratorFlags.Inject */
);
var Optional = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Optional"),
    8
    /* InternalInjectFlags.Optional */
  )
);
var Self = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Self"),
    2
    /* InternalInjectFlags.Self */
  )
);
var SkipSelf = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("SkipSelf"),
    4
    /* InternalInjectFlags.SkipSelf */
  )
);
var Host = (
  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.
  // tslint:disable-next-line: no-toplevel-property-access
  attachInjectFlag(
    makeParamDecorator("Host"),
    1
    /* InternalInjectFlags.Host */
  )
);
function getFactoryDef(type2, throwNotFound) {
  const hasFactoryDef = type2.hasOwnProperty(NG_FACTORY_DEF);
  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
    throw new Error(`Type ${stringify(type2)} does not have '\u0275fac' property.`);
  }
  return hasFactoryDef ? type2[NG_FACTORY_DEF] : null;
}
function arrayEquals(a, b, identityAccessor) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    let valueA = a[i];
    let valueB = b[i];
    if (identityAccessor) {
      valueA = identityAccessor(valueA);
      valueB = identityAccessor(valueB);
    }
    if (valueB !== valueA) {
      return false;
    }
  }
  return true;
}
function flatten(list) {
  return list.flat(Number.POSITIVE_INFINITY);
}
function deepForEach(input2, fn) {
  input2.forEach((value2) => Array.isArray(value2) ? deepForEach(value2, fn) : fn(value2));
}
function addToArray(arr, index, value2) {
  if (index >= arr.length) {
    arr.push(value2);
  } else {
    arr.splice(index, 0, value2);
  }
}
function removeFromArray(arr, index) {
  if (index >= arr.length - 1) {
    return arr.pop();
  } else {
    return arr.splice(index, 1)[0];
  }
}
function newArray(size2, value2) {
  const list = [];
  for (let i = 0; i < size2; i++) {
    list.push(value2);
  }
  return list;
}
function arraySplice(array2, index, count3) {
  const length = array2.length - count3;
  while (index < length) {
    array2[index] = array2[index + count3];
    index++;
  }
  while (count3--) {
    array2.pop();
  }
}
function arrayInsert2(array2, index, value1, value2) {
  ngDevMode && assertLessThanOrEqual(index, array2.length, "Can't insert past array end.");
  let end2 = array2.length;
  if (end2 == index) {
    array2.push(value1, value2);
  } else if (end2 === 1) {
    array2.push(value2, array2[0]);
    array2[0] = value1;
  } else {
    end2--;
    array2.push(array2[end2 - 1], array2[end2]);
    while (end2 > index) {
      const previousEnd = end2 - 2;
      array2[end2] = array2[previousEnd];
      end2--;
    }
    array2[index] = value1;
    array2[index + 1] = value2;
  }
}
function keyValueArraySet(keyValueArray, key, value2) {
  let index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    keyValueArray[index | 1] = value2;
  } else {
    index = ~index;
    arrayInsert2(keyValueArray, index, key, value2);
  }
  return index;
}
function keyValueArrayGet(keyValueArray, key) {
  const index = keyValueArrayIndexOf(keyValueArray, key);
  if (index >= 0) {
    return keyValueArray[index | 1];
  }
  return void 0;
}
function keyValueArrayIndexOf(keyValueArray, key) {
  return _arrayIndexOfSorted(keyValueArray, key, 1);
}
function _arrayIndexOfSorted(array2, value2, shift2) {
  ngDevMode && assertEqual(Array.isArray(array2), true, "Expecting an array");
  let start2 = 0;
  let end2 = array2.length >> shift2;
  while (end2 !== start2) {
    const middle = start2 + (end2 - start2 >> 1);
    const current = array2[middle << shift2];
    if (value2 === current) {
      return middle << shift2;
    } else if (current > value2) {
      end2 = middle;
    } else {
      start2 = middle + 1;
    }
  }
  return ~(end2 << shift2);
}
var EMPTY_OBJ = {};
var EMPTY_ARRAY = [];
if ((typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode()) {
  Object.freeze(EMPTY_OBJ);
  Object.freeze(EMPTY_ARRAY);
}
var ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? "ENVIRONMENT_INITIALIZER" : "");
var INJECTOR$1 = new InjectionToken(
  ngDevMode ? "INJECTOR" : "",
  // Disable tslint because this is const enum which gets inlined not top level prop access.
  // tslint:disable-next-line: no-toplevel-property-access
  -1
  /* InjectorMarkers.Injector */
);
var INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? "INJECTOR_DEF_TYPES" : "");
var NullInjector = class {
  get(token, notFoundValue = THROW_IF_NOT_FOUND) {
    if (notFoundValue === THROW_IF_NOT_FOUND) {
      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
      error.name = "NullInjectorError";
      throw error;
    }
    return notFoundValue;
  }
};
function getNgModuleDef(type2, throwNotFound) {
  const ngModuleDef = type2[NG_MOD_DEF] || null;
  if (!ngModuleDef && throwNotFound === true) {
    throw new Error(`Type ${stringify(type2)} does not have '\u0275mod' property.`);
  }
  return ngModuleDef;
}
function getComponentDef(type2) {
  return type2[NG_COMP_DEF] || null;
}
function getDirectiveDef(type2) {
  return type2[NG_DIR_DEF] || null;
}
function getPipeDef$1(type2) {
  return type2[NG_PIPE_DEF] || null;
}
function isStandalone(type2) {
  const def = getComponentDef(type2) || getDirectiveDef(type2) || getPipeDef$1(type2);
  return def !== null ? def.standalone : false;
}
function makeEnvironmentProviders(providers2) {
  return {
    \u0275providers: providers2
  };
}
function importProvidersFrom(...sources) {
  return {
    \u0275providers: internalImportProvidersFrom(true, sources),
    \u0275fromNgModule: true
  };
}
function internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {
  const providersOut = [];
  const dedup = /* @__PURE__ */ new Set();
  let injectorTypesWithProviders;
  const collectProviders = (provider) => {
    providersOut.push(provider);
  };
  deepForEach(sources, (source) => {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && checkForStandaloneCmp) {
      const cmpDef = getComponentDef(source);
      if (cmpDef?.standalone) {
        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`);
      }
    }
    const internalSource = source;
    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {
      injectorTypesWithProviders ||= [];
      injectorTypesWithProviders.push(internalSource);
    }
  });
  if (injectorTypesWithProviders !== void 0) {
    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);
  }
  return providersOut;
}
function processInjectorTypesWithProviders(typesWithProviders, visitor) {
  for (let i = 0; i < typesWithProviders.length; i++) {
    const {
      ngModule,
      providers: providers2
    } = typesWithProviders[i];
    deepForEachProvider(providers2, (provider) => {
      ngDevMode && validateProvider(provider, providers2 || EMPTY_ARRAY, ngModule);
      visitor(provider, ngModule);
    });
  }
}
function walkProviderTree(container, visitor, parents, dedup) {
  container = resolveForwardRef(container);
  if (!container) return false;
  let defType = null;
  let injDef = getInjectorDef(container);
  const cmpDef = !injDef && getComponentDef(container);
  if (!injDef && !cmpDef) {
    const ngModule = container.ngModule;
    injDef = getInjectorDef(ngModule);
    if (injDef) {
      defType = ngModule;
    } else {
      return false;
    }
  } else if (cmpDef && !cmpDef.standalone) {
    return false;
  } else {
    defType = container;
  }
  if (ngDevMode && parents.indexOf(defType) !== -1) {
    const defName = stringify(defType);
    const path3 = parents.map(stringify);
    throwCyclicDependencyError(defName, path3);
  }
  const isDuplicate = dedup.has(defType);
  if (cmpDef) {
    if (isDuplicate) {
      return false;
    }
    dedup.add(defType);
    if (cmpDef.dependencies) {
      const deps = typeof cmpDef.dependencies === "function" ? cmpDef.dependencies() : cmpDef.dependencies;
      for (const dep of deps) {
        walkProviderTree(dep, visitor, parents, dedup);
      }
    }
  } else if (injDef) {
    if (injDef.imports != null && !isDuplicate) {
      ngDevMode && parents.push(defType);
      dedup.add(defType);
      let importTypesWithProviders;
      try {
        deepForEach(injDef.imports, (imported) => {
          if (walkProviderTree(imported, visitor, parents, dedup)) {
            importTypesWithProviders ||= [];
            importTypesWithProviders.push(imported);
          }
        });
      } finally {
        ngDevMode && parents.pop();
      }
      if (importTypesWithProviders !== void 0) {
        processInjectorTypesWithProviders(importTypesWithProviders, visitor);
      }
    }
    if (!isDuplicate) {
      const factory = getFactoryDef(defType) || (() => new defType());
      visitor({
        provide: defType,
        useFactory: factory,
        deps: EMPTY_ARRAY
      }, defType);
      visitor({
        provide: INJECTOR_DEF_TYPES,
        useValue: defType,
        multi: true
      }, defType);
      visitor({
        provide: ENVIRONMENT_INITIALIZER,
        useValue: () => \u0275\u0275inject(defType),
        multi: true
      }, defType);
    }
    const defProviders = injDef.providers;
    if (defProviders != null && !isDuplicate) {
      const injectorType = container;
      deepForEachProvider(defProviders, (provider) => {
        ngDevMode && validateProvider(provider, defProviders, injectorType);
        visitor(provider, injectorType);
      });
    }
  } else {
    return false;
  }
  return defType !== container && container.providers !== void 0;
}
function validateProvider(provider, providers2, containerType) {
  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {
    return;
  }
  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
  if (!classRef) {
    throwInvalidProviderError(containerType, providers2, provider);
  }
}
function deepForEachProvider(providers2, fn) {
  for (let provider of providers2) {
    if (isEnvironmentProviders(provider)) {
      provider = provider.\u0275providers;
    }
    if (Array.isArray(provider)) {
      deepForEachProvider(provider, fn);
    } else {
      fn(provider);
    }
  }
}
var USE_VALUE$1 = getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isValueProvider(value2) {
  return value2 !== null && typeof value2 == "object" && USE_VALUE$1 in value2;
}
function isExistingProvider(value2) {
  return !!(value2 && value2.useExisting);
}
function isFactoryProvider(value2) {
  return !!(value2 && value2.useFactory);
}
function isTypeProvider(value2) {
  return typeof value2 === "function";
}
function isClassProvider(value2) {
  return !!value2.useClass;
}
var INJECTOR_SCOPE = new InjectionToken(ngDevMode ? "Set Injector scope." : "");
var NOT_YET = {};
var CIRCULAR = {};
var NULL_INJECTOR = void 0;
function getNullInjector() {
  if (NULL_INJECTOR === void 0) {
    NULL_INJECTOR = new NullInjector();
  }
  return NULL_INJECTOR;
}
var EnvironmentInjector = class {
};
var R3Injector = class extends EnvironmentInjector {
  parent;
  source;
  scopes;
  /**
   * Map of tokens to records which contain the instances of those tokens.
   * - `null` value implies that we don't have the record. Used by tree-shakable injectors
   * to prevent further searches.
   */
  records = /* @__PURE__ */ new Map();
  /**
   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.
   */
  _ngOnDestroyHooks = /* @__PURE__ */ new Set();
  _onDestroyHooks = [];
  /**
   * Flag indicating that this injector was previously destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  _destroyed = false;
  injectorDefTypes;
  constructor(providers2, parent, source, scopes) {
    super();
    this.parent = parent;
    this.source = source;
    this.scopes = scopes;
    forEachSingleProvider(providers2, (provider) => this.processProvider(provider));
    this.records.set(INJECTOR$1, makeRecord(void 0, this));
    if (scopes.has("environment")) {
      this.records.set(EnvironmentInjector, makeRecord(void 0, this));
    }
    const record = this.records.get(INJECTOR_SCOPE);
    if (record != null && typeof record.value === "string") {
      this.scopes.add(record.value);
    }
    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, InjectFlags.Self));
  }
  /**
   * Destroy the injector and release references to every instance or provider associated with it.
   *
   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a
   * hook was found.
   */
  destroy() {
    assertNotDestroyed(this);
    this._destroyed = true;
    const prevConsumer = setActiveConsumer(null);
    try {
      for (const service of this._ngOnDestroyHooks) {
        service.ngOnDestroy();
      }
      const onDestroyHooks = this._onDestroyHooks;
      this._onDestroyHooks = [];
      for (const hook of onDestroyHooks) {
        hook();
      }
    } finally {
      this.records.clear();
      this._ngOnDestroyHooks.clear();
      this.injectorDefTypes.clear();
      setActiveConsumer(prevConsumer);
    }
  }
  onDestroy(callback) {
    assertNotDestroyed(this);
    this._onDestroyHooks.push(callback);
    return () => this.removeOnDestroy(callback);
  }
  runInContext(fn) {
    assertNotDestroyed(this);
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      return fn();
    } finally {
      setCurrentInjector(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
    assertNotDestroyed(this);
    if (token.hasOwnProperty(NG_ENV_ID)) {
      return token[NG_ENV_ID](this);
    }
    flags = convertToBitFlags(flags);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token
      });
    }
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (!(flags & InjectFlags.SkipSelf)) {
        let record = this.records.get(token);
        if (record === void 0) {
          const def = couldBeInjectableType(token) && getInjectableDef(token);
          if (def && this.injectableDefInScope(def)) {
            if (ngDevMode) {
              runInInjectorProfilerContext(this, token, () => {
                emitProviderConfiguredEvent(token);
              });
            }
            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
          } else {
            record = null;
          }
          this.records.set(token, record);
        }
        if (record != null) {
          return this.hydrate(token, record);
        }
      }
      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
      notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
      return nextInjector.get(token, notFoundValue);
    } catch (e) {
      if (e.name === "NullInjectorError") {
        const path3 = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path3.unshift(stringify(token));
        if (previousInjector) {
          throw e;
        } else {
          return catchInjectorError(e, token, "R3InjectorError", this.source);
        }
      } else {
        throw e;
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
      setCurrentInjector(previousInjector);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
    }
  }
  /** @internal */
  resolveInjectorInitializers() {
    const prevConsumer = setActiveConsumer(null);
    const previousInjector = setCurrentInjector(this);
    const previousInjectImplementation = setInjectImplementation(void 0);
    let prevInjectContext;
    if (ngDevMode) {
      prevInjectContext = setInjectorProfilerContext({
        injector: this,
        token: null
      });
    }
    try {
      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, InjectFlags.Self);
      if (ngDevMode && !Array.isArray(initializers)) {
        throw new RuntimeError(-209, `Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
      }
      for (const initializer of initializers) {
        initializer();
      }
    } finally {
      setCurrentInjector(previousInjector);
      setInjectImplementation(previousInjectImplementation);
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      setActiveConsumer(prevConsumer);
    }
  }
  toString() {
    const tokens = [];
    const records = this.records;
    for (const token of records.keys()) {
      tokens.push(stringify(token));
    }
    return `R3Injector[${tokens.join(", ")}]`;
  }
  /**
   * Process a `SingleProvider` and add it.
   */
  processProvider(provider) {
    provider = resolveForwardRef(provider);
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
    const record = providerToRecord(provider);
    if (ngDevMode) {
      runInInjectorProfilerContext(this, token, () => {
        if (isValueProvider(provider)) {
          emitInstanceCreatedByInjectorEvent(provider.useValue);
        }
        emitProviderConfiguredEvent(provider);
      });
    }
    if (!isTypeProvider(provider) && provider.multi === true) {
      let multiRecord = this.records.get(token);
      if (multiRecord) {
        if (ngDevMode && multiRecord.multi === void 0) {
          throwMixedMultiProviderError();
        }
      } else {
        multiRecord = makeRecord(void 0, NOT_YET, true);
        multiRecord.factory = () => injectArgs(multiRecord.multi);
        this.records.set(token, multiRecord);
      }
      token = provider;
      multiRecord.multi.push(provider);
    } else {
      if (ngDevMode) {
        const existing = this.records.get(token);
        if (existing && existing.multi !== void 0) {
          throwMixedMultiProviderError();
        }
      }
    }
    this.records.set(token, record);
  }
  hydrate(token, record) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (ngDevMode && record.value === CIRCULAR) {
        throwCyclicDependencyError(stringify(token));
      } else if (record.value === NOT_YET) {
        record.value = CIRCULAR;
        if (ngDevMode) {
          runInInjectorProfilerContext(this, token, () => {
            record.value = record.factory();
            emitInstanceCreatedByInjectorEvent(record.value);
          });
        } else {
          record.value = record.factory();
        }
      }
      if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
        this._ngOnDestroyHooks.add(record.value);
      }
      return record.value;
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
  injectableDefInScope(def) {
    if (!def.providedIn) {
      return false;
    }
    const providedIn = resolveForwardRef(def.providedIn);
    if (typeof providedIn === "string") {
      return providedIn === "any" || this.scopes.has(providedIn);
    } else {
      return this.injectorDefTypes.has(providedIn);
    }
  }
  removeOnDestroy(callback) {
    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);
    if (destroyCBIdx !== -1) {
      this._onDestroyHooks.splice(destroyCBIdx, 1);
    }
  }
};
function injectableDefOrInjectorDefFactory(token) {
  const injectableDef = getInjectableDef(token);
  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
  if (factory !== null) {
    return factory;
  }
  if (token instanceof InjectionToken) {
    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a \u0275prov definition.`);
  }
  if (token instanceof Function) {
    return getUndecoratedInjectableFactory(token);
  }
  throw new RuntimeError(204, ngDevMode && "unreachable");
}
function getUndecoratedInjectableFactory(token) {
  const paramLength = token.length;
  if (paramLength > 0) {
    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, "?").join(", ")}).`);
  }
  const inheritedInjectableDef = getInheritedInjectableDef(token);
  if (inheritedInjectableDef !== null) {
    return () => inheritedInjectableDef.factory(token);
  } else {
    return () => new token();
  }
}
function providerToRecord(provider) {
  if (isValueProvider(provider)) {
    return makeRecord(void 0, provider.useValue);
  } else {
    const factory = providerToFactory(provider);
    return makeRecord(factory, NOT_YET);
  }
}
function providerToFactory(provider, ngModuleType, providers2) {
  let factory = void 0;
  if (ngDevMode && isEnvironmentProviders(provider)) {
    throwInvalidProviderError(void 0, providers2, provider);
  }
  if (isTypeProvider(provider)) {
    const unwrappedProvider = resolveForwardRef(provider);
    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
  } else {
    if (isValueProvider(provider)) {
      factory = () => resolveForwardRef(provider.useValue);
    } else if (isFactoryProvider(provider)) {
      factory = () => provider.useFactory(...injectArgs(provider.deps || []));
    } else if (isExistingProvider(provider)) {
      factory = () => \u0275\u0275inject(resolveForwardRef(provider.useExisting));
    } else {
      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
      if (ngDevMode && !classRef) {
        throwInvalidProviderError(ngModuleType, providers2, provider);
      }
      if (hasDeps(provider)) {
        factory = () => new classRef(...injectArgs(provider.deps));
      } else {
        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
      }
    }
  }
  return factory;
}
function assertNotDestroyed(injector) {
  if (injector.destroyed) {
    throw new RuntimeError(205, ngDevMode && "Injector has already been destroyed.");
  }
}
function makeRecord(factory, value2, multi = false) {
  return {
    factory,
    value: value2,
    multi: multi ? [] : void 0
  };
}
function hasDeps(value2) {
  return !!value2.deps;
}
function hasOnDestroy(value2) {
  return value2 !== null && typeof value2 === "object" && typeof value2.ngOnDestroy === "function";
}
function couldBeInjectableType(value2) {
  return typeof value2 === "function" || typeof value2 === "object" && value2 instanceof InjectionToken;
}
function forEachSingleProvider(providers2, fn) {
  for (const provider of providers2) {
    if (Array.isArray(provider)) {
      forEachSingleProvider(provider, fn);
    } else if (provider && isEnvironmentProviders(provider)) {
      forEachSingleProvider(provider.\u0275providers, fn);
    } else {
      fn(provider);
    }
  }
}
function runInInjectionContext(injector, fn) {
  if (injector instanceof R3Injector) {
    assertNotDestroyed(injector);
  }
  let prevInjectorProfilerContext;
  if (ngDevMode) {
    prevInjectorProfilerContext = setInjectorProfilerContext({
      injector,
      token: null
    });
  }
  const prevInjector = setCurrentInjector(injector);
  const previousInjectImplementation = setInjectImplementation(void 0);
  try {
    return fn();
  } finally {
    setCurrentInjector(prevInjector);
    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);
    setInjectImplementation(previousInjectImplementation);
  }
}
function isInInjectionContext() {
  return getInjectImplementation() !== void 0 || getCurrentInjector() != null;
}
function assertInInjectionContext(debugFn) {
  if (!isInInjectionContext()) {
    throw new RuntimeError(-203, ngDevMode && debugFn.name + "() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`");
  }
}
var FactoryTarget;
(function(FactoryTarget2) {
  FactoryTarget2[FactoryTarget2["Directive"] = 0] = "Directive";
  FactoryTarget2[FactoryTarget2["Component"] = 1] = "Component";
  FactoryTarget2[FactoryTarget2["Injectable"] = 2] = "Injectable";
  FactoryTarget2[FactoryTarget2["Pipe"] = 3] = "Pipe";
  FactoryTarget2[FactoryTarget2["NgModule"] = 4] = "NgModule";
})(FactoryTarget || (FactoryTarget = {}));
var R3TemplateDependencyKind;
(function(R3TemplateDependencyKind2) {
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["Directive"] = 0] = "Directive";
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["Pipe"] = 1] = "Pipe";
  R3TemplateDependencyKind2[R3TemplateDependencyKind2["NgModule"] = 2] = "NgModule";
})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));
var ViewEncapsulation$1;
(function(ViewEncapsulation2) {
  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
function getCompilerFacade(request) {
  const globalNg = _global["ng"];
  if (globalNg && globalNg.\u0275compilerFacade) {
    return globalNg.\u0275compilerFacade;
  }
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.error(`JIT compilation failed for ${request.kind}`, request.type);
    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

`;
    if (request.usage === 1) {
      message += `The ${request.kind} is part of a library that has been partially compiled.
`;
      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
`;
      message += "\n";
      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
`;
    } else {
      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
`;
    }
    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
`;
    message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
    throw new Error(message);
  } else {
    throw new Error("JIT compiler unavailable");
  }
}
var angularCoreDiEnv = {
  "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
  "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
  "\u0275\u0275inject": \u0275\u0275inject,
  "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
  "resolveForwardRef": resolveForwardRef
};
var Type = Function;
function isType(v) {
  return typeof v === "function";
}
var ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
var ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
var ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
var ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;
function isDelegateCtor(typeStr) {
  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
}
var ReflectionCapabilities = class {
  _reflect;
  constructor(reflect) {
    this._reflect = reflect || _global["Reflect"];
  }
  factory(t2) {
    return (...args) => new t2(...args);
  }
  /** @internal */
  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
    let result;
    if (typeof paramTypes === "undefined") {
      result = newArray(paramAnnotations.length);
    } else {
      result = newArray(paramTypes.length);
    }
    for (let i = 0; i < result.length; i++) {
      if (typeof paramTypes === "undefined") {
        result[i] = [];
      } else if (paramTypes[i] && paramTypes[i] != Object) {
        result[i] = [paramTypes[i]];
      } else {
        result[i] = [];
      }
      if (paramAnnotations && paramAnnotations[i] != null) {
        result[i] = result[i].concat(paramAnnotations[i]);
      }
    }
    return result;
  }
  _ownParameters(type2, parentCtor) {
    const typeStr = type2.toString();
    if (isDelegateCtor(typeStr)) {
      return null;
    }
    if (type2.parameters && type2.parameters !== parentCtor.parameters) {
      return type2.parameters;
    }
    const tsickleCtorParams = type2.ctorParameters;
    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
      const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
      const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
      const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
      return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
    }
    const paramAnnotations = type2.hasOwnProperty(PARAMETERS) && type2[PARAMETERS];
    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type2);
    if (paramTypes || paramAnnotations) {
      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
    }
    return newArray(type2.length);
  }
  parameters(type2) {
    if (!isType(type2)) {
      return [];
    }
    const parentCtor = getParentCtor(type2);
    let parameters = this._ownParameters(type2, parentCtor);
    if (!parameters && parentCtor !== Object) {
      parameters = this.parameters(parentCtor);
    }
    return parameters || [];
  }
  _ownAnnotations(typeOrFunc, parentCtor) {
    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
      let annotations = typeOrFunc.annotations;
      if (typeof annotations === "function" && annotations.annotations) {
        annotations = annotations.annotations;
      }
      return annotations;
    }
    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
    }
    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
      return typeOrFunc[ANNOTATIONS];
    }
    return null;
  }
  annotations(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return [];
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
    return parentAnnotations.concat(ownAnnotations);
  }
  _ownPropMetadata(typeOrFunc, parentCtor) {
    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
      let propMetadata = typeOrFunc.propMetadata;
      if (typeof propMetadata === "function" && propMetadata.propMetadata) {
        propMetadata = propMetadata.propMetadata;
      }
      return propMetadata;
    }
    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
      const propDecorators = typeOrFunc.propDecorators;
      const propMetadata = {};
      Object.keys(propDecorators).forEach((prop) => {
        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
      });
      return propMetadata;
    }
    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
      return typeOrFunc[PROP_METADATA];
    }
    return null;
  }
  propMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    const parentCtor = getParentCtor(typeOrFunc);
    const propMetadata = {};
    if (parentCtor !== Object) {
      const parentPropMetadata = this.propMetadata(parentCtor);
      Object.keys(parentPropMetadata).forEach((propName) => {
        propMetadata[propName] = parentPropMetadata[propName];
      });
    }
    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
    if (ownPropMetadata) {
      Object.keys(ownPropMetadata).forEach((propName) => {
        const decorators = [];
        if (propMetadata.hasOwnProperty(propName)) {
          decorators.push(...propMetadata[propName]);
        }
        decorators.push(...ownPropMetadata[propName]);
        propMetadata[propName] = decorators;
      });
    }
    return propMetadata;
  }
  ownPropMetadata(typeOrFunc) {
    if (!isType(typeOrFunc)) {
      return {};
    }
    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
  }
  hasLifecycleHook(type2, lcProperty) {
    return type2 instanceof Type && lcProperty in type2.prototype;
  }
};
function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
  if (!decoratorInvocations) {
    return [];
  }
  return decoratorInvocations.map((decoratorInvocation) => {
    const decoratorType = decoratorInvocation.type;
    const annotationCls = decoratorType.annotationCls;
    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
    return new annotationCls(...annotationArgs);
  });
}
function getParentCtor(ctor) {
  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
  const parentCtor = parentProto ? parentProto.constructor : null;
  return parentCtor || Object;
}
var HOST = 0;
var TVIEW = 1;
var FLAGS = 2;
var PARENT = 3;
var NEXT = 4;
var T_HOST = 5;
var HYDRATION = 6;
var CLEANUP = 7;
var CONTEXT = 8;
var INJECTOR = 9;
var ENVIRONMENT = 10;
var RENDERER = 11;
var CHILD_HEAD = 12;
var CHILD_TAIL = 13;
var DECLARATION_VIEW = 14;
var DECLARATION_COMPONENT_VIEW = 15;
var DECLARATION_LCONTAINER = 16;
var PREORDER_HOOK_FLAGS = 17;
var QUERIES = 18;
var ID = 19;
var EMBEDDED_VIEW_INJECTOR = 20;
var ON_DESTROY_HOOKS = 21;
var EFFECTS_TO_SCHEDULE = 22;
var EFFECTS = 23;
var REACTIVE_TEMPLATE_CONSUMER = 24;
var HEADER_OFFSET = 25;
var TYPE = 1;
var DEHYDRATED_VIEWS = 6;
var NATIVE = 7;
var VIEW_REFS = 8;
var MOVED_VIEWS = 9;
var CONTAINER_HEADER_OFFSET = 10;
var LContainerFlags;
(function(LContainerFlags2) {
  LContainerFlags2[LContainerFlags2["None"] = 0] = "None";
  LContainerFlags2[LContainerFlags2["HasTransplantedViews"] = 2] = "HasTransplantedViews";
})(LContainerFlags || (LContainerFlags = {}));
function isLView(value2) {
  return Array.isArray(value2) && typeof value2[TYPE] === "object";
}
function isLContainer(value2) {
  return Array.isArray(value2) && value2[TYPE] === true;
}
function isContentQueryHost(tNode) {
  return (tNode.flags & 4) !== 0;
}
function isComponentHost(tNode) {
  return tNode.componentOffset > -1;
}
function isDirectiveHost(tNode) {
  return (tNode.flags & 1) === 1;
}
function isComponentDef(def) {
  return !!def.template;
}
function isRootView(target) {
  return (target[FLAGS] & 512) !== 0;
}
function isDestroyed(lView) {
  return (lView[FLAGS] & 256) === 256;
}
function assertTNodeForLView(tNode, lView) {
  assertTNodeForTView(tNode, lView[TVIEW]);
}
function assertTNodeForTView(tNode, tView) {
  assertTNode(tNode);
  const tData = tView.data;
  for (let i = HEADER_OFFSET; i < tData.length; i++) {
    if (tData[i] === tNode) {
      return;
    }
  }
  throwError2("This TNode does not belong to this TView.");
}
function assertTNode(tNode) {
  assertDefined(tNode, "TNode must be defined");
  if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
    throwError2("Not of type TNode, got: " + tNode);
  }
}
function assertTIcu(tIcu) {
  assertDefined(tIcu, "Expected TIcu to be defined");
  if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
    throwError2("Object is not of TIcu type.");
  }
}
function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have '\u0275cmp' property.") {
  if (!getComponentDef(actual)) {
    throwError2(msg);
  }
}
function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have '\u0275mod' property.") {
  if (!getNgModuleDef(actual)) {
    throwError2(msg);
  }
}
function assertHasParent(tNode) {
  assertDefined(tNode, "currentTNode should exist!");
  assertDefined(tNode.parent, "currentTNode should have a parent");
}
function assertLContainer(value2) {
  assertDefined(value2, "LContainer must be defined");
  assertEqual(isLContainer(value2), true, "Expecting LContainer");
}
function assertLViewOrUndefined(value2) {
  value2 && assertEqual(isLView(value2), true, "Expecting LView or undefined or null");
}
function assertLView(value2) {
  assertDefined(value2, "LView must be defined");
  assertEqual(isLView(value2), true, "Expecting LView");
}
function assertFirstCreatePass(tView, errMessage) {
  assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
}
function assertFirstUpdatePass(tView, errMessage) {
  assertEqual(tView.firstUpdatePass, true, errMessage || "Should only be called in first update pass.");
}
function assertDirectiveDef(obj) {
  if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
    throwError2(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
  }
}
function assertIndexInDeclRange(tView, index) {
  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
}
function assertIndexInExpandoRange(lView, index) {
  const tView = lView[1];
  assertBetween(tView.expandoStartIndex, lView.length, index);
}
function assertBetween(lower2, upper, index) {
  if (!(lower2 <= index && index < upper)) {
    throwError2(`Index out of range (expecting ${lower2} <= ${index} < ${upper})`);
  }
}
function assertProjectionSlots(lView, errMessage) {
  assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || "Components with projection nodes (<ng-content>) must have projection slots defined.");
}
function assertParentView(lView, errMessage) {
  assertDefined(lView, errMessage || "Component views should always have a parent view (component's host view)");
}
function assertNoDuplicateDirectives(directives) {
  if (directives.length < 2) {
    return;
  }
  const seenDirectives = /* @__PURE__ */ new Set();
  for (const current of directives) {
    if (seenDirectives.has(current)) {
      throw new RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);
    }
    seenDirectives.add(current);
  }
}
function assertNodeInjector(lView, injectorIndex) {
  assertIndexInExpandoRange(lView, injectorIndex);
  assertIndexInExpandoRange(
    lView,
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  );
  assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
  assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
  assertNumber(lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ], "injectorIndex should point to parent injector");
}
var SimpleChange = class {
  previousValue;
  currentValue;
  firstChange;
  constructor(previousValue, currentValue, firstChange) {
    this.previousValue = previousValue;
    this.currentValue = currentValue;
    this.firstChange = firstChange;
  }
  /**
   * Check whether the new value is the first value assigned.
   */
  isFirstChange() {
    return this.firstChange;
  }
};
function applyValueToInputField(instance, inputSignalNode, privateName, value2) {
  if (inputSignalNode !== null) {
    inputSignalNode.applyValueToInputSignal(inputSignalNode, value2);
  } else {
    instance[privateName] = value2;
  }
}
var \u0275\u0275NgOnChangesFeature = /* @__PURE__ */ (() => {
  const \u0275\u0275NgOnChangesFeatureImpl = () => NgOnChangesFeatureImpl;
  \u0275\u0275NgOnChangesFeatureImpl.ngInherit = true;
  return \u0275\u0275NgOnChangesFeatureImpl;
})();
function NgOnChangesFeatureImpl(definition) {
  if (definition.type.prototype.ngOnChanges) {
    definition.setInput = ngOnChangesSetInput;
  }
  return rememberChangeHistoryAndInvokeOnChangesHook;
}
function rememberChangeHistoryAndInvokeOnChangesHook() {
  const simpleChangesStore = getSimpleChangesStore(this);
  const current = simpleChangesStore?.current;
  if (current) {
    const previous = simpleChangesStore.previous;
    if (previous === EMPTY_OBJ) {
      simpleChangesStore.previous = current;
    } else {
      for (let key in current) {
        previous[key] = current[key];
      }
    }
    simpleChangesStore.current = null;
    this.ngOnChanges(current);
  }
}
function ngOnChangesSetInput(instance, inputSignalNode, value2, publicName, privateName) {
  const declaredName = this.declaredInputs[publicName];
  ngDevMode && assertString(declaredName, "Name of input in ngOnChanges has to be a string");
  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {
    previous: EMPTY_OBJ,
    current: null
  });
  const current = simpleChangesStore.current || (simpleChangesStore.current = {});
  const previous = simpleChangesStore.previous;
  const previousChange = previous[declaredName];
  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value2, previous === EMPTY_OBJ);
  applyValueToInputField(instance, inputSignalNode, privateName, value2);
}
var SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
function getSimpleChangesStore(instance) {
  return instance[SIMPLE_CHANGES_STORE] || null;
}
function setSimpleChangesStore(instance, store2) {
  return instance[SIMPLE_CHANGES_STORE] = store2;
}
var profilerCallback = null;
var setProfiler = (profiler2) => {
  profilerCallback = profiler2;
};
var profiler = function(event, instance, hookOrListener) {
  if (profilerCallback != null) {
    profilerCallback(event, instance, hookOrListener);
  }
};
var SVG_NAMESPACE = "svg";
var MATH_ML_NAMESPACE = "math";
function unwrapRNode(value2) {
  while (Array.isArray(value2)) {
    value2 = value2[HOST];
  }
  return value2;
}
function unwrapLView(value2) {
  while (Array.isArray(value2)) {
    if (typeof value2[TYPE] === "object") return value2;
    value2 = value2[HOST];
  }
  return null;
}
function getNativeByIndex(index, lView) {
  ngDevMode && assertIndexInRange(lView, index);
  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Expected to be past HEADER_OFFSET");
  return unwrapRNode(lView[index]);
}
function getNativeByTNode(tNode, lView) {
  ngDevMode && assertTNodeForLView(tNode, lView);
  ngDevMode && assertIndexInRange(lView, tNode.index);
  const node = unwrapRNode(lView[tNode.index]);
  return node;
}
function getTNode(tView, index) {
  ngDevMode && assertGreaterThan(index, -1, "wrong index for TNode");
  ngDevMode && assertLessThan(index, tView.data.length, "wrong index for TNode");
  const tNode = tView.data[index];
  ngDevMode && tNode !== null && assertTNode(tNode);
  return tNode;
}
function load(view, index) {
  ngDevMode && assertIndexInRange(view, index);
  return view[index];
}
function getComponentLViewByIndex(nodeIndex, hostView) {
  ngDevMode && assertIndexInRange(hostView, nodeIndex);
  const slotValue = hostView[nodeIndex];
  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
  return lView;
}
function isCreationMode(view) {
  return (view[FLAGS] & 4) === 4;
}
function viewAttachedToChangeDetector(view) {
  return (view[FLAGS] & 128) === 128;
}
function viewAttachedToContainer(view) {
  return isLContainer(view[PARENT]);
}
function getConstant(consts, index) {
  if (index === null || index === void 0) return null;
  ngDevMode && assertIndexInRange(consts, index);
  return consts[index];
}
function resetPreOrderHookFlags(lView) {
  lView[PREORDER_HOOK_FLAGS] = 0;
}
function markViewForRefresh(lView) {
  if (lView[FLAGS] & 1024) {
    return;
  }
  lView[FLAGS] |= 1024;
  if (viewAttachedToChangeDetector(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function walkUpViews(nestingLevel, currentView) {
  while (nestingLevel > 0) {
    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], "Declaration view should be defined if nesting level is greater than 0.");
    currentView = currentView[DECLARATION_VIEW];
    nestingLevel--;
  }
  return currentView;
}
function requiresRefreshOrTraversal(lView) {
  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);
}
function updateAncestorTraversalFlagsOnAttach(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    9
    /* NotificationSource.ViewAttached */
  );
  if (lView[FLAGS] & 64) {
    lView[FLAGS] |= 1024;
  }
  if (requiresRefreshOrTraversal(lView)) {
    markAncestorsForTraversal(lView);
  }
}
function markAncestorsForTraversal(lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    0
    /* NotificationSource.MarkAncestorsForTraversal */
  );
  let parent = getLViewParent(lView);
  while (parent !== null) {
    if (parent[FLAGS] & 8192) {
      break;
    }
    parent[FLAGS] |= 8192;
    if (!viewAttachedToChangeDetector(parent)) {
      break;
    }
    parent = getLViewParent(parent);
  }
}
function storeLViewOnDestroy(lView, onDestroyCallback) {
  if ((lView[FLAGS] & 256) === 256) {
    throw new RuntimeError(911, ngDevMode && "View has already been destroyed.");
  }
  if (lView[ON_DESTROY_HOOKS] === null) {
    lView[ON_DESTROY_HOOKS] = [];
  }
  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);
}
function removeLViewOnDestroy(lView, onDestroyCallback) {
  if (lView[ON_DESTROY_HOOKS] === null) return;
  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);
  if (destroyCBIdx !== -1) {
    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);
  }
}
function getLViewParent(lView) {
  ngDevMode && assertLView(lView);
  const parent = lView[PARENT];
  return isLContainer(parent) ? parent[PARENT] : parent;
}
var instructionState = {
  lFrame: createLFrame(null),
  bindingsEnabled: true,
  skipHydrationRootTNode: null
};
var CheckNoChangesMode;
(function(CheckNoChangesMode2) {
  CheckNoChangesMode2[CheckNoChangesMode2["Off"] = 0] = "Off";
  CheckNoChangesMode2[CheckNoChangesMode2["Exhaustive"] = 1] = "Exhaustive";
  CheckNoChangesMode2[CheckNoChangesMode2["OnlyDirtyViews"] = 2] = "OnlyDirtyViews";
})(CheckNoChangesMode || (CheckNoChangesMode = {}));
var _checkNoChangesMode = 0;
var _isRefreshingViews = false;
function getElementDepthCount() {
  return instructionState.lFrame.elementDepthCount;
}
function increaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount++;
}
function decreaseElementDepthCount() {
  instructionState.lFrame.elementDepthCount--;
}
function getBindingsEnabled() {
  return instructionState.bindingsEnabled;
}
function isInSkipHydrationBlock$1() {
  return instructionState.skipHydrationRootTNode !== null;
}
function isSkipHydrationRootTNode(tNode) {
  return instructionState.skipHydrationRootTNode === tNode;
}
function \u0275\u0275enableBindings() {
  instructionState.bindingsEnabled = true;
}
function \u0275\u0275disableBindings() {
  instructionState.bindingsEnabled = false;
}
function leaveSkipHydrationBlock() {
  instructionState.skipHydrationRootTNode = null;
}
function getLView() {
  return instructionState.lFrame.lView;
}
function getTView() {
  return instructionState.lFrame.tView;
}
function \u0275\u0275restoreView(viewToRestore) {
  instructionState.lFrame.contextLView = viewToRestore;
  return viewToRestore[CONTEXT];
}
function \u0275\u0275resetView(value2) {
  instructionState.lFrame.contextLView = null;
  return value2;
}
function getCurrentTNode() {
  let currentTNode = getCurrentTNodePlaceholderOk();
  while (currentTNode !== null && currentTNode.type === 64) {
    currentTNode = currentTNode.parent;
  }
  return currentTNode;
}
function getCurrentTNodePlaceholderOk() {
  return instructionState.lFrame.currentTNode;
}
function getCurrentParentTNode() {
  const lFrame = instructionState.lFrame;
  const currentTNode = lFrame.currentTNode;
  return lFrame.isParent ? currentTNode : currentTNode.parent;
}
function setCurrentTNode(tNode, isParent) {
  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
  const lFrame = instructionState.lFrame;
  lFrame.currentTNode = tNode;
  lFrame.isParent = isParent;
}
function isCurrentTNodeParent() {
  return instructionState.lFrame.isParent;
}
function setCurrentTNodeAsNotParent() {
  instructionState.lFrame.isParent = false;
}
function getContextLView() {
  const contextLView = instructionState.lFrame.contextLView;
  ngDevMode && assertDefined(contextLView, "contextLView must be defined.");
  return contextLView;
}
function isInCheckNoChangesMode() {
  !ngDevMode && throwError2("Must never be called in production mode");
  return _checkNoChangesMode !== CheckNoChangesMode.Off;
}
function isExhaustiveCheckNoChanges() {
  !ngDevMode && throwError2("Must never be called in production mode");
  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;
}
function setIsInCheckNoChangesMode(mode) {
  !ngDevMode && throwError2("Must never be called in production mode");
  _checkNoChangesMode = mode;
}
function isRefreshingViews() {
  return _isRefreshingViews;
}
function setIsRefreshingViews(mode) {
  const prev = _isRefreshingViews;
  _isRefreshingViews = mode;
  return prev;
}
function getBindingRoot() {
  const lFrame = instructionState.lFrame;
  let index = lFrame.bindingRootIndex;
  if (index === -1) {
    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
  }
  return index;
}
function getBindingIndex() {
  return instructionState.lFrame.bindingIndex;
}
function setBindingIndex(value2) {
  return instructionState.lFrame.bindingIndex = value2;
}
function nextBindingIndex() {
  return instructionState.lFrame.bindingIndex++;
}
function incrementBindingIndex(count3) {
  const lFrame = instructionState.lFrame;
  const index = lFrame.bindingIndex;
  lFrame.bindingIndex = lFrame.bindingIndex + count3;
  return index;
}
function isInI18nBlock() {
  return instructionState.lFrame.inI18n;
}
function setInI18nBlock(isInI18nBlock2) {
  instructionState.lFrame.inI18n = isInI18nBlock2;
}
function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
  const lFrame = instructionState.lFrame;
  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
  setCurrentDirectiveIndex(currentDirectiveIndex);
}
function getCurrentDirectiveIndex() {
  return instructionState.lFrame.currentDirectiveIndex;
}
function setCurrentDirectiveIndex(currentDirectiveIndex) {
  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
}
function getCurrentDirectiveDef(tData) {
  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
}
function getCurrentQueryIndex() {
  return instructionState.lFrame.currentQueryIndex;
}
function setCurrentQueryIndex(value2) {
  instructionState.lFrame.currentQueryIndex = value2;
}
function getDeclarationTNode(lView) {
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  }
  if (tView.type === 1) {
    return lView[T_HOST];
  }
  return null;
}
function enterDI(lView, tNode, flags) {
  ngDevMode && assertLViewOrUndefined(lView);
  if (flags & InjectFlags.SkipSelf) {
    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
    let parentTNode = tNode;
    let parentLView = lView;
    while (true) {
      ngDevMode && assertDefined(parentTNode, "Parent TNode should be defined");
      parentTNode = parentTNode.parent;
      if (parentTNode === null && !(flags & InjectFlags.Host)) {
        parentTNode = getDeclarationTNode(parentLView);
        if (parentTNode === null) break;
        ngDevMode && assertDefined(parentLView, "Parent LView should be defined");
        parentLView = parentLView[DECLARATION_VIEW];
        if (parentTNode.type & (2 | 8)) {
          break;
        }
      } else {
        break;
      }
    }
    if (parentTNode === null) {
      return false;
    } else {
      tNode = parentTNode;
      lView = parentLView;
    }
  }
  ngDevMode && assertTNodeForLView(tNode, lView);
  const lFrame = instructionState.lFrame = allocLFrame();
  lFrame.currentTNode = tNode;
  lFrame.lView = lView;
  return true;
}
function enterView(newView) {
  ngDevMode && assertNotEqual(newView[0], newView[1], "????");
  ngDevMode && assertLViewOrUndefined(newView);
  const newLFrame = allocLFrame();
  if (ngDevMode) {
    assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
    assertEqual(newLFrame.lView, null, "Expected clean LFrame");
    assertEqual(newLFrame.tView, null, "Expected clean LFrame");
    assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
    assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
    assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
    assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
  }
  const tView = newView[TVIEW];
  instructionState.lFrame = newLFrame;
  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
  newLFrame.currentTNode = tView.firstChild;
  newLFrame.lView = newView;
  newLFrame.tView = tView;
  newLFrame.contextLView = newView;
  newLFrame.bindingIndex = tView.bindingStartIndex;
  newLFrame.inI18n = false;
}
function allocLFrame() {
  const currentLFrame = instructionState.lFrame;
  const childLFrame = currentLFrame === null ? null : currentLFrame.child;
  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
  return newLFrame;
}
function createLFrame(parent) {
  const lFrame = {
    currentTNode: null,
    isParent: true,
    lView: null,
    tView: null,
    selectedIndex: -1,
    contextLView: null,
    elementDepthCount: 0,
    currentNamespace: null,
    currentDirectiveIndex: -1,
    bindingRootIndex: -1,
    bindingIndex: -1,
    currentQueryIndex: 0,
    parent,
    child: null,
    inI18n: false
  };
  parent !== null && (parent.child = lFrame);
  return lFrame;
}
function leaveViewLight() {
  const oldLFrame = instructionState.lFrame;
  instructionState.lFrame = oldLFrame.parent;
  oldLFrame.currentTNode = null;
  oldLFrame.lView = null;
  return oldLFrame;
}
var leaveDI = leaveViewLight;
function leaveView() {
  const oldLFrame = leaveViewLight();
  oldLFrame.isParent = true;
  oldLFrame.tView = null;
  oldLFrame.selectedIndex = -1;
  oldLFrame.contextLView = null;
  oldLFrame.elementDepthCount = 0;
  oldLFrame.currentDirectiveIndex = -1;
  oldLFrame.currentNamespace = null;
  oldLFrame.bindingRootIndex = -1;
  oldLFrame.bindingIndex = -1;
  oldLFrame.currentQueryIndex = 0;
}
function nextContextImpl(level) {
  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
  return contextLView[CONTEXT];
}
function getSelectedIndex() {
  return instructionState.lFrame.selectedIndex;
}
function setSelectedIndex(index) {
  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Index must be past HEADER_OFFSET (or -1).");
  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
  instructionState.lFrame.selectedIndex = index;
}
function getSelectedTNode() {
  const lFrame = instructionState.lFrame;
  return getTNode(lFrame.tView, lFrame.selectedIndex);
}
function \u0275\u0275namespaceSVG() {
  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
}
function \u0275\u0275namespaceMathML() {
  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
}
function \u0275\u0275namespaceHTML() {
  namespaceHTMLInternal();
}
function namespaceHTMLInternal() {
  instructionState.lFrame.currentNamespace = null;
}
function getNamespace$1() {
  return instructionState.lFrame.currentNamespace;
}
var _wasLastNodeCreated = true;
function wasLastNodeCreated() {
  return _wasLastNodeCreated;
}
function lastNodeWasCreated(flag) {
  _wasLastNodeCreated = flag;
}
function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
  ngDevMode && assertFirstCreatePass(tView);
  const {
    ngOnChanges,
    ngOnInit,
    ngDoCheck
  } = directiveDef.type.prototype;
  if (ngOnChanges) {
    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);
  }
  if (ngOnInit) {
    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);
  }
  if (ngDoCheck) {
    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);
    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);
  }
}
function registerPostOrderHooks(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let i = tNode.directiveStart, end2 = tNode.directiveEnd; i < end2; i++) {
    const directiveDef = tView.data[i];
    ngDevMode && assertDefined(directiveDef, "Expecting DirectiveDef");
    const lifecycleHooks = directiveDef.type.prototype;
    const {
      ngAfterContentInit,
      ngAfterContentChecked,
      ngAfterViewInit,
      ngAfterViewChecked,
      ngOnDestroy
    } = lifecycleHooks;
    if (ngAfterContentInit) {
      (tView.contentHooks ??= []).push(-i, ngAfterContentInit);
    }
    if (ngAfterContentChecked) {
      (tView.contentHooks ??= []).push(i, ngAfterContentChecked);
      (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);
    }
    if (ngAfterViewInit) {
      (tView.viewHooks ??= []).push(-i, ngAfterViewInit);
    }
    if (ngAfterViewChecked) {
      (tView.viewHooks ??= []).push(i, ngAfterViewChecked);
      (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);
    }
    if (ngOnDestroy != null) {
      (tView.destroyHooks ??= []).push(i, ngOnDestroy);
    }
  }
}
function executeCheckHooks(lView, hooks, nodeIndex) {
  callHooks(lView, hooks, 3, nodeIndex);
}
function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init pre-order hooks should not be called more than once");
  if ((lView[FLAGS] & 3) === initPhase) {
    callHooks(lView, hooks, initPhase, nodeIndex);
  }
}
function incrementInitPhaseFlags(lView, initPhase) {
  ngDevMode && assertNotEqual(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
  let flags = lView[FLAGS];
  if ((flags & 3) === initPhase) {
    flags &= 16383;
    flags += 1;
    lView[FLAGS] = flags;
  }
}
function callHooks(currentView, arr, initPhase, currentNodeIndex) {
  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, "Hooks should never be run when in check no changes mode.");
  const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
  const max6 = arr.length - 1;
  let lastNodeIndexFound = 0;
  for (let i = startIndex; i < max6; i++) {
    const hook = arr[i + 1];
    if (typeof hook === "number") {
      lastNodeIndexFound = arr[i];
      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
        break;
      }
    } else {
      const isInitHook = arr[i] < 0;
      if (isInitHook) {
        currentView[PREORDER_HOOK_FLAGS] += 65536;
      }
      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
        callHook(currentView, initPhase, arr, i);
        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
      }
      i++;
    }
  }
}
function callHookInternal(directive, hook) {
  profiler(4, directive, hook);
  const prevConsumer = setActiveConsumer(null);
  try {
    hook.call(directive);
  } finally {
    setActiveConsumer(prevConsumer);
    profiler(5, directive, hook);
  }
}
function callHook(currentView, initPhase, arr, i) {
  const isInitHook = arr[i] < 0;
  const hook = arr[i + 1];
  const directiveIndex = isInitHook ? -arr[i] : arr[i];
  const directive = currentView[directiveIndex];
  if (isInitHook) {
    const indexWithintInitPhase = currentView[FLAGS] >> 14;
    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
      currentView[FLAGS] += 16384;
      callHookInternal(directive, hook);
    }
  } else {
    callHookInternal(directive, hook);
  }
}
var NO_PARENT_INJECTOR = -1;
var NodeInjectorFactory = class {
  factory;
  /**
   * The inject implementation to be activated when using the factory.
   */
  injectImpl;
  /**
   * Marker set to true during factory invocation to see if we get into recursive loop.
   * Recursive loop causes an error to be displayed.
   */
  resolving = false;
  /**
   * Marks that the token can see other Tokens declared in `viewProviders` on the same node.
   */
  canSeeViewProviders;
  /**
   * An array of factories to use in case of `multi` provider.
   */
  multi;
  /**
   * Number of `multi`-providers which belong to the component.
   *
   * This is needed because when multiple components and directives declare the `multi` provider
   * they have to be concatenated in the correct order.
   *
   * Example:
   *
   * If we have a component and directive active an a single element as declared here
   * ```
   * component:
   *   providers: [ {provide: String, useValue: 'component', multi: true} ],
   *   viewProviders: [ {provide: String, useValue: 'componentView', multi: true} ],
   *
   * directive:
   *   providers: [ {provide: String, useValue: 'directive', multi: true} ],
   * ```
   *
   * Then the expected results are:
   *
   * ```
   * providers: ['component', 'directive']
   * viewProviders: ['component', 'componentView', 'directive']
   * ```
   *
   * The way to think about it is that the `viewProviders` have been inserted after the component
   * but before the directives, which is why we need to know how many `multi`s have been declared by
   * the component.
   */
  componentProviders;
  /**
   * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.
   * See `providerFactory`.
   */
  index;
  /**
   * Because the same `multi` provider can be declared in `providers` and `viewProviders` it is
   * possible for `viewProviders` to shadow the `providers`. For this reason we store the
   * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.
   *
   * Example:
   *
   * Given:
   * ```
   * providers: [ {provide: String, useValue: 'all', multi: true} ],
   * viewProviders: [ {provide: String, useValue: 'viewOnly', multi: true} ],
   * ```
   *
   * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case
   * of view injection. We further have to make sure that the shared instances (in our case
   * `all`) are the exact same instance in both the content as well as the view injection. (We
   * have to make sure that we don't double instantiate.) For this reason the `viewProviders`
   * `Factory` has a pointer to the shadowed `providers` factory so that it can instantiate the
   * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =
   * ['all', 'viewOnly']`).
   */
  providerFactory;
  constructor(factory, isViewProvider, injectImplementation) {
    this.factory = factory;
    ngDevMode && assertDefined(factory, "Factory not specified");
    ngDevMode && assertEqual(typeof factory, "function", "Expected factory function.");
    this.canSeeViewProviders = isViewProvider;
    this.injectImpl = injectImplementation;
  }
};
function isFactory(obj) {
  return obj instanceof NodeInjectorFactory;
}
function toTNodeTypeAsString(tNodeType) {
  let text2 = "";
  tNodeType & 1 && (text2 += "|Text");
  tNodeType & 2 && (text2 += "|Element");
  tNodeType & 4 && (text2 += "|Container");
  tNodeType & 8 && (text2 += "|ElementContainer");
  tNodeType & 16 && (text2 += "|Projection");
  tNodeType & 32 && (text2 += "|IcuContainer");
  tNodeType & 64 && (text2 += "|Placeholder");
  tNodeType & 128 && (text2 += "|LetDeclaration");
  return text2.length > 0 ? text2.substring(1) : text2;
}
function isTNodeShape(value2) {
  return value2 != null && typeof value2 === "object" && (value2.insertBeforeIndex === null || typeof value2.insertBeforeIndex === "number" || Array.isArray(value2.insertBeforeIndex));
}
function hasClassInput(tNode) {
  return (tNode.flags & 8) !== 0;
}
function hasStyleInput(tNode) {
  return (tNode.flags & 16) !== 0;
}
function assertTNodeType(tNode, expectedTypes, message) {
  assertDefined(tNode, "should be called with a TNode");
  if ((tNode.type & expectedTypes) === 0) {
    throwError2(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
  }
}
function assertPureTNodeType(type2) {
  if (!(type2 === 2 || type2 === 1 || type2 === 4 || type2 === 8 || type2 === 32 || type2 === 16 || type2 === 64 || type2 === 128)) {
    throwError2(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type2)}.`);
  }
}
function setUpAttributes(renderer, native, attrs) {
  let i = 0;
  while (i < attrs.length) {
    const value2 = attrs[i];
    if (typeof value2 === "number") {
      if (value2 !== 0) {
        break;
      }
      i++;
      const namespaceURI = attrs[i++];
      const attrName = attrs[i++];
      const attrVal = attrs[i++];
      ngDevMode && ngDevMode.rendererSetAttribute++;
      renderer.setAttribute(native, attrName, attrVal, namespaceURI);
    } else {
      const attrName = value2;
      const attrVal = attrs[++i];
      ngDevMode && ngDevMode.rendererSetAttribute++;
      if (isAnimationProp(attrName)) {
        renderer.setProperty(native, attrName, attrVal);
      } else {
        renderer.setAttribute(native, attrName, attrVal);
      }
      i++;
    }
  }
  return i;
}
function isNameOnlyAttributeMarker(marker) {
  return marker === 3 || marker === 4 || marker === 6;
}
function isAnimationProp(name) {
  return name.charCodeAt(0) === 64;
}
function mergeHostAttrs(dst, src) {
  if (src === null || src.length === 0) {
  } else if (dst === null || dst.length === 0) {
    dst = src.slice();
  } else {
    let srcMarker = -1;
    for (let i = 0; i < src.length; i++) {
      const item = src[i];
      if (typeof item === "number") {
        srcMarker = item;
      } else {
        if (srcMarker === 0) {
        } else if (srcMarker === -1 || srcMarker === 2) {
          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
        } else {
          mergeHostAttribute(dst, srcMarker, item, null, null);
        }
      }
    }
  }
  return dst;
}
function mergeHostAttribute(dst, marker, key1, key2, value2) {
  let i = 0;
  let markerInsertPosition = dst.length;
  if (marker === -1) {
    markerInsertPosition = -1;
  } else {
    while (i < dst.length) {
      const dstValue = dst[i++];
      if (typeof dstValue === "number") {
        if (dstValue === marker) {
          markerInsertPosition = -1;
          break;
        } else if (dstValue > marker) {
          markerInsertPosition = i - 1;
          break;
        }
      }
    }
  }
  while (i < dst.length) {
    const item = dst[i];
    if (typeof item === "number") {
      break;
    } else if (item === key1) {
      if (key2 === null) {
        if (value2 !== null) {
          dst[i + 1] = value2;
        }
        return;
      } else if (key2 === dst[i + 1]) {
        dst[i + 2] = value2;
        return;
      }
    }
    i++;
    if (key2 !== null) i++;
    if (value2 !== null) i++;
  }
  if (markerInsertPosition !== -1) {
    dst.splice(markerInsertPosition, 0, marker);
    i = markerInsertPosition + 1;
  }
  dst.splice(i++, 0, key1);
  if (key2 !== null) {
    dst.splice(i++, 0, key2);
  }
  if (value2 !== null) {
    dst.splice(i++, 0, value2);
  }
}
var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
var ChainedInjector = class {
  injector;
  parentInjector;
  constructor(injector, parentInjector) {
    this.injector = injector;
    this.parentInjector = parentInjector;
  }
  get(token, notFoundValue, flags) {
    flags = convertToBitFlags(flags);
    const value2 = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
    if (value2 !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
      return value2;
    }
    return this.parentInjector.get(token, notFoundValue, flags);
  }
};
function hasParentInjector(parentLocation) {
  return parentLocation !== NO_PARENT_INJECTOR;
}
function getParentInjectorIndex(parentLocation) {
  if (ngDevMode) {
    assertNumber(parentLocation, "Number expected");
    assertNotEqual(parentLocation, -1, "Not a valid state.");
    const parentInjectorIndex = parentLocation & 32767;
    assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
  }
  return parentLocation & 32767;
}
function getParentInjectorViewOffset(parentLocation) {
  return parentLocation >> 16;
}
function getParentInjectorView(location2, startView) {
  let viewOffset = getParentInjectorViewOffset(location2);
  let parentView = startView;
  while (viewOffset > 0) {
    parentView = parentView[DECLARATION_VIEW];
    viewOffset--;
  }
  return parentView;
}
function isRouterOutletInjector(currentInjector) {
  return currentInjector instanceof ChainedInjector && typeof currentInjector.injector.__ngOutletInjector === "function";
}
var includeViewProviders = true;
function setIncludeViewProviders(v) {
  const oldValue = includeViewProviders;
  includeViewProviders = v;
  return oldValue;
}
var BLOOM_SIZE = 256;
var BLOOM_MASK = BLOOM_SIZE - 1;
var BLOOM_BUCKET_BITS = 5;
var nextNgElementId = 0;
var NOT_FOUND = {};
function bloomAdd(injectorIndex, tView, type2) {
  ngDevMode && assertEqual(tView.firstCreatePass, true, "expected firstCreatePass to be true");
  let id3;
  if (typeof type2 === "string") {
    id3 = type2.charCodeAt(0) || 0;
  } else if (type2.hasOwnProperty(NG_ELEMENT_ID)) {
    id3 = type2[NG_ELEMENT_ID];
  }
  if (id3 == null) {
    id3 = type2[NG_ELEMENT_ID] = nextNgElementId++;
  }
  const bloomHash = id3 & BLOOM_MASK;
  const mask = 1 << bloomHash;
  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
}
function getOrCreateNodeInjectorForNode(tNode, lView) {
  const existingInjectorIndex = getInjectorIndex(tNode, lView);
  if (existingInjectorIndex !== -1) {
    return existingInjectorIndex;
  }
  const tView = lView[TVIEW];
  if (tView.firstCreatePass) {
    tNode.injectorIndex = lView.length;
    insertBloom(tView.data, tNode);
    insertBloom(lView, null);
    insertBloom(tView.blueprint, null);
  }
  const parentLoc = getParentInjectorLocation(tNode, lView);
  const injectorIndex = tNode.injectorIndex;
  if (hasParentInjector(parentLoc)) {
    const parentIndex = getParentInjectorIndex(parentLoc);
    const parentLView = getParentInjectorView(parentLoc, lView);
    const parentData = parentLView[TVIEW].data;
    for (let i = 0; i < 8; i++) {
      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
    }
  }
  lView[
    injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] = parentLoc;
  return injectorIndex;
}
function insertBloom(arr, footer) {
  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
}
function getInjectorIndex(tNode, lView) {
  if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been
  // copied down from the parent node. No injector has been created yet on this node.
  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values
  // might not have been calculated yet for this instance
  lView[
    tNode.injectorIndex + 8
    /* NodeInjectorOffset.PARENT */
  ] === null) {
    return -1;
  } else {
    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
    return tNode.injectorIndex;
  }
}
function getParentInjectorLocation(tNode, lView) {
  if (tNode.parent && tNode.parent.injectorIndex !== -1) {
    return tNode.parent.injectorIndex;
  }
  let declarationViewOffset = 0;
  let parentTNode = null;
  let lViewCursor = lView;
  while (lViewCursor !== null) {
    parentTNode = getTNodeFromLView(lViewCursor);
    if (parentTNode === null) {
      return NO_PARENT_INJECTOR;
    }
    ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
    declarationViewOffset++;
    lViewCursor = lViewCursor[DECLARATION_VIEW];
    if (parentTNode.injectorIndex !== -1) {
      return parentTNode.injectorIndex | declarationViewOffset << 16;
    }
  }
  return NO_PARENT_INJECTOR;
}
function diPublicInInjector(injectorIndex, tView, token) {
  bloomAdd(injectorIndex, tView, token);
}
function injectAttributeImpl(tNode, attrNameToInject) {
  ngDevMode && assertTNodeType(
    tNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  ngDevMode && assertDefined(tNode, "expecting tNode");
  if (attrNameToInject === "class") {
    return tNode.classes;
  }
  if (attrNameToInject === "style") {
    return tNode.styles;
  }
  const attrs = tNode.attrs;
  if (attrs) {
    const attrsLength = attrs.length;
    let i = 0;
    while (i < attrsLength) {
      const value2 = attrs[i];
      if (isNameOnlyAttributeMarker(value2)) break;
      if (value2 === 0) {
        i = i + 2;
      } else if (typeof value2 === "number") {
        i++;
        while (i < attrsLength && typeof attrs[i] === "string") {
          i++;
        }
      } else if (value2 === attrNameToInject) {
        return attrs[i + 1];
      } else {
        i = i + 2;
      }
    }
  }
  return null;
}
function notFoundValueOrThrow(notFoundValue, token, flags) {
  if (flags & InjectFlags.Optional || notFoundValue !== void 0) {
    return notFoundValue;
  } else {
    throwProviderNotFoundError(token, "NodeInjector");
  }
}
function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
  if (flags & InjectFlags.Optional && notFoundValue === void 0) {
    notFoundValue = null;
  }
  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
    const moduleInjector = lView[INJECTOR];
    const previousInjectImplementation = setInjectImplementation(void 0);
    try {
      if (moduleInjector) {
        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
      } else {
        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
      }
    } finally {
      setInjectImplementation(previousInjectImplementation);
    }
  }
  return notFoundValueOrThrow(notFoundValue, token, flags);
}
function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
  if (tNode !== null) {
    if (lView[FLAGS] & 2048 && // The token must be present on the current node injector when the `Self`
    // flag is set, so the lookup on embedded view injector(s) can be skipped.
    !(flags & InjectFlags.Self)) {
      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND);
      if (embeddedInjectorValue !== NOT_FOUND) {
        return embeddedInjectorValue;
      }
    }
    const value2 = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND);
    if (value2 !== NOT_FOUND) {
      return value2;
    }
  }
  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
}
function lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {
  const bloomHash = bloomHashBitOrFactory(token);
  if (typeof bloomHash === "function") {
    if (!enterDI(lView, tNode, flags)) {
      return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
    }
    try {
      let value2;
      if (ngDevMode) {
        runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {
          value2 = bloomHash(flags);
          if (value2 != null) {
            emitInstanceCreatedByInjectorEvent(value2);
          }
        });
      } else {
        value2 = bloomHash(flags);
      }
      if (value2 == null && !(flags & InjectFlags.Optional)) {
        throwProviderNotFoundError(token);
      } else {
        return value2;
      }
    } finally {
      leaveDI();
    }
  } else if (typeof bloomHash === "number") {
    let previousTView = null;
    let injectorIndex = getInjectorIndex(tNode, lView);
    let parentLocation = NO_PARENT_INJECTOR;
    let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
    if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
        injectorIndex = -1;
      } else {
        previousTView = lView[TVIEW];
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      }
    }
    while (injectorIndex !== -1) {
      ngDevMode && assertNodeInjector(lView, injectorIndex);
      const tView = lView[TVIEW];
      ngDevMode && assertTNodeForLView(tView.data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ], lView);
      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
        if (instance !== NOT_FOUND) {
          return instance;
        }
      }
      parentLocation = lView[
        injectorIndex + 8
        /* NodeInjectorOffset.PARENT */
      ];
      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
        previousTView = tView;
        injectorIndex = getParentInjectorIndex(parentLocation);
        lView = getParentInjectorView(parentLocation, lView);
      } else {
        injectorIndex = -1;
      }
    }
  }
  return notFoundValue;
}
function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
  const currentTView = lView[TVIEW];
  const tNode = currentTView.data[
    injectorIndex + 8
    /* NodeInjectorOffset.TNODE */
  ];
  const canAccessViewProviders = previousTView == null ? (
    // 1) This is the first invocation `previousTView == null` which means that we are at the
    // `TNode` of where injector is starting to look. In such a case the only time we are allowed
    // to look into the ViewProviders is if:
    // - we are on a component
    // - AND the injector set `includeViewProviders` to true (implying that the token can see
    // ViewProviders because it is the Component or a Service which itself was declared in
    // ViewProviders)
    isComponentHost(tNode) && includeViewProviders
  ) : (
    // 2) `previousTView != null` which means that we are now walking across the parent nodes.
    // In such a case we are only allowed to look into the ViewProviders if:
    // - We just crossed from child View to Parent View `previousTView != currentTView`
    // - AND the parent TNode is an Element.
    // This means that we just came from the Component's View and therefore are allowed to see
    // into the ViewProviders.
    previousTView != currentTView && (tNode.type & 3) !== 0
  );
  const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
  if (injectableIdx !== null) {
    return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
  } else {
    return NOT_FOUND;
  }
}
function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
  const nodeProviderIndexes = tNode.providerIndexes;
  const tInjectables = tView.data;
  const injectablesStart = nodeProviderIndexes & 1048575;
  const directivesStart = tNode.directiveStart;
  const directiveEnd = tNode.directiveEnd;
  const cptViewProvidersCount = nodeProviderIndexes >> 20;
  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
  for (let i = startingIndex; i < endIndex; i++) {
    const providerTokenOrDef = tInjectables[i];
    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
      return i;
    }
  }
  if (isHostSpecialCase) {
    const dirDef = tInjectables[directivesStart];
    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
      return directivesStart;
    }
  }
  return null;
}
function getNodeInjectable(lView, tView, index, tNode) {
  let value2 = lView[index];
  const tData = tView.data;
  if (isFactory(value2)) {
    const factory = value2;
    if (factory.resolving) {
      throwCyclicDependencyError(stringifyForError(tData[index]));
    }
    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
    factory.resolving = true;
    let prevInjectContext;
    if (ngDevMode) {
      const token = tData[index].type || tData[index];
      const injector = new NodeInjector(tNode, lView);
      prevInjectContext = setInjectorProfilerContext({
        injector,
        token
      });
    }
    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
    const success = enterDI(lView, tNode, InjectFlags.Default);
    ngDevMode && assertEqual(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
    try {
      value2 = lView[index] = factory.factory(void 0, tData, lView, tNode);
      ngDevMode && emitInstanceCreatedByInjectorEvent(value2);
      if (tView.firstCreatePass && index >= tNode.directiveStart) {
        ngDevMode && assertDirectiveDef(tData[index]);
        registerPreOrderHooks(index, tData[index], tView);
      }
    } finally {
      ngDevMode && setInjectorProfilerContext(prevInjectContext);
      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
      setIncludeViewProviders(previousIncludeViewProviders);
      factory.resolving = false;
      leaveDI();
    }
  }
  return value2;
}
function bloomHashBitOrFactory(token) {
  ngDevMode && assertDefined(token, "token must be defined");
  if (typeof token === "string") {
    return token.charCodeAt(0) || 0;
  }
  const tokenId = (
    // First check with `hasOwnProperty` so we don't get an inherited ID.
    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0
  );
  if (typeof tokenId === "number") {
    if (tokenId >= 0) {
      return tokenId & BLOOM_MASK;
    } else {
      ngDevMode && assertEqual(tokenId, -1, "Expecting to get Special Injector Id");
      return createNodeInjector;
    }
  } else {
    return tokenId;
  }
}
function bloomHasToken(bloomHash, injectorIndex, injectorView) {
  const mask = 1 << bloomHash;
  const value2 = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
  return !!(value2 & mask);
}
function shouldSearchParent(flags, isFirstHostTNode) {
  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
}
function getNodeInjectorLView(nodeInjector) {
  return nodeInjector._lView;
}
function getNodeInjectorTNode(nodeInjector) {
  return nodeInjector._tNode;
}
var NodeInjector = class {
  _tNode;
  _lView;
  constructor(_tNode, _lView) {
    this._tNode = _tNode;
    this._lView = _lView;
  }
  get(token, notFoundValue, flags) {
    return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);
  }
};
function createNodeInjector() {
  return new NodeInjector(getCurrentTNode(), getLView());
}
function \u0275\u0275getInheritedFactory(type2) {
  return noSideEffects(() => {
    const ownConstructor = type2.prototype.constructor;
    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
    const objectPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type2.prototype).constructor;
    while (parent && parent !== objectPrototype) {
      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
      if (factory && factory !== ownFactory) {
        return factory;
      }
      parent = Object.getPrototypeOf(parent);
    }
    return (t2) => new t2();
  });
}
function getFactoryOf(type2) {
  if (isForwardRef(type2)) {
    return () => {
      const factory = getFactoryOf(resolveForwardRef(type2));
      return factory && factory();
    };
  }
  return getFactoryDef(type2);
}
function lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {
  let currentTNode = tNode;
  let currentLView = lView;
  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 && !(currentLView[FLAGS] & 512)) {
    ngDevMode && assertTNodeForLView(currentTNode, currentLView);
    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND);
    if (nodeInjectorValue !== NOT_FOUND) {
      return nodeInjectorValue;
    }
    let parentTNode = currentTNode.parent;
    if (!parentTNode) {
      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];
      if (embeddedViewInjector) {
        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND, flags);
        if (embeddedViewInjectorValue !== NOT_FOUND) {
          return embeddedViewInjectorValue;
        }
      }
      parentTNode = getTNodeFromLView(currentLView);
      currentLView = currentLView[DECLARATION_VIEW];
    }
    currentTNode = parentTNode;
  }
  return notFoundValue;
}
function getTNodeFromLView(lView) {
  const tView = lView[TVIEW];
  const tViewType = tView.type;
  if (tViewType === 2) {
    ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
    return tView.declTNode;
  } else if (tViewType === 1) {
    return lView[T_HOST];
  }
  return null;
}
function \u0275\u0275injectAttribute(attrNameToInject) {
  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
}
var Attribute = makeParamDecorator("Attribute", (attributeName) => ({
  attributeName,
  __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName)
}));
var _reflect = null;
function getReflect() {
  return _reflect = _reflect || new ReflectionCapabilities();
}
function reflectDependencies(type2) {
  return convertDependencies(getReflect().parameters(type2));
}
function convertDependencies(deps) {
  return deps.map((dep) => reflectDependency(dep));
}
function reflectDependency(dep) {
  const meta = {
    token: null,
    attribute: null,
    host: false,
    optional: false,
    self: false,
    skipSelf: false
  };
  if (Array.isArray(dep) && dep.length > 0) {
    for (let j = 0; j < dep.length; j++) {
      const param = dep[j];
      if (param === void 0) {
        continue;
      }
      const proto = Object.getPrototypeOf(param);
      if (param instanceof Optional || proto.ngMetadataName === "Optional") {
        meta.optional = true;
      } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
        meta.skipSelf = true;
      } else if (param instanceof Self || proto.ngMetadataName === "Self") {
        meta.self = true;
      } else if (param instanceof Host || proto.ngMetadataName === "Host") {
        meta.host = true;
      } else if (param instanceof Inject) {
        meta.token = param.token;
      } else if (param instanceof Attribute) {
        if (param.attributeName === void 0) {
          throw new RuntimeError(204, ngDevMode && `Attribute name must be defined.`);
        }
        meta.attribute = param.attributeName;
      } else {
        meta.token = param;
      }
    }
  } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
    meta.token = null;
  } else {
    meta.token = dep;
  }
  return meta;
}
function compileInjectable(type2, meta) {
  let ngInjectableDef = null;
  let ngFactoryDef = null;
  if (!type2.hasOwnProperty(NG_PROV_DEF)) {
    Object.defineProperty(type2, NG_PROV_DEF, {
      get: () => {
        if (ngInjectableDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type: type2
          });
          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type2.name}/\u0275prov.js`, getInjectableMetadata(type2, meta));
        }
        return ngInjectableDef;
      }
    });
  }
  if (!type2.hasOwnProperty(NG_FACTORY_DEF)) {
    Object.defineProperty(type2, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({
            usage: 0,
            kind: "injectable",
            type: type2
          });
          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type2.name}/\u0275fac.js`, {
            name: type2.name,
            type: type2,
            typeArgumentCount: 0,
            // In JIT mode types are not available nor used.
            deps: reflectDependencies(type2),
            target: compiler.FactoryTarget.Injectable
          });
        }
        return ngFactoryDef;
      },
      // Leave this configurable so that the factories from directives or pipes can take precedence.
      configurable: true
    });
  }
}
var USE_VALUE = getClosureSafeProperty({
  provide: String,
  useValue: getClosureSafeProperty
});
function isUseClassProvider(meta) {
  return meta.useClass !== void 0;
}
function isUseValueProvider(meta) {
  return USE_VALUE in meta;
}
function isUseFactoryProvider(meta) {
  return meta.useFactory !== void 0;
}
function isUseExistingProvider(meta) {
  return meta.useExisting !== void 0;
}
function getInjectableMetadata(type2, srcMeta) {
  const meta = srcMeta || {
    providedIn: null
  };
  const compilerMeta = {
    name: type2.name,
    type: type2,
    typeArgumentCount: 0,
    providedIn: meta.providedIn
  };
  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
    compilerMeta.deps = convertDependencies(meta.deps);
  }
  if (isUseClassProvider(meta)) {
    compilerMeta.useClass = meta.useClass;
  } else if (isUseValueProvider(meta)) {
    compilerMeta.useValue = meta.useValue;
  } else if (isUseFactoryProvider(meta)) {
    compilerMeta.useFactory = meta.useFactory;
  } else if (isUseExistingProvider(meta)) {
    compilerMeta.useExisting = meta.useExisting;
  }
  return compilerMeta;
}
var Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type2, meta) => compileInjectable(type2, meta));
function createInjector(defType, parent = null, additionalProviders = null, name) {
  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
  injector.resolveInjectorInitializers();
  return injector;
}
function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = /* @__PURE__ */ new Set()) {
  const providers2 = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];
  name = name || (typeof defType === "object" ? void 0 : stringify(defType));
  return new R3Injector(providers2, parent || getNullInjector(), name || null, scopes);
}
var Injector = class _Injector {
  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
  static NULL = new NullInjector();
  static create(options, parent) {
    if (Array.isArray(options)) {
      return createInjector({
        name: ""
      }, parent, options, "");
    } else {
      const name = options.name ?? "";
      return createInjector({
        name
      }, options.parent, options.providers, name);
    }
  }
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _Injector,
      providedIn: "any",
      factory: () => \u0275\u0275inject(INJECTOR$1)
    })
  );
  /**
   * @internal
   * @nocollapse
   */
  static __NG_ELEMENT_ID__ = -1;
};
var HOST_TAG_NAME = new InjectionToken(ngDevMode ? "HOST_TAG_NAME" : "");
HOST_TAG_NAME.__NG_ELEMENT_ID__ = (flags) => {
  const tNode = getCurrentTNode();
  if (tNode === null) {
    throw new RuntimeError(204, ngDevMode && "HOST_TAG_NAME can only be injected in directives and components during construction time (in a class constructor or as a class field initializer)");
  }
  if (tNode.type & 2) {
    return tNode.value;
  }
  if (flags & InjectFlags.Optional) {
    return null;
  }
  throw new RuntimeError(204, ngDevMode && `HOST_TAG_NAME was used on ${getDevModeNodeName(tNode)} which doesn't have an underlying element in the DOM. This is invalid, and so the dependency should be marked as optional.`);
};
function getDevModeNodeName(tNode) {
  if (tNode.type & 8) {
    return "an <ng-container>";
  } else if (tNode.type & 4) {
    return "an <ng-template>";
  } else if (tNode.type & 128) {
    return "an @let declaration";
  } else {
    return "a node";
  }
}
var SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;
var DestroyRef = class {
  /**
   * @internal
   * @nocollapse
   */
  static __NG_ELEMENT_ID__ = injectDestroyRef;
  /**
   * @internal
   * @nocollapse
   */
  static __NG_ENV_ID__ = (injector) => injector;
};
var NodeInjectorDestroyRef = class extends DestroyRef {
  _lView;
  constructor(_lView) {
    super();
    this._lView = _lView;
  }
  onDestroy(callback) {
    storeLViewOnDestroy(this._lView, callback);
    return () => removeLViewOnDestroy(this._lView, callback);
  }
};
function injectDestroyRef() {
  return new NodeInjectorDestroyRef(getLView());
}
var ChangeDetectionScheduler = class {
};
var ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless enabled" : "", {
  providedIn: "root",
  factory: () => false
});
var PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Zoneless provided" : "", {
  providedIn: "root",
  factory: () => false
});
var ZONELESS_SCHEDULER_DISABLED = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "scheduler disabled" : "");
var SCHEDULE_IN_ROOT_ZONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "run changes outside zone in root" : "");
var PendingTasksInternal = class _PendingTasksInternal {
  taskId = 0;
  pendingTasks = /* @__PURE__ */ new Set();
  get _hasPendingTasks() {
    return this.hasPendingTasks.value;
  }
  hasPendingTasks = new BehaviorSubject(false);
  add() {
    if (!this._hasPendingTasks) {
      this.hasPendingTasks.next(true);
    }
    const taskId = this.taskId++;
    this.pendingTasks.add(taskId);
    return taskId;
  }
  has(taskId) {
    return this.pendingTasks.has(taskId);
  }
  remove(taskId) {
    this.pendingTasks.delete(taskId);
    if (this.pendingTasks.size === 0 && this._hasPendingTasks) {
      this.hasPendingTasks.next(false);
    }
  }
  ngOnDestroy() {
    this.pendingTasks.clear();
    if (this._hasPendingTasks) {
      this.hasPendingTasks.next(false);
    }
  }
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _PendingTasksInternal,
      providedIn: "root",
      factory: () => new _PendingTasksInternal()
    })
  );
};
var EventEmitter_ = class extends Subject {
  __isAsync;
  // tslint:disable-line
  destroyRef = void 0;
  pendingTasks = void 0;
  constructor(isAsync = false) {
    super();
    this.__isAsync = isAsync;
    if (isInInjectionContext()) {
      this.destroyRef = inject(DestroyRef, {
        optional: true
      }) ?? void 0;
      this.pendingTasks = inject(PendingTasksInternal, {
        optional: true
      }) ?? void 0;
    }
  }
  emit(value2) {
    const prevConsumer = setActiveConsumer(null);
    try {
      super.next(value2);
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
  subscribe(observerOrNext, error, complete) {
    let nextFn = observerOrNext;
    let errorFn = error || (() => null);
    let completeFn = complete;
    if (observerOrNext && typeof observerOrNext === "object") {
      const observer = observerOrNext;
      nextFn = observer.next?.bind(observer);
      errorFn = observer.error?.bind(observer);
      completeFn = observer.complete?.bind(observer);
    }
    if (this.__isAsync) {
      errorFn = this.wrapInTimeout(errorFn);
      if (nextFn) {
        nextFn = this.wrapInTimeout(nextFn);
      }
      if (completeFn) {
        completeFn = this.wrapInTimeout(completeFn);
      }
    }
    const sink = super.subscribe({
      next: nextFn,
      error: errorFn,
      complete: completeFn
    });
    if (observerOrNext instanceof Subscription) {
      observerOrNext.add(sink);
    }
    return sink;
  }
  wrapInTimeout(fn) {
    return (value2) => {
      const taskId = this.pendingTasks?.add();
      setTimeout(() => {
        fn(value2);
        if (taskId !== void 0) {
          this.pendingTasks?.remove(taskId);
        }
      });
    };
  }
};
var EventEmitter = EventEmitter_;
function noop2(...args) {
}
function scheduleCallbackWithRafRace(callback) {
  let timeoutId;
  let animationFrameId;
  function cleanup() {
    callback = noop2;
    try {
      if (animationFrameId !== void 0 && typeof cancelAnimationFrame === "function") {
        cancelAnimationFrame(animationFrameId);
      }
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
      }
    } catch {
    }
  }
  timeoutId = setTimeout(() => {
    callback();
    cleanup();
  });
  if (typeof requestAnimationFrame === "function") {
    animationFrameId = requestAnimationFrame(() => {
      callback();
      cleanup();
    });
  }
  return () => cleanup();
}
function scheduleCallbackWithMicrotask(callback) {
  queueMicrotask(() => callback());
  return () => {
    callback = noop2;
  };
}
var AsyncStackTaggingZoneSpec = class {
  createTask;
  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {
    this.name = "asyncStackTagging for " + namePrefix;
    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);
  }
  // ZoneSpec implementation below.
  name;
  onScheduleTask(delegate, _current, target, task) {
    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);
    return delegate.scheduleTask(target, task);
  }
  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {
    let ret;
    if (task.consoleTask) {
      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));
    } else {
      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);
    }
    return ret;
  }
};
var isAngularZoneProperty = "isAngularZone";
var angularZoneInstanceIdProperty = isAngularZoneProperty + "_ID";
var ngZoneInstanceId = 0;
var NgZone = class _NgZone {
  hasPendingMacrotasks = false;
  hasPendingMicrotasks = false;
  /**
   * Whether there are no outstanding microtasks or macrotasks.
   */
  isStable = true;
  /**
   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
   */
  onUnstable = new EventEmitter(false);
  /**
   * Notifies when there is no more microtasks enqueued in the current VM Turn.
   * This is a hint for Angular to do change detection, which may enqueue more microtasks.
   * For this reason this event can fire multiple times per VM Turn.
   */
  onMicrotaskEmpty = new EventEmitter(false);
  /**
   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
   * implies we are about to relinquish VM turn.
   * This event gets called just once.
   */
  onStable = new EventEmitter(false);
  /**
   * Notifies that an error has been delivered.
   */
  onError = new EventEmitter(false);
  constructor(options) {
    const {
      enableLongStackTrace = false,
      shouldCoalesceEventChangeDetection = false,
      shouldCoalesceRunChangeDetection = false,
      scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT
    } = options;
    if (typeof Zone == "undefined") {
      throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);
    }
    Zone.assertZonePatched();
    const self = this;
    self._nesting = 0;
    self._outer = self._inner = Zone.current;
    if (ngDevMode) {
      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec("Angular"));
    }
    if (Zone["TaskTrackingZoneSpec"]) {
      self._inner = self._inner.fork(new Zone["TaskTrackingZoneSpec"]());
    }
    if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
      self._inner = self._inner.fork(Zone["longStackTraceZoneSpec"]);
    }
    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
    self.callbackScheduled = false;
    self.scheduleInRootZone = scheduleInRootZone;
    forkInnerZoneWithAngularBehavior(self);
  }
  /**
    This method checks whether the method call happens within an Angular Zone instance.
  */
  static isInAngularZone() {
    return typeof Zone !== "undefined" && Zone.current.get(isAngularZoneProperty) === true;
  }
  /**
    Assures that the method is called within the Angular Zone, otherwise throws an error.
  */
  static assertInAngularZone() {
    if (!_NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && "Expected to be in Angular Zone, but it is not!");
    }
  }
  /**
    Assures that the method is called outside of the Angular Zone, otherwise throws an error.
  */
  static assertNotInAngularZone() {
    if (_NgZone.isInAngularZone()) {
      throw new RuntimeError(909, ngDevMode && "Expected to not be in Angular Zone, but it is!");
    }
  }
  /**
   * Executes the `fn` function synchronously within the Angular zone and returns value returned by
   * the function.
   *
   * Running functions via `run` allows you to reenter Angular zone from a task that was executed
   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * within the Angular zone.
   *
   * If a synchronous error happens it will be rethrown and not reported via `onError`.
   */
  run(fn, applyThis, applyArgs) {
    return this._inner.run(fn, applyThis, applyArgs);
  }
  /**
   * Executes the `fn` function synchronously within the Angular zone as a task and returns value
   * returned by the function.
   *
   * Running functions via `run` allows you to reenter Angular zone from a task that was executed
   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * within the Angular zone.
   *
   * If a synchronous error happens it will be rethrown and not reported via `onError`.
   */
  runTask(fn, applyThis, applyArgs, name) {
    const zone = this._inner;
    const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop2, noop2);
    try {
      return zone.runTask(task, applyThis, applyArgs);
    } finally {
      zone.cancelTask(task);
    }
  }
  /**
   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
   * rethrown.
   */
  runGuarded(fn, applyThis, applyArgs) {
    return this._inner.runGuarded(fn, applyThis, applyArgs);
  }
  /**
   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
   * the function.
   *
   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
   * work that
   * doesn't trigger Angular change-detection or is subject to Angular's error handling.
   *
   * Any future tasks or microtasks scheduled from within this function will continue executing from
   * outside of the Angular zone.
   *
   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
   */
  runOutsideAngular(fn) {
    return this._outer.run(fn);
  }
};
var EMPTY_PAYLOAD = {};
function checkStable(zone) {
  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
    try {
      zone._nesting++;
      zone.onMicrotaskEmpty.emit(null);
    } finally {
      zone._nesting--;
      if (!zone.hasPendingMicrotasks) {
        try {
          zone.runOutsideAngular(() => zone.onStable.emit(null));
        } finally {
          zone.isStable = true;
        }
      }
    }
  }
}
function delayChangeDetectionForEvents(zone) {
  if (zone.isCheckStableRunning || zone.callbackScheduled) {
    return;
  }
  zone.callbackScheduled = true;
  function scheduleCheckStable() {
    scheduleCallbackWithRafRace(() => {
      zone.callbackScheduled = false;
      updateMicroTaskStatus(zone);
      zone.isCheckStableRunning = true;
      checkStable(zone);
      zone.isCheckStableRunning = false;
    });
  }
  if (zone.scheduleInRootZone) {
    Zone.root.run(() => {
      scheduleCheckStable();
    });
  } else {
    zone._outer.run(() => {
      scheduleCheckStable();
    });
  }
  updateMicroTaskStatus(zone);
}
function forkInnerZoneWithAngularBehavior(zone) {
  const delayChangeDetectionForEventsDelegate = () => {
    delayChangeDetectionForEvents(zone);
  };
  const instanceId = ngZoneInstanceId++;
  zone._inner = zone._inner.fork({
    name: "angular",
    properties: {
      [isAngularZoneProperty]: true,
      [angularZoneInstanceIdProperty]: instanceId,
      [angularZoneInstanceIdProperty + instanceId]: true
    },
    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
      if (shouldBeIgnoredByZone(applyArgs)) {
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      try {
        onEnter(zone);
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      } finally {
        if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
      try {
        onEnter(zone);
        return delegate.invoke(target, callback, applyThis, applyArgs, source);
      } finally {
        if (zone.shouldCoalesceRunChangeDetection && // Do not delay change detection when the task is the scheduler's tick.
        // We need to synchronously trigger the stability logic so that the
        // zone-based scheduler can prevent a duplicate ApplicationRef.tick
        // by first checking if the scheduler tick is running. This does seem a bit roundabout,
        // but we _do_ still want to trigger all the correct events when we exit the zone.run
        // (`onMicrotaskEmpty` and `onStable` _should_ emit; developers can have code which
        // relies on these events happening after change detection runs).
        // Note: `zone.callbackScheduled` is already in delayChangeDetectionForEventsDelegate
        // but is added here as well to prevent reads of applyArgs when not necessary
        !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {
          delayChangeDetectionForEventsDelegate();
        }
        onLeave(zone);
      }
    },
    onHasTask: (delegate, current, target, hasTaskState) => {
      delegate.hasTask(target, hasTaskState);
      if (current === target) {
        if (hasTaskState.change == "microTask") {
          zone._hasPendingMicrotasks = hasTaskState.microTask;
          updateMicroTaskStatus(zone);
          checkStable(zone);
        } else if (hasTaskState.change == "macroTask") {
          zone.hasPendingMacrotasks = hasTaskState.macroTask;
        }
      }
    },
    onHandleError: (delegate, current, target, error) => {
      delegate.handleError(target, error);
      zone.runOutsideAngular(() => zone.onError.emit(error));
      return false;
    }
  });
}
function updateMicroTaskStatus(zone) {
  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {
    zone.hasPendingMicrotasks = true;
  } else {
    zone.hasPendingMicrotasks = false;
  }
}
function onEnter(zone) {
  zone._nesting++;
  if (zone.isStable) {
    zone.isStable = false;
    zone.onUnstable.emit(null);
  }
}
function onLeave(zone) {
  zone._nesting--;
  checkStable(zone);
}
var NoopNgZone = class {
  hasPendingMicrotasks = false;
  hasPendingMacrotasks = false;
  isStable = true;
  onUnstable = new EventEmitter();
  onMicrotaskEmpty = new EventEmitter();
  onStable = new EventEmitter();
  onError = new EventEmitter();
  run(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runGuarded(fn, applyThis, applyArgs) {
    return fn.apply(applyThis, applyArgs);
  }
  runOutsideAngular(fn) {
    return fn();
  }
  runTask(fn, applyThis, applyArgs, name) {
    return fn.apply(applyThis, applyArgs);
  }
};
function shouldBeIgnoredByZone(applyArgs) {
  return hasApplyArgsData(applyArgs, "__ignore_ng_zone__");
}
function isSchedulerTick(applyArgs) {
  return hasApplyArgsData(applyArgs, "__scheduler_tick__");
}
function hasApplyArgsData(applyArgs, key) {
  if (!Array.isArray(applyArgs)) {
    return false;
  }
  if (applyArgs.length !== 1) {
    return false;
  }
  return applyArgs[0]?.data?.[key] === true;
}
function getNgZone(ngZoneToUse = "zone.js", options) {
  if (ngZoneToUse === "noop") {
    return new NoopNgZone();
  }
  if (ngZoneToUse === "zone.js") {
    return new NgZone(options);
  }
  return ngZoneToUse;
}
var ErrorHandler = class {
  /**
   * @internal
   */
  _console = console;
  handleError(error) {
    this._console.error("ERROR", error);
  }
};
var INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "internal error handler" : "", {
  providedIn: "root",
  factory: () => {
    const zone = inject(NgZone);
    const userErrorHandler = inject(ErrorHandler);
    return (e) => zone.runOutsideAngular(() => userErrorHandler.handleError(e));
  }
});
var OutputEmitterRef = class {
  destroyed = false;
  listeners = null;
  errorHandler = inject(ErrorHandler, {
    optional: true
  });
  /** @internal */
  destroyRef = inject(DestroyRef);
  constructor() {
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
      this.listeners = null;
    });
  }
  subscribe(callback) {
    if (this.destroyed) {
      throw new RuntimeError(953, ngDevMode && "Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");
    }
    (this.listeners ??= []).push(callback);
    return {
      unsubscribe: () => {
        const idx = this.listeners?.indexOf(callback);
        if (idx !== void 0 && idx !== -1) {
          this.listeners?.splice(idx, 1);
        }
      }
    };
  }
  /** Emits a new value to the output. */
  emit(value2) {
    if (this.destroyed) {
      throw new RuntimeError(953, ngDevMode && "Unexpected emit for destroyed `OutputRef`. The owning directive/component is destroyed.");
    }
    if (this.listeners === null) {
      return;
    }
    const previousConsumer = setActiveConsumer(null);
    try {
      for (const listenerFn of this.listeners) {
        try {
          listenerFn(value2);
        } catch (err) {
          this.errorHandler?.handleError(err);
        }
      }
    } finally {
      setActiveConsumer(previousConsumer);
    }
  }
};
function inputFunction(initialValue, opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(initialValue, opts);
}
function inputRequiredFunction(opts) {
  ngDevMode && assertInInjectionContext(input);
  return createInputSignal(REQUIRED_UNSET_VALUE, opts);
}
var input = (() => {
  inputFunction.required = inputRequiredFunction;
  return inputFunction;
})();
function injectElementRef() {
  return createElementRef(getCurrentTNode(), getLView());
}
function createElementRef(tNode, lView) {
  return new ElementRef(getNativeByTNode(tNode, lView));
}
var ElementRef = class {
  /**
   * <div class="callout is-critical">
   *   <header>Use with caution</header>
   *   <p>
   *    Use this API as the last resort when direct access to DOM is needed. Use templating and
   *    data-binding provided by Angular instead. Alternatively you can take a look at
   *    {@link Renderer2} which provides an API that can be safely used.
   *   </p>
   * </div>
   */
  nativeElement;
  constructor(nativeElement) {
    this.nativeElement = nativeElement;
  }
  /**
   * @internal
   * @nocollapse
   */
  static __NG_ELEMENT_ID__ = injectElementRef;
};
function unwrapElementRef(value2) {
  return value2 instanceof ElementRef ? value2.nativeElement : value2;
}
function symbolIterator() {
  return this._results[Symbol.iterator]();
}
var QueryList = class {
  _emitDistinctChangesOnly;
  dirty = true;
  _onDirty = void 0;
  _results = [];
  _changesDetected = false;
  _changes = void 0;
  length = 0;
  first = void 0;
  last = void 0;
  /**
   * Returns `Observable` of `QueryList` notifying the subscriber of changes.
   */
  get changes() {
    return this._changes ??= new Subject();
  }
  /**
   * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change
   *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in
   *     the same result)
   */
  constructor(_emitDistinctChangesOnly = false) {
    this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
  }
  /**
   * Returns the QueryList entry at `index`.
   */
  get(index) {
    return this._results[index];
  }
  /**
   * See
   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
   */
  map(fn) {
    return this._results.map(fn);
  }
  filter(fn) {
    return this._results.filter(fn);
  }
  /**
   * See
   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
   */
  find(fn) {
    return this._results.find(fn);
  }
  /**
   * See
   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
   */
  reduce(fn, init2) {
    return this._results.reduce(fn, init2);
  }
  /**
   * See
   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
   */
  forEach(fn) {
    this._results.forEach(fn);
  }
  /**
   * See
   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
   */
  some(fn) {
    return this._results.some(fn);
  }
  /**
   * Returns a copy of the internal results list as an Array.
   */
  toArray() {
    return this._results.slice();
  }
  toString() {
    return this._results.toString();
  }
  /**
   * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that
   * on change detection, it will not notify of changes to the queries, unless a new change
   * occurs.
   *
   * @param resultsTree The query results to store
   * @param identityAccessor Optional function for extracting stable object identity from a value
   *    in the array. This function is executed for each element of the query result list while
   *    comparing current query list with the new one (provided as a first argument of the `reset`
   *    function) to detect if the lists are different. If the function is not provided, elements
   *    are compared as is (without any pre-processing).
   */
  reset(resultsTree, identityAccessor) {
    this.dirty = false;
    const newResultFlat = flatten(resultsTree);
    if (this._changesDetected = !arrayEquals(this._results, newResultFlat, identityAccessor)) {
      this._results = newResultFlat;
      this.length = newResultFlat.length;
      this.last = newResultFlat[this.length - 1];
      this.first = newResultFlat[0];
    }
  }
  /**
   * Triggers a change event by emitting on the `changes` {@link EventEmitter}.
   */
  notifyOnChanges() {
    if (this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly)) this._changes.next(this);
  }
  /** @internal */
  onDirty(cb) {
    this._onDirty = cb;
  }
  /** internal */
  setDirty() {
    this.dirty = true;
    this._onDirty?.();
  }
  /** internal */
  destroy() {
    if (this._changes !== void 0) {
      this._changes.complete();
      this._changes.unsubscribe();
    }
  }
  [Symbol.iterator] = /* @__PURE__ */ (() => symbolIterator)();
};
function hasInSkipHydrationBlockFlag(tNode) {
  return (tNode.flags & 128) === 128;
}
var ChangeDetectionStrategy;
(function(ChangeDetectionStrategy2) {
  ChangeDetectionStrategy2[ChangeDetectionStrategy2["OnPush"] = 0] = "OnPush";
  ChangeDetectionStrategy2[ChangeDetectionStrategy2["Default"] = 1] = "Default";
})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
var TRACKED_LVIEWS = /* @__PURE__ */ new Map();
var uniqueIdCounter = 0;
function getUniqueLViewId() {
  return uniqueIdCounter++;
}
function registerLView(lView) {
  ngDevMode && assertNumber(lView[ID], "LView must have an ID in order to be registered");
  TRACKED_LVIEWS.set(lView[ID], lView);
}
function getLViewById(id3) {
  ngDevMode && assertNumber(id3, "ID used for LView lookup must be a number");
  return TRACKED_LVIEWS.get(id3) || null;
}
function unregisterLView(lView) {
  ngDevMode && assertNumber(lView[ID], "Cannot stop tracking an LView that does not have an ID");
  TRACKED_LVIEWS.delete(lView[ID]);
}
function getTrackedLViews() {
  return TRACKED_LVIEWS;
}
var LContext = class {
  lViewId;
  nodeIndex;
  native;
  /**
   * The instance of the Component node.
   */
  component;
  /**
   * The list of active directives that exist on this element.
   */
  directives;
  /**
   * The map of local references (local reference name => element or directive instance) that
   * exist on this element.
   */
  localRefs;
  /** Component's parent view data. */
  get lView() {
    return getLViewById(this.lViewId);
  }
  constructor(lViewId, nodeIndex, native) {
    this.lViewId = lViewId;
    this.nodeIndex = nodeIndex;
    this.native = native;
  }
};
function getLContext(target) {
  let mpValue = readPatchedData(target);
  if (mpValue) {
    if (isLView(mpValue)) {
      const lView = mpValue;
      let nodeIndex;
      let component = void 0;
      let directives = void 0;
      if (isComponentInstance(target)) {
        nodeIndex = findViaComponent(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided component was not found in the application");
        }
        component = target;
      } else if (isDirectiveInstance(target)) {
        nodeIndex = findViaDirective(lView, target);
        if (nodeIndex == -1) {
          throw new Error("The provided directive was not found in the application");
        }
        directives = getDirectivesAtNodeIndex(nodeIndex, lView);
      } else {
        nodeIndex = findViaNativeElement(lView, target);
        if (nodeIndex == -1) {
          return null;
        }
      }
      const native = unwrapRNode(lView[nodeIndex]);
      const existingCtx = readPatchedData(native);
      const context2 = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
      if (component && context2.component === void 0) {
        context2.component = component;
        attachPatchData(context2.component, context2);
      }
      if (directives && context2.directives === void 0) {
        context2.directives = directives;
        for (let i = 0; i < directives.length; i++) {
          attachPatchData(directives[i], context2);
        }
      }
      attachPatchData(context2.native, context2);
      mpValue = context2;
    }
  } else {
    const rElement = target;
    ngDevMode && assertDomNode(rElement);
    let parent = rElement;
    while (parent = parent.parentNode) {
      const parentContext = readPatchedData(parent);
      if (parentContext) {
        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;
        if (!lView) {
          return null;
        }
        const index = findViaNativeElement(lView, rElement);
        if (index >= 0) {
          const native = unwrapRNode(lView[index]);
          const context2 = createLContext(lView, index, native);
          attachPatchData(native, context2);
          mpValue = context2;
          break;
        }
      }
    }
  }
  return mpValue || null;
}
function createLContext(lView, nodeIndex, native) {
  return new LContext(lView[ID], nodeIndex, native);
}
function getComponentViewByInstance(componentInstance) {
  let patchedData = readPatchedData(componentInstance);
  let lView;
  if (isLView(patchedData)) {
    const contextLView = patchedData;
    const nodeIndex = findViaComponent(contextLView, componentInstance);
    lView = getComponentLViewByIndex(nodeIndex, contextLView);
    const context2 = createLContext(contextLView, nodeIndex, lView[HOST]);
    context2.component = componentInstance;
    attachPatchData(componentInstance, context2);
    attachPatchData(context2.native, context2);
  } else {
    const context2 = patchedData;
    const contextLView = context2.lView;
    ngDevMode && assertLView(contextLView);
    lView = getComponentLViewByIndex(context2.nodeIndex, contextLView);
  }
  return lView;
}
var MONKEY_PATCH_KEY_NAME = "__ngContext__";
function attachPatchData(target, data) {
  ngDevMode && assertDefined(target, "Target expected");
  if (isLView(data)) {
    target[MONKEY_PATCH_KEY_NAME] = data[ID];
    registerLView(data);
  } else {
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
}
function readPatchedData(target) {
  ngDevMode && assertDefined(target, "Target expected");
  const data = target[MONKEY_PATCH_KEY_NAME];
  return typeof data === "number" ? getLViewById(data) : data || null;
}
function readPatchedLView(target) {
  const value2 = readPatchedData(target);
  if (value2) {
    return isLView(value2) ? value2 : value2.lView;
  }
  return null;
}
function isComponentInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275cmp;
}
function isDirectiveInstance(instance) {
  return instance && instance.constructor && instance.constructor.\u0275dir;
}
function findViaNativeElement(lView, target) {
  const tView = lView[TVIEW];
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if (unwrapRNode(lView[i]) === target) {
      return i;
    }
  }
  return -1;
}
function traverseNextElement(tNode) {
  if (tNode.child) {
    return tNode.child;
  } else if (tNode.next) {
    return tNode.next;
  } else {
    while (tNode.parent && !tNode.parent.next) {
      tNode = tNode.parent;
    }
    return tNode.parent && tNode.parent.next;
  }
}
function findViaComponent(lView, componentInstance) {
  const componentIndices = lView[TVIEW].components;
  if (componentIndices) {
    for (let i = 0; i < componentIndices.length; i++) {
      const elementComponentIndex = componentIndices[i];
      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
      if (componentView[CONTEXT] === componentInstance) {
        return elementComponentIndex;
      }
    }
  } else {
    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
    const rootComponent = rootComponentView[CONTEXT];
    if (rootComponent === componentInstance) {
      return HEADER_OFFSET;
    }
  }
  return -1;
}
function findViaDirective(lView, directiveInstance) {
  let tNode = lView[TVIEW].firstChild;
  while (tNode) {
    const directiveIndexStart = tNode.directiveStart;
    const directiveIndexEnd = tNode.directiveEnd;
    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
      if (lView[i] === directiveInstance) {
        return tNode.index;
      }
    }
    tNode = traverseNextElement(tNode);
  }
  return -1;
}
function getDirectivesAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  if (tNode.directiveStart === 0) return EMPTY_ARRAY;
  const results = [];
  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
    const directiveInstance = lView[i];
    if (!isComponentInstance(directiveInstance)) {
      results.push(directiveInstance);
    }
  }
  return results;
}
function getComponentAtNodeIndex(nodeIndex, lView) {
  const tNode = lView[TVIEW].data[nodeIndex];
  const {
    directiveStart,
    componentOffset
  } = tNode;
  return componentOffset > -1 ? lView[directiveStart + componentOffset] : null;
}
function getRootView(componentOrLView) {
  ngDevMode && assertDefined(componentOrLView, "component");
  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
  while (lView && !(lView[FLAGS] & 512)) {
    lView = getLViewParent(lView);
  }
  ngDevMode && assertLView(lView);
  return lView;
}
function getRootContext(viewOrComponent) {
  const rootView = getRootView(viewOrComponent);
  ngDevMode && assertDefined(rootView[CONTEXT], "Root view has no context. Perhaps it is disconnected?");
  return rootView[CONTEXT];
}
function getFirstLContainer(lView) {
  return getNearestLContainer(lView[CHILD_HEAD]);
}
function getNextLContainer(container) {
  return getNearestLContainer(container[NEXT]);
}
function getNearestLContainer(viewOrContainer) {
  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
    viewOrContainer = viewOrContainer[NEXT];
  }
  return viewOrContainer;
}
function getComponent(element) {
  ngDevMode && assertDomElement(element);
  const context2 = getLContext(element);
  if (context2 === null) return null;
  if (context2.component === void 0) {
    const lView = context2.lView;
    if (lView === null) {
      return null;
    }
    context2.component = getComponentAtNodeIndex(context2.nodeIndex, lView);
  }
  return context2.component;
}
function getContext(element) {
  assertDomElement(element);
  const context2 = getLContext(element);
  const lView = context2 ? context2.lView : null;
  return lView === null ? null : lView[CONTEXT];
}
function getOwningComponent(elementOrDir) {
  const context2 = getLContext(elementOrDir);
  let lView = context2 ? context2.lView : null;
  if (lView === null) return null;
  let parent;
  while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
    lView = parent;
  }
  return lView[FLAGS] & 512 ? null : lView[CONTEXT];
}
function getRootComponents(elementOrDir) {
  const lView = readPatchedLView(elementOrDir);
  return lView !== null ? [getRootContext(lView)] : [];
}
function getInjector(elementOrDir) {
  const context2 = getLContext(elementOrDir);
  const lView = context2 ? context2.lView : null;
  if (lView === null) return Injector.NULL;
  const tNode = lView[TVIEW].data[context2.nodeIndex];
  return new NodeInjector(tNode, lView);
}
function getDirectives(node) {
  if (node instanceof Text) {
    return [];
  }
  const context2 = getLContext(node);
  const lView = context2 ? context2.lView : null;
  if (lView === null) {
    return [];
  }
  const tView = lView[TVIEW];
  const nodeIndex = context2.nodeIndex;
  if (!tView?.data[nodeIndex]) {
    return [];
  }
  if (context2.directives === void 0) {
    context2.directives = getDirectivesAtNodeIndex(nodeIndex, lView);
  }
  return context2.directives === null ? [] : [...context2.directives];
}
function getDirectiveMetadata$1(directiveOrComponentInstance) {
  const {
    constructor
  } = directiveOrComponentInstance;
  if (!constructor) {
    throw new Error("Unable to find the instance constructor");
  }
  const componentDef = getComponentDef(constructor);
  if (componentDef) {
    const inputs = extractInputDebugMetadata(componentDef.inputs);
    return {
      inputs,
      outputs: componentDef.outputs,
      encapsulation: componentDef.encapsulation,
      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
    };
  }
  const directiveDef = getDirectiveDef(constructor);
  if (directiveDef) {
    const inputs = extractInputDebugMetadata(directiveDef.inputs);
    return {
      inputs,
      outputs: directiveDef.outputs
    };
  }
  return null;
}
function getHostElement(componentOrDirective) {
  return getLContext(componentOrDirective).native;
}
function getListeners(element) {
  ngDevMode && assertDomElement(element);
  const lContext = getLContext(element);
  const lView = lContext === null ? null : lContext.lView;
  if (lView === null) return [];
  const tView = lView[TVIEW];
  const lCleanup = lView[CLEANUP];
  const tCleanup = tView.cleanup;
  const listeners = [];
  if (tCleanup && lCleanup) {
    for (let i = 0; i < tCleanup.length; ) {
      const firstParam = tCleanup[i++];
      const secondParam = tCleanup[i++];
      if (typeof firstParam === "string") {
        const name = firstParam;
        const listenerElement = unwrapRNode(lView[secondParam]);
        const callback = lCleanup[tCleanup[i++]];
        const useCaptureOrIndx = tCleanup[i++];
        const type2 = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
        const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
        if (element == listenerElement) {
          listeners.push({
            element,
            name,
            callback,
            useCapture,
            type: type2
          });
        }
      }
    }
  }
  listeners.sort(sortListeners);
  return listeners;
}
function sortListeners(a, b) {
  if (a.name == b.name) return 0;
  return a.name < b.name ? -1 : 1;
}
function assertDomElement(value2) {
  if (typeof Element !== "undefined" && !(value2 instanceof Element)) {
    throw new Error("Expecting instance of DOM Element");
  }
}
function extractInputDebugMetadata(inputs) {
  const res = {};
  for (const key in inputs) {
    if (!inputs.hasOwnProperty(key)) {
      continue;
    }
    const value2 = inputs[key];
    if (value2 === void 0) {
      continue;
    }
    let minifiedName;
    if (Array.isArray(value2)) {
      minifiedName = value2[0];
    } else {
      minifiedName = value2;
    }
    res[key] = minifiedName;
  }
  return res;
}
var DOCUMENT = void 0;
function setDocument(document2) {
  DOCUMENT = document2;
}
function getDocument() {
  if (DOCUMENT !== void 0) {
    return DOCUMENT;
  } else if (typeof document !== "undefined") {
    return document;
  }
  throw new RuntimeError(210, (typeof ngDevMode === "undefined" || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);
}
var APP_ID = new InjectionToken(ngDevMode ? "AppId" : "", {
  providedIn: "root",
  factory: () => DEFAULT_APP_ID
});
var DEFAULT_APP_ID = "ng";
var PLATFORM_INITIALIZER = new InjectionToken(ngDevMode ? "Platform Initializer" : "");
var PLATFORM_ID = new InjectionToken(ngDevMode ? "Platform ID" : "", {
  providedIn: "platform",
  factory: () => "unknown"
  // set a default platform name, when none set explicitly
});
var PACKAGE_ROOT_URL = new InjectionToken(ngDevMode ? "Application Packages Root URL" : "");
var ANIMATION_MODULE_TYPE = new InjectionToken(ngDevMode ? "AnimationModuleType" : "");
var CSP_NONCE = new InjectionToken(ngDevMode ? "CSP nonce" : "", {
  providedIn: "root",
  factory: () => {
    return getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null;
  }
});
var IMAGE_CONFIG_DEFAULTS = {
  breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  placeholderResolution: 30,
  disableImageSizeWarning: false,
  disableImageLazyLoadWarning: false
};
var IMAGE_CONFIG = new InjectionToken(ngDevMode ? "ImageConfig" : "", {
  providedIn: "root",
  factory: () => IMAGE_CONFIG_DEFAULTS
});
function makeStateKey(key) {
  return key;
}
function initTransferState() {
  const transferState = new TransferState();
  if (inject(PLATFORM_ID) === "browser") {
    transferState.store = retrieveTransferredState(getDocument(), inject(APP_ID));
  }
  return transferState;
}
var TransferState = class _TransferState {
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _TransferState,
      providedIn: "root",
      factory: initTransferState
    })
  );
  /** @internal */
  store = {};
  onSerializeCallbacks = {};
  /**
   * Get the value corresponding to a key. Return `defaultValue` if key is not found.
   */
  get(key, defaultValue) {
    return this.store[key] !== void 0 ? this.store[key] : defaultValue;
  }
  /**
   * Set the value corresponding to a key.
   */
  set(key, value2) {
    this.store[key] = value2;
  }
  /**
   * Remove a key from the store.
   */
  remove(key) {
    delete this.store[key];
  }
  /**
   * Test whether a key exists in the store.
   */
  hasKey(key) {
    return this.store.hasOwnProperty(key);
  }
  /**
   * Indicates whether the state is empty.
   */
  get isEmpty() {
    return Object.keys(this.store).length === 0;
  }
  /**
   * Register a callback to provide the value for a key when `toJson` is called.
   */
  onSerialize(key, callback) {
    this.onSerializeCallbacks[key] = callback;
  }
  /**
   * Serialize the current state of the store to JSON.
   */
  toJson() {
    for (const key in this.onSerializeCallbacks) {
      if (this.onSerializeCallbacks.hasOwnProperty(key)) {
        try {
          this.store[key] = this.onSerializeCallbacks[key]();
        } catch (e) {
          console.warn("Exception in onSerialize callback: ", e);
        }
      }
    }
    return JSON.stringify(this.store).replace(/</g, "\\u003C");
  }
};
function retrieveTransferredState(doc, appId) {
  const script = doc.getElementById(appId + "-state");
  if (script?.textContent) {
    try {
      return JSON.parse(script.textContent);
    } catch (e) {
      console.warn("Exception while restoring TransferState for app " + appId, e);
    }
  }
  return {};
}
var REFERENCE_NODE_HOST = "h";
var REFERENCE_NODE_BODY = "b";
var NodeNavigationStep;
(function(NodeNavigationStep2) {
  NodeNavigationStep2["FirstChild"] = "f";
  NodeNavigationStep2["NextSibling"] = "n";
})(NodeNavigationStep || (NodeNavigationStep = {}));
var NUM_ROOT_NODES = "r";
var DEFER_BLOCK_ID = "di";
var DEFER_BLOCK_STATE$1 = "s";
var DEFER_PARENT_BLOCK_ID = "p";
var IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_HYDRATION_DOM_REUSE_ENABLED" : "");
var PRESERVE_HOST_CONTENT_DEFAULT = false;
var PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "PRESERVE_HOST_CONTENT" : "", {
  providedIn: "root",
  factory: () => PRESERVE_HOST_CONTENT_DEFAULT
});
var IS_I18N_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_I18N_HYDRATION_ENABLED" : "");
var IS_EVENT_REPLAY_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_EVENT_REPLAY_ENABLED" : "");
var IS_INCREMENTAL_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === "undefined" || !!ngDevMode ? "IS_INCREMENTAL_HYDRATION_ENABLED" : "");
var JSACTION_BLOCK_ELEMENT_MAP = new InjectionToken(ngDevMode ? "JSACTION_BLOCK_ELEMENT_MAP" : "", {
  providedIn: "root",
  factory: () => /* @__PURE__ */ new Map()
});
var TracingAction;
(function(TracingAction2) {
  TracingAction2[TracingAction2["CHANGE_DETECTION"] = 0] = "CHANGE_DETECTION";
  TracingAction2[TracingAction2["AFTER_NEXT_RENDER"] = 1] = "AFTER_NEXT_RENDER";
})(TracingAction || (TracingAction = {}));
var TracingService = new InjectionToken(ngDevMode ? "TracingService" : "");
var markedFeatures = /* @__PURE__ */ new Set();
function performanceMarkFeature(feature) {
  if (markedFeatures.has(feature)) {
    return;
  }
  markedFeatures.add(feature);
  performance?.mark?.("mark_feature_usage", {
    detail: {
      feature
    }
  });
}
var AfterRenderPhase;
(function(AfterRenderPhase2) {
  AfterRenderPhase2[AfterRenderPhase2["EarlyRead"] = 0] = "EarlyRead";
  AfterRenderPhase2[AfterRenderPhase2["Write"] = 1] = "Write";
  AfterRenderPhase2[AfterRenderPhase2["MixedReadWrite"] = 2] = "MixedReadWrite";
  AfterRenderPhase2[AfterRenderPhase2["Read"] = 3] = "Read";
})(AfterRenderPhase || (AfterRenderPhase = {}));
var AfterRenderManager = class _AfterRenderManager {
  impl = null;
  execute() {
    this.impl?.execute();
  }
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _AfterRenderManager,
      providedIn: "root",
      factory: () => new _AfterRenderManager()
    })
  );
};
var AFTER_RENDER_PHASES = /* @__PURE__ */ (() => [AfterRenderPhase.EarlyRead, AfterRenderPhase.Write, AfterRenderPhase.MixedReadWrite, AfterRenderPhase.Read])();
var AfterRenderImpl = class _AfterRenderImpl {
  ngZone = inject(NgZone);
  scheduler = inject(ChangeDetectionScheduler);
  errorHandler = inject(ErrorHandler, {
    optional: true
  });
  /** Current set of active sequences. */
  sequences = /* @__PURE__ */ new Set();
  /** Tracks registrations made during the current set of executions. */
  deferredRegistrations = /* @__PURE__ */ new Set();
  /** Whether the `AfterRenderManager` is currently executing hooks. */
  executing = false;
  constructor() {
    inject(TracingService, {
      optional: true
    });
  }
  /**
   * Run the sequence of phases of hooks, once through. As a result of executing some hooks, more
   * might be scheduled.
   */
  execute() {
    this.executing = true;
    for (const phase of AFTER_RENDER_PHASES) {
      for (const sequence2 of this.sequences) {
        if (sequence2.erroredOrDestroyed || !sequence2.hooks[phase]) {
          continue;
        }
        try {
          sequence2.pipelinedValue = this.ngZone.runOutsideAngular(() => this.maybeTrace(() => sequence2.hooks[phase](sequence2.pipelinedValue), sequence2.snapshot));
        } catch (err) {
          sequence2.erroredOrDestroyed = true;
          this.errorHandler?.handleError(err);
        }
      }
    }
    this.executing = false;
    for (const sequence2 of this.sequences) {
      sequence2.afterRun();
      if (sequence2.once) {
        this.sequences.delete(sequence2);
        sequence2.destroy();
      }
    }
    for (const sequence2 of this.deferredRegistrations) {
      this.sequences.add(sequence2);
    }
    if (this.deferredRegistrations.size > 0) {
      this.scheduler.notify(
        8
        /* NotificationSource.DeferredRenderHook */
      );
    }
    this.deferredRegistrations.clear();
  }
  register(sequence2) {
    if (!this.executing) {
      this.sequences.add(sequence2);
      this.scheduler.notify(
        7
        /* NotificationSource.RenderHook */
      );
    } else {
      this.deferredRegistrations.add(sequence2);
    }
  }
  unregister(sequence2) {
    if (this.executing && this.sequences.has(sequence2)) {
      sequence2.erroredOrDestroyed = true;
      sequence2.pipelinedValue = void 0;
      sequence2.once = true;
    } else {
      this.sequences.delete(sequence2);
      this.deferredRegistrations.delete(sequence2);
    }
  }
  maybeTrace(fn, snapshot) {
    return snapshot?.run(TracingAction.AFTER_NEXT_RENDER, fn) ?? fn();
  }
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _AfterRenderImpl,
      providedIn: "root",
      factory: () => new _AfterRenderImpl()
    })
  );
};
var AfterRenderSequence = class {
  impl;
  hooks;
  once;
  snapshot;
  /**
   * Whether this sequence errored or was destroyed during this execution, and hooks should no
   * longer run for it.
   */
  erroredOrDestroyed = false;
  /**
   * The value returned by the last hook execution (if any), ready to be pipelined into the next
   * one.
   */
  pipelinedValue = void 0;
  unregisterOnDestroy;
  constructor(impl, hooks, once, destroyRef, snapshot = null) {
    this.impl = impl;
    this.hooks = hooks;
    this.once = once;
    this.snapshot = snapshot;
    this.unregisterOnDestroy = destroyRef?.onDestroy(() => this.destroy());
  }
  afterRun() {
    this.erroredOrDestroyed = false;
    this.pipelinedValue = void 0;
    this.snapshot = null;
  }
  destroy() {
    this.impl.unregister(this);
    this.unregisterOnDestroy?.();
  }
};
function afterNextRender(callbackOrSpec, options) {
  !options?.injector && assertInInjectionContext(afterNextRender);
  const injector = options?.injector ?? inject(Injector);
  if (false) {
    return NOOP_AFTER_RENDER_REF;
  }
  performanceMarkFeature("NgAfterNextRender");
  return afterRenderImpl(
    callbackOrSpec,
    injector,
    options,
    /* once */
    true
  );
}
function getHooks(callbackOrSpec, phase) {
  if (callbackOrSpec instanceof Function) {
    const hooks = [void 0, void 0, void 0, void 0];
    hooks[phase] = callbackOrSpec;
    return hooks;
  } else {
    return [callbackOrSpec.earlyRead, callbackOrSpec.write, callbackOrSpec.mixedReadWrite, callbackOrSpec.read];
  }
}
function afterRenderImpl(callbackOrSpec, injector, options, once) {
  const manager = injector.get(AfterRenderManager);
  manager.impl ??= injector.get(AfterRenderImpl);
  const tracing = injector.get(TracingService, null, {
    optional: true
  });
  const hooks = options?.phase ?? AfterRenderPhase.MixedReadWrite;
  const destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;
  const sequence2 = new AfterRenderSequence(manager.impl, getHooks(callbackOrSpec, hooks), once, destroyRef, tracing?.snapshot(null));
  manager.impl.register(sequence2);
  return sequence2;
}
var DeferDependenciesLoadingState;
(function(DeferDependenciesLoadingState2) {
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["NOT_STARTED"] = 0] = "NOT_STARTED";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["IN_PROGRESS"] = 1] = "IN_PROGRESS";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["COMPLETE"] = 2] = "COMPLETE";
  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2["FAILED"] = 3] = "FAILED";
})(DeferDependenciesLoadingState || (DeferDependenciesLoadingState = {}));
var MINIMUM_SLOT = 0;
var LOADING_AFTER_SLOT = 1;
var DeferBlockState;
(function(DeferBlockState2) {
  DeferBlockState2[DeferBlockState2["Placeholder"] = 0] = "Placeholder";
  DeferBlockState2[DeferBlockState2["Loading"] = 1] = "Loading";
  DeferBlockState2[DeferBlockState2["Complete"] = 2] = "Complete";
  DeferBlockState2[DeferBlockState2["Error"] = 3] = "Error";
})(DeferBlockState || (DeferBlockState = {}));
var DeferBlockInternalState;
(function(DeferBlockInternalState2) {
  DeferBlockInternalState2[DeferBlockInternalState2["Initial"] = -1] = "Initial";
})(DeferBlockInternalState || (DeferBlockInternalState = {}));
var NEXT_DEFER_BLOCK_STATE = 0;
var DEFER_BLOCK_STATE = 1;
var STATE_IS_FROZEN_UNTIL = 2;
var LOADING_AFTER_CLEANUP_FN = 3;
var TRIGGER_CLEANUP_FNS = 4;
var PREFETCH_TRIGGER_CLEANUP_FNS = 5;
var SSR_UNIQUE_ID = 6;
var SSR_BLOCK_STATE = 7;
var ON_COMPLETE_FNS = 8;
var HYDRATE_TRIGGER_CLEANUP_FNS = 9;
var DeferBlockBehavior;
(function(DeferBlockBehavior2) {
  DeferBlockBehavior2[DeferBlockBehavior2["Manual"] = 0] = "Manual";
  DeferBlockBehavior2[DeferBlockBehavior2["Playthrough"] = 1] = "Playthrough";
})(DeferBlockBehavior || (DeferBlockBehavior = {}));
function storeTriggerCleanupFn(type2, lDetails, cleanupFn) {
  const key = getCleanupFnKeyByType(type2);
  if (lDetails[key] === null) {
    lDetails[key] = [];
  }
  lDetails[key].push(cleanupFn);
}
function invokeTriggerCleanupFns(type2, lDetails) {
  const key = getCleanupFnKeyByType(type2);
  const cleanupFns = lDetails[key];
  if (cleanupFns !== null) {
    for (const cleanupFn of cleanupFns) {
      cleanupFn();
    }
    lDetails[key] = null;
  }
}
function invokeAllTriggerCleanupFns(lDetails) {
  invokeTriggerCleanupFns(1, lDetails);
  invokeTriggerCleanupFns(0, lDetails);
  invokeTriggerCleanupFns(2, lDetails);
}
function getCleanupFnKeyByType(type2) {
  let key = TRIGGER_CLEANUP_FNS;
  if (type2 === 1) {
    key = PREFETCH_TRIGGER_CLEANUP_FNS;
  } else if (type2 === 2) {
    key = HYDRATE_TRIGGER_CLEANUP_FNS;
  }
  return key;
}
function getDeferBlockDataIndex(deferBlockIndex) {
  return deferBlockIndex + 1;
}
function getLDeferBlockDetails(lView, tNode) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return lView[slotIndex];
}
function setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {
  const tView = lView[TVIEW];
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  lView[slotIndex] = lDetails;
}
function getTDeferBlockDetails(tView, tNode) {
  const slotIndex = getDeferBlockDataIndex(tNode.index);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  return tView.data[slotIndex];
}
function setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {
  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);
  ngDevMode && assertIndexInDeclRange(tView, slotIndex);
  tView.data[slotIndex] = deferBlockConfig;
}
function getTemplateIndexForState(newState, hostLView, tNode) {
  const tView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  switch (newState) {
    case DeferBlockState.Complete:
      return tDetails.primaryTmplIndex;
    case DeferBlockState.Loading:
      return tDetails.loadingTmplIndex;
    case DeferBlockState.Error:
      return tDetails.errorTmplIndex;
    case DeferBlockState.Placeholder:
      return tDetails.placeholderTmplIndex;
    default:
      ngDevMode && throwError2(`Unexpected defer block state: ${newState}`);
      return null;
  }
}
function getMinimumDurationForState(tDetails, currentState) {
  if (currentState === DeferBlockState.Placeholder) {
    return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;
  } else if (currentState === DeferBlockState.Loading) {
    return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;
  }
  return null;
}
function getLoadingBlockAfter(tDetails) {
  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;
}
function addDepsToRegistry(currentDeps, newDeps) {
  if (!currentDeps || currentDeps.length === 0) {
    return newDeps;
  }
  const currentDepSet = new Set(currentDeps);
  for (const dep of newDeps) {
    currentDepSet.add(dep);
  }
  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);
}
function getPrimaryBlockTNode(tView, tDetails) {
  const adjustedIndex = tDetails.primaryTmplIndex + HEADER_OFFSET;
  return getTNode(tView, adjustedIndex);
}
function assertDeferredDependenciesLoaded(tDetails) {
  assertEqual(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, "Expecting all deferred dependencies to be loaded.");
}
var eventListenerOptions = {
  passive: true,
  capture: true
};
var hoverTriggers = /* @__PURE__ */ new WeakMap();
var interactionTriggers = /* @__PURE__ */ new WeakMap();
var viewportTriggers = /* @__PURE__ */ new WeakMap();
var interactionEventNames = ["click", "keydown"];
var hoverEventNames = ["mouseenter", "mouseover", "focusin"];
var intersectionObserver = null;
var observedViewportElements = 0;
var DeferEventEntry = class {
  callbacks = /* @__PURE__ */ new Set();
  listener = () => {
    for (const callback of this.callbacks) {
      callback();
    }
  };
};
function onInteraction(trigger2, callback) {
  let entry = interactionTriggers.get(trigger2);
  if (!entry) {
    entry = new DeferEventEntry();
    interactionTriggers.set(trigger2, entry);
    for (const name of interactionEventNames) {
      trigger2.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const {
      callbacks,
      listener: listener2
    } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      interactionTriggers.delete(trigger2);
      for (const name of interactionEventNames) {
        trigger2.removeEventListener(name, listener2, eventListenerOptions);
      }
    }
  };
}
function onHover(trigger2, callback) {
  let entry = hoverTriggers.get(trigger2);
  if (!entry) {
    entry = new DeferEventEntry();
    hoverTriggers.set(trigger2, entry);
    for (const name of hoverEventNames) {
      trigger2.addEventListener(name, entry.listener, eventListenerOptions);
    }
  }
  entry.callbacks.add(callback);
  return () => {
    const {
      callbacks,
      listener: listener2
    } = entry;
    callbacks.delete(callback);
    if (callbacks.size === 0) {
      for (const name of hoverEventNames) {
        trigger2.removeEventListener(name, listener2, eventListenerOptions);
      }
      hoverTriggers.delete(trigger2);
    }
  };
}
function onViewport(trigger2, callback, injector) {
  const ngZone = injector.get(NgZone);
  let entry = viewportTriggers.get(trigger2);
  intersectionObserver = intersectionObserver || ngZone.runOutsideAngular(() => {
    return new IntersectionObserver((entries) => {
      for (const current of entries) {
        if (current.isIntersecting && viewportTriggers.has(current.target)) {
          ngZone.run(viewportTriggers.get(current.target).listener);
        }
      }
    });
  });
  if (!entry) {
    entry = new DeferEventEntry();
    ngZone.runOutsideAngular(() => intersectionObserver.observe(trigger2));
    viewportTriggers.set(trigger2, entry);
    observedViewportElements++;
  }
  entry.callbacks.add(callback);
  return () => {
    if (!viewportTriggers.has(trigger2)) {
      return;
    }
    entry.callbacks.delete(callback);
    if (entry.callbacks.size === 0) {
      intersectionObserver?.unobserve(trigger2);
      viewportTriggers.delete(trigger2);
      observedViewportElements--;
    }
    if (observedViewportElements === 0) {
      intersectionObserver?.disconnect();
      intersectionObserver = null;
    }
  };
}
function getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {
  if (walkUpTimes == null) {
    return deferredHostLView;
  }
  if (walkUpTimes >= 0) {
    return walkUpViews(walkUpTimes, deferredHostLView);
  }
  const deferredContainer = deferredHostLView[deferredTNode.index];
  ngDevMode && assertLContainer(deferredContainer);
  const triggerLView = deferredContainer[CONTAINER_HEADER_OFFSET] ?? null;
  if (ngDevMode && triggerLView !== null) {
    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    assertEqual(renderedState, DeferBlockState.Placeholder, "Expected a placeholder to be rendered in this defer block.");
    assertLView(triggerLView);
  }
  return triggerLView;
}
function getTriggerElement(triggerLView, triggerIndex) {
  const element = getNativeByIndex(HEADER_OFFSET + triggerIndex, triggerLView);
  ngDevMode && assertElement(element);
  return element;
}
function registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type2) {
  const injector = initialLView[INJECTOR];
  const zone = injector.get(NgZone);
  function pollDomTrigger() {
    if (isDestroyed(initialLView)) {
      return;
    }
    const lDetails = getLDeferBlockDetails(initialLView, tNode);
    const renderedState = lDetails[DEFER_BLOCK_STATE];
    if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {
      return;
    }
    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);
    if (!triggerLView) {
      afterNextRender({
        read: pollDomTrigger
      }, {
        injector
      });
      return;
    }
    if (isDestroyed(triggerLView)) {
      return;
    }
    const element = getTriggerElement(triggerLView, triggerIndex);
    const cleanup = registerFn(element, () => {
      zone.run(() => {
        if (initialLView !== triggerLView) {
          removeLViewOnDestroy(triggerLView, cleanup);
        }
        callback();
      });
    }, injector);
    if (initialLView !== triggerLView) {
      storeLViewOnDestroy(triggerLView, cleanup);
    }
    storeTriggerCleanupFn(type2, lDetails, cleanup);
  }
  afterNextRender({
    read: pollDomTrigger
  }, {
    injector
  });
}
var JSACTION_EVENT_CONTRACT = new InjectionToken(ngDevMode ? "EVENT_CONTRACT_DETAILS" : "", {
  providedIn: "root",
  factory: () => ({})
});
var DEHYDRATED_BLOCK_REGISTRY = new InjectionToken(ngDevMode ? "DEHYDRATED_BLOCK_REGISTRY" : "");
var TRANSFER_STATE_TOKEN_ID = "__nghData__";
var NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);
var TRANSFER_STATE_DEFER_BLOCKS_INFO = "__nghDeferData__";
var NGH_DEFER_BLOCKS_KEY = makeStateKey(TRANSFER_STATE_DEFER_BLOCKS_INFO);
var _retrieveHydrationInfoImpl = () => null;
function retrieveHydrationInfo(rNode, injector, isRootView2 = false) {
  return _retrieveHydrationInfoImpl(rNode, injector, isRootView2);
}
function getLNodeForHydration(viewRef) {
  let lView = viewRef._lView;
  const tView = lView[TVIEW];
  if (tView.type === 2) {
    return null;
  }
  if (isRootView(lView)) {
    lView = lView[HEADER_OFFSET];
  }
  return lView;
}
var HydrationStatus;
(function(HydrationStatus2) {
  HydrationStatus2["Hydrated"] = "hydrated";
  HydrationStatus2["Skipped"] = "skipped";
  HydrationStatus2["Mismatched"] = "mismatched";
})(HydrationStatus || (HydrationStatus = {}));
var HYDRATION_INFO_KEY = "__ngDebugHydrationInfo__";
function patchHydrationInfo(node, info) {
  node[HYDRATION_INFO_KEY] = info;
}
function markRNodeAsHavingHydrationMismatch(node, expectedNodeDetails = null, actualNodeDetails = null) {
  if (!ngDevMode) {
    throw new Error("Calling `markRNodeAsMismatchedByHydration` in prod mode is not supported and likely a mistake.");
  }
  while (node && !getComponent(node)) {
    node = node?.parentNode;
  }
  if (node) {
    patchHydrationInfo(node, {
      status: HydrationStatus.Mismatched,
      expectedNodeDetails,
      actualNodeDetails
    });
  }
}
function isIncrementalHydrationEnabled(injector) {
  return injector.get(IS_INCREMENTAL_HYDRATION_ENABLED, false, {
    optional: true
  });
}
function assertIncrementalHydrationIsConfigured(injector) {
  if (!isIncrementalHydrationEnabled(injector)) {
    throw new RuntimeError(508, "Angular has detected that some `@defer` blocks use `hydrate` triggers, but incremental hydration was not enabled. Please ensure that the `withIncrementalHydration()` call is added as an argument for the `provideClientHydration()` function call in your application config.");
  }
}
function assertSsrIdDefined(ssrUniqueId) {
  assertDefined(ssrUniqueId, "Internal error: expecting an SSR id for a defer block that should be hydrated, but the id is not present");
}
function getParentBlockHydrationQueue(deferBlockId, injector) {
  const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
  const transferState = injector.get(TransferState);
  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});
  let isTopMostDeferBlock = false;
  let currentBlockId = deferBlockId;
  let parentBlockPromise = null;
  const hydrationQueue = [];
  while (!isTopMostDeferBlock && currentBlockId) {
    ngDevMode && assertEqual(hydrationQueue.indexOf(currentBlockId), -1, "Internal error: defer block hierarchy has a cycle.");
    isTopMostDeferBlock = dehydratedBlockRegistry.has(currentBlockId);
    const hydratingParentBlock = dehydratedBlockRegistry.hydrating.get(currentBlockId);
    if (parentBlockPromise === null && hydratingParentBlock != null) {
      parentBlockPromise = hydratingParentBlock.promise;
      break;
    }
    hydrationQueue.unshift(currentBlockId);
    currentBlockId = deferBlockParents[currentBlockId][DEFER_PARENT_BLOCK_ID];
  }
  return {
    parentBlockPromise,
    hydrationQueue
  };
}
var ViewEncapsulation;
(function(ViewEncapsulation2) {
  ViewEncapsulation2[ViewEncapsulation2["Emulated"] = 0] = "Emulated";
  ViewEncapsulation2[ViewEncapsulation2["None"] = 2] = "None";
  ViewEncapsulation2[ViewEncapsulation2["ShadowDom"] = 3] = "ShadowDom";
})(ViewEncapsulation || (ViewEncapsulation = {}));
var policy$1;
function getPolicy$1() {
  if (policy$1 === void 0) {
    policy$1 = null;
    if (_global.trustedTypes) {
      try {
        policy$1 = _global.trustedTypes.createPolicy("angular", {
          createHTML: (s2) => s2,
          createScript: (s2) => s2,
          createScriptURL: (s2) => s2
        });
      } catch {
      }
    }
  }
  return policy$1;
}
function trustedHTMLFromString(html) {
  return getPolicy$1()?.createHTML(html) || html;
}
function trustedScriptURLFromString(url) {
  return getPolicy$1()?.createScriptURL(url) || url;
}
var policy;
function getPolicy() {
  if (policy === void 0) {
    policy = null;
    if (_global.trustedTypes) {
      try {
        policy = _global.trustedTypes.createPolicy("angular#unsafe-bypass", {
          createHTML: (s2) => s2,
          createScript: (s2) => s2,
          createScriptURL: (s2) => s2
        });
      } catch {
      }
    }
  }
  return policy;
}
function trustedHTMLFromStringBypass(html) {
  return getPolicy()?.createHTML(html) || html;
}
function trustedScriptFromStringBypass(script) {
  return getPolicy()?.createScript(script) || script;
}
function trustedScriptURLFromStringBypass(url) {
  return getPolicy()?.createScriptURL(url) || url;
}
var SafeValueImpl = class {
  changingThisBreaksApplicationSecurity;
  constructor(changingThisBreaksApplicationSecurity) {
    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
  }
  toString() {
    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${XSS_SECURITY_URL})`;
  }
};
var SafeHtmlImpl = class extends SafeValueImpl {
  getTypeName() {
    return "HTML";
  }
};
var SafeStyleImpl = class extends SafeValueImpl {
  getTypeName() {
    return "Style";
  }
};
var SafeScriptImpl = class extends SafeValueImpl {
  getTypeName() {
    return "Script";
  }
};
var SafeUrlImpl = class extends SafeValueImpl {
  getTypeName() {
    return "URL";
  }
};
var SafeResourceUrlImpl = class extends SafeValueImpl {
  getTypeName() {
    return "ResourceURL";
  }
};
function unwrapSafeValue(value2) {
  return value2 instanceof SafeValueImpl ? value2.changingThisBreaksApplicationSecurity : value2;
}
function allowSanitizationBypassAndThrow(value2, type2) {
  const actualType = getSanitizationBypassType(value2);
  if (actualType != null && actualType !== type2) {
    if (actualType === "ResourceURL" && type2 === "URL") return true;
    throw new Error(`Required a safe ${type2}, got a ${actualType} (see ${XSS_SECURITY_URL})`);
  }
  return actualType === type2;
}
function getSanitizationBypassType(value2) {
  return value2 instanceof SafeValueImpl && value2.getTypeName() || null;
}
function bypassSanitizationTrustHtml(trustedHtml) {
  return new SafeHtmlImpl(trustedHtml);
}
function bypassSanitizationTrustStyle(trustedStyle) {
  return new SafeStyleImpl(trustedStyle);
}
function bypassSanitizationTrustScript(trustedScript) {
  return new SafeScriptImpl(trustedScript);
}
function bypassSanitizationTrustUrl(trustedUrl) {
  return new SafeUrlImpl(trustedUrl);
}
function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
  return new SafeResourceUrlImpl(trustedResourceUrl);
}
function getInertBodyHelper(defaultDoc) {
  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
}
var DOMParserHelper = class {
  inertDocumentHelper;
  constructor(inertDocumentHelper) {
    this.inertDocumentHelper = inertDocumentHelper;
  }
  getInertBodyElement(html) {
    html = "<body><remove></remove>" + html;
    try {
      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), "text/html").body;
      if (body === null) {
        return this.inertDocumentHelper.getInertBodyElement(html);
      }
      body.firstChild?.remove();
      return body;
    } catch {
      return null;
    }
  }
};
var InertDocumentHelper = class {
  defaultDoc;
  inertDocument;
  constructor(defaultDoc) {
    this.defaultDoc = defaultDoc;
    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
  }
  getInertBodyElement(html) {
    const templateEl = this.inertDocument.createElement("template");
    templateEl.innerHTML = trustedHTMLFromString(html);
    return templateEl;
  }
};
function isDOMParserAvailable() {
  try {
    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
  } catch {
    return false;
  }
}
var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
function _sanitizeUrl(url) {
  url = String(url);
  if (url.match(SAFE_URL_PATTERN)) return url;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);
  }
  return "unsafe:" + url;
}
function tagSet(tags) {
  const res = {};
  for (const t2 of tags.split(",")) res[t2] = true;
  return res;
}
function merge(...sets) {
  const res = {};
  for (const s2 of sets) {
    for (const v in s2) {
      if (s2.hasOwnProperty(v)) res[v] = true;
    }
  }
  return res;
}
var VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
var URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
var HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
var ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
var VALID_ATTRS = merge(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);
var SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
var SanitizingHtmlSerializer = class {
  // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just
  // because characters were re-encoded.
  sanitizedSomething = false;
  buf = [];
  sanitizeChildren(el) {
    let current = el.firstChild;
    let traverseContent = true;
    let parentNodes = [];
    while (current) {
      if (current.nodeType === Node.ELEMENT_NODE) {
        traverseContent = this.startElement(current);
      } else if (current.nodeType === Node.TEXT_NODE) {
        this.chars(current.nodeValue);
      } else {
        this.sanitizedSomething = true;
      }
      if (traverseContent && current.firstChild) {
        parentNodes.push(current);
        current = getFirstChild(current);
        continue;
      }
      while (current) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          this.endElement(current);
        }
        let next = getNextSibling(current);
        if (next) {
          current = next;
          break;
        }
        current = parentNodes.pop();
      }
    }
    return this.buf.join("");
  }
  /**
   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should
   * be traversed. Element content must always be traversed (even if the element itself is not
   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.
   *
   * @param element The element to sanitize.
   * @return True if the element's contents should be traversed.
   */
  startElement(element) {
    const tagName = getNodeName(element).toLowerCase();
    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
      this.sanitizedSomething = true;
      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
    }
    this.buf.push("<");
    this.buf.push(tagName);
    const elAttrs = element.attributes;
    for (let i = 0; i < elAttrs.length; i++) {
      const elAttr = elAttrs.item(i);
      const attrName = elAttr.name;
      const lower2 = attrName.toLowerCase();
      if (!VALID_ATTRS.hasOwnProperty(lower2)) {
        this.sanitizedSomething = true;
        continue;
      }
      let value2 = elAttr.value;
      if (URI_ATTRS[lower2]) value2 = _sanitizeUrl(value2);
      this.buf.push(" ", attrName, '="', encodeEntities(value2), '"');
    }
    this.buf.push(">");
    return true;
  }
  endElement(current) {
    const tagName = getNodeName(current).toLowerCase();
    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
      this.buf.push("</");
      this.buf.push(tagName);
      this.buf.push(">");
    }
  }
  chars(chars) {
    this.buf.push(encodeEntities(chars));
  }
};
function isClobberedElement(parentNode, childNode) {
  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
}
function getNextSibling(node) {
  const nextSibling = node.nextSibling;
  if (nextSibling && node !== nextSibling.previousSibling) {
    throw clobberedElementError(nextSibling);
  }
  return nextSibling;
}
function getFirstChild(node) {
  const firstChild = node.firstChild;
  if (firstChild && isClobberedElement(node, firstChild)) {
    throw clobberedElementError(firstChild);
  }
  return firstChild;
}
function getNodeName(node) {
  const nodeName = node.nodeName;
  return typeof nodeName === "string" ? nodeName : "FORM";
}
function clobberedElementError(node) {
  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
}
var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
function encodeEntities(value2) {
  return value2.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match2) {
    const hi = match2.charCodeAt(0);
    const low = match2.charCodeAt(1);
    return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
  }).replace(NON_ALPHANUMERIC_REGEXP, function(match2) {
    return "&#" + match2.charCodeAt(0) + ";";
  }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
var inertBodyHelper;
function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
  let inertBodyElement = null;
  try {
    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    let mXSSAttempts = 5;
    let parsedHtml = unsafeHtml;
    do {
      if (mXSSAttempts === 0) {
        throw new Error("Failed to sanitize html because the input is unstable");
      }
      mXSSAttempts--;
      unsafeHtml = parsedHtml;
      parsedHtml = inertBodyElement.innerHTML;
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
    } while (unsafeHtml !== parsedHtml);
    const sanitizer = new SanitizingHtmlSerializer();
    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && sanitizer.sanitizedSomething) {
      console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);
    }
    return trustedHTMLFromString(safeHtml);
  } finally {
    if (inertBodyElement) {
      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
      while (parent.firstChild) {
        parent.firstChild.remove();
      }
    }
  }
}
function getTemplateContent(el) {
  return "content" in el && isTemplateElement(el) ? el.content : null;
}
function isTemplateElement(el) {
  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
}
var SecurityContext;
(function(SecurityContext2) {
  SecurityContext2[SecurityContext2["NONE"] = 0] = "NONE";
  SecurityContext2[SecurityContext2["HTML"] = 1] = "HTML";
  SecurityContext2[SecurityContext2["STYLE"] = 2] = "STYLE";
  SecurityContext2[SecurityContext2["SCRIPT"] = 3] = "SCRIPT";
  SecurityContext2[SecurityContext2["URL"] = 4] = "URL";
  SecurityContext2[SecurityContext2["RESOURCE_URL"] = 5] = "RESOURCE_URL";
})(SecurityContext || (SecurityContext = {}));
function \u0275\u0275sanitizeHtml(unsafeHtml) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeHtml,
    "HTML"
    /* BypassType.Html */
  )) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
}
function \u0275\u0275sanitizeStyle(unsafeStyle) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeStyle,
    "Style"
    /* BypassType.Style */
  )) {
    return unwrapSafeValue(unsafeStyle);
  }
  return renderStringify(unsafeStyle);
}
function \u0275\u0275sanitizeUrl(unsafeUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
  }
  if (allowSanitizationBypassAndThrow(
    unsafeUrl,
    "URL"
    /* BypassType.Url */
  )) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl(renderStringify(unsafeUrl));
}
function \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeResourceUrl,
    "ResourceURL"
    /* BypassType.ResourceUrl */
  )) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
}
function \u0275\u0275sanitizeScript(unsafeScript) {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
  }
  if (allowSanitizationBypassAndThrow(
    unsafeScript,
    "Script"
    /* BypassType.Script */
  )) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new RuntimeError(905, ngDevMode && "unsafe value used in a script context");
}
function \u0275\u0275trustConstantHtml(html) {
  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
  }
  return trustedHTMLFromString(html[0]);
}
function \u0275\u0275trustConstantResourceUrl(url) {
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
  }
  return trustedScriptURLFromString(url[0]);
}
function getUrlSanitizer(tag, prop) {
  if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
    return \u0275\u0275sanitizeResourceUrl;
  }
  return \u0275\u0275sanitizeUrl;
}
function \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}
function validateAgainstEventProperties(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
    throw new RuntimeError(306, errorMessage);
  }
}
function validateAgainstEventAttributes(name) {
  if (name.toLowerCase().startsWith("on")) {
    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
    throw new RuntimeError(306, errorMessage);
  }
}
function getSanitizer() {
  const lView = getLView();
  return lView && lView[ENVIRONMENT].sanitizer;
}
var COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
var COMMENT_DELIMITER = /(<|>)/g;
var COMMENT_DELIMITER_ESCAPED = "\u200B$1\u200B";
function escapeCommentText(value2) {
  return value2.replace(COMMENT_DISALLOWED, (text2) => text2.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
}
function normalizeDebugBindingName(name) {
  name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
  return `ng-reflect-${name}`;
}
var CAMEL_CASE_REGEXP = /([A-Z])/g;
function camelCaseToDashCase(input2) {
  return input2.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
}
function normalizeDebugBindingValue(value2) {
  try {
    return value2 != null ? value2.toString().slice(0, 30) : value2;
  } catch (e) {
    return "[ERROR] Exception while trying to serialize the value";
  }
}
var CUSTOM_ELEMENTS_SCHEMA = {
  name: "custom-elements"
};
var NO_ERRORS_SCHEMA = {
  name: "no-errors-schema"
};
var shouldThrowErrorOnUnknownElement = false;
var shouldThrowErrorOnUnknownProperty = false;
function validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {
  if (schemas === null) return;
  if (!hasDirectives && tagName !== null) {
    const isUnknown = (
      // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because
      // Domino doesn't expose HTMLUnknownElement globally.
      typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName)
    );
    if (isUnknown && !matchingSchemas(schemas, tagName)) {
      const isHostStandalone = isHostComponentStandalone(lView);
      const templateLocation = getTemplateLocationDetails(lView);
      const schemas2 = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
      let message = `'${tagName}' is not a known element${templateLocation}:
`;
      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared"}.
`;
      if (tagName && tagName.indexOf("-") > -1) {
        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.`;
      } else {
        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;
      }
      if (shouldThrowErrorOnUnknownElement) {
        throw new RuntimeError(304, message);
      } else {
        console.error(formatRuntimeError(304, message));
      }
    }
  }
}
function isPropertyValid(element, propName, tagName, schemas) {
  if (schemas === null) return true;
  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {
    return true;
  }
  return typeof Node === "undefined" || Node === null || !(element instanceof Node);
}
function handleUnknownPropertyError(propName, tagName, nodeType, lView) {
  if (!tagName && nodeType === 4) {
    tagName = "ng-template";
  }
  const isHostStandalone = isHostComponentStandalone(lView);
  const templateLocation = getTemplateLocationDetails(lView);
  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;
  const schemas = `'${isHostStandalone ? "@Component" : "@NgModule"}.schemas'`;
  const importLocation = isHostStandalone ? "included in the '@Component.imports' of this component" : "a part of an @NgModule where this component is declared";
  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {
    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);
    message += `
If the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;
  } else {
    message += `
1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;
    if (tagName && tagName.indexOf("-") > -1) {
      message += `
2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;
      message += `
3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    } else {
      message += `
2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;
    }
  }
  reportUnknownPropertyError(message);
}
function reportUnknownPropertyError(message) {
  if (shouldThrowErrorOnUnknownProperty) {
    throw new RuntimeError(303, message);
  } else {
    console.error(formatRuntimeError(303, message));
  }
}
function getDeclarationComponentDef(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  if (!context2) return null;
  return context2.constructor ? getComponentDef(context2.constructor) : null;
}
function isHostComponentStandalone(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const componentDef = getDeclarationComponentDef(lView);
  return !!componentDef?.standalone;
}
function getTemplateLocationDetails(lView) {
  !ngDevMode && throwError2("Must never be called in production mode");
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  return componentClassName ? ` (used in the '${componentClassName}' component template)` : "";
}
var KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([["ngIf", "NgIf"], ["ngFor", "NgFor"], ["ngSwitchCase", "NgSwitchCase"], ["ngSwitchDefault", "NgSwitchDefault"]]);
function matchingSchemas(schemas, tagName) {
  if (schemas !== null) {
    for (let i = 0; i < schemas.length; i++) {
      const schema = schemas[i];
      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
        return true;
      }
    }
  }
  return false;
}
function \u0275\u0275resolveWindow(element) {
  return element.ownerDocument.defaultView;
}
function \u0275\u0275resolveDocument(element) {
  return element.ownerDocument;
}
function \u0275\u0275resolveBody(element) {
  return element.ownerDocument.body;
}
var INTERPOLATION_DELIMITER = `\uFFFD`;
function maybeUnwrapFn(value2) {
  if (value2 instanceof Function) {
    return value2();
  } else {
    return value2;
  }
}
var VALUE_STRING_LENGTH_LIMIT = 200;
function assertComponentDef(type2) {
  if (!getComponentDef(type2)) {
    throw new RuntimeError(906, `The ${stringifyForError(type2)} is not an Angular component, make sure it has the \`@Component\` decorator.`);
  }
}
function throwMultipleComponentError(tNode, first2, second2) {
  throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first2)} and ${stringifyForError(second2)}`);
}
function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {
  const hostComponentDef = getDeclarationComponentDef(lView);
  const componentClassName = hostComponentDef?.type?.name;
  const field = propName ? ` for '${propName}'` : "";
  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : ""}`;
  if (creationMode) {
    msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
  }
  throw new RuntimeError(-100, msg);
}
function formatValue(value2) {
  let strValue = String(value2);
  try {
    if (Array.isArray(value2) || strValue === "[object Object]") {
      strValue = JSON.stringify(value2);
    }
  } catch (error) {
  }
  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + "\u2026" : strValue;
}
function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
  let oldValue = prefix, newValue = prefix;
  for (let i = 0; i < chunks.length; i++) {
    const slotIdx = rootIndex + i;
    oldValue += `${lView[slotIdx]}${chunks[i]}`;
    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
  }
  return {
    propName,
    oldValue,
    newValue
  };
}
function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
  const tData = lView[TVIEW].data;
  const metadata = tData[bindingIndex];
  if (typeof metadata === "string") {
    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
    }
    return {
      propName: metadata,
      oldValue,
      newValue
    };
  }
  if (metadata === null) {
    let idx = bindingIndex - 1;
    while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
      idx--;
    }
    const meta = tData[idx];
    if (typeof meta === "string") {
      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
      if (matches && matches.length - 1 > bindingIndex - idx) {
        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
      }
    }
  }
  return {
    propName: void 0,
    oldValue,
    newValue
  };
}
var InputFlags;
(function(InputFlags2) {
  InputFlags2[InputFlags2["None"] = 0] = "None";
  InputFlags2[InputFlags2["SignalBased"] = 1] = "SignalBased";
  InputFlags2[InputFlags2["HasDecoratorInputTransform"] = 2] = "HasDecoratorInputTransform";
})(InputFlags || (InputFlags = {}));
var RendererStyleFlags2;
(function(RendererStyleFlags22) {
  RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
  RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
var _icuContainerIterate;
function icuContainerIterate(tIcuContainerNode, lView) {
  return _icuContainerIterate(tIcuContainerNode, lView);
}
function ensureIcuContainerVisitorLoaded(loader) {
  if (_icuContainerIterate === void 0) {
    _icuContainerIterate = loader();
  }
}
function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
  if (lNodeToHandle != null) {
    let lContainer;
    let isComponent2 = false;
    if (isLContainer(lNodeToHandle)) {
      lContainer = lNodeToHandle;
    } else if (isLView(lNodeToHandle)) {
      isComponent2 = true;
      ngDevMode && assertDefined(lNodeToHandle[HOST], "HOST must be defined for a component LView");
      lNodeToHandle = lNodeToHandle[HOST];
    }
    const rNode = unwrapRNode(lNodeToHandle);
    if (action === 0 && parent !== null) {
      if (beforeNode == null) {
        nativeAppendChild(renderer, parent, rNode);
      } else {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      }
    } else if (action === 1 && parent !== null) {
      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
    } else if (action === 2) {
      nativeRemoveNode(renderer, rNode, isComponent2);
    } else if (action === 3) {
      ngDevMode && ngDevMode.rendererDestroyNode++;
      renderer.destroyNode(rNode);
    }
    if (lContainer != null) {
      applyContainer(renderer, action, lContainer, parent, beforeNode);
    }
  }
}
function createTextNode(renderer, value2) {
  ngDevMode && ngDevMode.rendererCreateTextNode++;
  ngDevMode && ngDevMode.rendererSetText++;
  return renderer.createText(value2);
}
function updateTextNode(renderer, rNode, value2) {
  ngDevMode && ngDevMode.rendererSetText++;
  renderer.setValue(rNode, value2);
}
function createCommentNode(renderer, value2) {
  ngDevMode && ngDevMode.rendererCreateComment++;
  return renderer.createComment(escapeCommentText(value2));
}
function createElementNode(renderer, name, namespace2) {
  ngDevMode && ngDevMode.rendererCreateElement++;
  return renderer.createElement(name, namespace2);
}
function removeViewFromDOM(tView, lView) {
  detachViewFromDOM(tView, lView);
  lView[HOST] = null;
  lView[T_HOST] = null;
}
function addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
  lView[HOST] = parentNativeNode;
  lView[T_HOST] = parentTNode;
  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
}
function detachViewFromDOM(tView, lView) {
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(
    10
    /* NotificationSource.ViewDetachedFromDOM */
  );
  applyView(tView, lView, lView[RENDERER], 2, null, null);
}
function destroyViewTree(rootView) {
  let lViewOrLContainer = rootView[CHILD_HEAD];
  if (!lViewOrLContainer) {
    return cleanUpView(rootView[TVIEW], rootView);
  }
  while (lViewOrLContainer) {
    let next = null;
    if (isLView(lViewOrLContainer)) {
      next = lViewOrLContainer[CHILD_HEAD];
    } else {
      ngDevMode && assertLContainer(lViewOrLContainer);
      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
      if (firstView) next = firstView;
    }
    if (!next) {
      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
        if (isLView(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
        }
        lViewOrLContainer = lViewOrLContainer[PARENT];
      }
      if (lViewOrLContainer === null) lViewOrLContainer = rootView;
      if (isLView(lViewOrLContainer)) {
        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
      }
      next = lViewOrLContainer && lViewOrLContainer[NEXT];
    }
    lViewOrLContainer = next;
  }
}
function insertView(tView, lView, lContainer, index) {
  ngDevMode && assertLView(lView);
  ngDevMode && assertLContainer(lContainer);
  const indexInContainer = CONTAINER_HEADER_OFFSET + index;
  const containerLength = lContainer.length;
  if (index > 0) {
    lContainer[indexInContainer - 1][NEXT] = lView;
  }
  if (index < containerLength - CONTAINER_HEADER_OFFSET) {
    lView[NEXT] = lContainer[indexInContainer];
    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
  } else {
    lContainer.push(lView);
    lView[NEXT] = null;
  }
  lView[PARENT] = lContainer;
  const declarationLContainer = lView[DECLARATION_LCONTAINER];
  if (declarationLContainer !== null && lContainer !== declarationLContainer) {
    trackMovedView(declarationLContainer, lView);
  }
  const lQueries = lView[QUERIES];
  if (lQueries !== null) {
    lQueries.insertView(tView);
  }
  updateAncestorTraversalFlagsOnAttach(lView);
  lView[FLAGS] |= 128;
}
function trackMovedView(declarationContainer, lView) {
  ngDevMode && assertDefined(lView, "LView required");
  ngDevMode && assertLContainer(declarationContainer);
  const movedViews = declarationContainer[MOVED_VIEWS];
  const parent = lView[PARENT];
  ngDevMode && assertDefined(parent, "missing parent");
  if (isLView(parent)) {
    declarationContainer[FLAGS] |= LContainerFlags.HasTransplantedViews;
  } else {
    const insertedComponentLView = parent[PARENT][DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(insertedComponentLView, "Missing insertedComponentLView");
    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(declaredComponentLView, "Missing declaredComponentLView");
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[FLAGS] |= LContainerFlags.HasTransplantedViews;
    }
  }
  if (movedViews === null) {
    declarationContainer[MOVED_VIEWS] = [lView];
  } else {
    movedViews.push(lView);
  }
}
function detachMovedView(declarationContainer, lView) {
  ngDevMode && assertLContainer(declarationContainer);
  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
  const movedViews = declarationContainer[MOVED_VIEWS];
  const declarationViewIndex = movedViews.indexOf(lView);
  movedViews.splice(declarationViewIndex, 1);
}
function detachView(lContainer, removeIndex) {
  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;
  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
  const viewToDetach = lContainer[indexInContainer];
  if (viewToDetach) {
    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && declarationLContainer !== lContainer) {
      detachMovedView(declarationLContainer, viewToDetach);
    }
    if (removeIndex > 0) {
      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
    }
    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
    removeViewFromDOM(viewToDetach[TVIEW], viewToDetach);
    const lQueries = removedLView[QUERIES];
    if (lQueries !== null) {
      lQueries.detachView(removedLView[TVIEW]);
    }
    viewToDetach[PARENT] = null;
    viewToDetach[NEXT] = null;
    viewToDetach[FLAGS] &= ~128;
  }
  return viewToDetach;
}
function destroyLView(tView, lView) {
  if (!(lView[FLAGS] & 256)) {
    const renderer = lView[RENDERER];
    if (renderer.destroyNode) {
      applyView(tView, lView, renderer, 3, null, null);
    }
    destroyViewTree(lView);
  }
}
function cleanUpView(tView, lView) {
  if (lView[FLAGS] & 256) {
    return;
  }
  const prevConsumer = setActiveConsumer(null);
  try {
    lView[FLAGS] &= ~128;
    lView[FLAGS] |= 256;
    lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
    executeOnDestroys(tView, lView);
    processCleanups(tView, lView);
    if (lView[TVIEW].type === 1) {
      ngDevMode && ngDevMode.rendererDestroy++;
      lView[RENDERER].destroy();
    }
    const declarationContainer = lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && isLContainer(lView[PARENT])) {
      if (declarationContainer !== lView[PARENT]) {
        detachMovedView(declarationContainer, lView);
      }
      const lQueries = lView[QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(tView);
      }
    }
    unregisterLView(lView);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function processCleanups(tView, lView) {
  ngDevMode && assertNotReactive(processCleanups.name);
  const tCleanup = tView.cleanup;
  const lCleanup = lView[CLEANUP];
  if (tCleanup !== null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      if (typeof tCleanup[i] === "string") {
        const targetIdx = tCleanup[i + 3];
        ngDevMode && assertNumber(targetIdx, "cleanup target must be a number");
        if (targetIdx >= 0) {
          lCleanup[targetIdx]();
        } else {
          lCleanup[-targetIdx].unsubscribe();
        }
        i += 2;
      } else {
        const context2 = lCleanup[tCleanup[i + 1]];
        tCleanup[i].call(context2);
      }
    }
  }
  if (lCleanup !== null) {
    lView[CLEANUP] = null;
  }
  const destroyHooks = lView[ON_DESTROY_HOOKS];
  if (destroyHooks !== null) {
    lView[ON_DESTROY_HOOKS] = null;
    for (let i = 0; i < destroyHooks.length; i++) {
      const destroyHooksFn = destroyHooks[i];
      ngDevMode && assertFunction(destroyHooksFn, "Expecting destroy hook to be a function.");
      destroyHooksFn();
    }
  }
  const effects = lView[EFFECTS];
  if (effects !== null) {
    lView[EFFECTS] = null;
    for (const effect of effects) {
      effect.destroy();
    }
  }
}
function executeOnDestroys(tView, lView) {
  ngDevMode && assertNotReactive(executeOnDestroys.name);
  let destroyHooks;
  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
    for (let i = 0; i < destroyHooks.length; i += 2) {
      const context2 = lView[destroyHooks[i]];
      if (!(context2 instanceof NodeInjectorFactory)) {
        const toCall = destroyHooks[i + 1];
        if (Array.isArray(toCall)) {
          for (let j = 0; j < toCall.length; j += 2) {
            const callContext = context2[toCall[j]];
            const hook = toCall[j + 1];
            profiler(4, callContext, hook);
            try {
              hook.call(callContext);
            } finally {
              profiler(5, callContext, hook);
            }
          }
        } else {
          profiler(4, context2, toCall);
          try {
            toCall.call(context2);
          } finally {
            profiler(5, context2, toCall);
          }
        }
      }
    }
  }
}
function getParentRElement(tView, tNode, lView) {
  return getClosestRElement(tView, tNode.parent, lView);
}
function getClosestRElement(tView, tNode, lView) {
  let parentTNode = tNode;
  while (parentTNode !== null && parentTNode.type & (8 | 32 | 128)) {
    tNode = parentTNode;
    parentTNode = tNode.parent;
  }
  if (parentTNode === null) {
    return lView[HOST];
  } else {
    ngDevMode && assertTNodeType(
      parentTNode,
      3 | 4
      /* TNodeType.Container */
    );
    const {
      componentOffset
    } = parentTNode;
    if (componentOffset > -1) {
      ngDevMode && assertTNodeForLView(parentTNode, lView);
      const {
        encapsulation
      } = tView.data[parentTNode.directiveStart + componentOffset];
      if (encapsulation === ViewEncapsulation.None || encapsulation === ViewEncapsulation.Emulated) {
        return null;
      }
    }
    return getNativeByTNode(parentTNode, lView);
  }
}
function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
  ngDevMode && ngDevMode.rendererInsertBefore++;
  renderer.insertBefore(parent, child, beforeNode, isMove);
}
function nativeAppendChild(renderer, parent, child) {
  ngDevMode && ngDevMode.rendererAppendChild++;
  ngDevMode && assertDefined(parent, "parent node must be defined");
  renderer.appendChild(parent, child);
}
function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
  if (beforeNode !== null) {
    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
  } else {
    nativeAppendChild(renderer, parent, child);
  }
}
function nativeParentNode(renderer, node) {
  return renderer.parentNode(node);
}
function nativeNextSibling(renderer, node) {
  return renderer.nextSibling(node);
}
function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
}
function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
  if (parentTNode.type & (8 | 32)) {
    return getNativeByTNode(parentTNode, lView);
  }
  return null;
}
var _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
var _processI18nInsertBefore;
function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
  _processI18nInsertBefore = processI18nInsertBefore2;
}
function appendChild(tView, lView, childRNode, childTNode) {
  const parentRNode = getParentRElement(tView, childTNode, lView);
  const renderer = lView[RENDERER];
  const parentTNode = childTNode.parent || lView[T_HOST];
  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
  if (parentRNode != null) {
    if (Array.isArray(childRNode)) {
      for (let i = 0; i < childRNode.length; i++) {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
      }
    } else {
      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
    }
  }
  _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
}
function getFirstNativeNode(lView, tNode) {
  if (tNode !== null) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 32 | 16 | 128
      /* TNodeType.LetDeclaration */
    );
    const tNodeType = tNode.type;
    if (tNodeType & 3) {
      return getNativeByTNode(tNode, lView);
    } else if (tNodeType & 4) {
      return getBeforeNodeForView(-1, lView[tNode.index]);
    } else if (tNodeType & 8) {
      const elIcuContainerChild = tNode.child;
      if (elIcuContainerChild !== null) {
        return getFirstNativeNode(lView, elIcuContainerChild);
      } else {
        const rNodeOrLContainer = lView[tNode.index];
        if (isLContainer(rNodeOrLContainer)) {
          return getBeforeNodeForView(-1, rNodeOrLContainer);
        } else {
          return unwrapRNode(rNodeOrLContainer);
        }
      }
    } else if (tNodeType & 128) {
      return getFirstNativeNode(lView, tNode.next);
    } else if (tNodeType & 32) {
      let nextRNode = icuContainerIterate(tNode, lView);
      let rNode = nextRNode();
      return rNode || unwrapRNode(lView[tNode.index]);
    } else {
      const projectionNodes = getProjectionNodes(lView, tNode);
      if (projectionNodes !== null) {
        if (Array.isArray(projectionNodes)) {
          return projectionNodes[0];
        }
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        return getFirstNativeNode(parentView, projectionNodes);
      } else {
        return getFirstNativeNode(lView, tNode.next);
      }
    }
  }
  return null;
}
function getProjectionNodes(lView, tNode) {
  if (tNode !== null) {
    const componentView = lView[DECLARATION_COMPONENT_VIEW];
    const componentHost = componentView[T_HOST];
    const slotIdx = tNode.projection;
    ngDevMode && assertProjectionSlots(lView);
    return componentHost.projection[slotIdx];
  }
  return null;
}
function getBeforeNodeForView(viewIndexInContainer, lContainer) {
  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
  if (nextViewIndex < lContainer.length) {
    const lView = lContainer[nextViewIndex];
    const firstTNodeOfView = lView[TVIEW].firstChild;
    if (firstTNodeOfView !== null) {
      return getFirstNativeNode(lView, firstTNodeOfView);
    }
  }
  return lContainer[NATIVE];
}
function nativeRemoveNode(renderer, rNode, isHostElement) {
  ngDevMode && ngDevMode.rendererRemoveNode++;
  renderer.removeChild(null, rNode, isHostElement);
}
function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
  while (tNode != null) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    if (tNode.type === 128) {
      tNode = tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const rawSlotValue = lView[tNode.index];
    const tNodeType = tNode.type;
    if (isProjection) {
      if (action === 0) {
        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
        tNode.flags |= 2;
      }
    }
    if ((tNode.flags & 32) !== 32) {
      if (tNodeType & 8) {
        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
        }
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      } else if (tNodeType & 16) {
        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
      } else {
        ngDevMode && assertTNodeType(
          tNode,
          3 | 4
          /* TNodeType.Container */
        );
        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
}
function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
}
function applyProjection(tView, lView, tProjectionNode) {
  const renderer = lView[RENDERER];
  const parentRNode = getParentRElement(tView, tProjectionNode, lView);
  const parentTNode = tProjectionNode.parent || lView[T_HOST];
  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
}
function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
  const componentLView = lView[DECLARATION_COMPONENT_VIEW];
  const componentNode = componentLView[T_HOST];
  ngDevMode && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
  if (Array.isArray(nodeToProjectOrRNodes)) {
    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
      const rNode = nodeToProjectOrRNodes[i];
      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
    }
  } else {
    let nodeToProject = nodeToProjectOrRNodes;
    const projectedComponentLView = componentLView[PARENT];
    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {
      nodeToProject.flags |= 128;
    }
    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
  }
}
function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
  ngDevMode && assertLContainer(lContainer);
  const anchor = lContainer[NATIVE];
  const native = unwrapRNode(lContainer);
  if (anchor !== native) {
    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
  }
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lView = lContainer[i];
    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
  }
}
function applyStyling(renderer, isClassBased, rNode, prop, value2) {
  if (isClassBased) {
    if (!value2) {
      ngDevMode && ngDevMode.rendererRemoveClass++;
      renderer.removeClass(rNode, prop);
    } else {
      ngDevMode && ngDevMode.rendererAddClass++;
      renderer.addClass(rNode, prop);
    }
  } else {
    let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value2 == null) {
      ngDevMode && ngDevMode.rendererRemoveStyle++;
      renderer.removeStyle(rNode, prop, flags);
    } else {
      const isImportant = typeof value2 === "string" ? value2.endsWith("!important") : false;
      if (isImportant) {
        value2 = value2.slice(0, -10);
        flags |= RendererStyleFlags2.Important;
      }
      ngDevMode && ngDevMode.rendererSetStyle++;
      renderer.setStyle(rNode, prop, value2, flags);
    }
  }
}
function writeDirectStyle(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  renderer.setAttribute(element, "style", newValue);
  ngDevMode && ngDevMode.rendererSetStyle++;
}
function writeDirectClass(renderer, element, newValue) {
  ngDevMode && assertString(newValue, "'newValue' should be a string");
  if (newValue === "") {
    renderer.removeAttribute(element, "class");
  } else {
    renderer.setAttribute(element, "class", newValue);
  }
  ngDevMode && ngDevMode.rendererSetClassName++;
}
function setupStaticAttributes(renderer, element, tNode) {
  const {
    mergedAttrs,
    classes,
    styles: styles2
  } = tNode;
  if (mergedAttrs !== null) {
    setUpAttributes(renderer, element, mergedAttrs);
  }
  if (classes !== null) {
    writeDirectClass(renderer, element, classes);
  }
  if (styles2 !== null) {
    writeDirectStyle(renderer, element, styles2);
  }
}
function classIndexOf(className, classToSearch, startingIndex) {
  ngDevMode && assertNotEqual(classToSearch, "", 'can not look for "" string.');
  let end2 = className.length;
  while (true) {
    const foundIndex = className.indexOf(classToSearch, startingIndex);
    if (foundIndex === -1) return foundIndex;
    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
      const length = classToSearch.length;
      if (foundIndex + length === end2 || className.charCodeAt(foundIndex + length) <= 32) {
        return foundIndex;
      }
    }
    startingIndex = foundIndex + 1;
  }
}
var NG_TEMPLATE_SELECTOR = "ng-template";
function isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {
  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
  let i = 0;
  if (isProjectionMode) {
    for (; i < attrs.length && typeof attrs[i] === "string"; i += 2) {
      if (attrs[i] === "class" && classIndexOf(attrs[i + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {
        return true;
      }
    }
  } else if (isInlineTemplate(tNode)) {
    return false;
  }
  i = attrs.indexOf(1, i);
  if (i > -1) {
    let item;
    while (++i < attrs.length && typeof (item = attrs[i]) === "string") {
      if (item.toLowerCase() === cssClassToMatch) {
        return true;
      }
    }
  }
  return false;
}
function isInlineTemplate(tNode) {
  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
}
function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
  return currentSelector === tagNameToCompare;
}
function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
  ngDevMode && assertDefined(selector[0], "Selector should have a tag name");
  let mode = 4;
  const nodeAttrs = tNode.attrs;
  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;
  let skipToNextSelector = false;
  for (let i = 0; i < selector.length; i++) {
    const current = selector[i];
    if (typeof current === "number") {
      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
        return false;
      }
      if (skipToNextSelector && isPositive(current)) continue;
      skipToNextSelector = false;
      mode = current | mode & 1;
      continue;
    }
    if (skipToNextSelector) continue;
    if (mode & 4) {
      mode = 2 | mode & 1;
      if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
      }
    } else if (mode & 8) {
      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
      }
    } else {
      const selectorAttrValue = selector[++i];
      const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
      if (attrIndexInNode === -1) {
        if (isPositive(mode)) return false;
        skipToNextSelector = true;
        continue;
      }
      if (selectorAttrValue !== "") {
        let nodeAttrValue;
        if (attrIndexInNode > nameOnlyMarkerIdx) {
          nodeAttrValue = "";
        } else {
          ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, "We do not match directives on namespaced attributes");
          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
        }
        if (mode & 2 && selectorAttrValue !== nodeAttrValue) {
          if (isPositive(mode)) return false;
          skipToNextSelector = true;
        }
      }
    }
  }
  return isPositive(mode) || skipToNextSelector;
}
function isPositive(mode) {
  return (mode & 1) === 0;
}
function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
  if (attrs === null) return -1;
  let i = 0;
  if (isProjectionMode || !isInlineTemplate2) {
    let bindingsMode = false;
    while (i < attrs.length) {
      const maybeAttrName = attrs[i];
      if (maybeAttrName === name) {
        return i;
      } else if (maybeAttrName === 3 || maybeAttrName === 6) {
        bindingsMode = true;
      } else if (maybeAttrName === 1 || maybeAttrName === 2) {
        let value2 = attrs[++i];
        while (typeof value2 === "string") {
          value2 = attrs[++i];
        }
        continue;
      } else if (maybeAttrName === 4) {
        break;
      } else if (maybeAttrName === 0) {
        i += 4;
        continue;
      }
      i += bindingsMode ? 1 : 2;
    }
    return -1;
  } else {
    return matchTemplateAttribute(attrs, name);
  }
}
function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
  for (let i = 0; i < selector.length; i++) {
    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
      return true;
    }
  }
  return false;
}
function getProjectAsAttrValue(tNode) {
  const nodeAttrs = tNode.attrs;
  if (nodeAttrs != null) {
    const ngProjectAsAttrIdx = nodeAttrs.indexOf(
      5
      /* AttributeMarker.ProjectAs */
    );
    if ((ngProjectAsAttrIdx & 1) === 0) {
      return nodeAttrs[ngProjectAsAttrIdx + 1];
    }
  }
  return null;
}
function getNameOnlyMarkerIndex(nodeAttrs) {
  for (let i = 0; i < nodeAttrs.length; i++) {
    const nodeAttr = nodeAttrs[i];
    if (isNameOnlyAttributeMarker(nodeAttr)) {
      return i;
    }
  }
  return nodeAttrs.length;
}
function matchTemplateAttribute(attrs, name) {
  let i = attrs.indexOf(
    4
    /* AttributeMarker.Template */
  );
  if (i > -1) {
    i++;
    while (i < attrs.length) {
      const attr = attrs[i];
      if (typeof attr === "number") return -1;
      if (attr === name) return i;
      i++;
    }
  }
  return -1;
}
function isSelectorInSelectorList(selector, list) {
  selectorListLoop: for (let i = 0; i < list.length; i++) {
    const currentSelectorInList = list[i];
    if (selector.length !== currentSelectorInList.length) {
      continue;
    }
    for (let j = 0; j < selector.length; j++) {
      if (selector[j] !== currentSelectorInList[j]) {
        continue selectorListLoop;
      }
    }
    return true;
  }
  return false;
}
function maybeWrapInNotSelector(isNegativeMode, chunk) {
  return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
}
function stringifyCSSSelector(selector) {
  let result = selector[0];
  let i = 1;
  let mode = 2;
  let currentChunk = "";
  let isNegativeMode = false;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode & 2) {
        const attrValue = selector[++i];
        currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
      } else if (mode & 8) {
        currentChunk += "." + valueOrMarker;
      } else if (mode & 4) {
        currentChunk += " " + valueOrMarker;
      }
    } else {
      if (currentChunk !== "" && !isPositive(valueOrMarker)) {
        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
        currentChunk = "";
      }
      mode = valueOrMarker;
      isNegativeMode = isNegativeMode || !isPositive(mode);
    }
    i++;
  }
  if (currentChunk !== "") {
    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
  }
  return result;
}
function stringifyCSSSelectorList(selectorList) {
  return selectorList.map(stringifyCSSSelector).join(",");
}
function extractAttrsAndClassesFromSelector(selector) {
  const attrs = [];
  const classes = [];
  let i = 1;
  let mode = 2;
  while (i < selector.length) {
    let valueOrMarker = selector[i];
    if (typeof valueOrMarker === "string") {
      if (mode === 2) {
        if (valueOrMarker !== "") {
          attrs.push(valueOrMarker, selector[++i]);
        }
      } else if (mode === 8) {
        classes.push(valueOrMarker);
      }
    } else {
      if (!isPositive(mode)) break;
      mode = valueOrMarker;
    }
    i++;
  }
  return {
    attrs,
    classes
  };
}
var NO_CHANGE = typeof ngDevMode === "undefined" || ngDevMode ? {
  __brand__: "NO_CHANGE"
} : {};
function \u0275\u0275advance(delta = 1) {
  ngDevMode && assertGreaterThan(delta, 0, "Can only advance forward");
  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());
}
function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
  ngDevMode && assertIndexInDeclRange(lView[TVIEW], index);
  if (!checkNoChangesMode) {
    const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
    if (hooksInitPhaseCompleted) {
      const preOrderCheckHooks = tView.preOrderCheckHooks;
      if (preOrderCheckHooks !== null) {
        executeCheckHooks(lView, preOrderCheckHooks, index);
      }
    } else {
      const preOrderHooks = tView.preOrderHooks;
      if (preOrderHooks !== null) {
        executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
      }
    }
  }
  setSelectedIndex(index);
}
function \u0275\u0275directiveInject(token, flags = InjectFlags.Default) {
  const lView = getLView();
  if (lView === null) {
    ngDevMode && assertInjectImplementationNotEqual(\u0275\u0275directiveInject);
    return \u0275\u0275inject(token, flags);
  }
  const tNode = getCurrentTNode();
  const value2 = getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
  ngDevMode && emitInjectEvent(token, value2, flags);
  return value2;
}
function \u0275\u0275invalidFactory() {
  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : "invalid";
  throw new Error(msg);
}
function writeToDirectiveInput(def, instance, publicName, privateName, flags, value2) {
  const prevConsumer = setActiveConsumer(null);
  try {
    let inputSignalNode = null;
    if ((flags & InputFlags.SignalBased) !== 0) {
      const field = instance[privateName];
      inputSignalNode = field[SIGNAL];
    }
    if (inputSignalNode !== null && inputSignalNode.transformFn !== void 0) {
      value2 = inputSignalNode.transformFn(value2);
    }
    if ((flags & InputFlags.HasDecoratorInputTransform) !== 0) {
      value2 = def.inputTransforms[privateName].call(instance, value2);
    }
    if (def.setInput !== null) {
      def.setInput(instance, inputSignalNode, value2, publicName, privateName);
    } else {
      applyValueToInputField(instance, inputSignalNode, privateName, value2);
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function processHostBindingOpCodes(tView, lView) {
  const hostBindingOpCodes = tView.hostBindingOpCodes;
  if (hostBindingOpCodes === null) return;
  try {
    for (let i = 0; i < hostBindingOpCodes.length; i++) {
      const opCode = hostBindingOpCodes[i];
      if (opCode < 0) {
        setSelectedIndex(~opCode);
      } else {
        const directiveIdx = opCode;
        const bindingRootIndx = hostBindingOpCodes[++i];
        const hostBindingFn = hostBindingOpCodes[++i];
        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
        const context2 = lView[directiveIdx];
        hostBindingFn(2, context2);
      }
    }
  } finally {
    setSelectedIndex(-1);
  }
}
function createLView(parentLView, tView, context2, flags, host, tHostNode, environment2, renderer, injector, embeddedViewInjector, hydrationInfo) {
  const lView = tView.blueprint.slice();
  lView[HOST] = host;
  lView[FLAGS] = flags | 4 | 128 | 8 | 64 | 1024;
  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048) {
    lView[FLAGS] |= 2048;
  }
  resetPreOrderHookFlags(lView);
  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
  lView[CONTEXT] = context2;
  lView[ENVIRONMENT] = environment2 || parentLView && parentLView[ENVIRONMENT];
  ngDevMode && assertDefined(lView[ENVIRONMENT], "LViewEnvironment is required");
  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
  ngDevMode && assertDefined(lView[RENDERER], "Renderer is required");
  lView[INJECTOR] = injector || parentLView && parentLView[INJECTOR] || null;
  lView[T_HOST] = tHostNode;
  lView[ID] = getUniqueLViewId();
  lView[HYDRATION] = hydrationInfo;
  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;
  ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
  return lView;
}
function getOrCreateTNode(tView, index, type2, name, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertPureTNodeType(type2);
  let tNode = tView.data[index];
  if (tNode === null) {
    tNode = createTNodeAtIndex(tView, index, type2, name, attrs);
    if (isInI18nBlock()) {
      tNode.flags |= 32;
    }
  } else if (tNode.type & 64) {
    tNode.type = type2;
    tNode.value = name;
    tNode.attrs = attrs;
    const parent = getCurrentParentTNode();
    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
    ngDevMode && assertTNodeForTView(tNode, tView);
    ngDevMode && assertEqual(index, tNode.index, "Expecting same index");
  }
  setCurrentTNode(tNode, true);
  return tNode;
}
function createTNodeAtIndex(tView, index, type2, name, attrs) {
  const currentTNode = getCurrentTNodePlaceholderOk();
  const isParent = isCurrentTNodeParent();
  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
  const tNode = tView.data[index] = createTNode(tView, parent, type2, index, name, attrs);
  if (tView.firstChild === null) {
    tView.firstChild = tNode;
  }
  if (currentTNode !== null) {
    if (isParent) {
      if (currentTNode.child == null && tNode.parent !== null) {
        currentTNode.child = tNode;
      }
    } else {
      if (currentTNode.next === null) {
        currentTNode.next = tNode;
        tNode.prev = currentTNode;
      }
    }
  }
  return tNode;
}
function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
  if (numSlotsToAlloc === 0) return -1;
  if (ngDevMode) {
    assertFirstCreatePass(tView);
    assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
    assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
    assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
    assertFirstUpdatePass(tView);
  }
  const allocIdx = lView.length;
  for (let i = 0; i < numSlotsToAlloc; i++) {
    lView.push(initialValue);
    tView.blueprint.push(initialValue);
    tView.data.push(null);
  }
  return allocIdx;
}
function executeTemplate(tView, lView, templateFn, rf, context2) {
  const prevSelectedIndex = getSelectedIndex();
  const isUpdatePhase = rf & 2;
  try {
    setSelectedIndex(-1);
    if (isUpdatePhase && lView.length > HEADER_OFFSET) {
      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());
    }
    const preHookType = isUpdatePhase ? 2 : 0;
    profiler(preHookType, context2);
    templateFn(rf, context2);
  } finally {
    setSelectedIndex(prevSelectedIndex);
    const postHookType = isUpdatePhase ? 3 : 1;
    profiler(postHookType, context2);
  }
}
function executeContentQueries(tView, tNode, lView) {
  if (isContentQueryHost(tNode)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const start2 = tNode.directiveStart;
      const end2 = tNode.directiveEnd;
      for (let directiveIndex = start2; directiveIndex < end2; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          const directiveInstance = lView[directiveIndex];
          ngDevMode && assertDefined(directiveIndex, "Incorrect reference to a directive defining a content query");
          def.contentQueries(1, directiveInstance, directiveIndex);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function createDirectivesInstances(tView, lView, tNode) {
  if (!getBindingsEnabled()) return;
  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
  if ((tNode.flags & 64) === 64) {
    invokeDirectivesHostBindings(tView, lView, tNode);
  }
}
function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    let localIndex = tNode.index + 1;
    for (let i = 0; i < localNames.length; i += 2) {
      const index = localNames[i + 1];
      const value2 = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
      viewData[localIndex++] = value2;
    }
  }
}
function getOrCreateComponentTView(def) {
  const tView = def.tView;
  if (tView === null || tView.incompleteFirstPass) {
    const declTNode = null;
    return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);
  }
  return tView;
}
function createTView(type2, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {
  ngDevMode && ngDevMode.tView++;
  const bindingStartIndex = HEADER_OFFSET + decls;
  const initialViewLength = bindingStartIndex + vars;
  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
  const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
  const tView = blueprint[TVIEW] = {
    type: type2,
    blueprint,
    template: templateFn,
    queries: null,
    viewQuery,
    declTNode,
    data: blueprint.slice().fill(null, bindingStartIndex),
    bindingStartIndex,
    expandoStartIndex: initialViewLength,
    hostBindingOpCodes: null,
    firstCreatePass: true,
    firstUpdatePass: true,
    staticViewQueries: false,
    staticContentQueries: false,
    preOrderHooks: null,
    preOrderCheckHooks: null,
    contentHooks: null,
    contentCheckHooks: null,
    viewHooks: null,
    viewCheckHooks: null,
    destroyHooks: null,
    cleanup: null,
    contentQueries: null,
    components: null,
    directiveRegistry: typeof directives === "function" ? directives() : directives,
    pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
    firstChild: null,
    schemas,
    consts,
    incompleteFirstPass: false,
    ssrId
  };
  if (ngDevMode) {
    Object.seal(tView);
  }
  return tView;
}
function createViewBlueprint(bindingStartIndex, initialViewLength) {
  const blueprint = [];
  for (let i = 0; i < initialViewLength; i++) {
    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
  }
  return blueprint;
}
function locateHostElement(renderer, elementOrSelector, encapsulation, injector) {
  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);
  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation.ShadowDom;
  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);
  applyRootElementTransform(rootElement);
  return rootElement;
}
function applyRootElementTransform(rootElement) {
  _applyRootElementTransformImpl(rootElement);
}
var _applyRootElementTransformImpl = () => null;
function storeCleanupWithContext(tView, lView, context2, cleanupFn) {
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertDefined(context2, "Cleanup context is mandatory when registering framework-level destroy hooks");
  lCleanup.push(context2);
  if (tView.firstCreatePass) {
    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
  } else {
    if (ngDevMode) {
      Object.freeze(getOrCreateTViewCleanup(tView));
    }
  }
}
function createTNode(tView, tParent, type2, index, value2, attrs) {
  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in
  // `view_engine_compatibility` for additional context.
  assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
  ngDevMode && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'");
  ngDevMode && ngDevMode.tNode++;
  ngDevMode && tParent && assertTNodeForTView(tParent, tView);
  let injectorIndex = tParent ? tParent.injectorIndex : -1;
  let flags = 0;
  if (isInSkipHydrationBlock$1()) {
    flags |= 128;
  }
  const tNode = {
    type: type2,
    index,
    insertBeforeIndex: null,
    injectorIndex,
    directiveStart: -1,
    directiveEnd: -1,
    directiveStylingLast: -1,
    componentOffset: -1,
    propertyBindings: null,
    flags,
    providerIndexes: 0,
    value: value2,
    attrs,
    mergedAttrs: null,
    localNames: null,
    initialInputs: void 0,
    inputs: null,
    outputs: null,
    tView: null,
    next: null,
    prev: null,
    projectionNext: null,
    child: null,
    parent: tParent,
    projection: null,
    styles: null,
    stylesWithoutHost: null,
    residualStyles: void 0,
    classes: null,
    classesWithoutHost: null,
    residualClasses: void 0,
    classBindings: 0,
    styleBindings: 0
  };
  if (ngDevMode) {
    Object.seal(tNode);
  }
  return tNode;
}
function captureNodeBindings(mode, aliasMap, directiveIndex, bindingsResult, hostDirectiveAliasMap) {
  for (let publicName in aliasMap) {
    if (!aliasMap.hasOwnProperty(publicName)) {
      continue;
    }
    const value2 = aliasMap[publicName];
    if (value2 === void 0) {
      continue;
    }
    bindingsResult ??= {};
    let internalName;
    let inputFlags = InputFlags.None;
    if (Array.isArray(value2)) {
      internalName = value2[0];
      inputFlags = value2[1];
    } else {
      internalName = value2;
    }
    let finalPublicName = publicName;
    if (hostDirectiveAliasMap !== null) {
      if (!hostDirectiveAliasMap.hasOwnProperty(publicName)) {
        continue;
      }
      finalPublicName = hostDirectiveAliasMap[publicName];
    }
    if (mode === 0) {
      addPropertyBinding(bindingsResult, directiveIndex, finalPublicName, internalName, inputFlags);
    } else {
      addPropertyBinding(bindingsResult, directiveIndex, finalPublicName, internalName);
    }
  }
  return bindingsResult;
}
function addPropertyBinding(bindings, directiveIndex, publicName, internalName, inputFlags) {
  let values;
  if (bindings.hasOwnProperty(publicName)) {
    (values = bindings[publicName]).push(directiveIndex, internalName);
  } else {
    values = bindings[publicName] = [directiveIndex, internalName];
  }
  if (inputFlags !== void 0) {
    values.push(inputFlags);
  }
}
function initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefinitionMap) {
  ngDevMode && assertFirstCreatePass(tView);
  const start2 = tNode.directiveStart;
  const end2 = tNode.directiveEnd;
  const tViewData = tView.data;
  const tNodeAttrs = tNode.attrs;
  const inputsFromAttrs = [];
  let inputsStore = null;
  let outputsStore = null;
  for (let directiveIndex = start2; directiveIndex < end2; directiveIndex++) {
    const directiveDef = tViewData[directiveIndex];
    const aliasData = hostDirectiveDefinitionMap ? hostDirectiveDefinitionMap.get(directiveDef) : null;
    const aliasedInputs = aliasData ? aliasData.inputs : null;
    const aliasedOutputs = aliasData ? aliasData.outputs : null;
    inputsStore = captureNodeBindings(0, directiveDef.inputs, directiveIndex, inputsStore, aliasedInputs);
    outputsStore = captureNodeBindings(1, directiveDef.outputs, directiveIndex, outputsStore, aliasedOutputs);
    const initialInputs = inputsStore !== null && tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(inputsStore, directiveIndex, tNodeAttrs) : null;
    inputsFromAttrs.push(initialInputs);
  }
  if (inputsStore !== null) {
    if (inputsStore.hasOwnProperty("class")) {
      tNode.flags |= 8;
    }
    if (inputsStore.hasOwnProperty("style")) {
      tNode.flags |= 16;
    }
  }
  tNode.initialInputs = inputsFromAttrs;
  tNode.inputs = inputsStore;
  tNode.outputs = outputsStore;
}
function mapPropName(name) {
  if (name === "class") return "className";
  if (name === "for") return "htmlFor";
  if (name === "formaction") return "formAction";
  if (name === "innerHtml") return "innerHTML";
  if (name === "readonly") return "readOnly";
  if (name === "tabindex") return "tabIndex";
  return name;
}
function elementPropertyInternal(tView, tNode, lView, propName, value2, renderer, sanitizer, nativeOnly) {
  ngDevMode && assertNotSame(value2, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  const element = getNativeByTNode(tNode, lView);
  let inputData = tNode.inputs;
  let dataValue;
  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
    setInputsForProperty(tView, lView, dataValue, propName, value2);
    if (isComponentHost(tNode)) markDirtyIfOnPush(lView, tNode.index);
    if (ngDevMode) {
      setNgReflectProperties(lView, element, tNode.type, dataValue, value2);
    }
  } else if (tNode.type & 3) {
    propName = mapPropName(propName);
    if (ngDevMode) {
      validateAgainstEventProperties(propName);
      if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {
        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
      }
      ngDevMode.rendererSetProperty++;
    }
    value2 = sanitizer != null ? sanitizer(value2, tNode.value || "", propName) : value2;
    renderer.setProperty(element, propName, value2);
  } else if (tNode.type & 12) {
    if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {
      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);
    }
  }
}
function markDirtyIfOnPush(lView, viewIndex) {
  ngDevMode && assertLView(lView);
  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
  if (!(childComponentLView[FLAGS] & 16)) {
    childComponentLView[FLAGS] |= 64;
  }
}
function setNgReflectProperty(lView, element, type2, attrName, value2) {
  const renderer = lView[RENDERER];
  attrName = normalizeDebugBindingName(attrName);
  const debugValue = normalizeDebugBindingValue(value2);
  if (type2 & 3) {
    if (value2 == null) {
      renderer.removeAttribute(element, attrName);
    } else {
      renderer.setAttribute(element, attrName, debugValue);
    }
  } else {
    const textContent = escapeCommentText(`bindings=${JSON.stringify({
      [attrName]: debugValue
    }, null, 2)}`);
    renderer.setValue(element, textContent);
  }
}
function setNgReflectProperties(lView, element, type2, dataValue, value2) {
  if (type2 & (3 | 4)) {
    for (let i = 0; i < dataValue.length; i += 3) {
      setNgReflectProperty(lView, element, type2, dataValue[i + 1], value2);
    }
  }
}
function resolveDirectives(tView, lView, tNode, localRefs) {
  ngDevMode && assertFirstCreatePass(tView);
  if (getBindingsEnabled()) {
    const exportsMap = localRefs === null ? null : {
      "": -1
    };
    const matchResult = findDirectiveDefMatches(tView, tNode);
    let directiveDefs;
    let hostDirectiveDefs;
    if (matchResult === null) {
      directiveDefs = hostDirectiveDefs = null;
    } else {
      [directiveDefs, hostDirectiveDefs] = matchResult;
    }
    if (directiveDefs !== null) {
      initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs);
    }
    if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);
  }
  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
}
function initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs) {
  ngDevMode && assertFirstCreatePass(tView);
  for (let i = 0; i < directives.length; i++) {
    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, directives[i].type);
  }
  initTNodeFlags(tNode, tView.data.length, directives.length);
  for (let i = 0; i < directives.length; i++) {
    const def = directives[i];
    if (def.providersResolver) def.providersResolver(def);
  }
  let preOrderHooksFound = false;
  let preOrderCheckHooksFound = false;
  let directiveIdx = allocExpando(tView, lView, directives.length, null);
  ngDevMode && assertSame(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
  for (let i = 0; i < directives.length; i++) {
    const def = directives[i];
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
    saveNameToExportMap(directiveIdx, def, exportsMap);
    if (def.contentQueries !== null) tNode.flags |= 4;
    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) tNode.flags |= 64;
    const lifeCycleHooks = def.type.prototype;
    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderHooks ??= []).push(tNode.index);
      preOrderHooksFound = true;
    }
    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
      (tView.preOrderCheckHooks ??= []).push(tNode.index);
      preOrderCheckHooksFound = true;
    }
    directiveIdx++;
  }
  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);
}
function registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {
  ngDevMode && assertFirstCreatePass(tView);
  const hostBindings = def.hostBindings;
  if (hostBindings) {
    let hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null) {
      hostBindingOpCodes = tView.hostBindingOpCodes = [];
    }
    const elementIndx = ~tNode.index;
    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
      hostBindingOpCodes.push(elementIndx);
    }
    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
  }
}
function lastSelectedElementIdx(hostBindingOpCodes) {
  let i = hostBindingOpCodes.length;
  while (i > 0) {
    const value2 = hostBindingOpCodes[--i];
    if (typeof value2 === "number" && value2 < 0) {
      return value2;
    }
  }
  return 0;
}
function instantiateAllDirectives(tView, lView, tNode, native) {
  const start2 = tNode.directiveStart;
  const end2 = tNode.directiveEnd;
  if (isComponentHost(tNode)) {
    ngDevMode && assertTNodeType(
      tNode,
      3
      /* TNodeType.AnyRNode */
    );
    addComponentLogic(lView, tNode, tView.data[start2 + tNode.componentOffset]);
  }
  if (!tView.firstCreatePass) {
    getOrCreateNodeInjectorForNode(tNode, lView);
  }
  attachPatchData(native, lView);
  const initialInputs = tNode.initialInputs;
  for (let i = start2; i < end2; i++) {
    const def = tView.data[i];
    const directive = getNodeInjectable(lView, tView, i, tNode);
    attachPatchData(directive, lView);
    if (initialInputs !== null) {
      setInputsFromAttrs(lView, i - start2, directive, def, tNode, initialInputs);
    }
    if (isComponentDef(def)) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);
    }
  }
}
function invokeDirectivesHostBindings(tView, lView, tNode) {
  const start2 = tNode.directiveStart;
  const end2 = tNode.directiveEnd;
  const elementIndex = tNode.index;
  const currentDirectiveIndex = getCurrentDirectiveIndex();
  try {
    setSelectedIndex(elementIndex);
    for (let dirIndex = start2; dirIndex < end2; dirIndex++) {
      const def = tView.data[dirIndex];
      const directive = lView[dirIndex];
      setCurrentDirectiveIndex(dirIndex);
      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
        invokeHostBindingsInCreationMode(def, directive);
      }
    }
  } finally {
    setSelectedIndex(-1);
    setCurrentDirectiveIndex(currentDirectiveIndex);
  }
}
function invokeHostBindingsInCreationMode(def, directive) {
  if (def.hostBindings !== null) {
    def.hostBindings(1, directive);
  }
}
function findDirectiveDefMatches(tView, tNode) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  const registry = tView.directiveRegistry;
  let matches = null;
  let hostDirectiveDefs = null;
  if (registry) {
    for (let i = 0; i < registry.length; i++) {
      const def = registry[i];
      if (isNodeMatchingSelectorList(
        tNode,
        def.selectors,
        /* isProjectionMode */
        false
      )) {
        matches || (matches = []);
        if (isComponentDef(def)) {
          if (ngDevMode) {
            assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);
            if (isComponentHost(tNode)) {
              throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);
            }
          }
          if (def.findHostDirectiveDefs !== null) {
            const hostDirectiveMatches = [];
            hostDirectiveDefs = hostDirectiveDefs || /* @__PURE__ */ new Map();
            def.findHostDirectiveDefs(def, hostDirectiveMatches, hostDirectiveDefs);
            matches.unshift(...hostDirectiveMatches, def);
            const componentOffset = hostDirectiveMatches.length;
            markAsComponentHost(tView, tNode, componentOffset);
          } else {
            matches.unshift(def);
            markAsComponentHost(tView, tNode, 0);
          }
        } else {
          hostDirectiveDefs = hostDirectiveDefs || /* @__PURE__ */ new Map();
          def.findHostDirectiveDefs?.(def, matches, hostDirectiveDefs);
          matches.push(def);
        }
      }
    }
  }
  ngDevMode && matches !== null && assertNoDuplicateDirectives(matches);
  return matches === null ? null : [matches, hostDirectiveDefs];
}
function markAsComponentHost(tView, hostTNode, componentOffset) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && assertGreaterThan(componentOffset, -1, "componentOffset must be great than -1");
  hostTNode.componentOffset = componentOffset;
  (tView.components ??= []).push(hostTNode.index);
}
function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
  if (localRefs) {
    const localNames = tNode.localNames = [];
    for (let i = 0; i < localRefs.length; i += 2) {
      const index = exportsMap[localRefs[i + 1]];
      if (index == null) throw new RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);
      localNames.push(localRefs[i], index);
    }
  }
}
function saveNameToExportMap(directiveIdx, def, exportsMap) {
  if (exportsMap) {
    if (def.exportAs) {
      for (let i = 0; i < def.exportAs.length; i++) {
        exportsMap[def.exportAs[i]] = directiveIdx;
      }
    }
    if (isComponentDef(def)) exportsMap[""] = directiveIdx;
  }
}
function initTNodeFlags(tNode, index, numberOfDirectives) {
  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
  tNode.flags |= 1;
  tNode.directiveStart = index;
  tNode.directiveEnd = index + numberOfDirectives;
  tNode.providerIndexes = index;
}
function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, "Must be in Expando section");
  tView.data[directiveIndex] = def;
  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), \u0275\u0275directiveInject);
  tView.blueprint[directiveIndex] = nodeInjectorFactory;
  lView[directiveIndex] = nodeInjectorFactory;
  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
}
function getInitialLViewFlagsFromDef(def) {
  let flags = 16;
  if (def.signals) {
    flags = 4096;
  } else if (def.onPush) {
    flags = 64;
  }
  return flags;
}
function addComponentLogic(lView, hostTNode, def) {
  const native = getNativeByTNode(hostTNode, lView);
  const tView = getOrCreateComponentTView(def);
  const rendererFactory = lView[ENVIRONMENT].rendererFactory;
  const componentView = addToEndOfViewTree(lView, createLView(lView, tView, null, getInitialLViewFlagsFromDef(def), native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));
  lView[hostTNode.index] = componentView;
}
function elementAttributeInternal(tNode, lView, name, value2, sanitizer, namespace2) {
  if (ngDevMode) {
    assertNotSame(value2, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    validateAgainstEventAttributes(name);
    assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
  }
  const element = getNativeByTNode(tNode, lView);
  setElementAttribute(lView[RENDERER], element, namespace2, tNode.value, name, value2, sanitizer);
}
function setElementAttribute(renderer, element, namespace2, tagName, name, value2, sanitizer) {
  if (value2 == null) {
    ngDevMode && ngDevMode.rendererRemoveAttribute++;
    renderer.removeAttribute(element, name, namespace2);
  } else {
    ngDevMode && ngDevMode.rendererSetAttribute++;
    const strValue = sanitizer == null ? renderStringify(value2) : sanitizer(value2, tagName || "", name);
    renderer.setAttribute(element, name, strValue, namespace2);
  }
}
function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
  const initialInputs = initialInputData[directiveIndex];
  if (initialInputs !== null) {
    for (let i = 0; i < initialInputs.length; ) {
      const publicName = initialInputs[i++];
      const privateName = initialInputs[i++];
      const flags = initialInputs[i++];
      const value2 = initialInputs[i++];
      writeToDirectiveInput(def, instance, publicName, privateName, flags, value2);
      if (ngDevMode) {
        const nativeElement = getNativeByTNode(tNode, lView);
        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value2);
      }
    }
  }
}
function generateInitialInputs(inputs, directiveIndex, attrs) {
  let inputsToStore = null;
  let i = 0;
  while (i < attrs.length) {
    const attrName = attrs[i];
    if (attrName === 0) {
      i += 4;
      continue;
    } else if (attrName === 5) {
      i += 2;
      continue;
    }
    if (typeof attrName === "number") break;
    if (inputs.hasOwnProperty(attrName)) {
      if (inputsToStore === null) inputsToStore = [];
      const inputConfig = inputs[attrName];
      for (let j = 0; j < inputConfig.length; j += 3) {
        if (inputConfig[j] === directiveIndex) {
          inputsToStore.push(attrName, inputConfig[j + 1], inputConfig[j + 2], attrs[i + 1]);
          break;
        }
      }
    }
    i += 2;
  }
  return inputsToStore;
}
function createLContainer(hostNative, currentView, native, tNode) {
  ngDevMode && assertLView(currentView);
  const lContainer = [
    hostNative,
    // host native
    true,
    // Boolean `true` in this position signifies that this is an `LContainer`
    0,
    // flags
    currentView,
    // parent
    null,
    // next
    tNode,
    // t_host
    null,
    // dehydrated views
    native,
    // native,
    null,
    // view refs
    null
    // moved views
  ];
  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
  return lContainer;
}
function refreshContentQueries(tView, lView) {
  const contentQueries = tView.contentQueries;
  if (contentQueries !== null) {
    const prevConsumer = setActiveConsumer(null);
    try {
      for (let i = 0; i < contentQueries.length; i += 2) {
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && assertDefined(directiveDef, "DirectiveDef not found.");
          ngDevMode && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined");
          setCurrentQueryIndex(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function addToEndOfViewTree(lView, lViewOrLContainer) {
  if (lView[CHILD_HEAD]) {
    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
  } else {
    lView[CHILD_HEAD] = lViewOrLContainer;
  }
  lView[CHILD_TAIL] = lViewOrLContainer;
  return lViewOrLContainer;
}
function executeViewQueryFn(flags, viewQueryFn, component) {
  ngDevMode && assertDefined(viewQueryFn, "View queries function to execute must be defined.");
  setCurrentQueryIndex(0);
  const prevConsumer = setActiveConsumer(null);
  try {
    viewQueryFn(flags, component);
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
  if (tData[bindingIndex] === null) {
    if (tNode.inputs == null || !tNode.inputs[propertyName]) {
      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
      propBindingIdxs.push(bindingIndex);
      let bindingMetadata = propertyName;
      if (interpolationParts.length > 0) {
        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
      }
      tData[bindingIndex] = bindingMetadata;
    }
  }
}
function getOrCreateLViewCleanup(view) {
  return view[CLEANUP] ??= [];
}
function getOrCreateTViewCleanup(tView) {
  return tView.cleanup ??= [];
}
function loadComponentRenderer(currentDef, tNode, lView) {
  if (currentDef === null || isComponentDef(currentDef)) {
    lView = unwrapLView(lView[tNode.index]);
  }
  return lView[RENDERER];
}
function handleError(lView, error) {
  const injector = lView[INJECTOR];
  const errorHandler2 = injector ? injector.get(ErrorHandler, null) : null;
  errorHandler2 && errorHandler2.handleError(error);
}
function setInputsForProperty(tView, lView, inputs, publicName, value2) {
  for (let i = 0; i < inputs.length; ) {
    const index = inputs[i++];
    const privateName = inputs[i++];
    const flags = inputs[i++];
    const instance = lView[index];
    ngDevMode && assertIndexInRange(lView, index);
    const def = tView.data[index];
    writeToDirectiveInput(def, instance, publicName, privateName, flags, value2);
  }
}
function textBindingInternal(lView, index, value2) {
  ngDevMode && assertString(value2, "Value should be a string");
  ngDevMode && assertNotSame(value2, NO_CHANGE, "value should not be NO_CHANGE");
  ngDevMode && assertIndexInRange(lView, index);
  const element = getNativeByIndex(index, lView);
  ngDevMode && assertDefined(element, "native element should exist");
  updateTextNode(lView[RENDERER], element, value2);
}
function renderComponent(hostLView, componentHostIdx) {
  ngDevMode && assertEqual(isCreationMode(hostLView), true, "Should be run in creation mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  const componentTView = componentView[TVIEW];
  syncViewWithBlueprint(componentTView, componentView);
  const hostRNode = componentView[HOST];
  if (hostRNode !== null && componentView[HYDRATION] === null) {
    componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR]);
  }
  renderView(componentTView, componentView, componentView[CONTEXT]);
}
function syncViewWithBlueprint(tView, lView) {
  for (let i = lView.length; i < tView.blueprint.length; i++) {
    lView.push(tView.blueprint[i]);
  }
}
function renderView(tView, lView, context2) {
  ngDevMode && assertEqual(isCreationMode(lView), true, "Should be run in creation mode");
  ngDevMode && assertNotReactive(renderView.name);
  enterView(lView);
  try {
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(1, viewQuery, context2);
    }
    const templateFn = tView.template;
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 1, context2);
    }
    if (tView.firstCreatePass) {
      tView.firstCreatePass = false;
    }
    lView[QUERIES]?.finishViewCreation(tView);
    if (tView.staticContentQueries) {
      refreshContentQueries(tView, lView);
    }
    if (tView.staticViewQueries) {
      executeViewQueryFn(2, tView.viewQuery, context2);
    }
    const components = tView.components;
    if (components !== null) {
      renderChildComponents(lView, components);
    }
  } catch (error) {
    if (tView.firstCreatePass) {
      tView.incompleteFirstPass = true;
      tView.firstCreatePass = false;
    }
    throw error;
  } finally {
    lView[FLAGS] &= ~4;
    leaveView();
  }
}
function renderChildComponents(hostLView, components) {
  for (let i = 0; i < components.length; i++) {
    renderComponent(hostLView, components[i]);
  }
}
function createAndRenderEmbeddedLView(declarationLView, templateTNode, context2, options) {
  const prevConsumer = setActiveConsumer(null);
  try {
    const embeddedTView = templateTNode.tView;
    ngDevMode && assertDefined(embeddedTView, "TView must be defined for a template node.");
    ngDevMode && assertTNodeForLView(templateTNode, declarationLView);
    const isSignalView = declarationLView[FLAGS] & 4096;
    const viewFlags = isSignalView ? 4096 : 16;
    const embeddedLView = createLView(declarationLView, embeddedTView, context2, viewFlags, null, templateTNode, null, null, options?.injector ?? null, options?.embeddedViewInjector ?? null, options?.dehydratedView ?? null);
    const declarationLContainer = declarationLView[templateTNode.index];
    ngDevMode && assertLContainer(declarationLContainer);
    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
    const declarationViewLQueries = declarationLView[QUERIES];
    if (declarationViewLQueries !== null) {
      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
    }
    renderView(embeddedTView, embeddedLView, context2);
    return embeddedLView;
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function getLViewFromLContainer(lContainer, index) {
  const adjustedIndex = CONTAINER_HEADER_OFFSET + index;
  if (adjustedIndex < lContainer.length) {
    const lView = lContainer[adjustedIndex];
    ngDevMode && assertLView(lView);
    return lView;
  }
  return void 0;
}
function shouldAddViewToDom(tNode, dehydratedView) {
  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);
}
function addLViewToLContainer(lContainer, lView, index, addToDOM = true) {
  const tView = lView[TVIEW];
  insertView(tView, lView, lContainer, index);
  if (addToDOM) {
    const beforeNode = getBeforeNodeForView(index, lContainer);
    const renderer = lView[RENDERER];
    const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
    if (parentRNode !== null) {
      addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
    }
  }
  const hydrationInfo = lView[HYDRATION];
  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {
    hydrationInfo.firstChild = null;
  }
}
function removeLViewFromLContainer(lContainer, index) {
  const lView = detachView(lContainer, index);
  if (lView !== void 0) {
    destroyLView(lView[TVIEW], lView);
  }
  return lView;
}
function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
  while (tNode !== null) {
    if (tNode.type === 128) {
      tNode = isProjection ? tNode.projectionNext : tNode.next;
      continue;
    }
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12 | 16 | 32
      /* TNodeType.Icu */
    );
    const lNode = lView[tNode.index];
    if (lNode !== null) {
      result.push(unwrapRNode(lNode));
    }
    if (isLContainer(lNode)) {
      collectNativeNodesInLContainer(lNode, result);
    }
    const tNodeType = tNode.type;
    if (tNodeType & 8) {
      collectNativeNodes(tView, lView, tNode.child, result);
    } else if (tNodeType & 32) {
      const nextRNode = icuContainerIterate(tNode, lView);
      let rNode;
      while (rNode = nextRNode()) {
        result.push(rNode);
      }
    } else if (tNodeType & 16) {
      const nodesInSlot = getProjectionNodes(lView, tNode);
      if (Array.isArray(nodesInSlot)) {
        result.push(...nodesInSlot);
      } else {
        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
        ngDevMode && assertParentView(parentView);
        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
      }
    }
    tNode = isProjection ? tNode.projectionNext : tNode.next;
  }
  return result;
}
function collectNativeNodesInLContainer(lContainer, result) {
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    const lViewInAContainer = lContainer[i];
    const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
    if (lViewFirstChildTNode !== null) {
      collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
    }
  }
  if (lContainer[NATIVE] !== lContainer[HOST]) {
    result.push(lContainer[NATIVE]);
  }
}
var freeConsumers = [];
function getOrBorrowReactiveLViewConsumer(lView) {
  return lView[REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);
}
function borrowReactiveLViewConsumer(lView) {
  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
function maybeReturnReactiveLViewConsumer(consumer) {
  if (consumer.lView[REACTIVE_TEMPLATE_CONSUMER] === consumer) {
    return;
  }
  consumer.lView = null;
  freeConsumers.push(consumer);
}
var REACTIVE_LVIEW_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
  consumerIsAlwaysLive: true,
  consumerMarkedDirty: (node) => {
    markAncestorsForTraversal(node.lView);
  },
  consumerOnSignalRead() {
    this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
  }
});
function getOrCreateTemporaryConsumer(lView) {
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER] ?? Object.create(TEMPORARY_CONSUMER_NODE);
  consumer.lView = lView;
  return consumer;
}
var TEMPORARY_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {
  consumerIsAlwaysLive: true,
  consumerMarkedDirty: (node) => {
    let parent = getLViewParent(node.lView);
    while (parent && !viewShouldHaveReactiveConsumer(parent[TVIEW])) {
      parent = getLViewParent(parent);
    }
    if (!parent) {
      return;
    }
    markViewForRefresh(parent);
  },
  consumerOnSignalRead() {
    this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;
  }
});
function viewShouldHaveReactiveConsumer(tView) {
  return tView.type !== 2;
}
function runEffectsInView(view) {
  if (view[EFFECTS] === null) {
    return;
  }
  let tryFlushEffects = true;
  while (tryFlushEffects) {
    let foundDirtyEffect = false;
    for (const effect of view[EFFECTS]) {
      if (!effect.dirty) {
        continue;
      }
      foundDirtyEffect = true;
      if (effect.zone === null || Zone.current === effect.zone) {
        effect.run();
      } else {
        effect.zone.run(() => effect.run());
      }
    }
    tryFlushEffects = foundDirtyEffect && !!(view[FLAGS] & 8192);
  }
}
var MAXIMUM_REFRESH_RERUNS$1 = 100;
function detectChangesInternal(lView, notifyErrorHandler = true, mode = 0) {
  const environment2 = lView[ENVIRONMENT];
  const rendererFactory = environment2.rendererFactory;
  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();
  if (!checkNoChangesMode) {
    rendererFactory.begin?.();
  }
  try {
    detectChangesInViewWhileDirty(lView, mode);
  } catch (error) {
    if (notifyErrorHandler) {
      handleError(lView, error);
    }
    throw error;
  } finally {
    if (!checkNoChangesMode) {
      rendererFactory.end?.();
    }
  }
}
function detectChangesInViewWhileDirty(lView, mode) {
  const lastIsRefreshingViewsValue = isRefreshingViews();
  try {
    setIsRefreshingViews(true);
    detectChangesInView(lView, mode);
    if (ngDevMode && isExhaustiveCheckNoChanges()) {
      return;
    }
    let retries = 0;
    while (requiresRefreshOrTraversal(lView)) {
      if (retries === MAXIMUM_REFRESH_RERUNS$1) {
        throw new RuntimeError(103, ngDevMode && "Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.");
      }
      retries++;
      detectChangesInView(
        lView,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  } finally {
    setIsRefreshingViews(lastIsRefreshingViewsValue);
  }
}
function checkNoChangesInternal(lView, mode, notifyErrorHandler = true) {
  setIsInCheckNoChangesMode(mode);
  try {
    detectChangesInternal(lView, notifyErrorHandler);
  } finally {
    setIsInCheckNoChangesMode(CheckNoChangesMode.Off);
  }
}
function refreshView(tView, lView, templateFn, context2) {
  ngDevMode && assertEqual(isCreationMode(lView), false, "Should be run in update mode");
  const flags = lView[FLAGS];
  if ((flags & 256) === 256) return;
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const isInExhaustiveCheckNoChangesPass = ngDevMode && isExhaustiveCheckNoChanges();
  enterView(lView);
  let returnConsumerToPool = true;
  let prevConsumer = null;
  let currentConsumer = null;
  if (!isInCheckNoChangesPass) {
    if (viewShouldHaveReactiveConsumer(tView)) {
      currentConsumer = getOrBorrowReactiveLViewConsumer(lView);
      prevConsumer = consumerBeforeComputation(currentConsumer);
    } else if (getActiveConsumer() === null) {
      returnConsumerToPool = false;
      currentConsumer = getOrCreateTemporaryConsumer(lView);
      prevConsumer = consumerBeforeComputation(currentConsumer);
    } else if (lView[REACTIVE_TEMPLATE_CONSUMER]) {
      consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);
      lView[REACTIVE_TEMPLATE_CONSUMER] = null;
    }
  }
  try {
    resetPreOrderHookFlags(lView);
    setBindingIndex(tView.bindingStartIndex);
    if (templateFn !== null) {
      executeTemplate(tView, lView, templateFn, 2, context2);
    }
    const hooksInitPhaseCompleted = (flags & 3) === 3;
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, null);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
        }
        incrementInitPhaseFlags(
          lView,
          0
          /* InitPhaseState.OnInitHooksToBeRun */
        );
      }
    }
    if (!isInExhaustiveCheckNoChangesPass) {
      markTransplantedViewsForRefresh(lView);
    }
    runEffectsInView(lView);
    detectChangesInEmbeddedViews(
      lView,
      0
      /* ChangeDetectionMode.Global */
    );
    if (tView.contentQueries !== null) {
      refreshContentQueries(tView, lView);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const contentCheckHooks = tView.contentCheckHooks;
        if (contentCheckHooks !== null) {
          executeCheckHooks(lView, contentCheckHooks);
        }
      } else {
        const contentHooks = tView.contentHooks;
        if (contentHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            contentHooks,
            1
            /* InitPhaseState.AfterContentInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          1
          /* InitPhaseState.AfterContentInitHooksToBeRun */
        );
      }
    }
    processHostBindingOpCodes(tView, lView);
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        0
        /* ChangeDetectionMode.Global */
      );
    }
    const viewQuery = tView.viewQuery;
    if (viewQuery !== null) {
      executeViewQueryFn(2, viewQuery, context2);
    }
    if (!isInCheckNoChangesPass) {
      if (hooksInitPhaseCompleted) {
        const viewCheckHooks = tView.viewCheckHooks;
        if (viewCheckHooks !== null) {
          executeCheckHooks(lView, viewCheckHooks);
        }
      } else {
        const viewHooks = tView.viewHooks;
        if (viewHooks !== null) {
          executeInitAndCheckHooks(
            lView,
            viewHooks,
            2
            /* InitPhaseState.AfterViewInitHooksToBeRun */
          );
        }
        incrementInitPhaseFlags(
          lView,
          2
          /* InitPhaseState.AfterViewInitHooksToBeRun */
        );
      }
    }
    if (tView.firstUpdatePass === true) {
      tView.firstUpdatePass = false;
    }
    if (lView[EFFECTS_TO_SCHEDULE]) {
      for (const notifyEffect of lView[EFFECTS_TO_SCHEDULE]) {
        notifyEffect();
      }
      lView[EFFECTS_TO_SCHEDULE] = null;
    }
    if (!isInCheckNoChangesPass) {
      lView[FLAGS] &= ~(64 | 8);
    }
  } catch (e) {
    if (!isInCheckNoChangesPass) {
      markAncestorsForTraversal(lView);
    }
    throw e;
  } finally {
    if (currentConsumer !== null) {
      consumerAfterComputation(currentConsumer, prevConsumer);
      if (returnConsumerToPool) {
        maybeReturnReactiveLViewConsumer(currentConsumer);
      }
    }
    leaveView();
  }
}
function detectChangesInEmbeddedViews(lView, mode) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const embeddedLView = lContainer[i];
      detectChangesInViewIfAttached(embeddedLView, mode);
    }
  }
}
function markTransplantedViewsForRefresh(lView) {
  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
    if (!(lContainer[FLAGS] & LContainerFlags.HasTransplantedViews)) continue;
    const movedViews = lContainer[MOVED_VIEWS];
    ngDevMode && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
    for (let i = 0; i < movedViews.length; i++) {
      const movedLView = movedViews[i];
      markViewForRefresh(movedLView);
    }
  }
}
function detectChangesInComponent(hostLView, componentHostIdx, mode) {
  ngDevMode && assertEqual(isCreationMode(hostLView), false, "Should be run in update mode");
  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
  detectChangesInViewIfAttached(componentView, mode);
}
function detectChangesInViewIfAttached(lView, mode) {
  if (!viewAttachedToChangeDetector(lView)) {
    return;
  }
  detectChangesInView(lView, mode);
}
function detectChangesInView(lView, mode) {
  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();
  const tView = lView[TVIEW];
  const flags = lView[FLAGS];
  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER];
  let shouldRefreshView = !!(mode === 0 && flags & 16);
  shouldRefreshView ||= !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass);
  shouldRefreshView ||= !!(flags & 1024);
  shouldRefreshView ||= !!(consumer?.dirty && consumerPollProducersForChange(consumer));
  shouldRefreshView ||= !!(ngDevMode && isExhaustiveCheckNoChanges());
  if (consumer) {
    consumer.dirty = false;
  }
  lView[FLAGS] &= ~(8192 | 1024);
  if (shouldRefreshView) {
    refreshView(tView, lView, tView.template, lView[CONTEXT]);
  } else if (flags & 8192) {
    runEffectsInView(lView);
    detectChangesInEmbeddedViews(
      lView,
      1
      /* ChangeDetectionMode.Targeted */
    );
    const components = tView.components;
    if (components !== null) {
      detectChangesInChildComponents(
        lView,
        components,
        1
        /* ChangeDetectionMode.Targeted */
      );
    }
  }
}
function detectChangesInChildComponents(hostLView, components, mode) {
  for (let i = 0; i < components.length; i++) {
    detectChangesInComponent(hostLView, components[i], mode);
  }
}
function markViewDirty(lView, source) {
  const dirtyBitsToUse = isRefreshingViews() ? (
    // When we are actively refreshing views, we only use the `Dirty` bit to mark a view
    64
  ) : (
    // When we are not actively refreshing a view tree, it is absolutely
    // valid to update state and mark views dirty. We use the `RefreshView` flag in this
    // case to allow synchronously rerunning change detection. This applies today to
    // afterRender hooks as well as animation listeners which execute after detecting
    // changes in a view when the render factory flushes.
    1024 | 64
  );
  lView[ENVIRONMENT].changeDetectionScheduler?.notify(source);
  while (lView) {
    lView[FLAGS] |= dirtyBitsToUse;
    const parent = getLViewParent(lView);
    if (isRootView(lView) && !parent) {
      return lView;
    }
    lView = parent;
  }
  return null;
}
var ViewRef$1 = class {
  _lView;
  _cdRefInjectingView;
  notifyErrorHandler;
  _appRef = null;
  _attachedToViewContainer = false;
  get rootNodes() {
    const lView = this._lView;
    const tView = lView[TVIEW];
    return collectNativeNodes(tView, lView, tView.firstChild, []);
  }
  constructor(_lView, _cdRefInjectingView, notifyErrorHandler = true) {
    this._lView = _lView;
    this._cdRefInjectingView = _cdRefInjectingView;
    this.notifyErrorHandler = notifyErrorHandler;
  }
  get context() {
    return this._lView[CONTEXT];
  }
  /**
   * Reports whether the given view is considered dirty according to the different marking mechanisms.
   */
  get dirty() {
    return !!(this._lView[FLAGS] & (64 | 1024 | 8192)) || !!this._lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty;
  }
  /**
   * @deprecated Replacing the full context object is not supported. Modify the context
   *   directly, or consider using a `Proxy` if you need to replace the full object.
   * // TODO(devversion): Remove this.
   */
  set context(value2) {
    if (ngDevMode) {
      console.warn("Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.");
    }
    this._lView[CONTEXT] = value2;
  }
  get destroyed() {
    return (this._lView[FLAGS] & 256) === 256;
  }
  destroy() {
    if (this._appRef) {
      this._appRef.detachView(this);
    } else if (this._attachedToViewContainer) {
      const parent = this._lView[PARENT];
      if (isLContainer(parent)) {
        const viewRefs = parent[VIEW_REFS];
        const index = viewRefs ? viewRefs.indexOf(this) : -1;
        if (index > -1) {
          ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
          detachView(parent, index);
          removeFromArray(viewRefs, index);
        }
      }
      this._attachedToViewContainer = false;
    }
    destroyLView(this._lView[TVIEW], this._lView);
  }
  onDestroy(callback) {
    storeLViewOnDestroy(this._lView, callback);
  }
  /**
   * Marks a view and all of its ancestors dirty.
   *
   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is
   * checked when it needs to be re-rendered but the two normal triggers haven't marked it
   * dirty (i.e. inputs haven't changed and events haven't fired in the view).
   *
   * <!-- TODO: Add a link to a chapter on OnPush components -->
   *
   * @usageNotes
   * ### Example
   *
   * ```typescript
   * @Component({
   *   selector: 'app-root',
   *   template: `Number of ticks: {{numberOfTicks}}`
   *   changeDetection: ChangeDetectionStrategy.OnPush,
   * })
   * class AppComponent {
   *   numberOfTicks = 0;
   *
   *   constructor(private ref: ChangeDetectorRef) {
   *     setInterval(() => {
   *       this.numberOfTicks++;
   *       // the following is required, otherwise the view will not be updated
   *       this.ref.markForCheck();
   *     }, 1000);
   *   }
   * }
   * ```
   */
  markForCheck() {
    markViewDirty(
      this._cdRefInjectingView || this._lView,
      4
      /* NotificationSource.MarkForCheck */
    );
  }
  markForRefresh() {
    markViewForRefresh(this._cdRefInjectingView || this._lView);
  }
  /**
   * Detaches the view from the change detection tree.
   *
   * Detached views will not be checked during change detection runs until they are
   * re-attached, even if they are dirty. `detach` can be used in combination with
   * {@link ChangeDetectorRef#detectChanges} to implement local change
   * detection checks.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example defines a component with a large list of readonly data.
   * Imagine the data changes constantly, many times per second. For performance reasons,
   * we want to check and update the list every five seconds. We can do that by detaching
   * the component's change detector and doing a local check every five seconds.
   *
   * ```typescript
   * class DataProvider {
   *   // in a real application the returned data will be different every time
   *   get data() {
   *     return [1,2,3,4,5];
   *   }
   * }
   *
   * @Component({
   *   selector: 'giant-list',
   *   template: `
   *     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
   *   `,
   * })
   * class GiantList {
   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
   *     ref.detach();
   *     setInterval(() => {
   *       this.ref.detectChanges();
   *     }, 5000);
   *   }
   * }
   *
   * @Component({
   *   selector: 'app',
   *   providers: [DataProvider],
   *   template: `
   *     <giant-list><giant-list>
   *   `,
   * })
   * class App {
   * }
   * ```
   */
  detach() {
    this._lView[FLAGS] &= ~128;
  }
  /**
   * Re-attaches a view to the change detection tree.
   *
   * This can be used to re-attach views that were previously detached from the tree
   * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example creates a component displaying `live` data. The component will detach
   * its change detector from the main change detector tree when the component's live property
   * is set to false.
   *
   * ```typescript
   * class DataProvider {
   *   data = 1;
   *
   *   constructor() {
   *     setInterval(() => {
   *       this.data = this.data * 2;
   *     }, 500);
   *   }
   * }
   *
   * @Component({
   *   selector: 'live-data',
   *   inputs: ['live'],
   *   template: 'Data: {{dataProvider.data}}'
   * })
   * class LiveData {
   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
   *
   *   set live(value) {
   *     if (value) {
   *       this.ref.reattach();
   *     } else {
   *       this.ref.detach();
   *     }
   *   }
   * }
   *
   * @Component({
   *   selector: 'app-root',
   *   providers: [DataProvider],
   *   template: `
   *     Live Update: <input type="checkbox" [(ngModel)]="live">
   *     <live-data [live]="live"><live-data>
   *   `,
   * })
   * class AppComponent {
   *   live = true;
   * }
   * ```
   */
  reattach() {
    updateAncestorTraversalFlagsOnAttach(this._lView);
    this._lView[FLAGS] |= 128;
  }
  /**
   * Checks the view and its children.
   *
   * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement
   * local change detection checks.
   *
   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
   *
   * @usageNotes
   * ### Example
   *
   * The following example defines a component with a large list of readonly data.
   * Imagine, the data changes constantly, many times per second. For performance reasons,
   * we want to check and update the list every five seconds.
   *
   * We can do that by detaching the component's change detector and doing a local change detection
   * check every five seconds.
   *
   * See {@link ChangeDetectorRef#detach} for more information.
   */
  detectChanges() {
    this._lView[FLAGS] |= 1024;
    detectChangesInternal(this._lView, this.notifyErrorHandler);
  }
  /**
   * Checks the change detector and its children, and throws if any changes are detected.
   *
   * This is used in development mode to verify that running change detection doesn't
   * introduce other changes.
   */
  checkNoChanges() {
    if (ngDevMode) {
      checkNoChangesInternal(this._lView, CheckNoChangesMode.OnlyDirtyViews, this.notifyErrorHandler);
    }
  }
  attachToViewContainerRef() {
    if (this._appRef) {
      throw new RuntimeError(902, ngDevMode && "This view is already attached directly to the ApplicationRef!");
    }
    this._attachedToViewContainer = true;
  }
  detachFromAppRef() {
    this._appRef = null;
    const isRoot = isRootView(this._lView);
    const declarationContainer = this._lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      detachMovedView(declarationContainer, this._lView);
    }
    detachViewFromDOM(this._lView[TVIEW], this._lView);
  }
  attachToAppRef(appRef) {
    if (this._attachedToViewContainer) {
      throw new RuntimeError(902, ngDevMode && "This view is already attached to a ViewContainer!");
    }
    this._appRef = appRef;
    const isRoot = isRootView(this._lView);
    const declarationContainer = this._lView[DECLARATION_LCONTAINER];
    if (declarationContainer !== null && !isRoot) {
      trackMovedView(declarationContainer, this._lView);
    }
    updateAncestorTraversalFlagsOnAttach(this._lView);
  }
};
var TemplateRef = class {
  /**
   * @internal
   * @nocollapse
   */
  static __NG_ELEMENT_ID__ = injectTemplateRef;
};
var ViewEngineTemplateRef = TemplateRef;
var R3TemplateRef = class TemplateRef2 extends ViewEngineTemplateRef {
  _declarationLView;
  _declarationTContainer;
  elementRef;
  constructor(_declarationLView, _declarationTContainer, elementRef) {
    super();
    this._declarationLView = _declarationLView;
    this._declarationTContainer = _declarationTContainer;
    this.elementRef = elementRef;
  }
  /**
   * Returns an `ssrId` associated with a TView, which was used to
   * create this instance of the `TemplateRef`.
   *
   * @internal
   */
  get ssrId() {
    return this._declarationTContainer.tView?.ssrId || null;
  }
  createEmbeddedView(context2, injector) {
    return this.createEmbeddedViewImpl(context2, injector);
  }
  /**
   * @internal
   */
  createEmbeddedViewImpl(context2, injector, dehydratedView) {
    const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context2, {
      embeddedViewInjector: injector,
      dehydratedView
    });
    return new ViewRef$1(embeddedLView);
  }
};
function injectTemplateRef() {
  return createTemplateRef(getCurrentTNode(), getLView());
}
function createTemplateRef(hostTNode, hostLView) {
  if (hostTNode.type & 4) {
    ngDevMode && assertDefined(hostTNode.tView, "TView must be allocated");
    return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
  }
  return null;
}
var AT_THIS_LOCATION = "<-- AT THIS LOCATION";
function getFriendlyStringFromTNodeType(tNodeType) {
  switch (tNodeType) {
    case 4:
      return "view container";
    case 2:
      return "element";
    case 8:
      return "ng-container";
    case 32:
      return "icu";
    case 64:
      return "i18n";
    case 16:
      return "projection";
    case 1:
      return "text";
    case 128:
      return "@let";
    default:
      return "<unknown>";
  }
}
function validateSiblingNodeExists(node) {
  validateNodeExists(node);
  if (!node.nextSibling) {
    const header = "During hydration Angular expected more sibling nodes to be present.\n\n";
    const actual = `Actual DOM is:

${describeDomFromNode(node)}

`;
    const footer = getHydrationErrorFooter();
    const message = header + actual + footer;
    markRNodeAsHavingHydrationMismatch(node, "", actual);
    throw new RuntimeError(-501, message);
  }
}
function validateNodeExists(node, lView = null, tNode = null) {
  if (!node) {
    const header = "During hydration, Angular expected an element to be present at this location.\n\n";
    let expected = "";
    let footer = "";
    if (lView !== null && tNode !== null) {
      expected = describeExpectedDom(lView, tNode, false);
      footer = getHydrationErrorFooter();
      markRNodeAsHavingHydrationMismatch(unwrapRNode(lView[HOST]), expected, "");
    }
    throw new RuntimeError(-502, `${header}${expected}

${footer}`);
  }
}
function stringifyTNodeAttrs(tNode) {
  const results = [];
  if (tNode.attrs) {
    for (let i = 0; i < tNode.attrs.length; ) {
      const attrName = tNode.attrs[i++];
      if (typeof attrName == "number") {
        break;
      }
      const attrValue = tNode.attrs[i++];
      results.push(`${attrName}="${shorten(attrValue)}"`);
    }
  }
  return results.join(" ");
}
var internalAttrs = /* @__PURE__ */ new Set(["ngh", "ng-version", "ng-server-context"]);
function stringifyRNodeAttrs(rNode) {
  const results = [];
  for (let i = 0; i < rNode.attributes.length; i++) {
    const attr = rNode.attributes[i];
    if (internalAttrs.has(attr.name)) continue;
    results.push(`${attr.name}="${shorten(attr.value)}"`);
  }
  return results.join(" ");
}
function describeTNode(tNode, innerContent = "\u2026") {
  switch (tNode.type) {
    case 1:
      const content = tNode.value ? `(${tNode.value})` : "";
      return `#text${content}`;
    case 2:
      const attrs = stringifyTNodeAttrs(tNode);
      const tag = tNode.value.toLowerCase();
      return `<${tag}${attrs ? " " + attrs : ""}>${innerContent}</${tag}>`;
    case 8:
      return "<!-- ng-container -->";
    case 4:
      return "<!-- container -->";
    default:
      const typeAsString = getFriendlyStringFromTNodeType(tNode.type);
      return `#node(${typeAsString})`;
  }
}
function describeRNode(rNode, innerContent = "\u2026") {
  const node = rNode;
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
      const tag = node.tagName.toLowerCase();
      const attrs = stringifyRNodeAttrs(node);
      return `<${tag}${attrs ? " " + attrs : ""}>${innerContent}</${tag}>`;
    case Node.TEXT_NODE:
      const content = node.textContent ? shorten(node.textContent) : "";
      return `#text${content ? `(${content})` : ""}`;
    case Node.COMMENT_NODE:
      return `<!-- ${shorten(node.textContent ?? "")} -->`;
    default:
      return `#node(${node.nodeType})`;
  }
}
function describeExpectedDom(lView, tNode, isViewContainerAnchor) {
  const spacer = "  ";
  let content = "";
  if (tNode.prev) {
    content += spacer + "\u2026\n";
    content += spacer + describeTNode(tNode.prev) + "\n";
  } else if (tNode.type && tNode.type & 12) {
    content += spacer + "\u2026\n";
  }
  if (isViewContainerAnchor) {
    content += spacer + describeTNode(tNode) + "\n";
    content += spacer + `<!-- container -->  ${AT_THIS_LOCATION}
`;
  } else {
    content += spacer + describeTNode(tNode) + `  ${AT_THIS_LOCATION}
`;
  }
  content += spacer + "\u2026\n";
  const parentRNode = tNode.type ? getParentRElement(lView[TVIEW], tNode, lView) : null;
  if (parentRNode) {
    content = describeRNode(parentRNode, "\n" + content);
  }
  return content;
}
function describeDomFromNode(node) {
  const spacer = "  ";
  let content = "";
  const currentNode = node;
  if (currentNode.previousSibling) {
    content += spacer + "\u2026\n";
    content += spacer + describeRNode(currentNode.previousSibling) + "\n";
  }
  content += spacer + describeRNode(currentNode) + `  ${AT_THIS_LOCATION}
`;
  if (node.nextSibling) {
    content += spacer + "\u2026\n";
  }
  if (node.parentNode) {
    content = describeRNode(currentNode.parentNode, "\n" + content);
  }
  return content;
}
function getHydrationErrorFooter(componentClassName) {
  const componentInfo = componentClassName ? `the "${componentClassName}"` : "corresponding";
  return `To fix this problem:
  * check ${componentInfo} component for hydration-related issues
  * check to see if your template has valid HTML structure
  * or skip hydration by adding the \`ngSkipHydration\` attribute to its host node in a template

`;
}
function stripNewlines(input2) {
  return input2.replace(/\s+/gm, "");
}
function shorten(input2, maxLength = 50) {
  if (!input2) {
    return "";
  }
  input2 = stripNewlines(input2);
  return input2.length > maxLength ? `${input2.substring(0, maxLength - 1)}\u2026` : input2;
}
function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
  if (insertBeforeIndex === null) {
    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
  } else {
    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
    return unwrapRNode(lView[insertBeforeIndex]);
  }
}
function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
  if (Array.isArray(tNodeInsertBeforeIndex)) {
    ngDevMode && assertDomNode(childRNode);
    let i18nParent = childRNode;
    let anchorRNode = null;
    if (!(childTNode.type & 3)) {
      anchorRNode = i18nParent;
      i18nParent = parentRElement;
    }
    if (i18nParent !== null && childTNode.componentOffset === -1) {
      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
        const i18nChild = lView[tNodeInsertBeforeIndex[i]];
        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
      }
    }
  }
}
function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
  ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
  previousTNodes.push(newTNode);
  if (previousTNodes.length > 1) {
    for (let i = previousTNodes.length - 2; i >= 0; i--) {
      const existingTNode = previousTNodes[i];
      if (!isI18nText(existingTNode)) {
        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
          setInsertBeforeIndex(existingTNode, newTNode.index);
        }
      }
    }
  }
}
function isI18nText(tNode) {
  return !(tNode.type & 64);
}
function isNewTNodeCreatedBefore(existingTNode, newTNode) {
  return isI18nText(newTNode) || existingTNode.index > newTNode.index;
}
function getInsertBeforeIndex(tNode) {
  const index = tNode.insertBeforeIndex;
  return Array.isArray(index) ? index[0] : index;
}
function setInsertBeforeIndex(tNode, value2) {
  const index = tNode.insertBeforeIndex;
  if (Array.isArray(index)) {
    index[0] = value2;
  } else {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    tNode.insertBeforeIndex = value2;
  }
}
function getTIcu(tView, index) {
  const value2 = tView.data[index];
  if (value2 === null || typeof value2 === "string") return null;
  if (ngDevMode && !(value2.hasOwnProperty("tView") || value2.hasOwnProperty("currentCaseLViewIndex"))) {
    throwError2("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value2);
  }
  const tIcu = value2.hasOwnProperty("currentCaseLViewIndex") ? value2 : value2.value;
  ngDevMode && assertTIcu(tIcu);
  return tIcu;
}
function setTIcu(tView, index, tIcu) {
  const tNode = tView.data[index];
  ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty("tView"), true, "We expect to get 'null'|'TIcuContainer'");
  if (tNode === null) {
    tView.data[index] = tIcu;
  } else {
    ngDevMode && assertTNodeType(
      tNode,
      32
      /* TNodeType.Icu */
    );
    tNode.value = tIcu;
  }
}
function setTNodeInsertBeforeIndex(tNode, index) {
  ngDevMode && assertTNode(tNode);
  let insertBeforeIndex = tNode.insertBeforeIndex;
  if (insertBeforeIndex === null) {
    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
    insertBeforeIndex = tNode.insertBeforeIndex = [null, index];
  } else {
    assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
    insertBeforeIndex.push(index);
  }
}
function createTNodePlaceholder(tView, previousTNodes, index) {
  const tNode = createTNodeAtIndex(tView, index, 64, null, null);
  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
  return tNode;
}
function getCurrentICUCaseIndex(tIcu, lView) {
  const currentCase = lView[tIcu.currentCaseLViewIndex];
  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
}
function getParentFromIcuCreateOpCode(mergedCode) {
  return mergedCode >>> 17;
}
function getRefFromIcuCreateOpCode(mergedCode) {
  return (mergedCode & 131070) >>> 1;
}
function getInstructionFromIcuCreateOpCode(mergedCode) {
  return mergedCode & 1;
}
function icuCreateOpCode(opCode, parentIdx, refIdx) {
  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, "Missing parent index");
  ngDevMode && assertGreaterThan(refIdx, 0, "Missing ref index");
  return opCode | parentIdx << 17 | refIdx << 1;
}
function isRootTemplateMessage(subTemplateIndex) {
  return subTemplateIndex === -1;
}
function enterIcu(state2, tIcu, lView) {
  state2.index = 0;
  const currentCase = getCurrentICUCaseIndex(tIcu, lView);
  if (currentCase !== null) {
    ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
    state2.removes = tIcu.remove[currentCase];
  } else {
    state2.removes = EMPTY_ARRAY;
  }
}
function icuContainerIteratorNext(state2) {
  if (state2.index < state2.removes.length) {
    const removeOpCode = state2.removes[state2.index++];
    ngDevMode && assertNumber(removeOpCode, "Expecting OpCode number");
    if (removeOpCode > 0) {
      const rNode = state2.lView[removeOpCode];
      ngDevMode && assertDomNode(rNode);
      return rNode;
    } else {
      state2.stack.push(state2.index, state2.removes);
      const tIcuIndex = ~removeOpCode;
      const tIcu = state2.lView[TVIEW].data[tIcuIndex];
      ngDevMode && assertTIcu(tIcu);
      enterIcu(state2, tIcu, state2.lView);
      return icuContainerIteratorNext(state2);
    }
  } else {
    if (state2.stack.length === 0) {
      return null;
    } else {
      state2.removes = state2.stack.pop();
      state2.index = state2.stack.pop();
      return icuContainerIteratorNext(state2);
    }
  }
}
function loadIcuContainerVisitor() {
  const _state = {
    stack: [],
    index: -1
  };
  function icuContainerIteratorStart(tIcuContainerNode, lView) {
    _state.lView = lView;
    while (_state.stack.length) _state.stack.pop();
    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
    enterIcu(_state, tIcuContainerNode.value, lView);
    return icuContainerIteratorNext.bind(null, _state);
  }
  return icuContainerIteratorStart;
}
var REF_EXTRACTOR_REGEXP = new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);
var _prepareI18nBlockForHydrationImpl = () => {
};
function prepareI18nBlockForHydration(lView, index, parentTNode, subTemplateIndex) {
  _prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex);
}
var _claimDehydratedIcuCaseImpl = () => {
};
function claimDehydratedIcuCase(lView, icuIndex, caseIndex) {
  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);
}
function cleanupI18nHydrationData(lView) {
  const hydrationInfo = lView[HYDRATION];
  if (hydrationInfo) {
    const {
      i18nNodes,
      dehydratedIcuData: dehydratedIcuDataMap
    } = hydrationInfo;
    if (i18nNodes && dehydratedIcuDataMap) {
      const renderer = lView[RENDERER];
      for (const dehydratedIcuData of dehydratedIcuDataMap.values()) {
        cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData);
      }
    }
    hydrationInfo.i18nNodes = void 0;
    hydrationInfo.dehydratedIcuData = void 0;
  }
}
function cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData) {
  for (const node of dehydratedIcuData.node.cases[dehydratedIcuData.case]) {
    const rNode = i18nNodes.get(node.index - HEADER_OFFSET);
    if (rNode) {
      nativeRemoveNode(renderer, rNode, false);
    }
  }
}
function removeDehydratedViews(lContainer) {
  const views = lContainer[DEHYDRATED_VIEWS] ?? [];
  const parentLView = lContainer[PARENT];
  const renderer = parentLView[RENDERER];
  const retainedViews = [];
  for (const view of views) {
    if (view.data[DEFER_BLOCK_ID] !== void 0) {
      retainedViews.push(view);
    } else {
      removeDehydratedView(view, renderer);
      ngDevMode && ngDevMode.dehydratedViewsRemoved++;
    }
  }
  lContainer[DEHYDRATED_VIEWS] = retainedViews;
}
function removeDehydratedView(dehydratedView, renderer) {
  let nodesRemoved = 0;
  let currentRNode = dehydratedView.firstChild;
  if (currentRNode) {
    const numNodes = dehydratedView.data[NUM_ROOT_NODES];
    while (nodesRemoved < numNodes) {
      ngDevMode && validateSiblingNodeExists(currentRNode);
      const nextSibling = currentRNode.nextSibling;
      nativeRemoveNode(renderer, currentRNode, false);
      currentRNode = nextSibling;
      nodesRemoved++;
    }
  }
}
function cleanupLContainer(lContainer) {
  removeDehydratedViews(lContainer);
  const hostLView = lContainer[HOST];
  if (isLView(hostLView)) {
    cleanupLView(hostLView);
  }
  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
    cleanupLView(lContainer[i]);
  }
}
function cleanupLView(lView) {
  cleanupI18nHydrationData(lView);
  const tView = lView[TVIEW];
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    if (isLContainer(lView[i])) {
      const lContainer = lView[i];
      cleanupLContainer(lContainer);
    } else if (isLView(lView[i])) {
      cleanupLView(lView[i]);
    }
  }
}
function cleanupDehydratedViews(appRef) {
  const viewRefs = appRef._views;
  for (const viewRef of viewRefs) {
    const lNode = getLNodeForHydration(viewRef);
    if (lNode !== null && lNode[HOST] !== null) {
      if (isLView(lNode)) {
        cleanupLView(lNode);
      } else {
        cleanupLContainer(lNode);
      }
      ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;
    }
  }
}
function cleanupHydratedDeferBlocks(deferBlock, hydratedBlocks, registry, appRef) {
  if (deferBlock !== null) {
    registry.cleanup(hydratedBlocks);
    cleanupLContainer(deferBlock.lContainer);
    cleanupDehydratedViews(appRef);
  }
}
var _findMatchingDehydratedViewImpl = () => null;
function findMatchingDehydratedView(lContainer, template) {
  return _findMatchingDehydratedViewImpl(lContainer, template);
}
var ComponentRef$1 = class {
};
var ComponentFactory$1 = class {
};
var _NullComponentFactoryResolver = class {
  resolveComponentFactory(component) {
    throw Error(`No component factory found for ${stringify(component)}.`);
  }
};
var ComponentFactoryResolver$1 = class {
  static NULL = new _NullComponentFactoryResolver();
};
var RendererFactory2 = class {
};
var Renderer2 = class {
  /**
   * If null or undefined, the view engine won't call it.
   * This is used as a performance optimization for production mode.
   */
  destroyNode = null;
  /**
   * @internal
   * @nocollapse
   */
  static __NG_ELEMENT_ID__ = () => injectRenderer2();
};
function injectRenderer2() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];
}
var Sanitizer = class _Sanitizer {
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _Sanitizer,
      providedIn: "root",
      factory: () => null
    })
  );
};
function isModuleWithProviders(value2) {
  return value2.ngModule !== void 0;
}
function isNgModule(value2) {
  return !!getNgModuleDef(value2);
}
function isPipe(value2) {
  return !!getPipeDef$1(value2);
}
function isDirective(value2) {
  return !!getDirectiveDef(value2);
}
function isComponent(value2) {
  return !!getComponentDef(value2);
}
function getDependencyTypeForError(type2) {
  if (getComponentDef(type2)) return "component";
  if (getDirectiveDef(type2)) return "directive";
  if (getPipeDef$1(type2)) return "pipe";
  return "type";
}
function verifyStandaloneImport(depType, importingType) {
  if (isForwardRef(depType)) {
    depType = resolveForwardRef(depType);
    if (!depType) {
      throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType) || depType}".`);
    }
  }
  if (getNgModuleDef(depType) == null) {
    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef$1(depType);
    if (def != null) {
      if (!def.standalone) {
        throw new Error(`The "${stringifyForError(depType)}" ${getDependencyTypeForError(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`);
      }
    } else {
      if (isModuleWithProviders(depType)) {
        throw new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`);
      } else {
        throw new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);
      }
    }
  }
}
var USE_RUNTIME_DEPS_TRACKER_FOR_JIT = true;
var DepsTracker = class {
  ownerNgModule = /* @__PURE__ */ new Map();
  ngModulesWithSomeUnresolvedDecls = /* @__PURE__ */ new Set();
  ngModulesScopeCache = /* @__PURE__ */ new Map();
  standaloneComponentsScopeCache = /* @__PURE__ */ new Map();
  /**
   * Attempts to resolve ng module's forward ref declarations as much as possible and add them to
   * the `ownerNgModule` map. This method normally should be called after the initial parsing when
   * all the forward refs are resolved (e.g., when trying to render a component)
   */
  resolveNgModulesDecls() {
    if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {
      return;
    }
    for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {
      const def = getNgModuleDef(moduleType);
      if (def?.declarations) {
        for (const decl of maybeUnwrapFn(def.declarations)) {
          if (isComponent(decl)) {
            this.ownerNgModule.set(decl, moduleType);
          }
        }
      }
    }
    this.ngModulesWithSomeUnresolvedDecls.clear();
  }
  /** @override */
  getComponentDependencies(type2, rawImports) {
    this.resolveNgModulesDecls();
    const def = getComponentDef(type2);
    if (def === null) {
      throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type2}`);
    }
    if (def.standalone) {
      const scope = this.getStandaloneComponentScope(type2, rawImports);
      if (scope.compilation.isPoisoned) {
        return {
          dependencies: []
        };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes, ...scope.compilation.ngModules]
      };
    } else {
      if (!this.ownerNgModule.has(type2)) {
        return {
          dependencies: []
        };
      }
      const scope = this.getNgModuleScope(this.ownerNgModule.get(type2));
      if (scope.compilation.isPoisoned) {
        return {
          dependencies: []
        };
      }
      return {
        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes]
      };
    }
  }
  /**
   * @override
   * This implementation does not make use of param scopeInfo since it assumes the scope info is
   * already added to the type itself through methods like {@link ɵɵsetNgModuleScope}
   */
  registerNgModule(type2, scopeInfo) {
    if (!isNgModule(type2)) {
      throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type2}`);
    }
    this.ngModulesWithSomeUnresolvedDecls.add(type2);
  }
  /** @override */
  clearScopeCacheFor(type2) {
    this.ngModulesScopeCache.delete(type2);
    this.standaloneComponentsScopeCache.delete(type2);
  }
  /** @override */
  getNgModuleScope(type2) {
    if (this.ngModulesScopeCache.has(type2)) {
      return this.ngModulesScopeCache.get(type2);
    }
    const scope = this.computeNgModuleScope(type2);
    this.ngModulesScopeCache.set(type2, scope);
    return scope;
  }
  /** Compute NgModule scope afresh. */
  computeNgModuleScope(type2) {
    const def = getNgModuleDef(type2, true);
    const scope = {
      exported: {
        directives: /* @__PURE__ */ new Set(),
        pipes: /* @__PURE__ */ new Set()
      },
      compilation: {
        directives: /* @__PURE__ */ new Set(),
        pipes: /* @__PURE__ */ new Set()
      }
    };
    for (const imported of maybeUnwrapFn(def.imports)) {
      if (isNgModule(imported)) {
        const importedScope = this.getNgModuleScope(imported);
        addSet(importedScope.exported.directives, scope.compilation.directives);
        addSet(importedScope.exported.pipes, scope.compilation.pipes);
      } else if (isStandalone(imported)) {
        if (isDirective(imported) || isComponent(imported)) {
          scope.compilation.directives.add(imported);
        } else if (isPipe(imported)) {
          scope.compilation.pipes.add(imported);
        } else {
          throw new RuntimeError(980, "The standalone imported type is neither a component nor a directive nor a pipe");
        }
      } else {
        scope.compilation.isPoisoned = true;
        break;
      }
    }
    if (!scope.compilation.isPoisoned) {
      for (const decl of maybeUnwrapFn(def.declarations)) {
        if (isNgModule(decl) || isStandalone(decl)) {
          scope.compilation.isPoisoned = true;
          break;
        }
        if (isPipe(decl)) {
          scope.compilation.pipes.add(decl);
        } else {
          scope.compilation.directives.add(decl);
        }
      }
    }
    for (const exported of maybeUnwrapFn(def.exports)) {
      if (isNgModule(exported)) {
        const exportedScope = this.getNgModuleScope(exported);
        addSet(exportedScope.exported.directives, scope.exported.directives);
        addSet(exportedScope.exported.pipes, scope.exported.pipes);
        addSet(exportedScope.exported.directives, scope.compilation.directives);
        addSet(exportedScope.exported.pipes, scope.compilation.pipes);
      } else if (isPipe(exported)) {
        scope.exported.pipes.add(exported);
      } else {
        scope.exported.directives.add(exported);
      }
    }
    return scope;
  }
  /** @override */
  getStandaloneComponentScope(type2, rawImports) {
    if (this.standaloneComponentsScopeCache.has(type2)) {
      return this.standaloneComponentsScopeCache.get(type2);
    }
    const ans = this.computeStandaloneComponentScope(type2, rawImports);
    this.standaloneComponentsScopeCache.set(type2, ans);
    return ans;
  }
  computeStandaloneComponentScope(type2, rawImports) {
    const ans = {
      compilation: {
        // Standalone components are always able to self-reference.
        directives: /* @__PURE__ */ new Set([type2]),
        pipes: /* @__PURE__ */ new Set(),
        ngModules: /* @__PURE__ */ new Set()
      }
    };
    for (const rawImport of flatten(rawImports ?? [])) {
      const imported = resolveForwardRef(rawImport);
      try {
        verifyStandaloneImport(imported, type2);
      } catch (e) {
        ans.compilation.isPoisoned = true;
        return ans;
      }
      if (isNgModule(imported)) {
        ans.compilation.ngModules.add(imported);
        const importedScope = this.getNgModuleScope(imported);
        if (importedScope.exported.isPoisoned) {
          ans.compilation.isPoisoned = true;
          return ans;
        }
        addSet(importedScope.exported.directives, ans.compilation.directives);
        addSet(importedScope.exported.pipes, ans.compilation.pipes);
      } else if (isPipe(imported)) {
        ans.compilation.pipes.add(imported);
      } else if (isDirective(imported) || isComponent(imported)) {
        ans.compilation.directives.add(imported);
      } else {
        ans.compilation.isPoisoned = true;
        return ans;
      }
    }
    return ans;
  }
  /** @override */
  isOrphanComponent(cmp) {
    const def = getComponentDef(cmp);
    if (!def || def.standalone) {
      return false;
    }
    this.resolveNgModulesDecls();
    return !this.ownerNgModule.has(cmp);
  }
};
function addSet(sourceSet, targetSet) {
  for (const m of sourceSet) {
    targetSet.add(m);
  }
}
var depsTracker = new DepsTracker();
function computeStaticStyling(tNode, attrs, writeToHost) {
  ngDevMode && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
  let styles2 = writeToHost ? tNode.styles : null;
  let classes = writeToHost ? tNode.classes : null;
  let mode = 0;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const value2 = attrs[i];
      if (typeof value2 === "number") {
        mode = value2;
      } else if (mode == 1) {
        classes = concatStringsWithSpace(classes, value2);
      } else if (mode == 2) {
        const style2 = value2;
        const styleValue2 = attrs[++i];
        styles2 = concatStringsWithSpace(styles2, style2 + ": " + styleValue2 + ";");
      }
    }
  }
  writeToHost ? tNode.styles = styles2 : tNode.stylesWithoutHost = styles2;
  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
}
var ComponentFactoryResolver = class extends ComponentFactoryResolver$1 {
  ngModule;
  /**
   * @param ngModule The NgModuleRef to which all resolved factories are bound.
   */
  constructor(ngModule) {
    super();
    this.ngModule = ngModule;
  }
  resolveComponentFactory(component) {
    ngDevMode && assertComponentType(component);
    const componentDef = getComponentDef(component);
    return new ComponentFactory(componentDef, this.ngModule);
  }
};
function toRefArray(map3, isInputMap) {
  const array2 = [];
  for (const publicName in map3) {
    if (!map3.hasOwnProperty(publicName)) {
      continue;
    }
    const value2 = map3[publicName];
    if (value2 === void 0) {
      continue;
    }
    const isArray3 = Array.isArray(value2);
    const propName = isArray3 ? value2[0] : value2;
    const flags = isArray3 ? value2[1] : InputFlags.None;
    if (isInputMap) {
      array2.push({
        propName,
        templateName: publicName,
        isSignal: (flags & InputFlags.SignalBased) !== 0
      });
    } else {
      array2.push({
        propName,
        templateName: publicName
      });
    }
  }
  return array2;
}
function getNamespace(elementName) {
  const name = elementName.toLowerCase();
  return name === "svg" ? SVG_NAMESPACE : name === "math" ? MATH_ML_NAMESPACE : null;
}
var ComponentFactory = class extends ComponentFactory$1 {
  componentDef;
  ngModule;
  selector;
  componentType;
  ngContentSelectors;
  isBoundToModule;
  get inputs() {
    const componentDef = this.componentDef;
    const inputTransforms = componentDef.inputTransforms;
    const refArray = toRefArray(componentDef.inputs, true);
    if (inputTransforms !== null) {
      for (const input2 of refArray) {
        if (inputTransforms.hasOwnProperty(input2.propName)) {
          input2.transform = inputTransforms[input2.propName];
        }
      }
    }
    return refArray;
  }
  get outputs() {
    return toRefArray(this.componentDef.outputs, false);
  }
  /**
   * @param componentDef The component definition.
   * @param ngModule The NgModuleRef to which the factory is bound.
   */
  constructor(componentDef, ngModule) {
    super();
    this.componentDef = componentDef;
    this.ngModule = ngModule;
    this.componentType = componentDef.type;
    this.selector = stringifyCSSSelectorList(componentDef.selectors);
    this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
    this.isBoundToModule = !!ngModule;
  }
  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (ngDevMode && false) {
        if (depsTracker.isOrphanComponent(this.componentType)) {
          throw new RuntimeError(981, `Orphan component found! Trying to render the component ${debugStringifyTypeForError(this.componentType)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);
        }
      }
      environmentInjector = environmentInjector || this.ngModule;
      let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;
      if (realEnvironmentInjector && this.componentDef.getStandaloneInjector !== null) {
        realEnvironmentInjector = this.componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;
      }
      const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;
      const rendererFactory = rootViewInjector.get(RendererFactory2, null);
      if (rendererFactory === null) {
        throw new RuntimeError(407, ngDevMode && "Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");
      }
      const sanitizer = rootViewInjector.get(Sanitizer, null);
      const changeDetectionScheduler = rootViewInjector.get(ChangeDetectionScheduler, null);
      const environment2 = {
        rendererFactory,
        sanitizer,
        changeDetectionScheduler
      };
      const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
      const elementName = this.componentDef.selectors[0][0] || "div";
      const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation, rootViewInjector) : createElementNode(hostRenderer, elementName, getNamespace(elementName));
      let rootFlags = 512;
      if (this.componentDef.signals) {
        rootFlags |= 4096;
      } else if (!this.componentDef.onPush) {
        rootFlags |= 16;
      }
      let hydrationInfo = null;
      if (hostRNode !== null) {
        hydrationInfo = retrieveHydrationInfo(
          hostRNode,
          rootViewInjector,
          true
          /* isRootView */
        );
      }
      const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null, null);
      const rootLView = createLView(null, rootTView, null, rootFlags, null, null, environment2, hostRenderer, rootViewInjector, null, hydrationInfo);
      enterView(rootLView);
      let component;
      let tElementNode;
      let componentView = null;
      try {
        const rootComponentDef = this.componentDef;
        let rootDirectives;
        let hostDirectiveDefs = null;
        if (rootComponentDef.findHostDirectiveDefs) {
          rootDirectives = [];
          hostDirectiveDefs = /* @__PURE__ */ new Map();
          rootComponentDef.findHostDirectiveDefs(rootComponentDef, rootDirectives, hostDirectiveDefs);
          rootDirectives.push(rootComponentDef);
          ngDevMode && assertNoDuplicateDirectives(rootDirectives);
        } else {
          rootDirectives = [rootComponentDef];
        }
        const hostTNode = createRootComponentTNode(rootLView, hostRNode);
        componentView = createRootComponentView(hostTNode, hostRNode, rootComponentDef, rootDirectives, rootLView, environment2, hostRenderer);
        tElementNode = getTNode(rootTView, HEADER_OFFSET);
        if (hostRNode) {
          setRootNodeAttributes(hostRenderer, rootComponentDef, hostRNode, rootSelectorOrNode);
        }
        if (projectableNodes !== void 0) {
          projectNodes(tElementNode, this.ngContentSelectors, projectableNodes);
        }
        component = createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, [LifecycleHooksFeature]);
        renderView(rootTView, rootLView, null);
      } catch (e) {
        if (componentView !== null) {
          unregisterLView(componentView);
        }
        unregisterLView(rootLView);
        throw e;
      } finally {
        leaveView();
      }
      return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
};
var ComponentRef = class extends ComponentRef$1 {
  location;
  _rootLView;
  _tNode;
  instance;
  hostView;
  changeDetectorRef;
  componentType;
  previousInputValues = null;
  constructor(componentType, instance, location2, _rootLView, _tNode) {
    super();
    this.location = location2;
    this._rootLView = _rootLView;
    this._tNode = _tNode;
    this.instance = instance;
    this.hostView = this.changeDetectorRef = new ViewRef$1(
      _rootLView,
      void 0,
      false
      /* notifyErrorHandler */
    );
    this.componentType = componentType;
  }
  setInput(name, value2) {
    const inputData = this._tNode.inputs;
    let dataValue;
    if (inputData !== null && (dataValue = inputData[name])) {
      this.previousInputValues ??= /* @__PURE__ */ new Map();
      if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value2)) {
        return;
      }
      const lView = this._rootLView;
      setInputsForProperty(lView[TVIEW], lView, dataValue, name, value2);
      this.previousInputValues.set(name, value2);
      const childComponentLView = getComponentLViewByIndex(this._tNode.index, lView);
      markViewDirty(
        childComponentLView,
        1
        /* NotificationSource.SetInput */
      );
    } else {
      if (ngDevMode) {
        const cmpNameForError = stringifyForError(this.componentType);
        let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;
        message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;
        reportUnknownPropertyError(message);
      }
    }
  }
  get injector() {
    return new NodeInjector(this._tNode, this._rootLView);
  }
  destroy() {
    this.hostView.destroy();
  }
  onDestroy(callback) {
    this.hostView.onDestroy(callback);
  }
};
function createRootComponentTNode(lView, rNode) {
  const tView = lView[TVIEW];
  const index = HEADER_OFFSET;
  ngDevMode && assertIndexInRange(lView, index);
  lView[index] = rNode;
  return getOrCreateTNode(tView, index, 2, "#host", null);
}
function createRootComponentView(tNode, hostRNode, rootComponentDef, rootDirectives, rootView, environment2, hostRenderer) {
  const tView = rootView[TVIEW];
  applyRootComponentStyling(rootDirectives, tNode, hostRNode, hostRenderer);
  let hydrationInfo = null;
  if (hostRNode !== null) {
    hydrationInfo = retrieveHydrationInfo(hostRNode, rootView[INJECTOR]);
  }
  const viewRenderer = environment2.rendererFactory.createRenderer(hostRNode, rootComponentDef);
  const componentView = createLView(rootView, getOrCreateComponentTView(rootComponentDef), null, getInitialLViewFlagsFromDef(rootComponentDef), rootView[tNode.index], tNode, environment2, viewRenderer, null, null, hydrationInfo);
  if (tView.firstCreatePass) {
    markAsComponentHost(tView, tNode, rootDirectives.length - 1);
  }
  addToEndOfViewTree(rootView, componentView);
  return rootView[tNode.index] = componentView;
}
function applyRootComponentStyling(rootDirectives, tNode, rNode, hostRenderer) {
  for (const def of rootDirectives) {
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
    if (rNode !== null) {
      setupStaticAttributes(hostRenderer, rNode, tNode);
    }
  }
}
function createRootComponent(componentView, rootComponentDef, rootDirectives, hostDirectiveDefs, rootLView, hostFeatures) {
  const rootTNode = getCurrentTNode();
  ngDevMode && assertDefined(rootTNode, "tNode should have been already created");
  const tView = rootLView[TVIEW];
  const native = getNativeByTNode(rootTNode, rootLView);
  initializeDirectives(tView, rootLView, rootTNode, rootDirectives, null, hostDirectiveDefs);
  for (let i = 0; i < rootDirectives.length; i++) {
    const directiveIndex = rootTNode.directiveStart + i;
    const directiveInstance = getNodeInjectable(rootLView, tView, directiveIndex, rootTNode);
    attachPatchData(directiveInstance, rootLView);
  }
  invokeDirectivesHostBindings(tView, rootLView, rootTNode);
  if (native) {
    attachPatchData(native, rootLView);
  }
  ngDevMode && assertGreaterThan(rootTNode.componentOffset, -1, "componentOffset must be great than -1");
  const component = getNodeInjectable(rootLView, tView, rootTNode.directiveStart + rootTNode.componentOffset, rootTNode);
  componentView[CONTEXT] = rootLView[CONTEXT] = component;
  if (hostFeatures !== null) {
    for (const feature of hostFeatures) {
      feature(component, rootComponentDef);
    }
  }
  executeContentQueries(tView, rootTNode, rootLView);
  return component;
}
function setRootNodeAttributes(hostRenderer, componentDef, hostRNode, rootSelectorOrNode) {
  if (rootSelectorOrNode) {
    setUpAttributes(hostRenderer, hostRNode, ["ng-version", "19.0.1"]);
  } else {
    const {
      attrs,
      classes
    } = extractAttrsAndClassesFromSelector(componentDef.selectors[0]);
    if (attrs) {
      setUpAttributes(hostRenderer, hostRNode, attrs);
    }
    if (classes && classes.length > 0) {
      writeDirectClass(hostRenderer, hostRNode, classes.join(" "));
    }
  }
}
function projectNodes(tNode, ngContentSelectors, projectableNodes) {
  const projection = tNode.projection = [];
  for (let i = 0; i < ngContentSelectors.length; i++) {
    const nodesforSlot = projectableNodes[i];
    projection.push(nodesforSlot != null && nodesforSlot.length ? Array.from(nodesforSlot) : null);
  }
}
function LifecycleHooksFeature() {
  const tNode = getCurrentTNode();
  ngDevMode && assertDefined(tNode, "TNode is required");
  registerPostOrderHooks(getLView()[TVIEW], tNode);
}
var ViewContainerRef = class {
  /**
   * @internal
   * @nocollapse
   */
  static __NG_ELEMENT_ID__ = injectViewContainerRef;
};
function injectViewContainerRef() {
  const previousTNode = getCurrentTNode();
  return createContainerRef(previousTNode, getLView());
}
var VE_ViewContainerRef = ViewContainerRef;
var R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
  _lContainer;
  _hostTNode;
  _hostLView;
  constructor(_lContainer, _hostTNode, _hostLView) {
    super();
    this._lContainer = _lContainer;
    this._hostTNode = _hostTNode;
    this._hostLView = _hostLView;
  }
  get element() {
    return createElementRef(this._hostTNode, this._hostLView);
  }
  get injector() {
    return new NodeInjector(this._hostTNode, this._hostLView);
  }
  /** @deprecated No replacement */
  get parentInjector() {
    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
    if (hasParentInjector(parentLocation)) {
      const parentView = getParentInjectorView(parentLocation, this._hostLView);
      const injectorIndex = getParentInjectorIndex(parentLocation);
      ngDevMode && assertNodeInjector(parentView, injectorIndex);
      const parentTNode = parentView[TVIEW].data[
        injectorIndex + 8
        /* NodeInjectorOffset.TNODE */
      ];
      return new NodeInjector(parentTNode, parentView);
    } else {
      return new NodeInjector(null, this._hostLView);
    }
  }
  clear() {
    while (this.length > 0) {
      this.remove(this.length - 1);
    }
  }
  get(index) {
    const viewRefs = getViewRefs(this._lContainer);
    return viewRefs !== null && viewRefs[index] || null;
  }
  get length() {
    return this._lContainer.length - CONTAINER_HEADER_OFFSET;
  }
  createEmbeddedView(templateRef, context2, indexOrOptions) {
    let index;
    let injector;
    if (typeof indexOrOptions === "number") {
      index = indexOrOptions;
    } else if (indexOrOptions != null) {
      index = indexOrOptions.index;
      injector = indexOrOptions.injector;
    }
    const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);
    const viewRef = templateRef.createEmbeddedViewImpl(context2 || {}, injector, dehydratedView);
    this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return viewRef;
  }
  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {
    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
    let index;
    if (isComponentFactory) {
      if (ngDevMode) {
        assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
      }
      index = indexOrOptions;
    } else {
      if (ngDevMode) {
        assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
        assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
      }
      const options = indexOrOptions || {};
      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {
        throwError2(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);
      }
      index = options.index;
      injector = options.injector;
      projectableNodes = options.projectableNodes;
      environmentInjector = options.environmentInjector || options.ngModuleRef;
    }
    const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef(componentFactoryOrType));
    const contextInjector = injector || this.parentInjector;
    if (!environmentInjector && componentFactory.ngModule == null) {
      const _injector = isComponentFactory ? contextInjector : this.parentInjector;
      const result = _injector.get(EnvironmentInjector, null);
      if (result) {
        environmentInjector = result;
      }
    }
    const componentDef = getComponentDef(componentFactory.componentType ?? {});
    const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);
    const rNode = dehydratedView?.firstChild ?? null;
    const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector);
    this.insertImpl(componentRef.hostView, index, shouldAddViewToDom(this._hostTNode, dehydratedView));
    return componentRef;
  }
  insert(viewRef, index) {
    return this.insertImpl(viewRef, index, true);
  }
  insertImpl(viewRef, index, addToDOM) {
    const lView = viewRef._lView;
    if (ngDevMode && viewRef.destroyed) {
      throw new Error("Cannot insert a destroyed View in a ViewContainer!");
    }
    if (viewAttachedToContainer(lView)) {
      const prevIdx = this.indexOf(viewRef);
      if (prevIdx !== -1) {
        this.detach(prevIdx);
      } else {
        const prevLContainer = lView[PARENT];
        ngDevMode && assertEqual(isLContainer(prevLContainer), true, "An attached view should have its PARENT point to a container.");
        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
        prevVCRef.detach(prevVCRef.indexOf(viewRef));
      }
    }
    const adjustedIdx = this._adjustIndex(index);
    const lContainer = this._lContainer;
    addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);
    viewRef.attachToViewContainerRef();
    addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
    return viewRef;
  }
  move(viewRef, newIndex) {
    if (ngDevMode && viewRef.destroyed) {
      throw new Error("Cannot move a destroyed View in a ViewContainer!");
    }
    return this.insert(viewRef, newIndex);
  }
  indexOf(viewRef) {
    const viewRefsArr = getViewRefs(this._lContainer);
    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
  }
  remove(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const detachedView = detachView(this._lContainer, adjustedIdx);
    if (detachedView) {
      removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
      destroyLView(detachedView[TVIEW], detachedView);
    }
  }
  detach(index) {
    const adjustedIdx = this._adjustIndex(index, -1);
    const view = detachView(this._lContainer, adjustedIdx);
    const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
    return wasDetached ? new ViewRef$1(view) : null;
  }
  _adjustIndex(index, shift2 = 0) {
    if (index == null) {
      return this.length + shift2;
    }
    if (ngDevMode) {
      assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
      assertLessThan(index, this.length + 1 + shift2, "index");
    }
    return index;
  }
};
function getViewRefs(lContainer) {
  return lContainer[VIEW_REFS];
}
function getOrCreateViewRefs(lContainer) {
  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
}
function createContainerRef(hostTNode, hostLView) {
  ngDevMode && assertTNodeType(
    hostTNode,
    12 | 3
    /* TNodeType.AnyRNode */
  );
  let lContainer;
  const slotValue = hostLView[hostTNode.index];
  if (isLContainer(slotValue)) {
    lContainer = slotValue;
  } else {
    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);
    hostLView[hostTNode.index] = lContainer;
    addToEndOfViewTree(hostLView, lContainer);
  }
  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);
  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
}
function insertAnchorNode(hostLView, hostTNode) {
  const renderer = hostLView[RENDERER];
  ngDevMode && ngDevMode.rendererCreateComment++;
  const commentNode = renderer.createComment(ngDevMode ? "container" : "");
  const hostNative = getNativeByTNode(hostTNode, hostLView);
  const parentOfHostNative = nativeParentNode(renderer, hostNative);
  nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);
  return commentNode;
}
var _locateOrCreateAnchorNode = createAnchorNode;
var _populateDehydratedViewsInLContainer = () => false;
function populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {
  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);
}
function createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {
  if (lContainer[NATIVE]) return;
  let commentNode;
  if (hostTNode.type & 8) {
    commentNode = unwrapRNode(slotValue);
  } else {
    commentNode = insertAnchorNode(hostLView, hostTNode);
  }
  lContainer[NATIVE] = commentNode;
}
var LQuery_ = class _LQuery_ {
  queryList;
  matches = null;
  constructor(queryList) {
    this.queryList = queryList;
  }
  clone() {
    return new _LQuery_(this.queryList);
  }
  setDirty() {
    this.queryList.setDirty();
  }
};
var LQueries_ = class _LQueries_ {
  queries;
  constructor(queries = []) {
    this.queries = queries;
  }
  createEmbeddedView(tView) {
    const tQueries = tView.queries;
    if (tQueries !== null) {
      const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
      const viewLQueries = [];
      for (let i = 0; i < noOfInheritedQueries; i++) {
        const tQuery = tQueries.getByIndex(i);
        const parentLQuery = this.queries[tQuery.indexInDeclarationView];
        viewLQueries.push(parentLQuery.clone());
      }
      return new _LQueries_(viewLQueries);
    }
    return null;
  }
  insertView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  detachView(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  finishViewCreation(tView) {
    this.dirtyQueriesWithMatches(tView);
  }
  dirtyQueriesWithMatches(tView) {
    for (let i = 0; i < this.queries.length; i++) {
      if (getTQuery(tView, i).matches !== null) {
        this.queries[i].setDirty();
      }
    }
  }
};
var TQueryMetadata_ = class {
  flags;
  read;
  predicate;
  constructor(predicate, flags, read = null) {
    this.flags = flags;
    this.read = read;
    if (typeof predicate === "string") {
      this.predicate = splitQueryMultiSelectors(predicate);
    } else {
      this.predicate = predicate;
    }
  }
};
var TQueries_ = class _TQueries_ {
  queries;
  constructor(queries = []) {
    this.queries = queries;
  }
  elementStart(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementStart(tView, tNode);
    }
  }
  elementEnd(tNode) {
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].elementEnd(tNode);
    }
  }
  embeddedTView(tNode) {
    let queriesForTemplateRef = null;
    for (let i = 0; i < this.length; i++) {
      const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
      const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
      if (tqueryClone) {
        tqueryClone.indexInDeclarationView = i;
        if (queriesForTemplateRef !== null) {
          queriesForTemplateRef.push(tqueryClone);
        } else {
          queriesForTemplateRef = [tqueryClone];
        }
      }
    }
    return queriesForTemplateRef !== null ? new _TQueries_(queriesForTemplateRef) : null;
  }
  template(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
    for (let i = 0; i < this.queries.length; i++) {
      this.queries[i].template(tView, tNode);
    }
  }
  getByIndex(index) {
    ngDevMode && assertIndexInRange(this.queries, index);
    return this.queries[index];
  }
  get length() {
    return this.queries.length;
  }
  track(tquery) {
    this.queries.push(tquery);
  }
};
var TQuery_ = class _TQuery_ {
  metadata;
  matches = null;
  indexInDeclarationView = -1;
  crossesNgTemplate = false;
  /**
   * A node index on which a query was declared (-1 for view queries and ones inherited from the
   * declaration template). We use this index (alongside with _appliesToNextNode flag) to know
   * when to apply content queries to elements in a template.
   */
  _declarationNodeIndex;
  /**
   * A flag indicating if a given query still applies to nodes it is crossing. We use this flag
   * (alongside with _declarationNodeIndex) to know when to stop applying content queries to
   * elements in a template.
   */
  _appliesToNextNode = true;
  constructor(metadata, nodeIndex = -1) {
    this.metadata = metadata;
    this._declarationNodeIndex = nodeIndex;
  }
  elementStart(tView, tNode) {
    if (this.isApplyingToNode(tNode)) {
      this.matchTNode(tView, tNode);
    }
  }
  elementEnd(tNode) {
    if (this._declarationNodeIndex === tNode.index) {
      this._appliesToNextNode = false;
    }
  }
  template(tView, tNode) {
    this.elementStart(tView, tNode);
  }
  embeddedTView(tNode, childQueryIndex) {
    if (this.isApplyingToNode(tNode)) {
      this.crossesNgTemplate = true;
      this.addMatch(-tNode.index, childQueryIndex);
      return new _TQuery_(this.metadata);
    }
    return null;
  }
  isApplyingToNode(tNode) {
    if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
      const declarationNodeIdx = this._declarationNodeIndex;
      let parent = tNode.parent;
      while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
        parent = parent.parent;
      }
      return declarationNodeIdx === (parent !== null ? parent.index : -1);
    }
    return this._appliesToNextNode;
  }
  matchTNode(tView, tNode) {
    const predicate = this.metadata.predicate;
    if (Array.isArray(predicate)) {
      for (let i = 0; i < predicate.length; i++) {
        const name = predicate[i];
        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
      }
    } else {
      if (predicate === TemplateRef) {
        if (tNode.type & 4) {
          this.matchTNodeWithReadOption(tView, tNode, -1);
        }
      } else {
        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
      }
    }
  }
  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
    if (nodeMatchIdx !== null) {
      const read = this.metadata.read;
      if (read !== null) {
        if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
          this.addMatch(tNode.index, -2);
        } else {
          const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
          if (directiveOrProviderIdx !== null) {
            this.addMatch(tNode.index, directiveOrProviderIdx);
          }
        }
      } else {
        this.addMatch(tNode.index, nodeMatchIdx);
      }
    }
  }
  addMatch(tNodeIdx, matchIdx) {
    if (this.matches === null) {
      this.matches = [tNodeIdx, matchIdx];
    } else {
      this.matches.push(tNodeIdx, matchIdx);
    }
  }
};
function getIdxOfMatchingSelector(tNode, selector) {
  const localNames = tNode.localNames;
  if (localNames !== null) {
    for (let i = 0; i < localNames.length; i += 2) {
      if (localNames[i] === selector) {
        return localNames[i + 1];
      }
    }
  }
  return null;
}
function createResultByTNodeType(tNode, currentView) {
  if (tNode.type & (3 | 8)) {
    return createElementRef(tNode, currentView);
  } else if (tNode.type & 4) {
    return createTemplateRef(tNode, currentView);
  }
  return null;
}
function createResultForNode(lView, tNode, matchingIdx, read) {
  if (matchingIdx === -1) {
    return createResultByTNodeType(tNode, lView);
  } else if (matchingIdx === -2) {
    return createSpecialToken(lView, tNode, read);
  } else {
    return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
  }
}
function createSpecialToken(lView, tNode, read) {
  if (read === ElementRef) {
    return createElementRef(tNode, lView);
  } else if (read === TemplateRef) {
    return createTemplateRef(tNode, lView);
  } else if (read === ViewContainerRef) {
    ngDevMode && assertTNodeType(
      tNode,
      3 | 12
      /* TNodeType.AnyContainer */
    );
    return createContainerRef(tNode, lView);
  } else {
    ngDevMode && throwError2(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
  }
}
function materializeViewResults(tView, lView, tQuery, queryIndex) {
  const lQuery = lView[QUERIES].queries[queryIndex];
  if (lQuery.matches === null) {
    const tViewData = tView.data;
    const tQueryMatches = tQuery.matches;
    const result = [];
    for (let i = 0; tQueryMatches !== null && i < tQueryMatches.length; i += 2) {
      const matchedNodeIdx = tQueryMatches[i];
      if (matchedNodeIdx < 0) {
        result.push(null);
      } else {
        ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
        const tNode = tViewData[matchedNodeIdx];
        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
      }
    }
    lQuery.matches = result;
  }
  return lQuery.matches;
}
function collectQueryResults(tView, lView, queryIndex, result) {
  const tQuery = tView.queries.getByIndex(queryIndex);
  const tQueryMatches = tQuery.matches;
  if (tQueryMatches !== null) {
    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
    for (let i = 0; i < tQueryMatches.length; i += 2) {
      const tNodeIdx = tQueryMatches[i];
      if (tNodeIdx > 0) {
        result.push(lViewResults[i / 2]);
      } else {
        const childQueryIndex = tQueryMatches[i + 1];
        const declarationLContainer = lView[-tNodeIdx];
        ngDevMode && assertLContainer(declarationLContainer);
        for (let i2 = CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {
          const embeddedLView = declarationLContainer[i2];
          if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
        if (declarationLContainer[MOVED_VIEWS] !== null) {
          const embeddedLViews = declarationLContainer[MOVED_VIEWS];
          for (let i2 = 0; i2 < embeddedLViews.length; i2++) {
            const embeddedLView = embeddedLViews[i2];
            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
          }
        }
      }
    }
  }
  return result;
}
function loadQueryInternal(lView, queryIndex) {
  ngDevMode && assertDefined(lView[QUERIES], "LQueries should be defined when trying to load a query");
  ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
  return lView[QUERIES].queries[queryIndex].queryList;
}
function createLQuery(tView, lView, flags) {
  const queryList = new QueryList(
    (flags & 4) === 4
    /* QueryFlags.emitDistinctChangesOnly */
  );
  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
  const lQueries = (lView[QUERIES] ??= new LQueries_()).queries;
  return lQueries.push(new LQuery_(queryList)) - 1;
}
function createViewQuery(predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
    if ((flags & 2) === 2) {
      tView.staticViewQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function createContentQuery(directiveIndex, predicate, flags, read) {
  ngDevMode && assertNumber(flags, "Expecting flags");
  const tView = getTView();
  if (tView.firstCreatePass) {
    const tNode = getCurrentTNode();
    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
    saveContentQueryAndDirectiveIndex(tView, directiveIndex);
    if ((flags & 2) === 2) {
      tView.staticContentQueries = true;
    }
  }
  return createLQuery(tView, getLView(), flags);
}
function splitQueryMultiSelectors(locator) {
  return locator.split(",").map((s2) => s2.trim());
}
function createTQuery(tView, metadata, nodeIndex) {
  if (tView.queries === null) tView.queries = new TQueries_();
  tView.queries.track(new TQuery_(metadata, nodeIndex));
}
function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
  if (directiveIndex !== lastSavedDirectiveIndex) {
    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
  }
}
function getTQuery(tView, index) {
  ngDevMode && assertDefined(tView.queries, "TQueries must be defined to retrieve a TQuery");
  return tView.queries.getByIndex(index);
}
function getQueryResults(lView, queryIndex) {
  const tView = lView[TVIEW];
  const tQuery = getTQuery(tView, queryIndex);
  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
}
function isSignal(value2) {
  return typeof value2 === "function" && value2[SIGNAL] !== void 0;
}
function signal(initialValue, options) {
  performanceMarkFeature("NgSignals");
  const signalFn = createSignal(initialValue);
  const node = signalFn[SIGNAL];
  if (options?.equal) {
    node.equal = options.equal;
  }
  signalFn.set = (newValue) => signalSetFn(node, newValue);
  signalFn.update = (updateFn) => signalUpdateFn(node, updateFn);
  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);
  if (ngDevMode) {
    signalFn.toString = () => `[Signal: ${signalFn()}]`;
    node.debugName = options?.debugName;
  }
  return signalFn;
}
function signalAsReadonlyFn() {
  const node = this[SIGNAL];
  if (node.readonlyFn === void 0) {
    const readonlyFn = () => this();
    readonlyFn[SIGNAL] = node;
    node.readonlyFn = readonlyFn;
  }
  return node.readonlyFn;
}
function isWritableSignal(value2) {
  return isSignal(value2) && typeof value2.set === "function";
}
function createQuerySignalFn(firstOnly, required2, opts) {
  let node;
  const signalFn = createComputed(() => {
    node._dirtyCounter();
    const value2 = refreshSignalQuery(node, firstOnly);
    if (required2 && value2 === void 0) {
      throw new RuntimeError(-951, ngDevMode && "Child query result is required but no value is available.");
    }
    return value2;
  });
  node = signalFn[SIGNAL];
  node._dirtyCounter = signal(0);
  node._flatValue = void 0;
  if (ngDevMode) {
    signalFn.toString = () => `[Query Signal]`;
    node.debugName = opts?.debugName;
  }
  return signalFn;
}
function createSingleResultOptionalQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    false,
    opts
  );
}
function createSingleResultRequiredQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    true,
    /* required */
    true,
    opts
  );
}
function createMultiResultQuerySignalFn(opts) {
  return createQuerySignalFn(
    /* firstOnly */
    false,
    /* required */
    false,
    opts
  );
}
function bindQueryToSignal(target, queryIndex) {
  const node = target[SIGNAL];
  node._lView = getLView();
  node._queryIndex = queryIndex;
  node._queryList = loadQueryInternal(node._lView, queryIndex);
  node._queryList.onDirty(() => node._dirtyCounter.update((v) => v + 1));
}
function refreshSignalQuery(node, firstOnly) {
  const lView = node._lView;
  const queryIndex = node._queryIndex;
  if (lView === void 0 || queryIndex === void 0 || lView[FLAGS] & 4) {
    return firstOnly ? void 0 : EMPTY_ARRAY;
  }
  const queryList = loadQueryInternal(lView, queryIndex);
  const results = getQueryResults(lView, queryIndex);
  queryList.reset(results, unwrapElementRef);
  if (firstOnly) {
    return queryList.first;
  } else {
    const resultChanged = queryList._changesDetected;
    if (resultChanged || node._flatValue === void 0) {
      return node._flatValue = queryList.toArray();
    }
    return node._flatValue;
  }
}
function viewChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultOptionalQuerySignalFn(opts);
}
function viewChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(viewChild);
  return createSingleResultRequiredQuerySignalFn(opts);
}
var viewChild = (() => {
  viewChildFn.required = viewChildRequiredFn;
  return viewChildFn;
})();
function contentChildFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChild);
  return createSingleResultOptionalQuerySignalFn(opts);
}
function contentChildRequiredFn(locator, opts) {
  ngDevMode && assertInInjectionContext(contentChildren);
  return createSingleResultRequiredQuerySignalFn(opts);
}
var contentChild = (() => {
  contentChildFn.required = contentChildRequiredFn;
  return contentChildFn;
})();
function contentChildren(locator, opts) {
  return createMultiResultQuerySignalFn(opts);
}
function createModelSignal(initialValue, opts) {
  const node = Object.create(INPUT_SIGNAL_NODE);
  const emitterRef = new OutputEmitterRef();
  node.value = initialValue;
  function getter() {
    producerAccessed(node);
    assertModelSet(node.value);
    return node.value;
  }
  getter[SIGNAL] = node;
  getter.asReadonly = signalAsReadonlyFn.bind(getter);
  getter.set = (newValue) => {
    if (!node.equal(node.value, newValue)) {
      signalSetFn(node, newValue);
      emitterRef.emit(newValue);
    }
  };
  getter.update = (updateFn) => {
    assertModelSet(node.value);
    getter.set(updateFn(node.value));
  };
  getter.subscribe = emitterRef.subscribe.bind(emitterRef);
  getter.destroyRef = emitterRef.destroyRef;
  if (ngDevMode) {
    getter.toString = () => `[Model Signal: ${getter()}]`;
    node.debugName = opts?.debugName;
  }
  return getter;
}
function assertModelSet(value2) {
  if (value2 === REQUIRED_UNSET_VALUE) {
    throw new RuntimeError(952, ngDevMode && "Model is required but no value is available yet.");
  }
}
function modelFunction(initialValue, opts) {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(initialValue, opts);
}
function modelRequiredFunction(opts) {
  ngDevMode && assertInInjectionContext(model);
  return createModelSignal(REQUIRED_UNSET_VALUE, opts);
}
var model = (() => {
  modelFunction.required = modelRequiredFunction;
  return modelFunction;
})();
var emitDistinctChangesOnlyDefaultValue = true;
var Query = class {
};
var ContentChildren = makePropDecorator("ContentChildren", (selector, opts = {}) => __spreadValues({
  selector,
  first: false,
  isViewQuery: false,
  descendants: false,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
}, opts), Query);
var ContentChild = makePropDecorator("ContentChild", (selector, opts = {}) => __spreadValues({
  selector,
  first: true,
  isViewQuery: false,
  descendants: true
}, opts), Query);
var ViewChildren = makePropDecorator("ViewChildren", (selector, opts = {}) => __spreadValues({
  selector,
  first: false,
  isViewQuery: true,
  descendants: true,
  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue
}, opts), Query);
var ViewChild = makePropDecorator("ViewChild", (selector, opts) => __spreadValues({
  selector,
  first: true,
  isViewQuery: true,
  descendants: true
}, opts), Query);
function resolveComponentResources(resourceResolver) {
  const componentResolved = [];
  const urlMap = /* @__PURE__ */ new Map();
  function cachedResourceResolve(url) {
    let promise = urlMap.get(url);
    if (!promise) {
      const resp = resourceResolver(url);
      urlMap.set(url, promise = resp.then(unwrapResponse));
    }
    return promise;
  }
  componentResourceResolutionQueue.forEach((component, type2) => {
    const promises = [];
    if (component.templateUrl) {
      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
        component.template = template;
      }));
    }
    const styles2 = typeof component.styles === "string" ? [component.styles] : component.styles || [];
    component.styles = styles2;
    if (component.styleUrl && component.styleUrls?.length) {
      throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");
    } else if (component.styleUrls?.length) {
      const styleOffset = component.styles.length;
      const styleUrls = component.styleUrls;
      component.styleUrls.forEach((styleUrl, index) => {
        styles2.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style2) => {
          styles2[styleOffset + index] = style2;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
    } else if (component.styleUrl) {
      promises.push(cachedResourceResolve(component.styleUrl).then((style2) => {
        styles2.push(style2);
        component.styleUrl = void 0;
      }));
    }
    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type2));
    componentResolved.push(fullyResolved);
  });
  clearResolutionOfComponentResourcesQueue();
  return Promise.all(componentResolved).then(() => void 0);
}
var componentResourceResolutionQueue = /* @__PURE__ */ new Map();
var componentDefPendingResolution = /* @__PURE__ */ new Set();
function maybeQueueResolutionOfComponentResources(type2, metadata) {
  if (componentNeedsResolution(metadata)) {
    componentResourceResolutionQueue.set(type2, metadata);
    componentDefPendingResolution.add(type2);
  }
}
function componentNeedsResolution(component) {
  return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length || component.styleUrl);
}
function clearResolutionOfComponentResourcesQueue() {
  const old = componentResourceResolutionQueue;
  componentResourceResolutionQueue = /* @__PURE__ */ new Map();
  return old;
}
function isComponentResourceResolutionQueueEmpty() {
  return componentResourceResolutionQueue.size === 0;
}
function unwrapResponse(response) {
  return typeof response == "string" ? response : response.text();
}
function componentDefResolved(type2) {
  componentDefPendingResolution.delete(type2);
}
var modules = /* @__PURE__ */ new Map();
var checkForDuplicateNgModules = true;
function assertSameOrNotExisting(id3, type2, incoming) {
  if (type2 && type2 !== incoming && checkForDuplicateNgModules) {
    throw new Error(`Duplicate module registered for ${id3} - ${stringify(type2)} vs ${stringify(type2.name)}`);
  }
}
function registerNgModuleType(ngModuleType, id3) {
  const existing = modules.get(id3) || null;
  assertSameOrNotExisting(id3, existing, ngModuleType);
  modules.set(id3, ngModuleType);
}
function \u0275\u0275validateIframeAttribute(attrValue, tagName, attrName) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  const element = getNativeByTNode(tNode, lView);
  if (tNode.type === 2 && tagName.toLowerCase() === "iframe") {
    const iframe = element;
    iframe.src = "";
    iframe.srcdoc = trustedHTMLFromString("");
    nativeRemoveNode(lView[RENDERER], iframe);
    const errorMessage = ngDevMode && `Angular has detected that the \`${attrName}\` was applied as a binding to an <iframe>${getTemplateLocationDetails(lView)}. For security reasons, the \`${attrName}\` can be set on an <iframe> as a static attribute only. 
To fix this, switch the \`${attrName}\` binding to a static attribute in a template or in host bindings section.`;
    throw new RuntimeError(-910, errorMessage);
  }
  return attrValue;
}
var NgModuleRef$1 = class {
};
var NgModuleFactory$1 = class {
};
function createNgModule(ngModule, parentInjector) {
  return new NgModuleRef(ngModule, parentInjector ?? null, []);
}
var NgModuleRef = class extends NgModuleRef$1 {
  ngModuleType;
  _parent;
  // tslint:disable-next-line:require-internal-with-underscore
  _bootstrapComponents = [];
  // tslint:disable-next-line:require-internal-with-underscore
  _r3Injector;
  instance;
  destroyCbs = [];
  // When bootstrapping a module we have a dependency graph that looks like this:
  // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the
  // module being resolved tries to inject the ComponentFactoryResolver, it'll create a
  // circular dependency which will result in a runtime error, because the injector doesn't
  // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves
  // and providing it, rather than letting the injector resolve it.
  componentFactoryResolver = new ComponentFactoryResolver(this);
  constructor(ngModuleType, _parent, additionalProviders, runInjectorInitializers = true) {
    super();
    this.ngModuleType = ngModuleType;
    this._parent = _parent;
    const ngModuleDef = getNgModuleDef(ngModuleType);
    ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
    this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
    this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [{
      provide: NgModuleRef$1,
      useValue: this
    }, {
      provide: ComponentFactoryResolver$1,
      useValue: this.componentFactoryResolver
    }, ...additionalProviders], stringify(ngModuleType), /* @__PURE__ */ new Set(["environment"]));
    if (runInjectorInitializers) {
      this.resolveInjectorInitializers();
    }
  }
  resolveInjectorInitializers() {
    this._r3Injector.resolveInjectorInitializers();
    this.instance = this._r3Injector.get(this.ngModuleType);
  }
  get injector() {
    return this._r3Injector;
  }
  destroy() {
    ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
    const injector = this._r3Injector;
    !injector.destroyed && injector.destroy();
    this.destroyCbs.forEach((fn) => fn());
    this.destroyCbs = null;
  }
  onDestroy(callback) {
    ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
    this.destroyCbs.push(callback);
  }
};
var NgModuleFactory = class extends NgModuleFactory$1 {
  moduleType;
  constructor(moduleType) {
    super();
    this.moduleType = moduleType;
  }
  create(parentInjector) {
    return new NgModuleRef(this.moduleType, parentInjector, []);
  }
};
function createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {
  return new NgModuleRef(moduleType, parentInjector, additionalProviders, false);
}
var EnvironmentNgModuleRefAdapter = class extends NgModuleRef$1 {
  injector;
  componentFactoryResolver = new ComponentFactoryResolver(this);
  instance = null;
  constructor(config3) {
    super();
    const injector = new R3Injector([...config3.providers, {
      provide: NgModuleRef$1,
      useValue: this
    }, {
      provide: ComponentFactoryResolver$1,
      useValue: this.componentFactoryResolver
    }], config3.parent || getNullInjector(), config3.debugName, /* @__PURE__ */ new Set(["environment"]));
    this.injector = injector;
    if (config3.runEnvironmentInitializers) {
      injector.resolveInjectorInitializers();
    }
  }
  destroy() {
    this.injector.destroy();
  }
  onDestroy(callback) {
    this.injector.onDestroy(callback);
  }
};
function createEnvironmentInjector(providers2, parent, debugName = null) {
  const adapter = new EnvironmentNgModuleRefAdapter({
    providers: providers2,
    parent,
    debugName,
    runEnvironmentInitializers: true
  });
  return adapter.injector;
}
var StandaloneService = class _StandaloneService {
  _injector;
  cachedInjectors = /* @__PURE__ */ new Map();
  constructor(_injector) {
    this._injector = _injector;
  }
  getOrCreateStandaloneInjector(componentDef) {
    if (!componentDef.standalone) {
      return null;
    }
    if (!this.cachedInjectors.has(componentDef)) {
      const providers2 = internalImportProvidersFrom(false, componentDef.type);
      const standaloneInjector = providers2.length > 0 ? createEnvironmentInjector([providers2], this._injector, `Standalone[${componentDef.type.name}]`) : null;
      this.cachedInjectors.set(componentDef, standaloneInjector);
    }
    return this.cachedInjectors.get(componentDef);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _StandaloneService,
      providedIn: "environment",
      factory: () => new _StandaloneService(\u0275\u0275inject(EnvironmentInjector))
    })
  );
};
function \u0275\u0275defineComponent(componentDefinition) {
  return noSideEffects(() => {
    (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
    const baseDef = getNgDirectiveDef(componentDefinition);
    const def = __spreadProps(__spreadValues({}, baseDef), {
      decls: componentDefinition.decls,
      vars: componentDefinition.vars,
      template: componentDefinition.template,
      consts: componentDefinition.consts || null,
      ngContentSelectors: componentDefinition.ngContentSelectors,
      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
      directiveDefs: null,
      // assigned in noSideEffects
      pipeDefs: null,
      // assigned in noSideEffects
      dependencies: baseDef.standalone && componentDefinition.dependencies || null,
      getStandaloneInjector: baseDef.standalone ? (parentInjector) => {
        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(def);
      } : null,
      getExternalStyles: null,
      signals: componentDefinition.signals ?? false,
      data: componentDefinition.data || {},
      encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,
      styles: componentDefinition.styles || EMPTY_ARRAY,
      _: null,
      schemas: componentDefinition.schemas || null,
      tView: null,
      id: ""
    });
    if (baseDef.standalone) {
      performanceMarkFeature("NgStandalone");
    }
    initFeatures(def);
    const dependencies = componentDefinition.dependencies;
    def.directiveDefs = extractDefListOrFactory(
      dependencies,
      /* pipeDef */
      false
    );
    def.pipeDefs = extractDefListOrFactory(
      dependencies,
      /* pipeDef */
      true
    );
    def.id = getComponentId(def);
    return def;
  });
}
function extractDirectiveDef(type2) {
  return getComponentDef(type2) || getDirectiveDef(type2);
}
function nonNull(value2) {
  return value2 !== null;
}
function \u0275\u0275defineNgModule(def) {
  return noSideEffects(() => {
    const res = {
      type: def.type,
      bootstrap: def.bootstrap || EMPTY_ARRAY,
      declarations: def.declarations || EMPTY_ARRAY,
      imports: def.imports || EMPTY_ARRAY,
      exports: def.exports || EMPTY_ARRAY,
      transitiveCompileScopes: null,
      schemas: def.schemas || null,
      id: def.id || null
    };
    return res;
  });
}
function parseAndConvertBindingsForDefinition(obj, declaredInputs) {
  if (obj == null) return EMPTY_OBJ;
  const newLookup = {};
  for (const minifiedKey in obj) {
    if (obj.hasOwnProperty(minifiedKey)) {
      const value2 = obj[minifiedKey];
      let publicName;
      let declaredName;
      let inputFlags = InputFlags.None;
      if (Array.isArray(value2)) {
        inputFlags = value2[0];
        publicName = value2[1];
        declaredName = value2[2] ?? publicName;
      } else {
        publicName = value2;
        declaredName = value2;
      }
      if (declaredInputs) {
        newLookup[publicName] = inputFlags !== InputFlags.None ? [minifiedKey, inputFlags] : minifiedKey;
        declaredInputs[publicName] = declaredName;
      } else {
        newLookup[publicName] = minifiedKey;
      }
    }
  }
  return newLookup;
}
function \u0275\u0275defineDirective(directiveDefinition) {
  return noSideEffects(() => {
    const def = getNgDirectiveDef(directiveDefinition);
    initFeatures(def);
    return def;
  });
}
function \u0275\u0275definePipe(pipeDef) {
  return {
    type: pipeDef.type,
    name: pipeDef.name,
    factory: null,
    pure: pipeDef.pure !== false,
    standalone: pipeDef.standalone ?? true,
    onDestroy: pipeDef.type.prototype.ngOnDestroy || null
  };
}
function getNgDirectiveDef(directiveDefinition) {
  const declaredInputs = {};
  return {
    type: directiveDefinition.type,
    providersResolver: null,
    factory: null,
    hostBindings: directiveDefinition.hostBindings || null,
    hostVars: directiveDefinition.hostVars || 0,
    hostAttrs: directiveDefinition.hostAttrs || null,
    contentQueries: directiveDefinition.contentQueries || null,
    declaredInputs,
    inputTransforms: null,
    inputConfig: directiveDefinition.inputs || EMPTY_OBJ,
    exportAs: directiveDefinition.exportAs || null,
    standalone: directiveDefinition.standalone ?? true,
    signals: directiveDefinition.signals === true,
    selectors: directiveDefinition.selectors || EMPTY_ARRAY,
    viewQuery: directiveDefinition.viewQuery || null,
    features: directiveDefinition.features || null,
    setInput: null,
    findHostDirectiveDefs: null,
    hostDirectives: null,
    inputs: parseAndConvertBindingsForDefinition(directiveDefinition.inputs, declaredInputs),
    outputs: parseAndConvertBindingsForDefinition(directiveDefinition.outputs),
    debugInfo: null
  };
}
function initFeatures(definition) {
  definition.features?.forEach((fn) => fn(definition));
}
function extractDefListOrFactory(dependencies, pipeDef) {
  if (!dependencies) {
    return null;
  }
  const defExtractor = pipeDef ? getPipeDef$1 : extractDirectiveDef;
  return () => (typeof dependencies === "function" ? dependencies() : dependencies).map((dep) => defExtractor(dep)).filter(nonNull);
}
var GENERATED_COMP_IDS = /* @__PURE__ */ new Map();
function getComponentId(componentDef) {
  let hash = 0;
  const componentDefConsts = typeof componentDef.consts === "function" ? "" : componentDef.consts;
  const hashSelectors = [
    componentDef.selectors,
    componentDef.ngContentSelectors,
    componentDef.hostVars,
    componentDef.hostAttrs,
    componentDefConsts,
    componentDef.vars,
    componentDef.decls,
    componentDef.encapsulation,
    componentDef.standalone,
    componentDef.signals,
    componentDef.exportAs,
    JSON.stringify(componentDef.inputs),
    JSON.stringify(componentDef.outputs),
    // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not
    // match in the server and browser bundles.
    Object.getOwnPropertyNames(componentDef.type.prototype),
    !!componentDef.contentQueries,
    !!componentDef.viewQuery
  ];
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    for (const item of hashSelectors) {
      assertNotEqual(typeof item, "function", "Internal error: attempting to use a function in component id computation logic.");
    }
  }
  for (const char of hashSelectors.join("|")) {
    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;
  }
  hash += 2147483647 + 1;
  const compId = "c" + hash;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (GENERATED_COMP_IDS.has(compId)) {
      const previousCompDefType = GENERATED_COMP_IDS.get(compId);
      if (previousCompDefType !== componentDef.type) {
        console.warn(formatRuntimeError(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));
      }
    } else {
      GENERATED_COMP_IDS.set(compId, componentDef.type);
    }
  }
  return compId;
}
function getSuperType(type2) {
  return Object.getPrototypeOf(type2.prototype).constructor;
}
function \u0275\u0275InheritDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let shouldInheritFields = true;
  const inheritanceChain = [definition];
  while (superType) {
    let superDef = void 0;
    if (isComponentDef(definition)) {
      superDef = superType.\u0275cmp || superType.\u0275dir;
    } else {
      if (superType.\u0275cmp) {
        throw new RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);
      }
      superDef = superType.\u0275dir;
    }
    if (superDef) {
      if (shouldInheritFields) {
        inheritanceChain.push(superDef);
        const writeableDef = definition;
        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
        writeableDef.inputTransforms = maybeUnwrapEmpty(definition.inputTransforms);
        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        const superHostBindings = superDef.hostBindings;
        superHostBindings && inheritHostBindings(definition, superHostBindings);
        const superViewQuery = superDef.viewQuery;
        const superContentQueries = superDef.contentQueries;
        superViewQuery && inheritViewQuery(definition, superViewQuery);
        superContentQueries && inheritContentQueries(definition, superContentQueries);
        mergeInputsWithTransforms(definition, superDef);
        fillProperties(definition.outputs, superDef.outputs);
        if (isComponentDef(superDef) && superDef.data.animation) {
          const defData = definition.data;
          defData.animation = (defData.animation || []).concat(superDef.data.animation);
        }
      }
      const features = superDef.features;
      if (features) {
        for (let i = 0; i < features.length; i++) {
          const feature = features[i];
          if (feature && feature.ngInherit) {
            feature(definition);
          }
          if (feature === \u0275\u0275InheritDefinitionFeature) {
            shouldInheritFields = false;
          }
        }
      }
    }
    superType = Object.getPrototypeOf(superType);
  }
  mergeHostAttrsAcrossInheritance(inheritanceChain);
}
function mergeInputsWithTransforms(target, source) {
  for (const key in source.inputs) {
    if (!source.inputs.hasOwnProperty(key)) {
      continue;
    }
    if (target.inputs.hasOwnProperty(key)) {
      continue;
    }
    const value2 = source.inputs[key];
    if (value2 === void 0) {
      continue;
    }
    target.inputs[key] = value2;
    target.declaredInputs[key] = source.declaredInputs[key];
    if (source.inputTransforms !== null) {
      const minifiedName = Array.isArray(value2) ? value2[0] : value2;
      if (!source.inputTransforms.hasOwnProperty(minifiedName)) {
        continue;
      }
      target.inputTransforms ??= {};
      target.inputTransforms[minifiedName] = source.inputTransforms[minifiedName];
    }
  }
}
function mergeHostAttrsAcrossInheritance(inheritanceChain) {
  let hostVars = 0;
  let hostAttrs = null;
  for (let i = inheritanceChain.length - 1; i >= 0; i--) {
    const def = inheritanceChain[i];
    def.hostVars = hostVars += def.hostVars;
    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
  }
}
function maybeUnwrapEmpty(value2) {
  if (value2 === EMPTY_OBJ) {
    return {};
  } else if (value2 === EMPTY_ARRAY) {
    return [];
  } else {
    return value2;
  }
}
function inheritViewQuery(definition, superViewQuery) {
  const prevViewQuery = definition.viewQuery;
  if (prevViewQuery) {
    definition.viewQuery = (rf, ctx) => {
      superViewQuery(rf, ctx);
      prevViewQuery(rf, ctx);
    };
  } else {
    definition.viewQuery = superViewQuery;
  }
}
function inheritContentQueries(definition, superContentQueries) {
  const prevContentQueries = definition.contentQueries;
  if (prevContentQueries) {
    definition.contentQueries = (rf, ctx, directiveIndex) => {
      superContentQueries(rf, ctx, directiveIndex);
      prevContentQueries(rf, ctx, directiveIndex);
    };
  } else {
    definition.contentQueries = superContentQueries;
  }
}
function inheritHostBindings(definition, superHostBindings) {
  const prevHostBindings = definition.hostBindings;
  if (prevHostBindings) {
    definition.hostBindings = (rf, ctx) => {
      superHostBindings(rf, ctx);
      prevHostBindings(rf, ctx);
    };
  } else {
    definition.hostBindings = superHostBindings;
  }
}
var COPY_DIRECTIVE_FIELDS = [
  // The child class should use the providers of its parent.
  "providersResolver"
  // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such
  // as inputs, outputs, and host binding functions.
];
var COPY_COMPONENT_FIELDS = [
  // The child class should use the template function of its parent, including all template
  // semantics.
  "template",
  "decls",
  "consts",
  "vars",
  "onPush",
  "ngContentSelectors",
  // The child class should use the CSS styles of its parent, including all styling semantics.
  "styles",
  "encapsulation",
  // The child class should be checked by the runtime in the same way as its parent.
  "schemas"
];
function \u0275\u0275CopyDefinitionFeature(definition) {
  let superType = getSuperType(definition.type);
  let superDef = void 0;
  if (isComponentDef(definition)) {
    superDef = superType.\u0275cmp;
  } else {
    superDef = superType.\u0275dir;
  }
  const defAny = definition;
  for (const field of COPY_DIRECTIVE_FIELDS) {
    defAny[field] = superDef[field];
  }
  if (isComponentDef(superDef)) {
    for (const field of COPY_COMPONENT_FIELDS) {
      defAny[field] = superDef[field];
    }
  }
}
function \u0275\u0275HostDirectivesFeature(rawHostDirectives) {
  const feature = (definition) => {
    const isEager = Array.isArray(rawHostDirectives);
    if (definition.hostDirectives === null) {
      definition.findHostDirectiveDefs = findHostDirectiveDefs;
      definition.hostDirectives = isEager ? rawHostDirectives.map(createHostDirectiveDef) : [rawHostDirectives];
    } else if (isEager) {
      definition.hostDirectives.unshift(...rawHostDirectives.map(createHostDirectiveDef));
    } else {
      definition.hostDirectives.unshift(rawHostDirectives);
    }
  };
  feature.ngInherit = true;
  return feature;
}
function findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {
  if (currentDef.hostDirectives !== null) {
    for (const configOrFn of currentDef.hostDirectives) {
      if (typeof configOrFn === "function") {
        const resolved = configOrFn();
        for (const config3 of resolved) {
          trackHostDirectiveDef(createHostDirectiveDef(config3), matchedDefs, hostDirectiveDefs);
        }
      } else {
        trackHostDirectiveDef(configOrFn, matchedDefs, hostDirectiveDefs);
      }
    }
  }
}
function trackHostDirectiveDef(def, matchedDefs, hostDirectiveDefs) {
  const hostDirectiveDef = getDirectiveDef(def.directive);
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    validateHostDirective(def, hostDirectiveDef);
  }
  patchDeclaredInputs(hostDirectiveDef.declaredInputs, def.inputs);
  findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);
  hostDirectiveDefs.set(hostDirectiveDef, def);
  matchedDefs.push(hostDirectiveDef);
}
function createHostDirectiveDef(config3) {
  return typeof config3 === "function" ? {
    directive: resolveForwardRef(config3),
    inputs: EMPTY_OBJ,
    outputs: EMPTY_OBJ
  } : {
    directive: resolveForwardRef(config3.directive),
    inputs: bindingArrayToMap(config3.inputs),
    outputs: bindingArrayToMap(config3.outputs)
  };
}
function bindingArrayToMap(bindings) {
  if (bindings === void 0 || bindings.length === 0) {
    return EMPTY_OBJ;
  }
  const result = {};
  for (let i = 0; i < bindings.length; i += 2) {
    result[bindings[i]] = bindings[i + 1];
  }
  return result;
}
function patchDeclaredInputs(declaredInputs, exposedInputs) {
  for (const publicName in exposedInputs) {
    if (exposedInputs.hasOwnProperty(publicName)) {
      const remappedPublicName = exposedInputs[publicName];
      const privateName = declaredInputs[publicName];
      if ((typeof ngDevMode === "undefined" || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {
        assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);
      }
      declaredInputs[remappedPublicName] = privateName;
    }
  }
}
function validateHostDirective(hostDirectiveConfig, directiveDef) {
  const type2 = hostDirectiveConfig.directive;
  if (directiveDef === null) {
    if (getComponentDef(type2) !== null) {
      throw new RuntimeError(310, `Host directive ${type2.name} cannot be a component.`);
    }
    throw new RuntimeError(307, `Could not resolve metadata for host directive ${type2.name}. Make sure that the ${type2.name} class is annotated with an @Directive decorator.`);
  }
  if (!directiveDef.standalone) {
    throw new RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);
  }
  validateMappings("input", directiveDef, hostDirectiveConfig.inputs);
  validateMappings("output", directiveDef, hostDirectiveConfig.outputs);
}
function validateMappings(bindingType, def, hostDirectiveBindings) {
  const className = def.type.name;
  const bindings = bindingType === "input" ? def.inputs : def.outputs;
  for (const publicName in hostDirectiveBindings) {
    if (hostDirectiveBindings.hasOwnProperty(publicName)) {
      if (!bindings.hasOwnProperty(publicName)) {
        throw new RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);
      }
      const remappedPublicName = hostDirectiveBindings[publicName];
      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {
        throw new RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);
      }
    }
  }
}
function \u0275\u0275InputTransformsFeature(definition) {
  const inputs = definition.inputConfig;
  const inputTransforms = {};
  for (const minifiedKey in inputs) {
    if (inputs.hasOwnProperty(minifiedKey)) {
      const value2 = inputs[minifiedKey];
      if (Array.isArray(value2) && value2[3]) {
        inputTransforms[minifiedKey] = value2[3];
      }
    }
  }
  definition.inputTransforms = inputTransforms;
}
function isListLikeIterable(obj) {
  if (!isJsObject(obj)) return false;
  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
  Symbol.iterator in obj;
}
function areIterablesEqual(a, b, comparator) {
  const iterator1 = a[Symbol.iterator]();
  const iterator2 = b[Symbol.iterator]();
  while (true) {
    const item1 = iterator1.next();
    const item2 = iterator2.next();
    if (item1.done && item2.done) return true;
    if (item1.done || item2.done) return false;
    if (!comparator(item1.value, item2.value)) return false;
  }
}
function iterateListLike(obj, fn) {
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn(obj[i]);
    }
  } else {
    const iterator2 = obj[Symbol.iterator]();
    let item;
    while (!(item = iterator2.next()).done) {
      fn(item.value);
    }
  }
}
function isJsObject(o2) {
  return o2 !== null && (typeof o2 === "function" || typeof o2 === "object");
}
function devModeEqual(a, b) {
  const isListLikeIterableA = isListLikeIterable(a);
  const isListLikeIterableB = isListLikeIterable(b);
  if (isListLikeIterableA && isListLikeIterableB) {
    return areIterablesEqual(a, b, devModeEqual);
  } else {
    const isAObject = a && (typeof a === "object" || typeof a === "function");
    const isBObject = b && (typeof b === "object" || typeof b === "function");
    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
      return true;
    } else {
      return Object.is(a, b);
    }
  }
}
function updateBinding(lView, bindingIndex, value2) {
  return lView[bindingIndex] = value2;
}
function getBinding(lView, bindingIndex) {
  ngDevMode && assertIndexInRange(lView, bindingIndex);
  ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
  return lView[bindingIndex];
}
function bindingUpdated(lView, bindingIndex, value2) {
  ngDevMode && assertNotSame(value2, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
  ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
  const oldValue = lView[bindingIndex];
  if (Object.is(oldValue, value2)) {
    return false;
  } else {
    if (ngDevMode && isInCheckNoChangesMode()) {
      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
      if (!devModeEqual(oldValueToCompare, value2)) {
        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value2);
        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);
      }
      return false;
    }
    lView[bindingIndex] = value2;
    return true;
  }
}
function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
  const different = bindingUpdated(lView, bindingIndex, exp1);
  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
}
function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
}
function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
}
function isDetachedByI18n(tNode) {
  return (tNode.flags & 32) === 32;
}
function templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrs, localRefsIndex) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const tNode = getOrCreateTNode(tView, index, 4, tagName || null, attrs || null);
  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
  registerPostOrderHooks(tView, tNode);
  const embeddedTView = tNode.tView = createTView(
    2,
    tNode,
    templateFn,
    decls,
    vars,
    tView.directiveRegistry,
    tView.pipeRegistry,
    null,
    tView.schemas,
    tViewConsts,
    null
    /* ssrId */
  );
  if (tView.queries !== null) {
    tView.queries.template(tView, tNode);
    embeddedTView.queries = tView.queries.embeddedTView(tNode);
  }
  return tNode;
}
function declareTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, localRefsIndex, localRefExtractor) {
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = declarationTView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, declarationTView, declarationLView, templateFn, decls, vars, tagName, attrs, localRefsIndex) : declarationTView.data[adjustedIndex];
  setCurrentTNode(tNode, false);
  const comment = _locateOrCreateContainerAnchor(declarationTView, declarationLView, tNode, index);
  if (wasLastNodeCreated()) {
    appendChild(declarationTView, declarationLView, comment, tNode);
  }
  attachPatchData(comment, declarationLView);
  const lContainer = createLContainer(comment, declarationLView, comment, tNode);
  declarationLView[adjustedIndex] = lContainer;
  addToEndOfViewTree(declarationLView, lContainer);
  populateDehydratedViewsInLContainer(lContainer, tNode, declarationLView);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(declarationTView, declarationLView, tNode);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);
  }
  return tNode;
}
function \u0275\u0275template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
  const lView = getLView();
  const tView = getTView();
  const attrs = getConstant(tView.consts, attrsIndex);
  declareTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, localRefsIndex, localRefExtractor);
  return \u0275\u0275template;
}
var _locateOrCreateContainerAnchor = createContainerAnchorImpl;
function createContainerAnchorImpl(tView, lView, tNode, index) {
  lastNodeWasCreated(true);
  return lView[RENDERER].createComment(ngDevMode ? "container" : "");
}
function onIdle(callback, injector) {
  const scheduler = injector.get(IdleScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(callback);
  return cleanupFn;
}
var _requestIdleCallback = () => typeof requestIdleCallback !== "undefined" ? requestIdleCallback : setTimeout;
var _cancelIdleCallback = () => typeof requestIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
var IdleScheduler = class _IdleScheduler {
  // Indicates whether current callbacks are being invoked.
  executingCallbacks = false;
  // Currently scheduled idle callback id.
  idleId = null;
  // Set of callbacks to be invoked next.
  current = /* @__PURE__ */ new Set();
  // Set of callbacks collected while invoking current set of callbacks.
  // Those callbacks are scheduled for the next idle period.
  deferred = /* @__PURE__ */ new Set();
  ngZone = inject(NgZone);
  requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);
  cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);
  add(callback) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    target.add(callback);
    if (this.idleId === null) {
      this.scheduleIdleCallback();
    }
  }
  remove(callback) {
    const {
      current,
      deferred
    } = this;
    current.delete(callback);
    deferred.delete(callback);
    if (current.size === 0 && deferred.size === 0) {
      this.cancelIdleCallback();
    }
  }
  scheduleIdleCallback() {
    const callback = () => {
      this.cancelIdleCallback();
      this.executingCallbacks = true;
      for (const callback2 of this.current) {
        callback2();
      }
      this.current.clear();
      this.executingCallbacks = false;
      if (this.deferred.size > 0) {
        for (const callback2 of this.deferred) {
          this.current.add(callback2);
        }
        this.deferred.clear();
        this.scheduleIdleCallback();
      }
    };
    this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));
  }
  cancelIdleCallback() {
    if (this.idleId !== null) {
      this.cancelIdleCallbackFn(this.idleId);
      this.idleId = null;
    }
  }
  ngOnDestroy() {
    this.cancelIdleCallback();
    this.current.clear();
    this.deferred.clear();
  }
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _IdleScheduler,
      providedIn: "root",
      factory: () => new _IdleScheduler()
    })
  );
};
function onTimer(delay) {
  return (callback, injector) => scheduleTimerTrigger(delay, callback, injector);
}
function scheduleTimerTrigger(delay, callback, injector) {
  const scheduler = injector.get(TimerScheduler);
  const cleanupFn = () => scheduler.remove(callback);
  scheduler.add(delay, callback);
  return cleanupFn;
}
var TimerScheduler = class _TimerScheduler {
  // Indicates whether current callbacks are being invoked.
  executingCallbacks = false;
  // Currently scheduled `setTimeout` id.
  timeoutId = null;
  // When currently scheduled timer would fire.
  invokeTimerAt = null;
  // List of callbacks to be invoked.
  // For each callback we also store a timestamp on when the callback
  // should be invoked. We store timestamps and callback functions
  // in a flat array to avoid creating new objects for each entry.
  // [timestamp1, callback1, timestamp2, callback2, ...]
  current = [];
  // List of callbacks collected while invoking current set of callbacks.
  // Those callbacks are added to the "current" queue at the end of
  // the current callback invocation. The shape of this list is the same
  // as the shape of the `current` list.
  deferred = [];
  add(delay, callback) {
    const target = this.executingCallbacks ? this.deferred : this.current;
    this.addToQueue(target, Date.now() + delay, callback);
    this.scheduleTimer();
  }
  remove(callback) {
    const {
      current,
      deferred
    } = this;
    const callbackIndex = this.removeFromQueue(current, callback);
    if (callbackIndex === -1) {
      this.removeFromQueue(deferred, callback);
    }
    if (current.length === 0 && deferred.length === 0) {
      this.clearTimeout();
    }
  }
  addToQueue(target, invokeAt, callback) {
    let insertAtIndex = target.length;
    for (let i = 0; i < target.length; i += 2) {
      const invokeQueuedCallbackAt = target[i];
      if (invokeQueuedCallbackAt > invokeAt) {
        insertAtIndex = i;
        break;
      }
    }
    arrayInsert2(target, insertAtIndex, invokeAt, callback);
  }
  removeFromQueue(target, callback) {
    let index = -1;
    for (let i = 0; i < target.length; i += 2) {
      const queuedCallback = target[i + 1];
      if (queuedCallback === callback) {
        index = i;
        break;
      }
    }
    if (index > -1) {
      arraySplice(target, index, 2);
    }
    return index;
  }
  scheduleTimer() {
    const callback = () => {
      this.clearTimeout();
      this.executingCallbacks = true;
      const current = [...this.current];
      const now2 = Date.now();
      for (let i = 0; i < current.length; i += 2) {
        const invokeAt = current[i];
        const callback2 = current[i + 1];
        if (invokeAt <= now2) {
          callback2();
        } else {
          break;
        }
      }
      let lastCallbackIndex = -1;
      for (let i = 0; i < this.current.length; i += 2) {
        const invokeAt = this.current[i];
        if (invokeAt <= now2) {
          lastCallbackIndex = i + 1;
        } else {
          break;
        }
      }
      if (lastCallbackIndex >= 0) {
        arraySplice(this.current, 0, lastCallbackIndex + 1);
      }
      this.executingCallbacks = false;
      if (this.deferred.length > 0) {
        for (let i = 0; i < this.deferred.length; i += 2) {
          const invokeAt = this.deferred[i];
          const callback2 = this.deferred[i + 1];
          this.addToQueue(this.current, invokeAt, callback2);
        }
        this.deferred.length = 0;
      }
      this.scheduleTimer();
    };
    const FRAME_DURATION_MS = 16;
    if (this.current.length > 0) {
      const now2 = Date.now();
      const invokeAt = this.current[0];
      if (this.timeoutId === null || // Reschedule a timer in case a queue contains an item with
      // an earlier timestamp and the delta is more than an average
      // frame duration.
      this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {
        this.clearTimeout();
        const timeout2 = Math.max(invokeAt - now2, FRAME_DURATION_MS);
        this.invokeTimerAt = invokeAt;
        this.timeoutId = setTimeout(callback, timeout2);
      }
    }
  }
  clearTimeout() {
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  ngOnDestroy() {
    this.clearTimeout();
    this.current.length = 0;
    this.deferred.length = 0;
  }
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _TimerScheduler,
      providedIn: "root",
      factory: () => new _TimerScheduler()
    })
  );
};
var CachedInjectorService = class _CachedInjectorService {
  cachedInjectors = /* @__PURE__ */ new Map();
  getOrCreateInjector(key, parentInjector, providers2, debugName) {
    if (!this.cachedInjectors.has(key)) {
      const injector = providers2.length > 0 ? createEnvironmentInjector(providers2, parentInjector, debugName) : null;
      this.cachedInjectors.set(key, injector);
    }
    return this.cachedInjectors.get(key);
  }
  ngOnDestroy() {
    try {
      for (const injector of this.cachedInjectors.values()) {
        if (injector !== null) {
          injector.destroy();
        }
      }
    } finally {
      this.cachedInjectors.clear();
    }
  }
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _CachedInjectorService,
      providedIn: "environment",
      factory: () => new _CachedInjectorService()
    })
  );
};
var DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = new InjectionToken("DEFER_BLOCK_DEPENDENCY_INTERCEPTOR");
var DEFER_BLOCK_CONFIG = new InjectionToken(ngDevMode ? "DEFER_BLOCK_CONFIG" : "");
function getOrCreateEnvironmentInjector(parentInjector, tDetails, providers2) {
  return parentInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentInjector, providers2, ngDevMode ? "DeferBlock Injector" : "");
}
function createDeferBlockInjector(parentInjector, tDetails, providers2) {
  if (parentInjector instanceof ChainedInjector) {
    const origInjector = parentInjector.injector;
    const parentEnvInjector2 = parentInjector.parentInjector;
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector2, tDetails, providers2);
    return new ChainedInjector(origInjector, envInjector);
  }
  const parentEnvInjector = parentInjector.get(EnvironmentInjector);
  if (parentEnvInjector !== parentInjector) {
    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers2);
    return new ChainedInjector(parentInjector, envInjector);
  }
  return getOrCreateEnvironmentInjector(parentInjector, tDetails, providers2);
}
function renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {
  const hostLView = lContainer[PARENT];
  const hostTView = hostLView[TVIEW];
  if (isDestroyed(hostLView)) return;
  ngDevMode && assertTNodeForLView(tNode, hostLView);
  const lDetails = getLDeferBlockDetails(hostLView, tNode);
  ngDevMode && assertDefined(lDetails, "Expected a defer block state defined");
  const currentState = lDetails[DEFER_BLOCK_STATE];
  const ssrState = lDetails[SSR_BLOCK_STATE];
  if (ssrState !== null && newState < ssrState) {
    return;
  }
  if (isValidStateChange(currentState, newState) && isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {
    const tDetails = getTDeferBlockDetails(hostTView, tNode);
    const needsScheduling = !skipTimerScheduling && true && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));
    if (ngDevMode && needsScheduling) {
      assertDefined(applyDeferBlockStateWithSchedulingImpl, "Expected scheduling function to be defined");
    }
    const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;
    try {
      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);
    } catch (error) {
      handleError(hostLView, error);
    }
  }
}
function findMatchingDehydratedViewForDeferBlock(lContainer, lDetails) {
  const views = lContainer[DEHYDRATED_VIEWS];
  if (views === null || views.length === 0) {
    return null;
  }
  return views.find((view) => view.data[DEFER_BLOCK_STATE$1] === lDetails[DEFER_BLOCK_STATE]) ?? null;
}
function applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {
  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);
  if (stateTmplIndex !== null) {
    lDetails[DEFER_BLOCK_STATE] = newState;
    const hostTView = hostLView[TVIEW];
    const adjustedIndex = stateTmplIndex + HEADER_OFFSET;
    const activeBlockTNode = getTNode(hostTView, adjustedIndex);
    const viewIndex = 0;
    removeLViewFromLContainer(lContainer, viewIndex);
    let injector;
    if (newState === DeferBlockState.Complete) {
      const tDetails = getTDeferBlockDetails(hostTView, tNode);
      const providers2 = tDetails.providers;
      if (providers2 && providers2.length > 0) {
        injector = createDeferBlockInjector(hostLView[INJECTOR], tDetails, providers2);
      }
    }
    const dehydratedView = findMatchingDehydratedViewForDeferBlock(lContainer, lDetails);
    const isClientOnly = lContainer[DEHYDRATED_VIEWS] === null || lContainer[DEHYDRATED_VIEWS].length === 0;
    if (isClientOnly || dehydratedView) {
      lContainer[DEHYDRATED_VIEWS] = null;
      const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, {
        injector,
        dehydratedView
      });
      addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));
      markViewDirty(
        embeddedLView,
        2
        /* NotificationSource.DeferBlockStateUpdate */
      );
    }
    if (newState === DeferBlockState.Complete && Array.isArray(lDetails[ON_COMPLETE_FNS])) {
      for (const callback of lDetails[ON_COMPLETE_FNS]) {
        callback();
      }
      lDetails[ON_COMPLETE_FNS] = null;
    }
  }
}
function applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {
  const now2 = Date.now();
  const hostTView = hostLView[TVIEW];
  const tDetails = getTDeferBlockDetails(hostTView, tNode);
  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now2) {
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    const loadingAfter = getLoadingBlockAfter(tDetails);
    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;
    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {
      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
      const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);
      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;
    } else {
      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {
        lDetails[LOADING_AFTER_CLEANUP_FN]();
        lDetails[LOADING_AFTER_CLEANUP_FN] = null;
        lDetails[NEXT_DEFER_BLOCK_STATE] = null;
      }
      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);
      const duration = getMinimumDurationForState(tDetails, newState);
      if (duration !== null) {
        lDetails[STATE_IS_FROZEN_UNTIL] = now2 + duration;
        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);
      }
    }
  } else {
    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;
  }
}
function scheduleDeferBlockUpdate(timeout2, lDetails, tNode, lContainer, hostLView) {
  const callback = () => {
    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];
    lDetails[STATE_IS_FROZEN_UNTIL] = null;
    lDetails[NEXT_DEFER_BLOCK_STATE] = null;
    if (nextState !== null) {
      renderDeferBlockState(nextState, tNode, lContainer);
    }
  };
  return scheduleTimerTrigger(timeout2, callback, hostLView[INJECTOR]);
}
function isValidStateChange(currentState, newState) {
  return currentState < newState;
}
function renderPlaceholder(lView, tNode) {
  const lContainer = lView[tNode.index];
  ngDevMode && assertLContainer(lContainer);
  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);
}
function renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {
  ngDevMode && assertDefined(tDetails.loadingPromise, "Expected loading Promise to exist on this defer block");
  tDetails.loadingPromise.then(() => {
    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
    }
  });
}
var applyDeferBlockStateWithSchedulingImpl = null;
function \u0275\u0275deferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {
  const tViewConsts = tView.consts;
  if (placeholderConfigIndex != null) {
    tDetails.placeholderBlockConfig = getConstant(tViewConsts, placeholderConfigIndex);
  }
  if (loadingConfigIndex != null) {
    tDetails.loadingBlockConfig = getConstant(tViewConsts, loadingConfigIndex);
  }
  if (applyDeferBlockStateWithSchedulingImpl === null) {
    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;
  }
}
function setClassMetadata(type2, decorators, ctorParameters, propDecorators) {
  return noSideEffects(() => {
    const clazz = type2;
    if (decorators !== null) {
      if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
        clazz.decorators.push(...decorators);
      } else {
        clazz.decorators = decorators;
      }
    }
    if (ctorParameters !== null) {
      clazz.ctorParameters = ctorParameters;
    }
    if (propDecorators !== null) {
      if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
        clazz.propDecorators = __spreadValues(__spreadValues({}, clazz.propDecorators), propDecorators);
      } else {
        clazz.propDecorators = propDecorators;
      }
    }
  });
}
var Console = class _Console {
  log(message) {
    console.log(message);
  }
  // Note: for reporting errors use `DOM.logError()` as it is platform specific
  warn(message) {
    console.warn(message);
  }
  static \u0275fac = function Console_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Console)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Console,
    factory: _Console.\u0275fac,
    providedIn: "platform"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
    type: Injectable,
    args: [{
      providedIn: "platform"
    }]
  }], null, null);
})();
var DIDebugData = class {
  resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
  resolverToProviders = /* @__PURE__ */ new WeakMap();
  standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
  reset() {
    this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();
    this.resolverToProviders = /* @__PURE__ */ new WeakMap();
    this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();
  }
};
var frameworkDIDebugData = new DIDebugData();
function getFrameworkDIDebugData() {
  return frameworkDIDebugData;
}
function setupFrameworkInjectorProfiler() {
  frameworkDIDebugData.reset();
  setInjectorProfiler((injectorProfilerEvent) => handleInjectorProfilerEvent(injectorProfilerEvent));
}
function handleInjectorProfilerEvent(injectorProfilerEvent) {
  const {
    context: context2,
    type: type2
  } = injectorProfilerEvent;
  if (type2 === 0) {
    handleInjectEvent(context2, injectorProfilerEvent.service);
  } else if (type2 === 1) {
    handleInstanceCreatedByInjectorEvent(context2, injectorProfilerEvent.instance);
  } else if (type2 === 2) {
    handleProviderConfiguredEvent(context2, injectorProfilerEvent.providerRecord);
  }
}
function handleInjectEvent(context2, data) {
  const diResolver = getDIResolver(context2.injector);
  if (diResolver === null) {
    throwError2("An Inject event must be run within an injection context.");
  }
  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;
  if (!diResolverToInstantiatedToken.has(diResolver)) {
    diResolverToInstantiatedToken.set(diResolver, /* @__PURE__ */ new WeakMap());
  }
  if (!canBeHeldWeakly(context2.token)) {
    return;
  }
  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);
  if (!instantiatedTokenToDependencies.has(context2.token)) {
    instantiatedTokenToDependencies.set(context2.token, []);
  }
  const {
    token,
    value: value2,
    flags
  } = data;
  assertDefined(context2.token, "Injector profiler context token is undefined.");
  const dependencies = instantiatedTokenToDependencies.get(context2.token);
  assertDefined(dependencies, "Could not resolve dependencies for token.");
  if (context2.injector instanceof NodeInjector) {
    dependencies.push({
      token,
      value: value2,
      flags,
      injectedIn: getNodeInjectorContext(context2.injector)
    });
  } else {
    dependencies.push({
      token,
      value: value2,
      flags
    });
  }
}
function getNodeInjectorContext(injector) {
  if (!(injector instanceof NodeInjector)) {
    throwError2("getNodeInjectorContext must be called with a NodeInjector");
  }
  const lView = getNodeInjectorLView(injector);
  const tNode = getNodeInjectorTNode(injector);
  if (tNode === null) {
    return;
  }
  assertTNodeForLView(tNode, lView);
  return {
    lView,
    tNode
  };
}
function handleInstanceCreatedByInjectorEvent(context2, data) {
  const {
    value: value2
  } = data;
  if (getDIResolver(context2.injector) === null) {
    throwError2("An InjectorCreatedInstance event must be run within an injection context.");
  }
  let standaloneComponent = void 0;
  if (typeof value2 === "object") {
    standaloneComponent = value2?.constructor;
  }
  if (standaloneComponent == void 0 || !isStandaloneComponent(standaloneComponent)) {
    return;
  }
  const environmentInjector = context2.injector.get(EnvironmentInjector, null, {
    optional: true
  });
  if (environmentInjector === null) {
    return;
  }
  const {
    standaloneInjectorToComponent
  } = frameworkDIDebugData;
  if (standaloneInjectorToComponent.has(environmentInjector)) {
    return;
  }
  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);
}
function isStandaloneComponent(value2) {
  const def = getComponentDef(value2);
  return !!def?.standalone;
}
function handleProviderConfiguredEvent(context2, data) {
  const {
    resolverToProviders
  } = frameworkDIDebugData;
  let diResolver;
  if (context2?.injector instanceof NodeInjector) {
    diResolver = getNodeInjectorTNode(context2.injector);
  } else {
    diResolver = context2.injector;
  }
  if (diResolver === null) {
    throwError2("A ProviderConfigured event must be run within an injection context.");
  }
  if (!resolverToProviders.has(diResolver)) {
    resolverToProviders.set(diResolver, []);
  }
  resolverToProviders.get(diResolver).push(data);
}
function getDIResolver(injector) {
  let diResolver = null;
  if (injector === void 0) {
    return diResolver;
  }
  if (injector instanceof NodeInjector) {
    diResolver = getNodeInjectorLView(injector);
  } else {
    diResolver = injector;
  }
  return diResolver;
}
function canBeHeldWeakly(value2) {
  return value2 !== null && (typeof value2 === "object" || typeof value2 === "function" || typeof value2 === "symbol");
}
function applyChanges(component) {
  ngDevMode && assertDefined(component, "component");
  markViewDirty(
    getComponentViewByInstance(component),
    3
    /* NotificationSource.DebugApplyChanges */
  );
  getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
}
function detectChanges(component) {
  const view = getComponentViewByInstance(component);
  view[FLAGS] |= 1024;
  detectChangesInternal(view);
}
function getDependenciesFromInjectable(injector, token) {
  const instance = injector.get(token, null, {
    self: true,
    optional: true
  });
  if (instance === null) {
    throw new Error(`Unable to determine instance of ${token} in given injector`);
  }
  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);
  const resolutionPath = getInjectorResolutionPath(injector);
  const dependencies = unformattedDependencies.map((dep) => {
    const formattedDependency = {
      value: dep.value
    };
    const flags = dep.flags;
    formattedDependency.flags = {
      optional: (8 & flags) === 8,
      host: (1 & flags) === 1,
      self: (2 & flags) === 2,
      skipSelf: (4 & flags) === 4
      /* InternalInjectFlags.SkipSelf */
    };
    for (let i = 0; i < resolutionPath.length; i++) {
      const injectorToCheck = resolutionPath[i];
      if (i === 0 && formattedDependency.flags.skipSelf) {
        continue;
      }
      if (formattedDependency.flags.host && injectorToCheck instanceof EnvironmentInjector) {
        break;
      }
      const instance2 = injectorToCheck.get(dep.token, null, {
        self: true,
        optional: true
      });
      if (instance2 !== null) {
        if (formattedDependency.flags.host) {
          const firstInjector = resolutionPath[0];
          const lookupFromFirstInjector = firstInjector.get(dep.token, null, __spreadProps(__spreadValues({}, formattedDependency.flags), {
            optional: true
          }));
          if (lookupFromFirstInjector !== null) {
            formattedDependency.providedIn = injectorToCheck;
          }
          break;
        }
        formattedDependency.providedIn = injectorToCheck;
        break;
      }
      if (i === 0 && formattedDependency.flags.self) {
        break;
      }
    }
    if (dep.token) formattedDependency.token = dep.token;
    return formattedDependency;
  });
  return {
    instance,
    dependencies
  };
}
function getDependenciesForTokenInInjector(token, injector) {
  const {
    resolverToTokenToDependencies
  } = getFrameworkDIDebugData();
  if (!(injector instanceof NodeInjector)) {
    return resolverToTokenToDependencies.get(injector)?.get?.(token) ?? [];
  }
  const lView = getNodeInjectorLView(injector);
  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);
  const dependencies = tokenDependencyMap?.get(token) ?? [];
  return dependencies.filter((dependency) => {
    const dependencyNode = dependency.injectedIn?.tNode;
    if (dependencyNode === void 0) {
      return false;
    }
    const instanceNode = getNodeInjectorTNode(injector);
    assertTNode(dependencyNode);
    assertTNode(instanceNode);
    return dependencyNode === instanceNode;
  });
}
function getProviderImportsContainer(injector) {
  const {
    standaloneInjectorToComponent
  } = getFrameworkDIDebugData();
  if (standaloneInjectorToComponent.has(injector)) {
    return standaloneInjectorToComponent.get(injector);
  }
  const defTypeRef = injector.get(NgModuleRef$1, null, {
    self: true,
    optional: true
  });
  if (defTypeRef === null) {
    return null;
  }
  if (defTypeRef.instance === null) {
    return null;
  }
  return defTypeRef.instance.constructor;
}
function getNodeInjectorProviders(injector) {
  const diResolver = getNodeInjectorTNode(injector);
  const {
    resolverToProviders
  } = getFrameworkDIDebugData();
  return resolverToProviders.get(diResolver) ?? [];
}
function getProviderImportPaths(providerImportsContainer) {
  const providerToPath = /* @__PURE__ */ new Map();
  const visitedContainers = /* @__PURE__ */ new Set();
  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);
  walkProviderTree(providerImportsContainer, visitor, [], /* @__PURE__ */ new Set());
  return providerToPath;
}
function walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {
  return (provider, container) => {
    if (!providerToPath.has(provider)) {
      providerToPath.set(provider, [container]);
    }
    if (!visitedContainers.has(container)) {
      for (const prov of providerToPath.keys()) {
        const existingImportPath = providerToPath.get(prov);
        let containerDef = getInjectorDef(container);
        if (!containerDef) {
          const ngModule = container.ngModule;
          containerDef = getInjectorDef(ngModule);
        }
        if (!containerDef) {
          return;
        }
        const lastContainerAddedToPath = existingImportPath[0];
        let isNextStepInPath = false;
        deepForEach(containerDef.imports, (moduleImport) => {
          if (isNextStepInPath) {
            return;
          }
          isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;
          if (isNextStepInPath) {
            providerToPath.get(prov)?.unshift(container);
          }
        });
      }
    }
    visitedContainers.add(container);
  };
}
function getEnvironmentInjectorProviders(injector) {
  const providerRecordsWithoutImportPaths = getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];
  if (isPlatformInjector(injector)) {
    return providerRecordsWithoutImportPaths;
  }
  const providerImportsContainer = getProviderImportsContainer(injector);
  if (providerImportsContainer === null) {
    return providerRecordsWithoutImportPaths;
  }
  const providerToPath = getProviderImportPaths(providerImportsContainer);
  const providerRecords = [];
  for (const providerRecord of providerRecordsWithoutImportPaths) {
    const provider = providerRecord.provider;
    const token = provider.provide;
    if (token === ENVIRONMENT_INITIALIZER || token === INJECTOR_DEF_TYPES) {
      continue;
    }
    let importPath = providerToPath.get(provider) ?? [];
    const def = getComponentDef(providerImportsContainer);
    const isStandaloneComponent2 = !!def?.standalone;
    if (isStandaloneComponent2) {
      importPath = [providerImportsContainer, ...importPath];
    }
    providerRecords.push(__spreadProps(__spreadValues({}, providerRecord), {
      importPath
    }));
  }
  return providerRecords;
}
function isPlatformInjector(injector) {
  return injector instanceof R3Injector && injector.scopes.has("platform");
}
function getInjectorProviders(injector) {
  if (injector instanceof NodeInjector) {
    return getNodeInjectorProviders(injector);
  } else if (injector instanceof EnvironmentInjector) {
    return getEnvironmentInjectorProviders(injector);
  }
  throwError2("getInjectorProviders only supports NodeInjector and EnvironmentInjector");
}
function getInjectorMetadata(injector) {
  if (injector instanceof NodeInjector) {
    const lView = getNodeInjectorLView(injector);
    const tNode = getNodeInjectorTNode(injector);
    assertTNodeForLView(tNode, lView);
    return {
      type: "element",
      source: getNativeByTNode(tNode, lView)
    };
  }
  if (injector instanceof R3Injector) {
    return {
      type: "environment",
      source: injector.source ?? null
    };
  }
  if (injector instanceof NullInjector) {
    return {
      type: "null",
      source: null
    };
  }
  return null;
}
function getInjectorResolutionPath(injector) {
  const resolutionPath = [injector];
  getInjectorResolutionPathHelper(injector, resolutionPath);
  return resolutionPath;
}
function getInjectorResolutionPathHelper(injector, resolutionPath) {
  const parent = getInjectorParent(injector);
  if (parent === null) {
    if (injector instanceof NodeInjector) {
      const firstInjector = resolutionPath[0];
      if (firstInjector instanceof NodeInjector) {
        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);
        if (moduleInjector === null) {
          throwError2("NodeInjector must have some connection to the module injector tree");
        }
        resolutionPath.push(moduleInjector);
        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);
      }
      return resolutionPath;
    }
  } else {
    resolutionPath.push(parent);
    getInjectorResolutionPathHelper(parent, resolutionPath);
  }
  return resolutionPath;
}
function getInjectorParent(injector) {
  if (injector instanceof R3Injector) {
    const parent = injector.parent;
    if (isRouterOutletInjector(parent)) {
      return parent.parentInjector;
    }
    return parent;
  }
  let tNode;
  let lView;
  if (injector instanceof NodeInjector) {
    tNode = getNodeInjectorTNode(injector);
    lView = getNodeInjectorLView(injector);
  } else if (injector instanceof NullInjector) {
    return null;
  } else if (injector instanceof ChainedInjector) {
    return injector.parentInjector;
  } else {
    throwError2("getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector");
  }
  const parentLocation = getParentInjectorLocation(tNode, lView);
  if (hasParentInjector(parentLocation)) {
    const parentInjectorIndex = getParentInjectorIndex(parentLocation);
    const parentLView = getParentInjectorView(parentLocation, lView);
    const parentTView = parentLView[TVIEW];
    const parentTNode = parentTView.data[
      parentInjectorIndex + 8
      /* NodeInjectorOffset.TNODE */
    ];
    return new NodeInjector(parentTNode, parentLView);
  } else {
    const chainedInjector = lView[INJECTOR];
    const injectorParent = chainedInjector.injector?.parent;
    if (injectorParent instanceof NodeInjector) {
      return injectorParent;
    }
  }
  return null;
}
function getModuleInjectorOfNodeInjector(injector) {
  let lView;
  if (injector instanceof NodeInjector) {
    lView = getNodeInjectorLView(injector);
  } else {
    throwError2("getModuleInjectorOfNodeInjector must be called with a NodeInjector");
  }
  const inj = lView[INJECTOR];
  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;
  if (!moduleInjector) {
    throwError2("NodeInjector must have some connection to the module injector tree");
  }
  return moduleInjector;
}
var GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
var globalUtilsFunctions = {
  /**
   * Warning: functions that start with `ɵ` are considered *INTERNAL* and should not be relied upon
   * in application's code. The contract of those functions might be changed in any release and/or a
   * function can be removed completely.
   */
  "\u0275getDependenciesFromInjectable": getDependenciesFromInjectable,
  "\u0275getInjectorProviders": getInjectorProviders,
  "\u0275getInjectorResolutionPath": getInjectorResolutionPath,
  "\u0275getInjectorMetadata": getInjectorMetadata,
  "\u0275setProfiler": setProfiler,
  "getDirectiveMetadata": getDirectiveMetadata$1,
  "getComponent": getComponent,
  "getContext": getContext,
  "getListeners": getListeners,
  "getOwningComponent": getOwningComponent,
  "getHostElement": getHostElement,
  "getInjector": getInjector,
  "getRootComponents": getRootComponents,
  "getDirectives": getDirectives,
  "applyChanges": applyChanges,
  "isSignal": isSignal
};
var _published = false;
function publishDefaultGlobalUtils$1() {
  if (!_published) {
    _published = true;
    if (typeof window !== "undefined") {
      setupFrameworkInjectorProfiler();
    }
    for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {
      publishGlobalUtil(methodName, method);
    }
  }
}
function publishGlobalUtil(name, fn) {
  publishUtil(name, fn);
}
function publishExternalGlobalUtil(name, fn) {
  publishUtil(name, fn);
}
function publishUtil(name, fn) {
  if (typeof COMPILED === "undefined" || !COMPILED) {
    const w2 = _global;
    ngDevMode && assertDefined(fn, "function not defined");
    w2[GLOBAL_PUBLISH_EXPANDO_KEY] ??= {};
    w2[GLOBAL_PUBLISH_EXPANDO_KEY][name] = fn;
  }
}
var TESTABILITY = new InjectionToken("");
var TESTABILITY_GETTER = new InjectionToken("");
var Testability = class _Testability {
  _ngZone;
  registry;
  _isZoneStable = true;
  _callbacks = [];
  taskTrackingZone = null;
  constructor(_ngZone, registry, testabilityGetter) {
    this._ngZone = _ngZone;
    this.registry = registry;
    if (!_testabilityGetter) {
      setTestabilityGetter(testabilityGetter);
      testabilityGetter.addToWindow(registry);
    }
    this._watchAngularEvents();
    _ngZone.run(() => {
      this.taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
    });
  }
  _watchAngularEvents() {
    this._ngZone.onUnstable.subscribe({
      next: () => {
        this._isZoneStable = false;
      }
    });
    this._ngZone.runOutsideAngular(() => {
      this._ngZone.onStable.subscribe({
        next: () => {
          NgZone.assertNotInAngularZone();
          queueMicrotask(() => {
            this._isZoneStable = true;
            this._runCallbacksIfReady();
          });
        }
      });
    });
  }
  /**
   * Whether an associated application is stable
   */
  isStable() {
    return this._isZoneStable && !this._ngZone.hasPendingMacrotasks;
  }
  _runCallbacksIfReady() {
    if (this.isStable()) {
      queueMicrotask(() => {
        while (this._callbacks.length !== 0) {
          let cb = this._callbacks.pop();
          clearTimeout(cb.timeoutId);
          cb.doneCb();
        }
      });
    } else {
      let pending = this.getPendingTasks();
      this._callbacks = this._callbacks.filter((cb) => {
        if (cb.updateCb && cb.updateCb(pending)) {
          clearTimeout(cb.timeoutId);
          return false;
        }
        return true;
      });
    }
  }
  getPendingTasks() {
    if (!this.taskTrackingZone) {
      return [];
    }
    return this.taskTrackingZone.macroTasks.map((t2) => {
      return {
        source: t2.source,
        // From TaskTrackingZone:
        // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
        creationLocation: t2.creationLocation,
        data: t2.data
      };
    });
  }
  addCallback(cb, timeout2, updateCb) {
    let timeoutId = -1;
    if (timeout2 && timeout2 > 0) {
      timeoutId = setTimeout(() => {
        this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
        cb();
      }, timeout2);
    }
    this._callbacks.push({
      doneCb: cb,
      timeoutId,
      updateCb
    });
  }
  /**
   * Wait for the application to be stable with a timeout. If the timeout is reached before that
   * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
   *
   * @param doneCb The callback to invoke when Angular is stable or the timeout expires
   *    whichever comes first.
   * @param timeout Optional. The maximum time to wait for Angular to become stable. If not
   *    specified, whenStable() will wait forever.
   * @param updateCb Optional. If specified, this callback will be invoked whenever the set of
   *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
   *    and no further updates will be issued.
   */
  whenStable(doneCb, timeout2, updateCb) {
    if (updateCb && !this.taskTrackingZone) {
      throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
    }
    this.addCallback(doneCb, timeout2, updateCb);
    this._runCallbacksIfReady();
  }
  /**
   * Registers an application with a testability hook so that it can be tracked.
   * @param token token of application, root element
   *
   * @internal
   */
  registerApplication(token) {
    this.registry.registerApplication(token, this);
  }
  /**
   * Unregisters an application.
   * @param token token of application, root element
   *
   * @internal
   */
  unregisterApplication(token) {
    this.registry.unregisterApplication(token);
  }
  /**
   * Find providers by name
   * @param using The root element to search from
   * @param provider The name of binding variable
   * @param exactMatch Whether using exactMatch
   */
  findProviders(using, provider, exactMatch) {
    return [];
  }
  static \u0275fac = function Testability_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Testability)(\u0275\u0275inject(NgZone), \u0275\u0275inject(TestabilityRegistry), \u0275\u0275inject(TESTABILITY_GETTER));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Testability,
    factory: _Testability.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: TestabilityRegistry
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [TESTABILITY_GETTER]
    }]
  }], null);
})();
var TestabilityRegistry = class _TestabilityRegistry {
  /** @internal */
  _applications = /* @__PURE__ */ new Map();
  /**
   * Registers an application with a testability hook so that it can be tracked
   * @param token token of application, root element
   * @param testability Testability hook
   */
  registerApplication(token, testability) {
    this._applications.set(token, testability);
  }
  /**
   * Unregisters an application.
   * @param token token of application, root element
   */
  unregisterApplication(token) {
    this._applications.delete(token);
  }
  /**
   * Unregisters all applications
   */
  unregisterAllApplications() {
    this._applications.clear();
  }
  /**
   * Get a testability hook associated with the application
   * @param elem root element
   */
  getTestability(elem) {
    return this._applications.get(elem) || null;
  }
  /**
   * Get all registered testabilities
   */
  getAllTestabilities() {
    return Array.from(this._applications.values());
  }
  /**
   * Get all registered applications(root elements)
   */
  getAllRootElements() {
    return Array.from(this._applications.keys());
  }
  /**
   * Find testability of a node in the Tree
   * @param elem node
   * @param findInAncestors whether finding testability in ancestors if testability was not found in
   * current node
   */
  findTestabilityInTree(elem, findInAncestors = true) {
    return _testabilityGetter?.findTestabilityInTree(this, elem, findInAncestors) ?? null;
  }
  static \u0275fac = function TestabilityRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TestabilityRegistry)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TestabilityRegistry,
    factory: _TestabilityRegistry.\u0275fac,
    providedIn: "platform"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "platform"
    }]
  }], null, null);
})();
function setTestabilityGetter(getter) {
  _testabilityGetter = getter;
}
var _testabilityGetter;
function isPromise2(obj) {
  return !!obj && typeof obj.then === "function";
}
function isSubscribable(obj) {
  return !!obj && typeof obj.subscribe === "function";
}
var APP_INITIALIZER = new InjectionToken(ngDevMode ? "Application Initializer" : "");
var ApplicationInitStatus = class _ApplicationInitStatus {
  // Using non null assertion, these fields are defined below
  // within the `new Promise` callback (synchronously).
  resolve;
  reject;
  initialized = false;
  done = false;
  donePromise = new Promise((res, rej) => {
    this.resolve = res;
    this.reject = rej;
  });
  appInits = inject(APP_INITIALIZER, {
    optional: true
  }) ?? [];
  injector = inject(Injector);
  constructor() {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !Array.isArray(this.appInits)) {
      throw new RuntimeError(-209, `Unexpected type of the \`APP_INITIALIZER\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \`APP_INITIALIZER\` token is configured as a \`multi: true\` provider.`);
    }
  }
  /** @internal */
  runInitializers() {
    if (this.initialized) {
      return;
    }
    const asyncInitPromises = [];
    for (const appInits of this.appInits) {
      const initResult = runInInjectionContext(this.injector, appInits);
      if (isPromise2(initResult)) {
        asyncInitPromises.push(initResult);
      } else if (isSubscribable(initResult)) {
        const observableAsPromise = new Promise((resolve, reject) => {
          initResult.subscribe({
            complete: resolve,
            error: reject
          });
        });
        asyncInitPromises.push(observableAsPromise);
      }
    }
    const complete = () => {
      this.done = true;
      this.resolve();
    };
    Promise.all(asyncInitPromises).then(() => {
      complete();
    }).catch((e) => {
      this.reject(e);
    });
    if (asyncInitPromises.length === 0) {
      complete();
    }
    this.initialized = true;
  }
  static \u0275fac = function ApplicationInitStatus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ApplicationInitStatus)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ApplicationInitStatus,
    factory: _ApplicationInitStatus.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var EffectScheduler = class _EffectScheduler {
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _EffectScheduler,
      providedIn: "root",
      factory: () => new ZoneAwareEffectScheduler()
    })
  );
};
var ZoneAwareEffectScheduler = class {
  queuedEffectCount = 0;
  queues = /* @__PURE__ */ new Map();
  schedule(handle) {
    this.enqueue(handle);
  }
  enqueue(handle) {
    const zone = handle.zone;
    if (!this.queues.has(zone)) {
      this.queues.set(zone, /* @__PURE__ */ new Set());
    }
    const queue = this.queues.get(zone);
    if (queue.has(handle)) {
      return;
    }
    this.queuedEffectCount++;
    queue.add(handle);
  }
  /**
   * Run all scheduled effects.
   *
   * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no
   * ordering guarantee between effects scheduled in different zones.
   */
  flush() {
    while (this.queuedEffectCount > 0) {
      for (const [zone, queue] of this.queues) {
        if (zone === null) {
          this.flushQueue(queue);
        } else {
          zone.run(() => this.flushQueue(queue));
        }
      }
    }
  }
  flushQueue(queue) {
    for (const handle of queue) {
      queue.delete(handle);
      this.queuedEffectCount--;
      handle.run();
    }
  }
};
var APP_BOOTSTRAP_LISTENER = new InjectionToken(ngDevMode ? "appBootstrapListener" : "");
function publishDefaultGlobalUtils() {
  ngDevMode && publishDefaultGlobalUtils$1();
}
function publishSignalConfiguration() {
  setThrowInvalidWriteToSignalError(() => {
    throw new RuntimeError(600, ngDevMode && "Writing to signals is not allowed in a `computed`.");
  });
}
function isBoundToModule(cf) {
  return cf.isBoundToModule;
}
var MAXIMUM_REFRESH_RERUNS = 10;
function _callAndReportToErrorHandler(errorHandler2, ngZone, callback) {
  try {
    const result = callback();
    if (isPromise2(result)) {
      return result.catch((e) => {
        ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
        throw e;
      });
    }
    return result;
  } catch (e) {
    ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
    throw e;
  }
}
function optionsReducer(dst, objs) {
  if (Array.isArray(objs)) {
    return objs.reduce(optionsReducer, dst);
  }
  return __spreadValues(__spreadValues({}, dst), objs);
}
var ApplicationRef = class _ApplicationRef {
  /** @internal */
  _runningTick = false;
  _destroyed = false;
  _destroyListeners = [];
  /** @internal */
  _views = [];
  internalErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
  afterRenderManager = inject(AfterRenderManager);
  zonelessEnabled = inject(ZONELESS_ENABLED);
  rootEffectScheduler = inject(EffectScheduler);
  /**
   * Current dirty state of the application across a number of dimensions (views, afterRender hooks,
   * etc).
   *
   * A flag set here means that `tick()` will attempt to resolve the dirtiness when executed.
   *
   * @internal
   */
  dirtyFlags = 0;
  /**
   * Like `dirtyFlags` but don't cause `tick()` to loop.
   *
   * @internal
   */
  deferredDirtyFlags = 0;
  /**
   * Most recent snapshot from the `TracingService`, if any.
   *
   * This snapshot attempts to capture the context when `tick()` was first
   * scheduled. It then runs wrapped in this context.
   *
   * @internal
   */
  tracingSnapshot = null;
  // Needed for ComponentFixture temporarily during migration of autoDetect behavior
  // Eventually the hostView of the fixture should just attach to ApplicationRef.
  externalTestViews = /* @__PURE__ */ new Set();
  /** @internal */
  afterTick = new Subject();
  /** @internal */
  get allViews() {
    return [...this.externalTestViews.keys(), ...this._views];
  }
  /**
   * Indicates whether this instance was destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  /**
   * Get a list of component types registered to this application.
   * This list is populated even before the component is created.
   */
  componentTypes = [];
  /**
   * Get a list of components registered to this application.
   */
  components = [];
  /**
   * Returns an Observable that indicates when the application is stable or unstable.
   */
  isStable = inject(PendingTasksInternal).hasPendingTasks.pipe(map((pending) => !pending));
  constructor() {
    inject(TracingService, {
      optional: true
    });
  }
  /**
   * @returns A promise that resolves when the application becomes stable
   */
  whenStable() {
    let subscription;
    return new Promise((resolve) => {
      subscription = this.isStable.subscribe({
        next: (stable) => {
          if (stable) {
            resolve();
          }
        }
      });
    }).finally(() => {
      subscription.unsubscribe();
    });
  }
  _injector = inject(EnvironmentInjector);
  /**
   * The `EnvironmentInjector` used to create this application.
   */
  get injector() {
    return this._injector;
  }
  /**
   * Bootstrap a component onto the element identified by its selector or, optionally, to a
   * specified element.
   *
   * @usageNotes
   * ### Bootstrap process
   *
   * When bootstrapping a component, Angular mounts it onto a target DOM element
   * and kicks off automatic change detection. The target DOM element can be
   * provided using the `rootSelectorOrNode` argument.
   *
   * If the target DOM element is not provided, Angular tries to find one on a page
   * using the `selector` of the component that is being bootstrapped
   * (first matched element is used).
   *
   * ### Example
   *
   * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,
   * but it requires us to know the component while writing the application code.
   *
   * Imagine a situation where we have to wait for an API call to decide about the component to
   * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to
   * dynamically bootstrap a component.
   *
   * {@example core/ts/platform/platform.ts region='componentSelector'}
   *
   * Optionally, a component can be mounted onto a DOM element that does not match the
   * selector of the bootstrapped component.
   *
   * In the following example, we are providing a CSS selector to match the target element.
   *
   * {@example core/ts/platform/platform.ts region='cssSelector'}
   *
   * While in this example, we are providing reference to a DOM node.
   *
   * {@example core/ts/platform/platform.ts region='domNode'}
   */
  bootstrap(componentOrFactory, rootSelectorOrNode) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;
    const initStatus = this._injector.get(ApplicationInitStatus);
    if (!initStatus.done) {
      const standalone = !isComponentFactory && isStandalone(componentOrFactory);
      const errorMessage = (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot bootstrap as there are still asynchronous initializers running." + (standalone ? "" : " Bootstrap components in the `ngDoBootstrap` method of the root module.");
      throw new RuntimeError(405, errorMessage);
    }
    let componentFactory;
    if (isComponentFactory) {
      componentFactory = componentOrFactory;
    } else {
      const resolver = this._injector.get(ComponentFactoryResolver$1);
      componentFactory = resolver.resolveComponentFactory(componentOrFactory);
    }
    this.componentTypes.push(componentFactory.componentType);
    const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
    const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
    const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
    const nativeElement = compRef.location.nativeElement;
    const testability = compRef.injector.get(TESTABILITY, null);
    testability?.registerApplication(nativeElement);
    compRef.onDestroy(() => {
      this.detachView(compRef.hostView);
      remove(this.components, compRef);
      testability?.unregisterApplication(nativeElement);
    });
    this._loadComponent(compRef);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const _console = this._injector.get(Console);
      _console.log(`Angular is running in development mode.`);
    }
    return compRef;
  }
  /**
   * Invoke this method to explicitly process change detection and its side-effects.
   *
   * In development mode, `tick()` also performs a second change detection cycle to ensure that no
   * further changes are detected. If additional changes are picked up during this second cycle,
   * bindings in the app have side-effects that cannot be resolved in a single change detection
   * pass.
   * In this case, Angular throws an error, since an Angular application can only have one change
   * detection pass during which all change detection must complete.
   */
  tick() {
    if (!this.zonelessEnabled) {
      this.dirtyFlags |= 1;
    }
    this._tick();
  }
  /** @internal */
  _tick = () => {
    if (this.tracingSnapshot !== null) {
      const snapshot = this.tracingSnapshot;
      this.tracingSnapshot = null;
      snapshot.run(TracingAction.CHANGE_DETECTION, this._tick);
      return;
    }
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    if (this._runningTick) {
      throw new RuntimeError(101, ngDevMode && "ApplicationRef.tick is called recursively");
    }
    const prevConsumer = setActiveConsumer(null);
    try {
      this._runningTick = true;
      this.synchronize();
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        for (let view of this.allViews) {
          view.checkNoChanges();
        }
      }
    } catch (e) {
      this.internalErrorHandler(e);
    } finally {
      this._runningTick = false;
      setActiveConsumer(prevConsumer);
      this.afterTick.next();
    }
  };
  /**
   * Performs the core work of synchronizing the application state with the UI, resolving any
   * pending dirtiness (potentially in a loop).
   */
  synchronize() {
    let rendererFactory = null;
    if (!this._injector.destroyed) {
      rendererFactory = this._injector.get(RendererFactory2, null, {
        optional: true
      });
    }
    this.dirtyFlags |= this.deferredDirtyFlags;
    this.deferredDirtyFlags = 0;
    let runs = 0;
    while (this.dirtyFlags !== 0 && runs++ < MAXIMUM_REFRESH_RERUNS) {
      this.synchronizeOnce(rendererFactory);
    }
    if ((typeof ngDevMode === "undefined" || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {
      throw new RuntimeError(103, ngDevMode && "Infinite change detection while refreshing application views. Ensure views are not calling `markForCheck` on every template execution or that afterRender hooks always mark views for check.");
    }
  }
  /**
   * Perform a single synchronization pass.
   */
  synchronizeOnce(rendererFactory) {
    this.dirtyFlags |= this.deferredDirtyFlags;
    this.deferredDirtyFlags = 0;
    if (this.dirtyFlags & 16) {
      this.dirtyFlags &= ~16;
      this.rootEffectScheduler.flush();
    }
    if (this.dirtyFlags & 7) {
      const useGlobalCheck = Boolean(
        this.dirtyFlags & 1
        /* ApplicationRefDirtyFlags.ViewTreeGlobal */
      );
      this.dirtyFlags &= ~7;
      this.dirtyFlags |= 8;
      for (let {
        _lView,
        notifyErrorHandler
      } of this.allViews) {
        detectChangesInViewIfRequired(_lView, notifyErrorHandler, useGlobalCheck, this.zonelessEnabled);
      }
      this.dirtyFlags &= ~4;
      this.syncDirtyFlagsWithViews();
      if (this.dirtyFlags & (7 | 16)) {
        return;
      }
    } else {
      rendererFactory?.begin?.();
      rendererFactory?.end?.();
    }
    if (this.dirtyFlags & 8) {
      this.dirtyFlags &= ~8;
      this.afterRenderManager.execute();
    }
    this.syncDirtyFlagsWithViews();
  }
  /**
   * Checks `allViews` for views which require refresh/traversal, and updates `dirtyFlags`
   * accordingly, with two potential behaviors:
   *
   * 1. If any of our views require updating, then this adds the `ViewTreeTraversal` dirty flag.
   *    This _should_ be a no-op, since the scheduler should've added the flag at the same time the
   *    view was marked as needing updating.
   *
   *    TODO(alxhub): figure out if this behavior is still needed for edge cases.
   *
   * 2. If none of our views require updating, then clear the view-related `dirtyFlag`s. This
   *    happens when the scheduler is notified of a view becoming dirty, but the view itself isn't
   *    reachable through traversal from our roots (e.g. it's detached from the CD tree).
   */
  syncDirtyFlagsWithViews() {
    if (this.allViews.some(({
      _lView
    }) => requiresRefreshOrTraversal(_lView))) {
      this.dirtyFlags |= 2;
      return;
    } else {
      this.dirtyFlags &= ~7;
    }
  }
  /**
   * Attaches a view so that it will be dirty checked.
   * The view will be automatically detached when it is destroyed.
   * This will throw if the view is already attached to a ViewContainer.
   */
  attachView(viewRef) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const view = viewRef;
    this._views.push(view);
    view.attachToAppRef(this);
  }
  /**
   * Detaches a view from dirty checking again.
   */
  detachView(viewRef) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    const view = viewRef;
    remove(this._views, view);
    view.detachFromAppRef();
  }
  _loadComponent(componentRef) {
    this.attachView(componentRef.hostView);
    this.tick();
    this.components.push(componentRef);
    const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);
    if (ngDevMode && !Array.isArray(listeners)) {
      throw new RuntimeError(-209, `Unexpected type of the \`APP_BOOTSTRAP_LISTENER\` token value (expected an array, but got ${typeof listeners}). Please check that the \`APP_BOOTSTRAP_LISTENER\` token is configured as a \`multi: true\` provider.`);
    }
    listeners.forEach((listener2) => listener2(componentRef));
  }
  /** @internal */
  ngOnDestroy() {
    if (this._destroyed) return;
    try {
      this._destroyListeners.forEach((listener2) => listener2());
      this._views.slice().forEach((view) => view.destroy());
    } finally {
      this._destroyed = true;
      this._views = [];
      this._destroyListeners = [];
    }
  }
  /**
   * Registers a listener to be called when an instance is destroyed.
   *
   * @param callback A callback function to add as a listener.
   * @returns A function which unregisters a listener.
   */
  onDestroy(callback) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.warnIfDestroyed();
    this._destroyListeners.push(callback);
    return () => remove(this._destroyListeners, callback);
  }
  /**
   * Destroys an Angular application represented by this `ApplicationRef`. Calling this function
   * will destroy the associated environment injectors as well as all the bootstrapped components
   * with their views.
   */
  destroy() {
    if (this._destroyed) {
      throw new RuntimeError(406, ngDevMode && "This instance of the `ApplicationRef` has already been destroyed.");
    }
    const injector = this._injector;
    if (injector.destroy && !injector.destroyed) {
      injector.destroy();
    }
  }
  /**
   * Returns the number of attached views.
   */
  get viewCount() {
    return this._views.length;
  }
  warnIfDestroyed() {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && this._destroyed) {
      console.warn(formatRuntimeError(406, "This instance of the `ApplicationRef` has already been destroyed."));
    }
  }
  static \u0275fac = function ApplicationRef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ApplicationRef)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ApplicationRef,
    factory: _ApplicationRef.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function remove(list, el) {
  const index = list.indexOf(el);
  if (index > -1) {
    list.splice(index, 1);
  }
}
function detectChangesInViewIfRequired(lView, notifyErrorHandler, isFirstPass, zonelessEnabled) {
  if (!isFirstPass && !requiresRefreshOrTraversal(lView)) {
    return;
  }
  const mode = isFirstPass && !zonelessEnabled ? (
    // The first pass is always in Global mode, which includes `CheckAlways` views.
    0
  ) : (
    // Only refresh views with the `RefreshView` flag or views is a changed signal
    1
  );
  detectChangesInternal(lView, notifyErrorHandler, mode);
}
function scheduleDelayedTrigger(scheduleFn) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const injector = lView[INJECTOR];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);
  renderPlaceholder(lView, tNode);
  if (shouldTriggerWhenOnClient(lView[INJECTOR], lDetails, tDetails)) {
    const cleanupFn = scheduleFn(() => triggerDeferBlock(lView, tNode), injector);
    storeTriggerCleanupFn(0, lDetails, cleanupFn);
  }
}
function scheduleDelayedPrefetching(scheduleFn, trigger2) {
  if (false) {
    return;
  }
  const lView = getLView();
  const injector = lView[INJECTOR];
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  const prefetchTriggers = getPrefetchTriggers(tDetails);
  prefetchTriggers.add(trigger2);
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    const lDetails = getLDeferBlockDetails(lView, tNode);
    const prefetch = () => triggerPrefetching(tDetails, lView, tNode);
    const cleanupFn = scheduleFn(prefetch, injector);
    storeTriggerCleanupFn(1, lDetails, cleanupFn);
  }
}
function scheduleDelayedHydrating(scheduleFn, lView, tNode) {
  if (false) {
    return;
  }
  const injector = lView[INJECTOR];
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
  ngDevMode && assertSsrIdDefined(ssrUniqueId);
  const cleanupFn = scheduleFn(() => triggerHydrationFromBlockName(injector, ssrUniqueId), injector);
  storeTriggerCleanupFn(2, lDetails, cleanupFn);
}
function triggerPrefetching(tDetails, lView, tNode) {
  const tDeferBlockDetails = getTDeferBlockDetails(lView[TVIEW], tNode);
  if (lView[INJECTOR] && shouldTriggerDeferBlock(lView[INJECTOR], tDeferBlockDetails)) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function triggerResourceLoading(tDetails, lView, tNode) {
  const injector = lView[INJECTOR];
  const tView = lView[TVIEW];
  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {
    return tDetails.loadingPromise ?? Promise.resolve();
  }
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);
  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;
  invokeTriggerCleanupFns(1, lDetails);
  let dependenciesFn = tDetails.dependencyResolverFn;
  if (ngDevMode) {
    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {
      optional: true
    });
    if (deferDependencyInterceptor) {
      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);
    }
  }
  const pendingTasks = injector.get(PendingTasksInternal);
  const taskId = pendingTasks.add();
  if (!dependenciesFn) {
    tDetails.loadingPromise = Promise.resolve().then(() => {
      tDetails.loadingPromise = null;
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      pendingTasks.remove(taskId);
    });
    return tDetails.loadingPromise;
  }
  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then((results) => {
    let failed = false;
    const directiveDefs = [];
    const pipeDefs = [];
    for (const result of results) {
      if (result.status === "fulfilled") {
        const dependency = result.value;
        const directiveDef = getComponentDef(dependency) || getDirectiveDef(dependency);
        if (directiveDef) {
          directiveDefs.push(directiveDef);
        } else {
          const pipeDef = getPipeDef$1(dependency);
          if (pipeDef) {
            pipeDefs.push(pipeDef);
          }
        }
      } else {
        failed = true;
        break;
      }
    }
    tDetails.loadingPromise = null;
    pendingTasks.remove(taskId);
    if (failed) {
      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;
      if (tDetails.errorTmplIndex === null) {
        const templateLocation = ngDevMode ? getTemplateLocationDetails(lView) : "";
        const error = new RuntimeError(750, ngDevMode && `Loading dependencies for \`@defer\` block failed, but no \`@error\` block was configured${templateLocation}. Consider using the \`@error\` block to render an error state.`);
        handleError(lView, error);
      }
    } else {
      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;
      const primaryBlockTView = primaryBlockTNode.tView;
      if (directiveDefs.length > 0) {
        primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);
        const directiveTypes = directiveDefs.map((def) => def.type);
        const providers2 = internalImportProvidersFrom(false, ...directiveTypes);
        tDetails.providers = providers2;
      }
      if (pipeDefs.length > 0) {
        primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);
      }
    }
  });
  return tDetails.loadingPromise;
}
function triggerDeferBlock(lView, tNode) {
  const tView = lView[TVIEW];
  const lContainer = lView[tNode.index];
  const injector = lView[INJECTOR];
  ngDevMode && assertLContainer(lContainer);
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(tView, tNode);
  if (!shouldTriggerDeferBlock(injector, tDetails)) return;
  invokeAllTriggerCleanupFns(lDetails);
  switch (tDetails.loadingState) {
    case DeferDependenciesLoadingState.NOT_STARTED:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      triggerResourceLoading(tDetails, lView, tNode);
      if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {
        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      }
      break;
    case DeferDependenciesLoadingState.IN_PROGRESS:
      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);
      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.COMPLETE:
      ngDevMode && assertDeferredDependenciesLoaded(tDetails);
      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);
      break;
    case DeferDependenciesLoadingState.FAILED:
      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);
      break;
    default:
      if (ngDevMode) {
        throwError2("Unknown defer block state");
      }
  }
}
function triggerHydrationFromBlockName(injector, blockName, replayQueuedEventsFn) {
  return __async(this, null, function* () {
    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;
    if (blocksBeingHydrated.has(blockName)) {
      return;
    }
    const {
      parentBlockPromise,
      hydrationQueue
    } = getParentBlockHydrationQueue(blockName, injector);
    populateHydratingStateForQueue(dehydratedBlockRegistry, hydrationQueue);
    const pendingTasks = injector.get(PendingTasksInternal);
    const taskId = pendingTasks.add();
    if (parentBlockPromise !== null) {
      yield parentBlockPromise;
    }
    for (const dehydratedBlockId of hydrationQueue) {
      yield triggerDeferBlockResourceLoading(dehydratedBlockId, dehydratedBlockRegistry);
      yield nextRender(injector);
      blocksBeingHydrated.get(dehydratedBlockId).resolve();
    }
    yield blocksBeingHydrated.get(blockName)?.promise;
    pendingTasks.remove(taskId);
    if (replayQueuedEventsFn) {
      replayQueuedEventsFn(hydrationQueue);
    }
    cleanupHydratedDeferBlocks(dehydratedBlockRegistry.get(blockName), hydrationQueue, dehydratedBlockRegistry, injector.get(ApplicationRef));
  });
}
function populateHydratingStateForQueue(registry, queue) {
  for (let blockId of queue) {
    registry.hydrating.set(blockId, Promise.withResolvers());
  }
}
function nextRender(injector) {
  let resolve;
  const promise = new Promise((resolveFn) => {
    resolve = resolveFn;
  });
  afterNextRender(() => resolve(), {
    injector
  });
  return promise;
}
function triggerDeferBlockResourceLoading(dehydratedBlockId, dehydratedBlockRegistry) {
  let resolve;
  const promise = new Promise((resolveFn) => resolve = resolveFn);
  const deferBlock = dehydratedBlockRegistry.get(dehydratedBlockId);
  if (deferBlock !== null) {
    const {
      tNode,
      lView
    } = deferBlock;
    const lDetails = getLDeferBlockDetails(lView, tNode);
    onDeferBlockCompletion(lDetails, () => resolve());
    triggerDeferBlock(lView, tNode);
  }
  return promise;
}
function onDeferBlockCompletion(lDetails, callback) {
  if (!Array.isArray(lDetails[ON_COMPLETE_FNS])) {
    lDetails[ON_COMPLETE_FNS] = [];
  }
  lDetails[ON_COMPLETE_FNS].push(callback);
}
function shouldActivateHydrateTrigger(lView, tNode) {
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const injector = lView[INJECTOR];
  return isIncrementalHydrationEnabled(injector) && lDetails[SSR_UNIQUE_ID] !== null;
}
function shouldTriggerWhenOnClient(injector, lDetails, tDetails) {
  if (false) {
    return false;
  }
  const isServerRendered = lDetails[SSR_BLOCK_STATE] && lDetails[SSR_BLOCK_STATE] === DeferBlockState.Complete;
  const hasHydrateTriggers = tDetails.hydrateTriggers && tDetails.hydrateTriggers.size > 0;
  if (hasHydrateTriggers && isServerRendered && isIncrementalHydrationEnabled(injector)) {
    return false;
  }
  return true;
}
function shouldTriggerDeferBlock(injector, tDeferBlockDetails) {
  const config3 = injector.get(DEFER_BLOCK_CONFIG, null, {
    optional: true
  });
  if (config3?.behavior === DeferBlockBehavior.Manual) {
    return false;
  }
  return true;
}
function getHydrateTriggers(tView, tNode) {
  const tDetails = getTDeferBlockDetails(tView, tNode);
  return tDetails.hydrateTriggers ??= /* @__PURE__ */ new Map();
}
function getPrefetchTriggers(tDetails) {
  return tDetails.prefetchTriggers ??= /* @__PURE__ */ new Set();
}
function \u0275\u0275defer(index, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = declareTemplate(lView, tView, index, null, 0, 0);
  const injector = lView[INJECTOR];
  if (tView.firstCreatePass) {
    performanceMarkFeature("NgDefer");
    const tDetails = {
      primaryTmplIndex,
      loadingTmplIndex: loadingTmplIndex ?? null,
      placeholderTmplIndex: placeholderTmplIndex ?? null,
      errorTmplIndex: errorTmplIndex ?? null,
      placeholderBlockConfig: null,
      loadingBlockConfig: null,
      dependencyResolverFn: dependencyResolverFn ?? null,
      loadingState: DeferDependenciesLoadingState.NOT_STARTED,
      loadingPromise: null,
      providers: null,
      hydrateTriggers: null,
      prefetchTriggers: null
    };
    enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);
    setTDeferBlockDetails(tView, adjustedIndex, tDetails);
  }
  const lContainer = lView[adjustedIndex];
  populateDehydratedViewsInLContainer(lContainer, tNode, lView);
  let ssrBlockState = null;
  let ssrUniqueId = null;
  if (lContainer[DEHYDRATED_VIEWS]?.length > 0) {
    const info = lContainer[DEHYDRATED_VIEWS][0].data;
    ssrUniqueId = info[DEFER_BLOCK_ID] ?? null;
    ssrBlockState = info[DEFER_BLOCK_STATE$1];
  }
  const lDetails = [
    null,
    // NEXT_DEFER_BLOCK_STATE
    DeferBlockInternalState.Initial,
    // DEFER_BLOCK_STATE
    null,
    // STATE_IS_FROZEN_UNTIL
    null,
    // LOADING_AFTER_CLEANUP_FN
    null,
    // TRIGGER_CLEANUP_FNS
    null,
    // PREFETCH_TRIGGER_CLEANUP_FNS
    ssrUniqueId,
    // SSR_UNIQUE_ID
    ssrBlockState,
    // SSR_BLOCK_STATE
    null,
    // ON_COMPLETE_FNS
    null
    // HYDRATE_TRIGGER_CLEANUP_FNS
  ];
  setLDeferBlockDetails(lView, adjustedIndex, lDetails);
  let registry = null;
  if (ssrUniqueId !== null) {
    ngDevMode && assertIncrementalHydrationIsConfigured(injector);
    registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);
    registry.add(ssrUniqueId, {
      lView,
      tNode,
      lContainer
    });
  }
  const onLViewDestroy = () => {
    invokeAllTriggerCleanupFns(lDetails);
    if (ssrUniqueId !== null) {
      registry?.cleanup([ssrUniqueId]);
    }
  };
  storeTriggerCleanupFn(0, lDetails, () => removeLViewOnDestroy(lView, onLViewDestroy));
  storeLViewOnDestroy(lView, onLViewDestroy);
}
function \u0275\u0275deferWhen(rawValue) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value2 = Boolean(rawValue);
      const tNode = getSelectedTNode();
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);
      const renderedState = lDetails[DEFER_BLOCK_STATE];
      if (value2 === false && renderedState === DeferBlockInternalState.Initial) {
        renderPlaceholder(lView, tNode);
      } else if (value2 === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder) && shouldTriggerWhenOnClient(lView[INJECTOR], lDetails, tDetails)) {
        triggerDeferBlock(lView, tNode);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function \u0275\u0275deferPrefetchWhen(rawValue) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  const bindingIndex = nextBindingIndex();
  const prefetchTriggers = getPrefetchTriggers(getTDeferBlockDetails(getTView(), tNode));
  prefetchTriggers.add(
    6
    /* DeferBlockTrigger.When */
  );
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      const value2 = Boolean(rawValue);
      const tView = lView[TVIEW];
      const tNode2 = getSelectedTNode();
      const tDetails = getTDeferBlockDetails(tView, tNode2);
      if (value2 === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
        triggerPrefetching(tDetails, lView, tNode2);
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  }
}
function \u0275\u0275deferHydrateWhen(rawValue) {
  const lView = getLView();
  const tNode = getSelectedTNode();
  if (!shouldActivateHydrateTrigger(lView, tNode)) {
    return;
  }
  const bindingIndex = nextBindingIndex();
  const tView = getTView();
  const hydrateTriggers = getHydrateTriggers(tView, tNode);
  hydrateTriggers.set(6, null);
  if (bindingUpdated(lView, bindingIndex, rawValue)) {
    const injector = lView[INJECTOR];
    if (false) {
      triggerDeferBlock(lView, tNode);
    } else {
      const prevConsumer = setActiveConsumer(null);
      try {
        const value2 = Boolean(rawValue);
        if (value2 === true) {
          const lDetails = getLDeferBlockDetails(lView, tNode);
          const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
          ngDevMode && assertSsrIdDefined(ssrUniqueId);
          triggerHydrationFromBlockName(injector, ssrUniqueId);
        }
      } finally {
        setActiveConsumer(prevConsumer);
      }
    }
  }
}
function \u0275\u0275deferHydrateNever() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (shouldActivateHydrateTrigger(lView, tNode)) {
    const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
    hydrateTriggers.set(7, null);
    if (false) {
      triggerDeferBlock(lView, tNode);
    }
  }
}
function \u0275\u0275deferOnIdle() {
  scheduleDelayedTrigger(onIdle);
}
function \u0275\u0275deferPrefetchOnIdle() {
  scheduleDelayedPrefetching(
    onIdle,
    0
    /* DeferBlockTrigger.Idle */
  );
}
function \u0275\u0275deferHydrateOnIdle() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (shouldActivateHydrateTrigger(lView, tNode)) {
    const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
    hydrateTriggers.set(0, null);
    if (false) {
      triggerDeferBlock(lView, tNode);
    } else {
      scheduleDelayedHydrating(onIdle, lView, tNode);
    }
  }
}
function \u0275\u0275deferOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const injector = lView[INJECTOR];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  const lDetails = getLDeferBlockDetails(lView, tNode);
  if (!shouldTriggerDeferBlock(injector, tDetails) || tDetails.loadingTmplIndex === null) {
    renderPlaceholder(lView, tNode);
  }
  if (shouldTriggerWhenOnClient(injector, lDetails, tDetails)) {
    triggerDeferBlock(lView, tNode);
  }
}
function \u0275\u0275deferPrefetchOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  const prefetchTriggers = getPrefetchTriggers(tDetails);
  prefetchTriggers.add(
    1
    /* DeferBlockTrigger.Immediate */
  );
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    triggerResourceLoading(tDetails, lView, tNode);
  }
}
function \u0275\u0275deferHydrateOnImmediate() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (shouldActivateHydrateTrigger(lView, tNode)) {
    const injector = lView[INJECTOR];
    const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
    hydrateTriggers.set(1, null);
    if (false) {
      triggerDeferBlock(lView, tNode);
    } else {
      const lDetails = getLDeferBlockDetails(lView, tNode);
      const ssrUniqueId = lDetails[SSR_UNIQUE_ID];
      ngDevMode && assertSsrIdDefined(ssrUniqueId);
      triggerHydrationFromBlockName(injector, ssrUniqueId);
    }
  }
}
function \u0275\u0275deferOnTimer(delay) {
  scheduleDelayedTrigger(onTimer(delay));
}
function \u0275\u0275deferPrefetchOnTimer(delay) {
  scheduleDelayedPrefetching(
    onTimer(delay),
    5
    /* DeferBlockTrigger.Timer */
  );
}
function \u0275\u0275deferHydrateOnTimer(delay) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (shouldActivateHydrateTrigger(lView, tNode)) {
    const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
    hydrateTriggers.set(5, delay);
    if (false) {
      triggerDeferBlock(lView, tNode);
    } else {
      scheduleDelayedHydrating(onTimer(delay), lView, tNode);
    }
  }
}
function \u0275\u0275deferOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);
  renderPlaceholder(lView, tNode);
  if (shouldTriggerWhenOnClient(lView[INJECTOR], lDetails, tDetails)) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerDeferBlock(lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnHover(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  const prefetchTriggers = getPrefetchTriggers(tDetails);
  prefetchTriggers.add(
    4
    /* DeferBlockTrigger.Hover */
  );
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onHover,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnHover() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (shouldActivateHydrateTrigger(lView, tNode)) {
    const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
    hydrateTriggers.set(4, null);
    if (false) {
      triggerDeferBlock(lView, tNode);
    }
  }
}
function \u0275\u0275deferOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);
  renderPlaceholder(lView, tNode);
  if (shouldTriggerWhenOnClient(lView[INJECTOR], lDetails, tDetails)) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerDeferBlock(lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnInteraction(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  const prefetchTriggers = getPrefetchTriggers(tDetails);
  prefetchTriggers.add(
    3
    /* DeferBlockTrigger.Interaction */
  );
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onInteraction,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnInteraction() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (shouldActivateHydrateTrigger(lView, tNode)) {
    const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
    hydrateTriggers.set(3, null);
    if (false) {
      triggerDeferBlock(lView, tNode);
    }
  }
}
function \u0275\u0275deferOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const lDetails = getLDeferBlockDetails(lView, tNode);
  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);
  renderPlaceholder(lView, tNode);
  if (shouldTriggerWhenOnClient(lView[INJECTOR], lDetails, tDetails)) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewport,
      () => triggerDeferBlock(lView, tNode),
      0
      /* TriggerType.Regular */
    );
  }
}
function \u0275\u0275deferPrefetchOnViewport(triggerIndex, walkUpTimes) {
  const lView = getLView();
  const tNode = getCurrentTNode();
  const tView = lView[TVIEW];
  const tDetails = getTDeferBlockDetails(tView, tNode);
  const prefetchTriggers = getPrefetchTriggers(tDetails);
  prefetchTriggers.add(
    2
    /* DeferBlockTrigger.Viewport */
  );
  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {
    registerDomTrigger(
      lView,
      tNode,
      triggerIndex,
      walkUpTimes,
      onViewport,
      () => triggerPrefetching(tDetails, lView, tNode),
      1
      /* TriggerType.Prefetch */
    );
  }
}
function \u0275\u0275deferHydrateOnViewport() {
  const lView = getLView();
  const tNode = getCurrentTNode();
  if (shouldActivateHydrateTrigger(lView, tNode)) {
    const hydrateTriggers = getHydrateTriggers(getTView(), tNode);
    hydrateTriggers.set(2, null);
    const injector = lView[INJECTOR];
    if (false) {
      triggerDeferBlock(lView, tNode);
    }
  }
}
function \u0275\u0275attribute(name, value2, sanitizer, namespace2) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value2)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, name, value2, sanitizer, namespace2);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, "attr." + name, bindingIndex);
  }
  return \u0275\u0275attribute;
}
function interpolationV(lView, values) {
  ngDevMode && assertLessThan(2, values.length, "should have at least 3 values");
  ngDevMode && assertEqual(values.length % 2, 1, "should have an odd number of values");
  let isBindingUpdated = false;
  let bindingIndex = getBindingIndex();
  for (let i = 1; i < values.length; i += 2) {
    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
  }
  setBindingIndex(bindingIndex);
  if (!isBindingUpdated) {
    return NO_CHANGE;
  }
  let content = values[0];
  for (let i = 1; i < values.length; i += 2) {
    content += renderStringify(values[i]) + values[i + 1];
  }
  return content;
}
function interpolation1(lView, prefix, v0, suffix) {
  const different = bindingUpdated(lView, nextBindingIndex(), v0);
  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
}
function interpolation2(lView, prefix, v0, i0, v1, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated2(lView, bindingIndex, v0, v1);
  incrementBindingIndex(2);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
}
function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
  incrementBindingIndex(3);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
}
function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const bindingIndex = getBindingIndex();
  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  incrementBindingIndex(4);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
}
function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
  incrementBindingIndex(5);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
}
function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
  incrementBindingIndex(6);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
}
function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
  incrementBindingIndex(7);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
}
function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const bindingIndex = getBindingIndex();
  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
  incrementBindingIndex(8);
  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
}
function \u0275\u0275attributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace2) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace2);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 1, prefix, suffix);
  }
  return \u0275\u0275attributeInterpolate1;
}
function \u0275\u0275attributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace2) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace2);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 2, prefix, i0, suffix);
  }
  return \u0275\u0275attributeInterpolate2;
}
function \u0275\u0275attributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace2) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace2);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);
  }
  return \u0275\u0275attributeInterpolate3;
}
function \u0275\u0275attributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace2) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace2);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
  }
  return \u0275\u0275attributeInterpolate4;
}
function \u0275\u0275attributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace2) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace2);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
  }
  return \u0275\u0275attributeInterpolate5;
}
function \u0275\u0275attributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace2) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace2);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
  }
  return \u0275\u0275attributeInterpolate6;
}
function \u0275\u0275attributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace2) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace2);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
  }
  return \u0275\u0275attributeInterpolate7;
}
function \u0275\u0275attributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace2) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace2);
    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
  }
  return \u0275\u0275attributeInterpolate8;
}
function \u0275\u0275attributeInterpolateV(attrName, values, sanitizer, namespace2) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    const tNode = getSelectedTNode();
    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace2);
    if (ngDevMode) {
      const interpolationInBetween = [values[0]];
      for (let i = 2; i < values.length; i += 2) {
        interpolationInBetween.push(values[i]);
      }
      storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
    }
  }
  return \u0275\u0275attributeInterpolateV;
}
function toTStylingRange(prev, next) {
  ngDevMode && assertNumberInRange(
    prev,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return prev << 17 | next << 2;
}
function getTStylingRangePrev(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange >> 17 & 32767;
}
function getTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 2) == 2;
}
function setTStylingRangePrev(tStylingRange, previous) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    previous,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~4294836224 | previous << 17;
}
function setTStylingRangePrevDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 2;
}
function getTStylingRangeNext(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 131068) >> 2;
}
function setTStylingRangeNext(tStylingRange, next) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  ngDevMode && assertNumberInRange(
    next,
    0,
    32767
    /* StylingRange.UNSIGNED_MASK */
  );
  return tStylingRange & ~131068 | //
  next << 2;
}
function getTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return (tStylingRange & 1) === 1;
}
function setTStylingRangeNextDuplicate(tStylingRange) {
  ngDevMode && assertNumber(tStylingRange, "expected number");
  return tStylingRange | 1;
}
function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {
  ngDevMode && assertFirstUpdatePass(getTView());
  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
  let tmplHead = getTStylingRangePrev(tBindings);
  let tmplTail = getTStylingRangeNext(tBindings);
  tData[index] = tStylingKeyWithStatic;
  let isKeyDuplicateOfStatic = false;
  let tStylingKey;
  if (Array.isArray(tStylingKeyWithStatic)) {
    const staticKeyValueArray = tStylingKeyWithStatic;
    tStylingKey = staticKeyValueArray[1];
    if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
      isKeyDuplicateOfStatic = true;
    }
  } else {
    tStylingKey = tStylingKeyWithStatic;
  }
  if (isHostBinding) {
    const hasTemplateBindings = tmplTail !== 0;
    if (hasTemplateBindings) {
      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
      tData[index + 1] = toTStylingRange(previousNode, tmplHead);
      if (previousNode !== 0) {
        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
      }
      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
    } else {
      tData[index + 1] = toTStylingRange(tmplHead, 0);
      if (tmplHead !== 0) {
        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
      }
      tmplHead = index;
    }
  } else {
    tData[index + 1] = toTStylingRange(tmplTail, 0);
    ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
    if (tmplHead === 0) {
      tmplHead = index;
    } else {
      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
    }
    tmplTail = index;
  }
  if (isKeyDuplicateOfStatic) {
    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
  }
  markDuplicates(tData, tStylingKey, index, true);
  markDuplicates(tData, tStylingKey, index, false);
  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
  tBindings = toTStylingRange(tmplHead, tmplTail);
  if (isClassBinding) {
    tNode.classBindings = tBindings;
  } else {
    tNode.styleBindings = tBindings;
  }
}
function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
  if (residual != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
  }
}
function markDuplicates(tData, tStylingKey, index, isPrevDir) {
  const tStylingAtIndex = tData[index + 1];
  const isMap = tStylingKey === null;
  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
  let foundDuplicate = false;
  while (cursor !== 0 && (foundDuplicate === false || isMap)) {
    ngDevMode && assertIndexInRange(tData, cursor);
    const tStylingValueAtCursor = tData[cursor];
    const tStyleRangeAtCursor = tData[cursor + 1];
    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
      foundDuplicate = true;
      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
    }
    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
  }
  if (foundDuplicate) {
    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
  }
}
function isStylingMatch(tStylingKeyCursor, tStylingKey) {
  ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
  if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that
  // location so we must assume that we have a match.
  tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it
  // contains a match.
  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
    return true;
  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
  }
  return false;
}
var parserState = {
  textEnd: 0,
  key: 0,
  keyEnd: 0,
  value: 0,
  valueEnd: 0
};
function getLastParsedKey(text2) {
  return text2.substring(parserState.key, parserState.keyEnd);
}
function getLastParsedValue(text2) {
  return text2.substring(parserState.value, parserState.valueEnd);
}
function parseClassName(text2) {
  resetParserState(text2);
  return parseClassNameNext(text2, consumeWhitespace(text2, 0, parserState.textEnd));
}
function parseClassNameNext(text2, index) {
  const end2 = parserState.textEnd;
  if (end2 === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeClassToken(text2, parserState.key = index, end2);
  return consumeWhitespace(text2, index, end2);
}
function parseStyle(text2) {
  resetParserState(text2);
  return parseStyleNext(text2, consumeWhitespace(text2, 0, parserState.textEnd));
}
function parseStyleNext(text2, startIndex) {
  const end2 = parserState.textEnd;
  let index = parserState.key = consumeWhitespace(text2, startIndex, end2);
  if (end2 === index) {
    return -1;
  }
  index = parserState.keyEnd = consumeStyleKey(text2, index, end2);
  index = consumeSeparator(
    text2,
    index,
    end2,
    58
    /* CharCode.COLON */
  );
  index = parserState.value = consumeWhitespace(text2, index, end2);
  index = parserState.valueEnd = consumeStyleValue(text2, index, end2);
  return consumeSeparator(
    text2,
    index,
    end2,
    59
    /* CharCode.SEMI_COLON */
  );
}
function resetParserState(text2) {
  parserState.key = 0;
  parserState.keyEnd = 0;
  parserState.value = 0;
  parserState.valueEnd = 0;
  parserState.textEnd = text2.length;
}
function consumeWhitespace(text2, startIndex, endIndex) {
  while (startIndex < endIndex && text2.charCodeAt(startIndex) <= 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeClassToken(text2, startIndex, endIndex) {
  while (startIndex < endIndex && text2.charCodeAt(startIndex) > 32) {
    startIndex++;
  }
  return startIndex;
}
function consumeStyleKey(text2, startIndex, endIndex) {
  let ch;
  while (startIndex < endIndex && ((ch = text2.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
    startIndex++;
  }
  return startIndex;
}
function consumeSeparator(text2, startIndex, endIndex, separator) {
  startIndex = consumeWhitespace(text2, startIndex, endIndex);
  if (startIndex < endIndex) {
    if (ngDevMode && text2.charCodeAt(startIndex) !== separator) {
      malformedStyleError(text2, String.fromCharCode(separator), startIndex);
    }
    startIndex++;
  }
  return startIndex;
}
function consumeStyleValue(text2, startIndex, endIndex) {
  let ch1 = -1;
  let ch2 = -1;
  let ch3 = -1;
  let i = startIndex;
  let lastChIndex = i;
  while (i < endIndex) {
    const ch = text2.charCodeAt(i++);
    if (ch === 59) {
      return lastChIndex;
    } else if (ch === 34 || ch === 39) {
      lastChIndex = i = consumeQuotedText(text2, ch, i, endIndex);
    } else if (startIndex === i - 4 && // We have seen only 4 characters so far "URL(" (Ignore "foo_URL()")
    ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
      lastChIndex = i = consumeQuotedText(text2, 41, i, endIndex);
    } else if (ch > 32) {
      lastChIndex = i;
    }
    ch3 = ch2;
    ch2 = ch1;
    ch1 = ch & -33;
  }
  return lastChIndex;
}
function consumeQuotedText(text2, quoteCharCode, startIndex, endIndex) {
  let ch1 = -1;
  let index = startIndex;
  while (index < endIndex) {
    const ch = text2.charCodeAt(index++);
    if (ch == quoteCharCode && ch1 !== 92) {
      return index;
    }
    if (ch == 92 && ch1 === 92) {
      ch1 = 0;
    } else {
      ch1 = ch;
    }
  }
  throw ngDevMode ? malformedStyleError(text2, String.fromCharCode(quoteCharCode), endIndex) : new Error();
}
function malformedStyleError(text2, expecting, index) {
  ngDevMode && assertEqual(typeof text2 === "string", true, "String expected here");
  throw throwError2(`Malformed style at location ${index} in string '` + text2.substring(0, index) + "[>>" + text2.substring(index, index + 1) + "<<]" + text2.slice(index + 1) + `'. Expecting '${expecting}'.`);
}
function \u0275\u0275property(propName, value2, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value2)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value2, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275property;
}
function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value2, isClassBased) {
  const inputs = tNode.inputs;
  const property = isClassBased ? "class" : "style";
  setInputsForProperty(tView, lView, inputs[property], property, value2);
}
function \u0275\u0275styleProp(prop, value2, suffix) {
  checkStylingProperty(prop, value2, suffix, false);
  return \u0275\u0275styleProp;
}
function \u0275\u0275classProp(className, value2) {
  checkStylingProperty(className, value2, null, true);
  return \u0275\u0275classProp;
}
function \u0275\u0275styleMap(styles2) {
  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles2, false);
}
function styleStringParser(keyValueArray, text2) {
  for (let i = parseStyle(text2); i >= 0; i = parseStyleNext(text2, i)) {
    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text2), getLastParsedValue(text2));
  }
}
function \u0275\u0275classMap(classes) {
  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);
}
function classStringParser(keyValueArray, text2) {
  for (let i = parseClassName(text2); i >= 0; i = parseClassNameNext(text2, i)) {
    keyValueArraySet(keyValueArray, getLastParsedKey(text2), true);
  }
}
function checkStylingProperty(prop, value2, suffix, isClassBased) {
  const lView = getLView();
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
  }
  if (value2 !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value2)) {
    const tNode = tView.data[getSelectedIndex()];
    updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value2, suffix), isClassBased, bindingIndex);
  }
}
function checkStylingMap(keyValueArraySet2, stringParser, value2, isClassBased) {
  const tView = getTView();
  const bindingIndex = incrementBindingIndex(2);
  if (tView.firstUpdatePass) {
    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
  }
  const lView = getLView();
  if (value2 !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value2)) {
    const tNode = tView.data[getSelectedIndex()];
    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
      if (ngDevMode) {
        const tStylingKey = tView.data[bindingIndex];
        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
      }
      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
      ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
      if (staticPrefix !== null) {
        value2 = concatStringsWithSpace(staticPrefix, value2 ? value2 : "");
      }
      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value2, isClassBased);
    } else {
      updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value2), isClassBased, bindingIndex);
    }
  }
}
function isInHostBindings(tView, bindingIndex) {
  return bindingIndex >= tView.expandoStartIndex;
}
function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
  ngDevMode && assertFirstUpdatePass(tView);
  const tData = tView.data;
  if (tData[bindingIndex + 1] === null) {
    const tNode = tData[getSelectedIndex()];
    ngDevMode && assertDefined(tNode, "TNode expected");
    const isHostBindings = isInHostBindings(tView, bindingIndex);
    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
      tStylingKey = false;
    }
    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
  }
}
function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
  const hostDirectiveDef = getCurrentDirectiveDef(tData);
  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
  if (hostDirectiveDef === null) {
    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
    if (isFirstStylingInstructionInTemplate) {
      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
      residual = null;
    }
  } else {
    const directiveStylingLast = tNode.directiveStylingLast;
    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
    if (isFirstStylingInstructionInHostBinding) {
      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
      if (residual === null) {
        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
        if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
        }
      } else {
        residual = collectResidual(tData, tNode, isClassBased);
      }
    }
  }
  if (residual !== void 0) {
    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
  }
  return stylingKey;
}
function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  if (getTStylingRangeNext(bindings) === 0) {
    return void 0;
  }
  return tData[getTStylingRangePrev(bindings)];
}
function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
  ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
  tData[getTStylingRangePrev(bindings)] = tStylingKey;
}
function collectResidual(tData, tNode, isClassBased) {
  let residual = void 0;
  const directiveEnd = tNode.directiveEnd;
  ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
    const attrs = tData[i].hostAttrs;
    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
  }
  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
}
function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
  let currentDirective = null;
  const directiveEnd = tNode.directiveEnd;
  let directiveStylingLast = tNode.directiveStylingLast;
  if (directiveStylingLast === -1) {
    directiveStylingLast = tNode.directiveStart;
  } else {
    directiveStylingLast++;
  }
  while (directiveStylingLast < directiveEnd) {
    currentDirective = tData[directiveStylingLast];
    ngDevMode && assertDefined(currentDirective, "expected to be defined");
    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
    if (currentDirective === hostDirectiveDef) break;
    directiveStylingLast++;
  }
  if (hostDirectiveDef !== null) {
    tNode.directiveStylingLast = directiveStylingLast;
  }
  return stylingKey;
}
function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
  const desiredMarker = isClassBased ? 1 : 2;
  let currentMarker = -1;
  if (attrs !== null) {
    for (let i = 0; i < attrs.length; i++) {
      const item = attrs[i];
      if (typeof item === "number") {
        currentMarker = item;
      } else {
        if (currentMarker === desiredMarker) {
          if (!Array.isArray(stylingKey)) {
            stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
          }
          keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
        }
      }
    }
  }
  return stylingKey === void 0 ? null : stylingKey;
}
function toStylingKeyValueArray(keyValueArraySet2, stringParser, value2) {
  if (value2 == null || value2 === "") return EMPTY_ARRAY;
  const styleKeyValueArray = [];
  const unwrappedValue = unwrapSafeValue(value2);
  if (Array.isArray(unwrappedValue)) {
    for (let i = 0; i < unwrappedValue.length; i++) {
      keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
    }
  } else if (typeof unwrappedValue === "object") {
    for (const key in unwrappedValue) {
      if (unwrappedValue.hasOwnProperty(key)) {
        keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
      }
    }
  } else if (typeof unwrappedValue === "string") {
    stringParser(styleKeyValueArray, unwrappedValue);
  } else {
    ngDevMode && throwError2("Unsupported styling type " + typeof unwrappedValue + ": " + unwrappedValue);
  }
  return styleKeyValueArray;
}
function styleKeyValueArraySet(keyValueArray, key, value2) {
  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value2));
}
function classKeyValueArraySet(keyValueArray, key, value2) {
  const stringKey = String(key);
  if (stringKey !== "" && !stringKey.includes(" ")) {
    keyValueArraySet(keyValueArray, stringKey, value2);
  }
}
function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
  if (oldKeyValueArray === NO_CHANGE) {
    oldKeyValueArray = EMPTY_ARRAY;
  }
  let oldIndex = 0;
  let newIndex = 0;
  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
  while (oldKey !== null || newKey !== null) {
    ngDevMode && assertLessThan(oldIndex, 999, "Are we stuck in infinite loop?");
    ngDevMode && assertLessThan(newIndex, 999, "Are we stuck in infinite loop?");
    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
    let setKey = null;
    let setValue = void 0;
    if (oldKey === newKey) {
      oldIndex += 2;
      newIndex += 2;
      if (oldValue !== newValue) {
        setKey = newKey;
        setValue = newValue;
      }
    } else if (newKey === null || oldKey !== null && oldKey < newKey) {
      oldIndex += 2;
      setKey = oldKey;
    } else {
      ngDevMode && assertDefined(newKey, "Expecting to have a valid key");
      newIndex += 2;
      setKey = newKey;
      setValue = newValue;
    }
    if (setKey !== null) {
      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
    }
    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
  }
}
function updateStyling(tView, tNode, lView, renderer, prop, value2, isClassBased, bindingIndex) {
  if (!(tNode.type & 3)) {
    return;
  }
  const tData = tView.data;
  const tRange = tData[bindingIndex + 1];
  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
  if (!isStylingValuePresent(higherPriorityValue)) {
    if (!isStylingValuePresent(value2)) {
      if (getTStylingRangePrevDuplicate(tRange)) {
        value2 = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
      }
    }
    const rNode = getNativeByIndex(getSelectedIndex(), lView);
    applyStyling(renderer, isClassBased, rNode, prop, value2);
  }
}
function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
  const isPrevDirection = tNode === null;
  let value2 = void 0;
  while (index > 0) {
    const rawKey = tData[index];
    const containsStatics = Array.isArray(rawKey);
    const key = containsStatics ? rawKey[1] : rawKey;
    const isStylingMap = key === null;
    let valueAtLViewIndex = lView[index + 1];
    if (valueAtLViewIndex === NO_CHANGE) {
      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
    }
    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
    if (containsStatics && !isStylingValuePresent(currentValue)) {
      currentValue = keyValueArrayGet(rawKey, prop);
    }
    if (isStylingValuePresent(currentValue)) {
      value2 = currentValue;
      if (isPrevDirection) {
        return value2;
      }
    }
    const tRange = tData[index + 1];
    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
  }
  if (tNode !== null) {
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null) {
      value2 = keyValueArrayGet(residual, prop);
    }
  }
  return value2;
}
function isStylingValuePresent(value2) {
  return value2 !== void 0;
}
function normalizeSuffix(value2, suffix) {
  if (value2 == null || value2 === "") {
  } else if (typeof suffix === "string") {
    value2 = value2 + suffix;
  } else if (typeof value2 === "object") {
    value2 = stringify(unwrapSafeValue(value2));
  }
  return value2;
}
function hasStylingInputShadow(tNode, isClassBased) {
  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;
}
function \u0275\u0275classMapInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275classMapInterpolateV(values) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
}
function \u0275\u0275componentInstance() {
  const instance = getLView()[DECLARATION_COMPONENT_VIEW][CONTEXT];
  ngDevMode && assertDefined(instance, "Expected component instance to be defined");
  return instance;
}
var LiveCollection = class {
  destroy(item) {
  }
  updateValue(index, value2) {
  }
  // operations below could be implemented on top of the operations defined so far, but having
  // them explicitly allow clear expression of intent and potentially more performant
  // implementations
  swap(index1, index2) {
    const startIdx = Math.min(index1, index2);
    const endIdx = Math.max(index1, index2);
    const endItem = this.detach(endIdx);
    if (endIdx - startIdx > 1) {
      const startItem = this.detach(startIdx);
      this.attach(startIdx, endItem);
      this.attach(endIdx, startItem);
    } else {
      this.attach(startIdx, endItem);
    }
  }
  move(prevIndex, newIdx) {
    this.attach(newIdx, this.detach(prevIndex));
  }
};
function valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {
  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {
    return 1;
  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {
    return -1;
  }
  return 0;
}
function recordDuplicateKeys(keyToIdx, key, idx) {
  const idxSoFar = keyToIdx.get(key);
  if (idxSoFar !== void 0) {
    idxSoFar.add(idx);
  } else {
    keyToIdx.set(key, /* @__PURE__ */ new Set([idx]));
  }
}
function reconcile(liveCollection, newCollection, trackByFn) {
  let detachedItems = void 0;
  let liveKeysInTheFuture = void 0;
  let liveStartIdx = 0;
  let liveEndIdx = liveCollection.length - 1;
  const duplicateKeys = ngDevMode ? /* @__PURE__ */ new Map() : void 0;
  if (Array.isArray(newCollection)) {
    let newEndIdx = newCollection.length - 1;
    while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {
      const liveStartValue = liveCollection.at(liveStartIdx);
      const newStartValue = newCollection[liveStartIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newStartValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newStartValue);
        }
        liveStartIdx++;
        continue;
      }
      const liveEndValue = liveCollection.at(liveEndIdx);
      const newEndValue = newCollection[newEndIdx];
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(newEndIdx, newEndValue), newEndIdx);
      }
      const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);
      if (isEndMatching !== 0) {
        if (isEndMatching < 0) {
          liveCollection.updateValue(liveEndIdx, newEndValue);
        }
        liveEndIdx--;
        newEndIdx--;
        continue;
      }
      const liveStartKey = trackByFn(liveStartIdx, liveStartValue);
      const liveEndKey = trackByFn(liveEndIdx, liveEndValue);
      const newStartKey = trackByFn(liveStartIdx, newStartValue);
      if (Object.is(newStartKey, liveEndKey)) {
        const newEndKey = trackByFn(newEndIdx, newEndValue);
        if (Object.is(newEndKey, liveStartKey)) {
          liveCollection.swap(liveStartIdx, liveEndIdx);
          liveCollection.updateValue(liveEndIdx, newEndValue);
          newEndIdx--;
          liveEndIdx--;
        } else {
          liveCollection.move(liveEndIdx, liveStartIdx);
        }
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        continue;
      }
      detachedItems ??= new UniqueValueMultiKeyMap();
      liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
      if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {
        liveCollection.updateValue(liveStartIdx, newStartValue);
        liveStartIdx++;
        liveEndIdx++;
      } else if (!liveKeysInTheFuture.has(newStartKey)) {
        const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);
        liveCollection.attach(liveStartIdx, newItem);
        liveStartIdx++;
        liveEndIdx++;
      } else {
        detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));
        liveEndIdx--;
      }
    }
    while (liveStartIdx <= newEndIdx) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);
      liveStartIdx++;
    }
  } else if (newCollection != null) {
    const newCollectionIterator = newCollection[Symbol.iterator]();
    let newIterationResult = newCollectionIterator.next();
    while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {
      const liveValue = liveCollection.at(liveStartIdx);
      const newValue = newIterationResult.value;
      if (ngDevMode) {
        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newValue), liveStartIdx);
      }
      const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);
      if (isStartMatching !== 0) {
        if (isStartMatching < 0) {
          liveCollection.updateValue(liveStartIdx, newValue);
        }
        liveStartIdx++;
        newIterationResult = newCollectionIterator.next();
      } else {
        detachedItems ??= new UniqueValueMultiKeyMap();
        liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);
        const newKey = trackByFn(liveStartIdx, newValue);
        if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {
          liveCollection.updateValue(liveStartIdx, newValue);
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else if (!liveKeysInTheFuture.has(newKey)) {
          liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));
          liveStartIdx++;
          liveEndIdx++;
          newIterationResult = newCollectionIterator.next();
        } else {
          const liveKey = trackByFn(liveStartIdx, liveValue);
          detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));
          liveEndIdx--;
        }
      }
    }
    while (!newIterationResult.done) {
      createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);
      newIterationResult = newCollectionIterator.next();
    }
  }
  while (liveStartIdx <= liveEndIdx) {
    liveCollection.destroy(liveCollection.detach(liveEndIdx--));
  }
  detachedItems?.forEach((item) => {
    liveCollection.destroy(item);
  });
  if (ngDevMode) {
    let duplicatedKeysMsg = [];
    for (const [key, idxSet] of duplicateKeys) {
      if (idxSet.size > 1) {
        const idx = [...idxSet].sort((a, b) => a - b);
        for (let i = 1; i < idx.length; i++) {
          duplicatedKeysMsg.push(`key "${stringifyForError(key)}" at index "${idx[i - 1]}" and "${idx[i]}"`);
        }
      }
    }
    if (duplicatedKeysMsg.length > 0) {
      const message = formatRuntimeError(-955, "The provided track expression resulted in duplicated keys for a given collection. Adjust the tracking expression such that it uniquely identifies all the items in the collection. Duplicated keys were: \n" + duplicatedKeysMsg.join(", \n") + ".");
      console.warn(message);
    }
  }
}
function attachPreviouslyDetached(prevCollection, detachedItems, index, key) {
  if (detachedItems !== void 0 && detachedItems.has(key)) {
    prevCollection.attach(index, detachedItems.get(key));
    detachedItems.delete(key);
    return true;
  }
  return false;
}
function createOrAttach(liveCollection, detachedItems, trackByFn, index, value2) {
  if (!attachPreviouslyDetached(liveCollection, detachedItems, index, trackByFn(index, value2))) {
    const newItem = liveCollection.create(index, value2);
    liveCollection.attach(index, newItem);
  } else {
    liveCollection.updateValue(index, value2);
  }
}
function initLiveItemsInTheFuture(liveCollection, start2, end2, trackByFn) {
  const keys = /* @__PURE__ */ new Set();
  for (let i = start2; i <= end2; i++) {
    keys.add(trackByFn(i, liveCollection.at(i)));
  }
  return keys;
}
var UniqueValueMultiKeyMap = class {
  // A map from a key to the first value corresponding to this key.
  kvMap = /* @__PURE__ */ new Map();
  // A map that acts as a linked list of values - each value maps to the next value in this "linked
  // list" (this only works if values are unique). Allocated lazily to avoid memory consumption when
  // there are no duplicated values.
  _vMap = void 0;
  has(key) {
    return this.kvMap.has(key);
  }
  delete(key) {
    if (!this.has(key)) return false;
    const value2 = this.kvMap.get(key);
    if (this._vMap !== void 0 && this._vMap.has(value2)) {
      this.kvMap.set(key, this._vMap.get(value2));
      this._vMap.delete(value2);
    } else {
      this.kvMap.delete(key);
    }
    return true;
  }
  get(key) {
    return this.kvMap.get(key);
  }
  set(key, value2) {
    if (this.kvMap.has(key)) {
      let prevValue = this.kvMap.get(key);
      if (ngDevMode && prevValue === value2) {
        throw new Error(`Detected a duplicated value ${value2} for the key ${key}`);
      }
      if (this._vMap === void 0) {
        this._vMap = /* @__PURE__ */ new Map();
      }
      const vMap = this._vMap;
      while (vMap.has(prevValue)) {
        prevValue = vMap.get(prevValue);
      }
      vMap.set(prevValue, value2);
    } else {
      this.kvMap.set(key, value2);
    }
  }
  forEach(cb) {
    for (let [key, value2] of this.kvMap) {
      cb(value2, key);
      if (this._vMap !== void 0) {
        const vMap = this._vMap;
        while (vMap.has(value2)) {
          value2 = vMap.get(value2);
          cb(value2, key);
        }
      }
    }
  }
};
function \u0275\u0275conditional(matchingTemplateIndex, contextValue) {
  performanceMarkFeature("NgControlFlow");
  const hostLView = getLView();
  const bindingIndex = nextBindingIndex();
  const prevMatchingTemplateIndex = hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;
  const prevContainer = prevMatchingTemplateIndex !== -1 ? getLContainer(hostLView, HEADER_OFFSET + prevMatchingTemplateIndex) : void 0;
  const viewInContainerIdx = 0;
  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {
    const prevConsumer = setActiveConsumer(null);
    try {
      if (prevContainer !== void 0) {
        removeLViewFromLContainer(prevContainer, viewInContainerIdx);
      }
      if (matchingTemplateIndex !== -1) {
        const nextLContainerIndex = HEADER_OFFSET + matchingTemplateIndex;
        const nextContainer = getLContainer(hostLView, nextLContainerIndex);
        const templateTNode = getExistingTNode(hostLView[TVIEW], nextLContainerIndex);
        const dehydratedView = findMatchingDehydratedView(nextContainer, templateTNode.tView.ssrId);
        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {
          dehydratedView
        });
        addLViewToLContainer(nextContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));
      }
    } finally {
      setActiveConsumer(prevConsumer);
    }
  } else if (prevContainer !== void 0) {
    const lView = getLViewFromLContainer(prevContainer, viewInContainerIdx);
    if (lView !== void 0) {
      lView[CONTEXT] = contextValue;
    }
  }
}
var RepeaterContext = class {
  lContainer;
  $implicit;
  $index;
  constructor(lContainer, $implicit, $index) {
    this.lContainer = lContainer;
    this.$implicit = $implicit;
    this.$index = $index;
  }
  get $count() {
    return this.lContainer.length - CONTAINER_HEADER_OFFSET;
  }
};
function \u0275\u0275repeaterTrackByIndex(index) {
  return index;
}
function \u0275\u0275repeaterTrackByIdentity(_, value2) {
  return value2;
}
var RepeaterMetadata = class {
  hasEmptyBlock;
  trackByFn;
  liveCollection;
  constructor(hasEmptyBlock, trackByFn, liveCollection) {
    this.hasEmptyBlock = hasEmptyBlock;
    this.trackByFn = trackByFn;
    this.liveCollection = liveCollection;
  }
};
function \u0275\u0275repeaterCreate(index, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {
  performanceMarkFeature("NgControlFlow");
  ngDevMode && assertFunction(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);
  const lView = getLView();
  const tView = getTView();
  const hasEmptyBlock = emptyTemplateFn !== void 0;
  const hostLView = getLView();
  const boundTrackBy = trackByUsesComponentInstance ? (
    // We only want to bind when necessary, because it produces a
    // new function. For pure functions it's not necessary.
    trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT])
  ) : trackByFn;
  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);
  hostLView[HEADER_OFFSET + index] = metadata;
  declareTemplate(lView, tView, index + 1, templateFn, decls, vars, tagName, getConstant(tView.consts, attrsIndex));
  if (hasEmptyBlock) {
    ngDevMode && assertDefined(emptyDecls, "Missing number of declarations for the empty repeater block.");
    ngDevMode && assertDefined(emptyVars, "Missing number of bindings for the empty repeater block.");
    declareTemplate(lView, tView, index + 2, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, getConstant(tView.consts, emptyAttrsIndex));
  }
}
function isViewExpensiveToRecreate(lView) {
  return lView.length - HEADER_OFFSET > 2;
}
var OperationsCounter = class {
  created = 0;
  destroyed = 0;
  reset() {
    this.created = 0;
    this.destroyed = 0;
  }
  recordCreate() {
    this.created++;
  }
  recordDestroy() {
    this.destroyed++;
  }
  /**
   * A method indicating if the entire collection was re-created as part of the reconciliation pass.
   * Used to warn developers about the usage of a tracking function that might result in excessive
   * amount of view creation / destroy operations.
   *
   * @returns boolean value indicating if a live collection was re-created
   */
  wasReCreated(collectionLen) {
    return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;
  }
};
var LiveCollectionLContainerImpl = class extends LiveCollection {
  lContainer;
  hostLView;
  templateTNode;
  operationsCounter = ngDevMode ? new OperationsCounter() : void 0;
  /**
   Property indicating if indexes in the repeater context need to be updated following the live
   collection changes. Index updates are necessary if and only if views are inserted / removed in
   the middle of LContainer. Adds and removals at the end don't require index updates.
  */
  needsIndexUpdate = false;
  constructor(lContainer, hostLView, templateTNode) {
    super();
    this.lContainer = lContainer;
    this.hostLView = hostLView;
    this.templateTNode = templateTNode;
  }
  get length() {
    return this.lContainer.length - CONTAINER_HEADER_OFFSET;
  }
  at(index) {
    return this.getLView(index)[CONTEXT].$implicit;
  }
  attach(index, lView) {
    const dehydratedView = lView[HYDRATION];
    this.needsIndexUpdate ||= index !== this.length;
    addLViewToLContainer(this.lContainer, lView, index, shouldAddViewToDom(this.templateTNode, dehydratedView));
  }
  detach(index) {
    this.needsIndexUpdate ||= index !== this.length - 1;
    return detachExistingView(this.lContainer, index);
  }
  create(index, value2) {
    const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);
    const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value2, index), {
      dehydratedView
    });
    this.operationsCounter?.recordCreate();
    return embeddedLView;
  }
  destroy(lView) {
    destroyLView(lView[TVIEW], lView);
    this.operationsCounter?.recordDestroy();
  }
  updateValue(index, value2) {
    this.getLView(index)[CONTEXT].$implicit = value2;
  }
  reset() {
    this.needsIndexUpdate = false;
    this.operationsCounter?.reset();
  }
  updateIndexes() {
    if (this.needsIndexUpdate) {
      for (let i = 0; i < this.length; i++) {
        this.getLView(i)[CONTEXT].$index = i;
      }
    }
  }
  getLView(index) {
    return getExistingLViewFromLContainer(this.lContainer, index);
  }
};
function \u0275\u0275repeater(collection) {
  const prevConsumer = setActiveConsumer(null);
  const metadataSlotIdx = getSelectedIndex();
  try {
    const hostLView = getLView();
    const hostTView = hostLView[TVIEW];
    const metadata = hostLView[metadataSlotIdx];
    const containerIndex = metadataSlotIdx + 1;
    const lContainer = getLContainer(hostLView, containerIndex);
    if (metadata.liveCollection === void 0) {
      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);
      metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);
    } else {
      metadata.liveCollection.reset();
    }
    const liveCollection = metadata.liveCollection;
    reconcile(liveCollection, collection, metadata.trackByFn);
    if (ngDevMode && metadata.trackByFn === \u0275\u0275repeaterTrackByIdentity && liveCollection.operationsCounter?.wasReCreated(liveCollection.length) && isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))) {
      const message = formatRuntimeError(-956, `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. Please review the "track expression" and make sure that it uniquely identifies items in a collection.`);
      console.warn(message);
    }
    liveCollection.updateIndexes();
    if (metadata.hasEmptyBlock) {
      const bindingIndex = nextBindingIndex();
      const isCollectionEmpty = liveCollection.length === 0;
      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {
        const emptyTemplateIndex = metadataSlotIdx + 2;
        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);
        if (isCollectionEmpty) {
          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);
          const dehydratedView = findMatchingDehydratedView(lContainerForEmpty, emptyTemplateTNode.tView.ssrId);
          const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, void 0, {
            dehydratedView
          });
          addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));
        } else {
          removeLViewFromLContainer(lContainerForEmpty, 0);
        }
      }
    }
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
function getLContainer(lView, index) {
  const lContainer = lView[index];
  ngDevMode && assertLContainer(lContainer);
  return lContainer;
}
function detachExistingView(lContainer, index) {
  const existingLView = detachView(lContainer, index);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingLViewFromLContainer(lContainer, index) {
  const existingLView = getLViewFromLContainer(lContainer, index);
  ngDevMode && assertLView(existingLView);
  return existingLView;
}
function getExistingTNode(tView, index) {
  const tNode = getTNode(tView, index);
  ngDevMode && assertTNode(tNode);
  return tNode;
}
function elementStartFirstCreatePass(index, tView, lView, name, attrsIndex, localRefsIndex) {
  ngDevMode && assertFirstCreatePass(tView);
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, 2, name, attrs);
  resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
  if (tNode.attrs !== null) {
    computeStaticStyling(tNode, tNode.attrs, false);
  }
  if (tNode.mergedAttrs !== null) {
    computeStaticStyling(tNode, tNode.mergedAttrs, true);
  }
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = HEADER_OFFSET + index;
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "elements should be created before any bindings");
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  const renderer = lView[RENDERER];
  const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  const native = _locateOrCreateElementNode(tView, lView, tNode, renderer, name, index);
  lView[adjustedIndex] = native;
  const hasDirectives = isDirectiveHost(tNode);
  if (ngDevMode && tView.firstCreatePass) {
    validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);
  }
  setCurrentTNode(tNode, true);
  setupStaticAttributes(renderer, native, tNode);
  if (!isDetachedByI18n(tNode) && wasLastNodeCreated()) {
    appendChild(tView, lView, native, tNode);
  }
  if (getElementDepthCount() === 0) {
    attachPatchData(native, lView);
  }
  increaseElementDepthCount();
  if (hasDirectives) {
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex !== null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275elementStart;
}
function \u0275\u0275elementEnd() {
  let currentTNode = getCurrentTNode();
  ngDevMode && assertDefined(currentTNode, "No parent node to close.");
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    ngDevMode && assertHasParent(getCurrentTNode());
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  const tNode = currentTNode;
  ngDevMode && assertTNodeType(
    tNode,
    3
    /* TNodeType.AnyRNode */
  );
  if (isSkipHydrationRootTNode(tNode)) {
    leaveSkipHydrationBlock();
  }
  decreaseElementDepthCount();
  const tView = getTView();
  if (tView.firstCreatePass) {
    registerPostOrderHooks(tView, currentTNode);
    if (isContentQueryHost(currentTNode)) {
      tView.queries.elementEnd(currentTNode);
    }
  }
  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);
  }
  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {
    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);
  }
  return \u0275\u0275elementEnd;
}
function \u0275\u0275element(index, name, attrsIndex, localRefsIndex) {
  \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex);
  \u0275\u0275elementEnd();
  return \u0275\u0275element;
}
var _locateOrCreateElementNode = (tView, lView, tNode, renderer, name, index) => {
  lastNodeWasCreated(true);
  return createElementNode(renderer, name, getNamespace$1());
};
function elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {
  ngDevMode && ngDevMode.firstCreatePass++;
  const tViewConsts = tView.consts;
  const attrs = getConstant(tViewConsts, attrsIndex);
  const tNode = getOrCreateTNode(tView, index, 8, "ng-container", attrs);
  if (attrs !== null) {
    computeStaticStyling(tNode, attrs, true);
  }
  const localRefs = getConstant(tViewConsts, localRefsIndex);
  resolveDirectives(tView, lView, tNode, localRefs);
  if (tView.queries !== null) {
    tView.queries.elementStart(tView, tNode);
  }
  return tNode;
}
function \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "element containers should be created before any bindings");
  const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
  setCurrentTNode(tNode, true);
  const comment = _locateOrCreateElementContainerNode(tView, lView, tNode, index);
  lView[adjustedIndex] = comment;
  if (wasLastNodeCreated()) {
    appendChild(tView, lView, comment, tNode);
  }
  attachPatchData(comment, lView);
  if (isDirectiveHost(tNode)) {
    createDirectivesInstances(tView, lView, tNode);
    executeContentQueries(tView, tNode, lView);
  }
  if (localRefsIndex != null) {
    saveResolvedLocalsInData(lView, tNode);
  }
  return \u0275\u0275elementContainerStart;
}
function \u0275\u0275elementContainerEnd() {
  let currentTNode = getCurrentTNode();
  const tView = getTView();
  if (isCurrentTNodeParent()) {
    setCurrentTNodeAsNotParent();
  } else {
    ngDevMode && assertHasParent(currentTNode);
    currentTNode = currentTNode.parent;
    setCurrentTNode(currentTNode, false);
  }
  ngDevMode && assertTNodeType(
    currentTNode,
    8
    /* TNodeType.ElementContainer */
  );
  if (tView.firstCreatePass) {
    registerPostOrderHooks(tView, currentTNode);
    if (isContentQueryHost(currentTNode)) {
      tView.queries.elementEnd(currentTNode);
    }
  }
  return \u0275\u0275elementContainerEnd;
}
function \u0275\u0275elementContainer(index, attrsIndex, localRefsIndex) {
  \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex);
  \u0275\u0275elementContainerEnd();
  return \u0275\u0275elementContainer;
}
var _locateOrCreateElementContainerNode = (tView, lView, tNode, index) => {
  lastNodeWasCreated(true);
  return createCommentNode(lView[RENDERER], ngDevMode ? "ng-container" : "");
};
function \u0275\u0275getCurrentView() {
  return getLView();
}
function \u0275\u0275hostProperty(propName, value2, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value2)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value2, lView[RENDERER], sanitizer, true);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275hostProperty;
}
function \u0275\u0275syntheticHostProperty(propName, value2, sanitizer) {
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value2)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    elementPropertyInternal(tView, tNode, lView, propName, value2, renderer, sanitizer, true);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275syntheticHostProperty;
}
if (false) {
  (function() {
    _global["ngI18nClosureMode"] = // TODO(FW-1250): validate that this actually, you know, works.
    // tslint:disable-next-line:no-toplevel-property-access
    typeof goog !== "undefined" && typeof goog.getMsg === "function";
  })();
}
var u = void 0;
function plural(val) {
  const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
  if (i === 1 && v === 0) return 1;
  return 5;
}
var localeEn = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
var LOCALE_DATA = {};
function findLocaleData(locale3) {
  const normalizedLocale = normalizeLocale(locale3);
  let match2 = getLocaleData(normalizedLocale);
  if (match2) {
    return match2;
  }
  const parentLocale = normalizedLocale.split("-")[0];
  match2 = getLocaleData(parentLocale);
  if (match2) {
    return match2;
  }
  if (parentLocale === "en") {
    return localeEn;
  }
  throw new RuntimeError(701, ngDevMode && `Missing locale data for the locale "${locale3}".`);
}
function getLocalePluralCase(locale3) {
  const data = findLocaleData(locale3);
  return data[LocaleDataIndex.PluralCase];
}
function getLocaleData(normalizedLocale) {
  if (!(normalizedLocale in LOCALE_DATA)) {
    LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];
  }
  return LOCALE_DATA[normalizedLocale];
}
var LocaleDataIndex;
(function(LocaleDataIndex2) {
  LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
  LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
  LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
  LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
  LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
  LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
  LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
  LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
  LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
  LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
  LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
  LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
  LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
  LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
  LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
  LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
  LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
  LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
  LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
  LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
  LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
})(LocaleDataIndex || (LocaleDataIndex = {}));
function normalizeLocale(locale3) {
  return locale3.toLowerCase().replace(/_/g, "-");
}
var pluralMapping = ["zero", "one", "two", "few", "many"];
function getPluralCase(value2, locale3) {
  const plural2 = getLocalePluralCase(locale3)(parseInt(value2, 10));
  const result = pluralMapping[plural2];
  return result !== void 0 ? result : "other";
}
var DEFAULT_LOCALE_ID = "en-US";
var USD_CURRENCY_CODE = "USD";
var ELEMENT_MARKER = {
  marker: "element"
};
var ICU_MARKER = {
  marker: "ICU"
};
var I18nCreateOpCode;
(function(I18nCreateOpCode2) {
  I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
  I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
  I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
})(I18nCreateOpCode || (I18nCreateOpCode = {}));
var LOCALE_ID$1 = DEFAULT_LOCALE_ID;
function setLocaleId(localeId) {
  ngDevMode && assertDefined(localeId, `Expected localeId to be defined`);
  if (typeof localeId === "string") {
    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
  }
}
function getLocaleId() {
  return LOCALE_ID$1;
}
var changeMask = 0;
var changeMaskCounter = 0;
function setMaskBit(hasChange) {
  if (hasChange) {
    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
  }
  changeMaskCounter++;
}
function applyI18n(tView, lView, index) {
  if (changeMaskCounter > 0) {
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const tI18n = tView.data[index];
    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
  }
  changeMask = 0;
  changeMaskCounter = 0;
}
function createNodeWithoutHydration(lView, textOrName, nodeType) {
  const renderer = lView[RENDERER];
  switch (nodeType) {
    case Node.COMMENT_NODE:
      return createCommentNode(renderer, textOrName);
    case Node.TEXT_NODE:
      return createTextNode(renderer, textOrName);
    case Node.ELEMENT_NODE:
      return createElementNode(renderer, textOrName, null);
  }
}
var _locateOrCreateNode = (lView, index, textOrName, nodeType) => {
  lastNodeWasCreated(true);
  return createNodeWithoutHydration(lView, textOrName, nodeType);
};
function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
  const renderer = lView[RENDERER];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text2 = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    let rNode = lView[index];
    let lastNodeWasCreated2 = false;
    if (rNode === null) {
      rNode = lView[index] = _locateOrCreateNode(lView, index, text2, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);
      lastNodeWasCreated2 = wasLastNodeCreated();
    }
    if (appendNow && parentRNode !== null && lastNodeWasCreated2) {
      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
    }
  }
}
function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
  ngDevMode && assertDomNode(anchorRNode);
  const renderer = lView[RENDERER];
  let rootIdx = null;
  let rootRNode;
  for (let i = 0; i < mutableOpCodes.length; i++) {
    const opCode = mutableOpCodes[i];
    if (typeof opCode == "string") {
      const textNodeIndex = mutableOpCodes[++i];
      if (lView[textNodeIndex] === null) {
        ngDevMode && ngDevMode.rendererCreateTextNode++;
        ngDevMode && assertIndexInRange(lView, textNodeIndex);
        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);
      }
    } else if (typeof opCode == "number") {
      switch (opCode & 1) {
        case 0:
          const parentIdx = getParentFromIcuCreateOpCode(opCode);
          if (rootIdx === null) {
            rootIdx = parentIdx;
            rootRNode = nativeParentNode(renderer, anchorRNode);
          }
          let insertInFrontOf;
          let parentRNode;
          if (parentIdx === rootIdx) {
            insertInFrontOf = anchorRNode;
            parentRNode = rootRNode;
          } else {
            insertInFrontOf = null;
            parentRNode = unwrapRNode(lView[parentIdx]);
          }
          if (parentRNode !== null) {
            ngDevMode && assertDomNode(parentRNode);
            const refIdx = getRefFromIcuCreateOpCode(opCode);
            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, "Missing ref");
            const child = lView[refIdx];
            ngDevMode && assertDomNode(child);
            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
            const tIcu = getTIcu(tView, refIdx);
            if (tIcu !== null && typeof tIcu === "object") {
              ngDevMode && assertTIcu(tIcu);
              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
              if (caseIndex !== null) {
                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
              }
            }
          }
          break;
        case 1:
          const elementNodeIndex = opCode >>> 1;
          const attrName = mutableOpCodes[++i];
          const attrValue = mutableOpCodes[++i];
          setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
          break;
        default:
          if (ngDevMode) {
            throw new RuntimeError(700, `Unable to determine the type of mutate operation for "${opCode}"`);
          }
      }
    } else {
      switch (opCode) {
        case ICU_MARKER:
          const commentValue = mutableOpCodes[++i];
          const commentNodeIndex = mutableOpCodes[++i];
          if (lView[commentNodeIndex] === null) {
            ngDevMode && assertEqual(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
            ngDevMode && ngDevMode.rendererCreateComment++;
            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
            const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);
            attachPatchData(commentRNode, lView);
          }
          break;
        case ELEMENT_MARKER:
          const tagName = mutableOpCodes[++i];
          const elementNodeIndex = mutableOpCodes[++i];
          if (lView[elementNodeIndex] === null) {
            ngDevMode && assertEqual(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
            ngDevMode && ngDevMode.rendererCreateElement++;
            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);
            const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);
            attachPatchData(elementRNode, lView);
          }
          break;
        default:
          ngDevMode && throwError2(`Unable to determine the type of mutate operation for "${opCode}"`);
      }
    }
  }
}
function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
  for (let i = 0; i < updateOpCodes.length; i++) {
    const checkBit = updateOpCodes[i];
    const skipCodes = updateOpCodes[++i];
    if (checkBit & changeMask2) {
      let value2 = "";
      for (let j = i + 1; j <= i + skipCodes; j++) {
        const opCode = updateOpCodes[j];
        if (typeof opCode == "string") {
          value2 += opCode;
        } else if (typeof opCode == "number") {
          if (opCode < 0) {
            value2 += renderStringify(lView[bindingsStartIndex - opCode]);
          } else {
            const nodeIndex = opCode >>> 2;
            switch (opCode & 3) {
              case 1:
                const propName = updateOpCodes[++j];
                const sanitizeFn = updateOpCodes[++j];
                const tNodeOrTagName = tView.data[nodeIndex];
                ngDevMode && assertDefined(tNodeOrTagName, "Experting TNode or string");
                if (typeof tNodeOrTagName === "string") {
                  setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value2, sanitizeFn);
                } else {
                  elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value2, lView[RENDERER], sanitizeFn, false);
                }
                break;
              case 0:
                const rText = lView[nodeIndex];
                rText !== null && updateTextNode(lView[RENDERER], rText, value2);
                break;
              case 2:
                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value2);
                break;
              case 3:
                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                break;
            }
          }
        }
      }
    } else {
      const opCode = updateOpCodes[i + 1];
      if (opCode > 0 && (opCode & 3) === 3) {
        const nodeIndex = opCode >>> 2;
        const tIcu = getTIcu(tView, nodeIndex);
        const currentIndex = lView[tIcu.currentCaseLViewIndex];
        if (currentIndex < 0) {
          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
        }
      }
    }
    i += skipCodes;
  }
}
function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
  if (activeCaseIndex !== null) {
    let mask = changeMask;
    if (activeCaseIndex < 0) {
      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
      mask = -1;
    }
    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
  }
}
function applyIcuSwitchCase(tView, tIcu, lView, value2) {
  const caseIndex = getCaseIndex(tIcu, value2);
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== caseIndex) {
    applyIcuSwitchCaseRemove(tView, tIcu, lView);
    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
    if (caseIndex !== null) {
      const anchorRNode = lView[tIcu.anchorIdx];
      if (anchorRNode) {
        ngDevMode && assertDomNode(anchorRNode);
        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
      }
      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);
    }
  }
}
function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
  if (activeCaseIndex !== null) {
    const removeCodes = tIcu.remove[activeCaseIndex];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
      } else {
        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
      }
    }
  }
}
function getCaseIndex(icuExpression, bindingValue) {
  let index = icuExpression.cases.indexOf(bindingValue);
  if (index === -1) {
    switch (icuExpression.type) {
      case 1: {
        const resolvedCase = getPluralCase(bindingValue, getLocaleId());
        index = icuExpression.cases.indexOf(resolvedCase);
        if (index === -1 && resolvedCase !== "other") {
          index = icuExpression.cases.indexOf("other");
        }
        break;
      }
      case 0: {
        index = icuExpression.cases.indexOf("other");
        break;
      }
    }
  }
  return index === -1 ? null : index;
}
function i18nCreateOpCodesToString(opcodes) {
  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < createOpCodes.length; i++) {
    const opCode = createOpCodes[i++];
    const text2 = createOpCodes[i];
    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
    const index = opCode >>> I18nCreateOpCode.SHIFT;
    lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text2)});`);
    if (appendNow) {
      lines.push(`parent.appendChild(lView[${index}]);`);
    }
  }
  return lines;
}
function i18nUpdateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(value2) {
    const ref = value2 >>> 2;
    const opCode = value2 & 3;
    switch (opCode) {
      case 0:
        return `(lView[${ref}] as Text).textContent = $$$`;
      case 1:
        const attrName = parser.consumeString();
        const sanitizationFn = parser.consumeFunction();
        const value3 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value3})`;
      case 2:
        return `icuSwitchCase(${ref}, $$$)`;
      case 3:
        return `icuUpdateCase(${ref})`;
    }
    throw new Error("unexpected OpCode");
  }
  while (parser.hasMore()) {
    let mask = parser.consumeNumber();
    let size2 = parser.consumeNumber();
    const end2 = parser.i + size2;
    const statements = [];
    let statement = "";
    while (parser.i < end2) {
      let value2 = parser.consumeNumberOrString();
      if (typeof value2 === "string") {
        statement += value2;
      } else if (value2 < 0) {
        statement += "${lView[i" + value2 + "]}";
      } else {
        const opCodeText = consumeOpCode(value2);
        statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
        statement = "";
      }
    }
    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
  }
  return lines;
}
function icuCreateOpCodesToString(opcodes) {
  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
  let lines = [];
  function consumeOpCode(opCode) {
    const parent = getParentFromIcuCreateOpCode(opCode);
    const ref = getRefFromIcuCreateOpCode(opCode);
    switch (getInstructionFromIcuCreateOpCode(opCode)) {
      case 0:
        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
      case 1:
        return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
    }
    throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
  }
  let lastRef = -1;
  while (parser.hasMore()) {
    let value2 = parser.consumeNumberStringOrMarker();
    if (value2 === ICU_MARKER) {
      const text2 = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createComment("${text2}")`);
    } else if (value2 === ELEMENT_MARKER) {
      const text2 = parser.consumeString();
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createElement("${text2}")`);
    } else if (typeof value2 === "string") {
      lastRef = parser.consumeNumber();
      lines.push(`lView[${lastRef}] = document.createTextNode("${value2}")`);
    } else if (typeof value2 === "number") {
      const line = consumeOpCode(value2);
      line && lines.push(line);
    } else {
      throw new Error("Unexpected value");
    }
  }
  return lines;
}
function i18nRemoveOpCodesToString(opcodes) {
  const removeCodes = opcodes || (Array.isArray(this) ? this : []);
  let lines = [];
  for (let i = 0; i < removeCodes.length; i++) {
    const nodeOrIcuIndex = removeCodes[i];
    if (nodeOrIcuIndex > 0) {
      lines.push(`remove(lView[${nodeOrIcuIndex}])`);
    } else {
      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
    }
  }
  return lines;
}
var OpCodeParser = class {
  i = 0;
  codes;
  constructor(codes) {
    this.codes = codes;
  }
  hasMore() {
    return this.i < this.codes.length;
  }
  consumeNumber() {
    let value2 = this.codes[this.i++];
    assertNumber(value2, "expecting number in OpCode");
    return value2;
  }
  consumeString() {
    let value2 = this.codes[this.i++];
    assertString(value2, "expecting string in OpCode");
    return value2;
  }
  consumeFunction() {
    let value2 = this.codes[this.i++];
    if (value2 === null || typeof value2 === "function") {
      return value2;
    }
    throw new Error("expecting function in OpCode");
  }
  consumeNumberOrString() {
    let value2 = this.codes[this.i++];
    if (typeof value2 === "string") {
      return value2;
    }
    assertNumber(value2, "expecting number or string in OpCode");
    return value2;
  }
  consumeNumberStringOrMarker() {
    let value2 = this.codes[this.i++];
    if (typeof value2 === "string" || typeof value2 === "number" || value2 == ICU_MARKER || value2 == ELEMENT_MARKER) {
      return value2;
    }
    assertNumber(value2, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
    return value2;
  }
};
var BINDING_REGEXP = /�(\d+):?\d*�/gi;
var ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
var NESTED_ICU = /�(\d+)�/;
var ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
var MARKER = `\uFFFD`;
var SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
var PH_REGEXP = /�(\/?[#*]\d+):?\d*�/gi;
var NGSP_UNICODE_REGEXP = /\uE500/g;
function replaceNgsp(value2) {
  return value2.replace(NGSP_UNICODE_REGEXP, " ");
}
function attachDebugGetter(obj, debugGetter) {
  if (ngDevMode) {
    Object.defineProperty(obj, "debug", {
      get: debugGetter,
      enumerable: false
    });
  } else {
    throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
  }
}
function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
  const rootTNode = getCurrentParentTNode();
  const createOpCodes = [];
  const updateOpCodes = [];
  const existingTNodeStack = [[]];
  const astStack = [[]];
  if (ngDevMode) {
    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  message = getTranslationForTemplate(message, subTemplateIndex);
  const msgParts = replaceNgsp(message).split(PH_REGEXP);
  for (let i = 0; i < msgParts.length; i++) {
    let value2 = msgParts[i];
    if ((i & 1) === 0) {
      const parts = i18nParseTextIntoPartsAndICU(value2);
      for (let j = 0; j < parts.length; j++) {
        let part = parts[j];
        if ((j & 1) === 0) {
          const text2 = part;
          ngDevMode && assertString(text2, "Parsed ICU part should be string");
          if (text2 !== "") {
            i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text2);
          }
        } else {
          const icuExpression = part;
          if (typeof icuExpression !== "object") {
            throw new Error(`Unable to parse ICU expression in "${message}" message.`);
          }
          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
          const icuNodeIndex = icuContainerTNode.index;
          ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, "Index must be in absolute LView offset");
          icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
        }
      }
    } else {
      const isClosing = value2.charCodeAt(0) === 47;
      const type2 = value2.charCodeAt(isClosing ? 1 : 0);
      ngDevMode && assertOneOf(
        type2,
        42,
        35
        /* CharCode.HASH */
      );
      const index2 = HEADER_OFFSET + Number.parseInt(value2.substring(isClosing ? 2 : 1));
      if (isClosing) {
        existingTNodeStack.shift();
        astStack.shift();
        setCurrentTNode(getCurrentParentTNode(), false);
      } else {
        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
        existingTNodeStack.unshift([]);
        setCurrentTNode(tNode, true);
        const placeholderNode = {
          kind: 2,
          index: index2,
          children: [],
          type: type2 === 35 ? 0 : 1
          /* I18nPlaceholderType.SUBTEMPLATE */
        };
        astStack[0].push(placeholderNode);
        astStack.unshift(placeholderNode.children);
      }
    }
  }
  tView.data[index] = {
    create: createOpCodes,
    update: updateOpCodes,
    ast: astStack[0],
    parentTNodeIndex
  };
}
function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text2, isICU) {
  const i18nNodeIdx = allocExpando(tView, lView, 1, null);
  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
  let parentTNode = getCurrentParentTNode();
  if (rootTNode === parentTNode) {
    parentTNode = null;
  }
  if (parentTNode === null) {
    opCode |= I18nCreateOpCode.APPEND_EAGERLY;
  }
  if (isICU) {
    opCode |= I18nCreateOpCode.COMMENT;
    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
  }
  createOpCodes.push(opCode, text2 === null ? "" : text2);
  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text2 === null ? ngDevMode ? "{{?}}" : "" : text2, null);
  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
  const tNodeIdx = tNode.index;
  setCurrentTNode(
    tNode,
    false
    /* Text nodes are self closing */
  );
  if (parentTNode !== null && rootTNode !== parentTNode) {
    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
  }
  return tNode;
}
function i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text2) {
  const hasBinding = text2.match(BINDING_REGEXP);
  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text2, false);
  const index = tNode.index;
  if (hasBinding) {
    generateBindingUpdateOpCodes(updateOpCodes, text2, index, null, 0, null);
  }
  ast.push({
    kind: 0,
    index
  });
}
function i18nAttributesFirstPass(tView, index, values) {
  const previousElement = getCurrentTNode();
  const previousElementIndex = previousElement.index;
  const updateOpCodes = [];
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  if (tView.firstCreatePass && tView.data[index] === null) {
    for (let i = 0; i < values.length; i += 2) {
      const attrName = values[i];
      const message = values[i + 1];
      if (message !== "") {
        if (ICU_REGEXP.test(message)) {
          throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
        }
        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
      }
    }
    tView.data[index] = updateOpCodes;
  }
}
function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
  ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, "Index must be in absolute LView offset");
  const maskIndex = updateOpCodes.length;
  const sizeIndex = maskIndex + 1;
  updateOpCodes.push(null, null);
  const startIndex = maskIndex + 2;
  if (ngDevMode) {
    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
  }
  const textParts = str.split(BINDING_REGEXP);
  let mask = 0;
  for (let j = 0; j < textParts.length; j++) {
    const textValue = textParts[j];
    if (j & 1) {
      const bindingIndex = bindingStart + parseInt(textValue, 10);
      updateOpCodes.push(-1 - bindingIndex);
      mask = mask | toMaskBit(bindingIndex);
    } else if (textValue !== "") {
      updateOpCodes.push(textValue);
    }
  }
  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
  if (attrName) {
    updateOpCodes.push(attrName, sanitizeFn);
  }
  updateOpCodes[maskIndex] = mask;
  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
  return mask;
}
function countBindings(opCodes) {
  let count3 = 0;
  for (let i = 0; i < opCodes.length; i++) {
    const opCode = opCodes[i];
    if (typeof opCode === "number" && opCode < 0) {
      count3++;
    }
  }
  return count3;
}
function toMaskBit(bindingIndex) {
  return 1 << Math.min(bindingIndex, 31);
}
function removeInnerTemplateTranslation(message) {
  let match2;
  let res = "";
  let index = 0;
  let inTemplate = false;
  let tagMatched;
  while ((match2 = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
    if (!inTemplate) {
      res += message.substring(index, match2.index + match2[0].length);
      tagMatched = match2[1];
      inTemplate = true;
    } else {
      if (match2[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
        index = match2.index;
        inTemplate = false;
      }
    }
  }
  ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
  res += message.slice(index);
  return res;
}
function getTranslationForTemplate(message, subTemplateIndex) {
  if (isRootTemplateMessage(subTemplateIndex)) {
    return removeInnerTemplateTranslation(message);
  } else {
    const start2 = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
    const end2 = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
    return removeInnerTemplateTranslation(message.substring(start2, end2));
  }
}
function icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
  ngDevMode && assertDefined(icuExpression, "ICU expression must be defined");
  let bindingMask = 0;
  const tIcu = {
    type: icuExpression.type,
    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
    anchorIdx,
    cases: [],
    create: [],
    remove: [],
    update: []
  };
  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
  setTIcu(tView, anchorIdx, tIcu);
  const values = icuExpression.values;
  const cases = [];
  for (let i = 0; i < values.length; i++) {
    const valueArr = values[i];
    const nestedIcus = [];
    for (let j = 0; j < valueArr.length; j++) {
      const value2 = valueArr[j];
      if (typeof value2 !== "string") {
        const icuIndex = nestedIcus.push(value2) - 1;
        valueArr[j] = `<!--\uFFFD${icuIndex}\uFFFD-->`;
      }
    }
    const caseAst = [];
    cases.push(caseAst);
    bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(""), nestedIcus) | bindingMask;
  }
  if (bindingMask) {
    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
  }
  ast.push({
    kind: 3,
    index: anchorIdx,
    cases,
    currentCaseLViewIndex: tIcu.currentCaseLViewIndex
  });
}
function parseICUBlock(pattern) {
  const cases = [];
  const values = [];
  let icuType = 1;
  let mainBinding = 0;
  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type2) {
    if (type2 === "select") {
      icuType = 0;
    } else {
      icuType = 1;
    }
    mainBinding = parseInt(binding.slice(1), 10);
    return "";
  });
  const parts = i18nParseTextIntoPartsAndICU(pattern);
  for (let pos = 0; pos < parts.length; ) {
    let key = parts[pos++].trim();
    if (icuType === 1) {
      key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
    }
    if (key.length) {
      cases.push(key);
    }
    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
    if (cases.length > values.length) {
      values.push(blocks);
    }
  }
  return {
    type: icuType,
    mainBinding,
    cases,
    values
  };
}
function i18nParseTextIntoPartsAndICU(pattern) {
  if (!pattern) {
    return [];
  }
  let prevPos = 0;
  const braceStack = [];
  const results = [];
  const braces = /[{}]/g;
  braces.lastIndex = 0;
  let match2;
  while (match2 = braces.exec(pattern)) {
    const pos = match2.index;
    if (match2[0] == "}") {
      braceStack.pop();
      if (braceStack.length == 0) {
        const block = pattern.substring(prevPos, pos);
        if (ICU_BLOCK_REGEXP.test(block)) {
          results.push(parseICUBlock(block));
        } else {
          results.push(block);
        }
        prevPos = pos + 1;
      }
    } else {
      if (braceStack.length == 0) {
        const substring2 = pattern.substring(prevPos, pos);
        results.push(substring2);
        prevPos = pos + 1;
      }
      braceStack.push("{");
    }
  }
  const substring = pattern.substring(prevPos);
  results.push(substring);
  return results;
}
function parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
  const create2 = [];
  const remove3 = [];
  const update = [];
  if (ngDevMode) {
    attachDebugGetter(create2, icuCreateOpCodesToString);
    attachDebugGetter(remove3, i18nRemoveOpCodesToString);
    attachDebugGetter(update, i18nUpdateOpCodesToString);
  }
  tIcu.cases.push(caseName);
  tIcu.create.push(create2);
  tIcu.remove.push(remove3);
  tIcu.update.push(update);
  const inertBodyHelper2 = getInertBodyHelper(getDocument());
  const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
  ngDevMode && assertDefined(inertBodyElement, "Unable to generate inert body element");
  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
  if (inertRootNode) {
    return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create2, remove3, update, inertRootNode, parentIdx, nestedIcus, 0);
  } else {
    return 0;
  }
}
function walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create2, remove3, update, parentNode, parentIdx, nestedIcus, depth) {
  let bindingMask = 0;
  let currentNode = parentNode.firstChild;
  while (currentNode) {
    const newIndex = allocExpando(tView, lView, 1, null);
    switch (currentNode.nodeType) {
      case Node.ELEMENT_NODE:
        const element = currentNode;
        const tagName = element.tagName.toLowerCase();
        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
          addCreateNodeAndAppend(create2, ELEMENT_MARKER, tagName, parentIdx, newIndex);
          tView.data[newIndex] = tagName;
          const elAttrs = element.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
            const attr = elAttrs.item(i);
            const lowerAttrName = attr.name.toLowerCase();
            const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
            if (hasBinding2) {
              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                if (URI_ATTRS[lowerAttrName]) {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                } else {
                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                }
              } else {
                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${XSS_SECURITY_URL})`);
              }
            } else {
              addCreateAttribute(create2, newIndex, attr);
            }
          }
          const elementNode = {
            kind: 1,
            index: newIndex,
            children: []
          };
          ast.push(elementNode);
          bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create2, remove3, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
          addRemoveNode(remove3, newIndex, depth);
        }
        break;
      case Node.TEXT_NODE:
        const value2 = currentNode.textContent || "";
        const hasBinding = value2.match(BINDING_REGEXP);
        addCreateNodeAndAppend(create2, null, hasBinding ? "" : value2, parentIdx, newIndex);
        addRemoveNode(remove3, newIndex, depth);
        if (hasBinding) {
          bindingMask = generateBindingUpdateOpCodes(update, value2, newIndex, null, 0, null) | bindingMask;
        }
        ast.push({
          kind: 0,
          index: newIndex
        });
        break;
      case Node.COMMENT_NODE:
        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
        if (isNestedIcu) {
          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
          const icuExpression = nestedIcus[nestedIcuIndex];
          addCreateNodeAndAppend(create2, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
          addRemoveNestedIcu(remove3, newIndex, depth);
        }
        break;
    }
    currentNode = currentNode.nextSibling;
  }
  return bindingMask;
}
function addRemoveNode(remove3, index, depth) {
  if (depth === 0) {
    remove3.push(index);
  }
}
function addRemoveNestedIcu(remove3, index, depth) {
  if (depth === 0) {
    remove3.push(~index);
    remove3.push(index);
  }
}
function addUpdateIcuSwitch(update, icuExpression, index) {
  update.push(
    toMaskBit(icuExpression.mainBinding),
    2,
    -1 - icuExpression.mainBinding,
    index << 2 | 2
    /* I18nUpdateOpCode.IcuSwitch */
  );
}
function addUpdateIcuUpdate(update, bindingMask, index) {
  update.push(
    bindingMask,
    1,
    index << 2 | 3
    /* I18nUpdateOpCode.IcuUpdate */
  );
}
function addCreateNodeAndAppend(create2, marker, text2, appendToParentIdx, createAtIdx) {
  if (marker !== null) {
    create2.push(marker);
  }
  create2.push(text2, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
}
function addCreateAttribute(create2, newIndex, attr) {
  create2.push(newIndex << 1 | 1, attr.name, attr.value);
}
var ROOT_TEMPLATE_ID = 0;
var PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
var PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
var PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
var PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
var PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
var PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
var PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
function i18nPostprocess(message, replacements = {}) {
  let result = message;
  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
    const matches = {};
    const templateIdsStack = [ROOT_TEMPLATE_ID];
    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
      const content = phs || tmpl;
      const placeholders = matches[content] || [];
      if (!placeholders.length) {
        content.split("|").forEach((placeholder2) => {
          const match2 = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
          const templateId2 = match2 ? parseInt(match2[1], 10) : ROOT_TEMPLATE_ID;
          const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
          placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
        });
        matches[content] = placeholders;
      }
      if (!placeholders.length) {
        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
      }
      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
      let idx = 0;
      for (let i = 0; i < placeholders.length; i++) {
        if (placeholders[i][0] === currentTemplateId) {
          idx = i;
          break;
        }
      }
      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
      if (isCloseTemplateTag) {
        templateIdsStack.pop();
      } else if (currentTemplateId !== templateId) {
        templateIdsStack.push(templateId);
      }
      placeholders.splice(idx, 1);
      return placeholder;
    });
  }
  if (!Object.keys(replacements).length) {
    return result;
  }
  result = result.replace(PP_ICU_VARS_REGEXP, (match2, start2, key, _type, _idx, end2) => {
    return replacements.hasOwnProperty(key) ? `${start2}${replacements[key]}${end2}` : match2;
  });
  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match2, key) => {
    return replacements.hasOwnProperty(key) ? replacements[key] : match2;
  });
  result = result.replace(PP_ICUS_REGEXP, (match2, key) => {
    if (replacements.hasOwnProperty(key)) {
      const list = replacements[key];
      if (!list.length) {
        throw new Error(`i18n postprocess: unmatched ICU - ${match2} with key: ${key}`);
      }
      return list.shift();
    }
    return match2;
  });
  return result;
}
function \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = HEADER_OFFSET + index;
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const message = getConstant(tView.consts, messageIndex);
  const parentTNode = getCurrentParentTNode();
  if (tView.firstCreatePass) {
    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
  }
  if (tView.type === 2) {
    const componentLView = lView[DECLARATION_COMPONENT_VIEW];
    componentLView[FLAGS] |= 32;
  } else {
    lView[FLAGS] |= 32;
  }
  const tI18n = tView.data[adjustedIndex];
  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
  prepareI18nBlockForHydration(lView, adjustedIndex, parentTNode, subTemplateIndex);
  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
  setInI18nBlock(true);
}
function \u0275\u0275i18nEnd() {
  setInI18nBlock(false);
}
function \u0275\u0275i18n(index, messageIndex, subTemplateIndex) {
  \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex);
  \u0275\u0275i18nEnd();
}
function \u0275\u0275i18nAttributes(index, attrsIndex) {
  const tView = getTView();
  ngDevMode && assertDefined(tView, `tView should be defined`);
  const attrs = getConstant(tView.consts, attrsIndex);
  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
}
function \u0275\u0275i18nExp(value2) {
  const lView = getLView();
  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value2));
  return \u0275\u0275i18nExp;
}
function \u0275\u0275i18nApply(index) {
  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
}
function \u0275\u0275i18nPostprocess(message, replacements = {}) {
  return i18nPostprocess(message, replacements);
}
var stashEventListener = (el, eventName, listenerFn) => {
};
function \u0275\u0275listener(eventName, listenerFn, useCapture, eventTargetResolver) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);
  return \u0275\u0275listener;
}
function \u0275\u0275syntheticHostListener(eventName, listenerFn) {
  const tNode = getCurrentTNode();
  const lView = getLView();
  const tView = getTView();
  const currentDef = getCurrentDirectiveDef(tView.data);
  const renderer = loadComponentRenderer(currentDef, tNode, lView);
  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);
  return \u0275\u0275syntheticHostListener;
}
function findExistingListener(tView, lView, eventName, tNodeIdx) {
  const tCleanup = tView.cleanup;
  if (tCleanup != null) {
    for (let i = 0; i < tCleanup.length - 1; i += 2) {
      const cleanupEventName = tCleanup[i];
      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
        const lCleanup = lView[CLEANUP];
        const listenerIdxInLCleanup = tCleanup[i + 2];
        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
      }
      if (typeof cleanupEventName === "string") {
        i += 2;
      }
    }
  }
  return null;
}
function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {
  const isTNodeDirectiveHost = isDirectiveHost(tNode);
  const firstCreatePass = tView.firstCreatePass;
  const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
  const context2 = lView[CONTEXT];
  const lCleanup = getOrCreateLViewCleanup(lView);
  ngDevMode && assertTNodeType(
    tNode,
    3 | 12
    /* TNodeType.AnyContainer */
  );
  let processOutputs = true;
  if (tNode.type & 3 || eventTargetResolver) {
    const native = getNativeByTNode(tNode, lView);
    const target = eventTargetResolver ? eventTargetResolver(native) : native;
    const lCleanupIndex = lCleanup.length;
    const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
    let existingListener = null;
    if (!eventTargetResolver && isTNodeDirectiveHost) {
      existingListener = findExistingListener(tView, lView, eventName, tNode.index);
    }
    if (existingListener !== null) {
      const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
      lastListenerFn.__ngNextListenerFn__ = listenerFn;
      existingListener.__ngLastListenerFn__ = listenerFn;
      processOutputs = false;
    } else {
      listenerFn = wrapListener(tNode, lView, context2, listenerFn);
      stashEventListener(native, eventName, listenerFn);
      const cleanupFn = renderer.listen(target, eventName, listenerFn);
      ngDevMode && ngDevMode.rendererAddEventListener++;
      lCleanup.push(listenerFn, cleanupFn);
      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
    }
  } else {
    listenerFn = wrapListener(tNode, lView, context2, listenerFn);
  }
  const outputs = tNode.outputs;
  let props;
  if (processOutputs && outputs !== null && (props = outputs[eventName])) {
    const propsLength = props.length;
    if (propsLength) {
      for (let i = 0; i < propsLength; i += 2) {
        const index = props[i];
        ngDevMode && assertIndexInRange(lView, index);
        const minifiedName = props[i + 1];
        const directiveInstance = lView[index];
        const output = directiveInstance[minifiedName];
        if (ngDevMode && !isOutputSubscribable(output)) {
          throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);
        }
        const subscription = output.subscribe(listenerFn);
        const idx = lCleanup.length;
        lCleanup.push(listenerFn, subscription);
        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
      }
    }
  }
}
function executeListenerWithErrorHandling(lView, context2, listenerFn, e) {
  const prevConsumer = setActiveConsumer(null);
  try {
    profiler(6, context2, listenerFn);
    return listenerFn(e) !== false;
  } catch (error) {
    handleError(lView, error);
    return false;
  } finally {
    profiler(7, context2, listenerFn);
    setActiveConsumer(prevConsumer);
  }
}
function wrapListener(tNode, lView, context2, listenerFn) {
  return function wrapListenerIn_markDirtyAndPreventDefault(e) {
    if (e === Function) {
      return listenerFn;
    }
    const startView = tNode.componentOffset > -1 ? getComponentLViewByIndex(tNode.index, lView) : lView;
    markViewDirty(
      startView,
      5
      /* NotificationSource.Listener */
    );
    let result = executeListenerWithErrorHandling(lView, context2, listenerFn, e);
    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
    while (nextListenerFn) {
      result = executeListenerWithErrorHandling(lView, context2, nextListenerFn, e) && result;
      nextListenerFn = nextListenerFn.__ngNextListenerFn__;
    }
    return result;
  };
}
function isOutputSubscribable(value2) {
  return value2 != null && typeof value2.subscribe === "function";
}
function \u0275\u0275nextContext(level = 1) {
  return nextContextImpl(level);
}
function matchingProjectionSlotIndex(tNode, projectionSlots) {
  let wildcardNgContentIndex = null;
  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
  for (let i = 0; i < projectionSlots.length; i++) {
    const slotValue = projectionSlots[i];
    if (slotValue === "*") {
      wildcardNgContentIndex = i;
      continue;
    }
    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(
      tNode,
      slotValue,
      /* isProjectionMode */
      true
    ) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
      return i;
    }
  }
  return wildcardNgContentIndex;
}
function \u0275\u0275projectionDef(projectionSlots) {
  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
  if (!componentNode.projection) {
    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
    const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
    const tails = projectionHeads.slice();
    let componentChild = componentNode.child;
    while (componentChild !== null) {
      if (componentChild.type !== 128) {
        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
      }
      componentChild = componentChild.next;
    }
  }
}
function \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs, fallbackTemplateFn, fallbackDecls, fallbackVars) {
  const lView = getLView();
  const tView = getTView();
  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;
  if (fallbackIndex !== null) {
    declareTemplate(lView, tView, fallbackIndex, fallbackTemplateFn, fallbackDecls, fallbackVars, null, attrs);
  }
  const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
  if (tProjectionNode.projection === null) {
    tProjectionNode.projection = selectorIndex;
  }
  setCurrentTNodeAsNotParent();
  const hydrationInfo = lView[HYDRATION];
  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();
  const componentHostNode = lView[DECLARATION_COMPONENT_VIEW][T_HOST];
  const isEmpty = componentHostNode.projection[tProjectionNode.projection] === null;
  if (isEmpty && fallbackIndex !== null) {
    insertFallbackContent(lView, tView, fallbackIndex);
  } else if (isNodeCreationMode && (tProjectionNode.flags & 32) !== 32) {
    applyProjection(tView, lView, tProjectionNode);
  }
}
function insertFallbackContent(lView, tView, fallbackIndex) {
  const adjustedIndex = HEADER_OFFSET + fallbackIndex;
  const fallbackTNode = tView.data[adjustedIndex];
  const fallbackLContainer = lView[adjustedIndex];
  ngDevMode && assertTNode(fallbackTNode);
  ngDevMode && assertLContainer(fallbackLContainer);
  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView.ssrId);
  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, void 0, {
    dehydratedView
  });
  addLViewToLContainer(fallbackLContainer, fallbackLView, 0, shouldAddViewToDom(fallbackTNode, dehydratedView));
}
function \u0275\u0275propertyInterpolate(propName, v0, sanitizer) {
  \u0275\u0275propertyInterpolate1(propName, "", v0, "", sanitizer);
  return \u0275\u0275propertyInterpolate;
}
function \u0275\u0275propertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);
  }
  return \u0275\u0275propertyInterpolate1;
}
function \u0275\u0275propertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);
  }
  return \u0275\u0275propertyInterpolate2;
}
function \u0275\u0275propertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);
  }
  return \u0275\u0275propertyInterpolate3;
}
function \u0275\u0275propertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
  }
  return \u0275\u0275propertyInterpolate4;
}
function \u0275\u0275propertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
  }
  return \u0275\u0275propertyInterpolate5;
}
function \u0275\u0275propertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
  }
  return \u0275\u0275propertyInterpolate6;
}
function \u0275\u0275propertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
  }
  return \u0275\u0275propertyInterpolate7;
}
function \u0275\u0275propertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
  }
  return \u0275\u0275propertyInterpolate8;
}
function \u0275\u0275propertyInterpolateV(propName, values, sanitizer) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  if (interpolatedValue !== NO_CHANGE) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
    if (ngDevMode) {
      const interpolationInBetween = [values[0]];
      for (let i = 2; i < values.length; i += 2) {
        interpolationInBetween.push(values[i]);
      }
      storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
    }
  }
  return \u0275\u0275propertyInterpolateV;
}
function \u0275\u0275contentQuery(directiveIndex, predicate, flags, read) {
  createContentQuery(directiveIndex, predicate, flags, read);
}
function \u0275\u0275viewQuery(predicate, flags, read) {
  createViewQuery(predicate, flags, read);
}
function \u0275\u0275queryRefresh(queryList) {
  const lView = getLView();
  const tView = getTView();
  const queryIndex = getCurrentQueryIndex();
  setCurrentQueryIndex(queryIndex + 1);
  const tQuery = getTQuery(tView, queryIndex);
  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
    if (tQuery.matches === null) {
      queryList.reset([]);
    } else {
      const result = getQueryResults(lView, queryIndex);
      queryList.reset(result, unwrapElementRef);
      queryList.notifyOnChanges();
    }
    return true;
  }
  return false;
}
function \u0275\u0275loadQuery() {
  return loadQueryInternal(getLView(), getCurrentQueryIndex());
}
function \u0275\u0275contentQuerySignal(directiveIndex, target, predicate, flags, read) {
  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));
}
function \u0275\u0275viewQuerySignal(target, predicate, flags, read) {
  bindQueryToSignal(target, createViewQuery(predicate, flags, read));
}
function \u0275\u0275queryAdvance(indexOffset = 1) {
  setCurrentQueryIndex(getCurrentQueryIndex() + indexOffset);
}
function store(tView, lView, index, value2) {
  if (index >= tView.data.length) {
    tView.data[index] = null;
    tView.blueprint[index] = null;
  }
  lView[index] = value2;
}
function \u0275\u0275reference(index) {
  const contextLView = getContextLView();
  return load(contextLView, HEADER_OFFSET + index);
}
function \u0275\u0275styleMapInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275styleMapInterpolateV(values) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  \u0275\u0275styleMap(interpolatedValue);
}
function \u0275\u0275stylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate1;
}
function \u0275\u0275stylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate2;
}
function \u0275\u0275stylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate3;
}
function \u0275\u0275stylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate4;
}
function \u0275\u0275stylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate5;
}
function \u0275\u0275stylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate6;
}
function \u0275\u0275stylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate7;
}
function \u0275\u0275stylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolate8;
}
function \u0275\u0275stylePropInterpolateV(prop, values, valueSuffix) {
  const lView = getLView();
  const interpolatedValue = interpolationV(lView, values);
  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
  return \u0275\u0275stylePropInterpolateV;
}
function \u0275\u0275text(index, value2 = "") {
  const lView = getLView();
  const tView = getTView();
  const adjustedIndex = index + HEADER_OFFSET;
  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "text nodes should be created before any bindings");
  ngDevMode && assertIndexInRange(lView, adjustedIndex);
  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value2, null) : tView.data[adjustedIndex];
  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value2, index);
  lView[adjustedIndex] = textNative;
  if (wasLastNodeCreated()) {
    appendChild(tView, lView, textNative, tNode);
  }
  setCurrentTNode(tNode, false);
}
var _locateOrCreateTextNode = (tView, lView, tNode, value2, index) => {
  lastNodeWasCreated(true);
  return createTextNode(lView[RENDERER], value2);
};
function \u0275\u0275textInterpolate(v0) {
  \u0275\u0275textInterpolate1("", v0, "");
  return \u0275\u0275textInterpolate;
}
function \u0275\u0275textInterpolate1(prefix, v0, suffix) {
  const lView = getLView();
  const interpolated = interpolation1(lView, prefix, v0, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate1;
}
function \u0275\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {
  const lView = getLView();
  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate2;
}
function \u0275\u0275textInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
  const lView = getLView();
  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate3;
}
function \u0275\u0275textInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
  const lView = getLView();
  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate4;
}
function \u0275\u0275textInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
  const lView = getLView();
  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate5;
}
function \u0275\u0275textInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
  const lView = getLView();
  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate6;
}
function \u0275\u0275textInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
  const lView = getLView();
  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate7;
}
function \u0275\u0275textInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
  const lView = getLView();
  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolate8;
}
function \u0275\u0275textInterpolateV(values) {
  const lView = getLView();
  const interpolated = interpolationV(lView, values);
  if (interpolated !== NO_CHANGE) {
    textBindingInternal(lView, getSelectedIndex(), interpolated);
  }
  return \u0275\u0275textInterpolateV;
}
function \u0275\u0275twoWayProperty(propName, value2, sanitizer) {
  if (isWritableSignal(value2)) {
    value2 = value2();
  }
  const lView = getLView();
  const bindingIndex = nextBindingIndex();
  if (bindingUpdated(lView, bindingIndex, value2)) {
    const tView = getTView();
    const tNode = getSelectedTNode();
    elementPropertyInternal(tView, tNode, lView, propName, value2, lView[RENDERER], sanitizer, false);
    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
  }
  return \u0275\u0275twoWayProperty;
}
function \u0275\u0275twoWayBindingSet(target, value2) {
  const canWrite = isWritableSignal(target);
  canWrite && target.set(value2);
  return canWrite;
}
function \u0275\u0275twoWayListener(eventName, listenerFn) {
  const lView = getLView();
  const tView = getTView();
  const tNode = getCurrentTNode();
  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn);
  return \u0275\u0275twoWayListener;
}
var UNINITIALIZED_LET = {};
function \u0275\u0275declareLet(index) {
  const tView = getTView();
  const lView = getLView();
  const adjustedIndex = index + HEADER_OFFSET;
  const tNode = getOrCreateTNode(tView, adjustedIndex, 128, null, null);
  setCurrentTNode(tNode, false);
  store(tView, lView, adjustedIndex, UNINITIALIZED_LET);
  return \u0275\u0275declareLet;
}
function \u0275\u0275storeLet(value2) {
  performanceMarkFeature("NgLet");
  const tView = getTView();
  const lView = getLView();
  const index = getSelectedIndex();
  store(tView, lView, index, value2);
  return value2;
}
function \u0275\u0275readContextLet(index) {
  const contextLView = getContextLView();
  const value2 = load(contextLView, HEADER_OFFSET + index);
  if (value2 === UNINITIALIZED_LET) {
    throw new RuntimeError(314, ngDevMode && "Attempting to access a @let declaration whose value is not available yet");
  }
  return value2;
}
function providersResolver(def, providers2, viewProviders) {
  const tView = getTView();
  if (tView.firstCreatePass) {
    const isComponent2 = isComponentDef(def);
    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent2, true);
    resolveProvider(providers2, tView.data, tView.blueprint, isComponent2, false);
  }
}
function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider) {
  provider = resolveForwardRef(provider);
  if (Array.isArray(provider)) {
    for (let i = 0; i < provider.length; i++) {
      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent2, isViewProvider);
    }
  } else {
    const tView = getTView();
    const lView = getLView();
    const tNode = getCurrentTNode();
    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
    const providerFactory = providerToFactory(provider);
    if (ngDevMode) {
      const injector = new NodeInjector(tNode, lView);
      runInInjectorProfilerContext(injector, token, () => {
        emitProviderConfiguredEvent(provider, isViewProvider);
      });
    }
    const beginIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveStart;
    const cptViewProvidersCount = tNode.providerIndexes >> 20;
    if (isTypeProvider(provider) || !provider.multi) {
      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject);
      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
      if (existingFactoryIndex === -1) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        lInjectablesBlueprint[existingFactoryIndex] = factory;
        lView[existingFactoryIndex] = factory;
      }
    } else {
      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent2, providerFactory);
        if (!isViewProvider && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
        }
        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
        tInjectables.push(token);
        tNode.directiveStart++;
        tNode.directiveEnd++;
        if (isViewProvider) {
          tNode.providerIndexes += 1048576;
        }
        lInjectablesBlueprint.push(factory);
        lView.push(factory);
      } else {
        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent2);
        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
      }
      if (!isViewProvider && isComponent2 && doesViewProvidersFactoryExist) {
        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
      }
    }
  }
}
function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
  const providerIsTypeProvider = isTypeProvider(provider);
  const providerIsClassProvider = isClassProvider(provider);
  if (providerIsTypeProvider || providerIsClassProvider) {
    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
    const prototype = classToken.prototype;
    const ngOnDestroy = prototype.ngOnDestroy;
    if (ngOnDestroy) {
      const hooks = tView.destroyHooks || (tView.destroyHooks = []);
      if (!providerIsTypeProvider && provider.multi) {
        ngDevMode && assertDefined(indexInFactory, "indexInFactory when registering multi factory destroy hook");
        const existingCallbacksIndex = hooks.indexOf(contextIndex);
        if (existingCallbacksIndex === -1) {
          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
        } else {
          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
        }
      } else {
        hooks.push(contextIndex, ngOnDestroy);
      }
    }
  }
}
function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
  if (isComponentProvider) {
    multiFactory2.componentProviders++;
  }
  return multiFactory2.multi.push(factory) - 1;
}
function indexOf(item, arr, begin2, end2) {
  for (let i = begin2; i < end2; i++) {
    if (arr[i] === item) return i;
  }
  return -1;
}
function multiProvidersFactoryResolver(_, tData, lData, tNode) {
  return multiResolve(this.multi, []);
}
function multiViewProvidersFactoryResolver(_, tData, lView, tNode) {
  const factories = this.multi;
  let result;
  if (this.providerFactory) {
    const componentCount = this.providerFactory.componentProviders;
    const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
    result = multiProviders.slice(0, componentCount);
    multiResolve(factories, result);
    for (let i = componentCount; i < multiProviders.length; i++) {
      result.push(multiProviders[i]);
    }
  } else {
    result = [];
    multiResolve(factories, result);
  }
  return result;
}
function multiResolve(factories, result) {
  for (let i = 0; i < factories.length; i++) {
    const factory = factories[i];
    result.push(factory());
  }
  return result;
}
function multiFactory(factoryFn, index, isViewProvider, isComponent2, f) {
  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject);
  factory.multi = [];
  factory.index = index;
  factory.componentProviders = 0;
  multiFactoryAdd(factory, f, isComponent2 && !isViewProvider);
  return factory;
}
function \u0275\u0275ProvidersFeature(providers2, viewProviders = []) {
  return (definition) => {
    definition.providersResolver = (def, processProvidersFn) => {
      return providersResolver(
        def,
        //
        processProvidersFn ? processProvidersFn(providers2) : providers2,
        //
        viewProviders
      );
    };
  };
}
function \u0275\u0275ExternalStylesFeature(styleUrls) {
  return (definition) => {
    if (styleUrls.length < 1) {
      return;
    }
    definition.getExternalStyles = (encapsulationId) => {
      const urls = styleUrls.map((value2) => value2 + "?ngcomp" + (encapsulationId ? "=" + encodeURIComponent(encapsulationId) : "") + "&e=" + definition.encapsulation);
      return urls;
    };
  };
}
function \u0275\u0275setComponentScope(type2, directives, pipes) {
  const def = type2.\u0275cmp;
  def.directiveDefs = extractDefListOrFactory(
    directives,
    /* pipeDef */
    false
  );
  def.pipeDefs = extractDefListOrFactory(
    pipes,
    /* pipeDef */
    true
  );
}
function \u0275\u0275setNgModuleScope(type2, scope) {
  return noSideEffects(() => {
    const ngModuleDef = getNgModuleDef(type2, true);
    ngModuleDef.declarations = convertToTypeArray(scope.declarations || EMPTY_ARRAY);
    ngModuleDef.imports = convertToTypeArray(scope.imports || EMPTY_ARRAY);
    ngModuleDef.exports = convertToTypeArray(scope.exports || EMPTY_ARRAY);
    if (scope.bootstrap) {
      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);
    }
    depsTracker.registerNgModule(type2, scope);
  });
}
function convertToTypeArray(values) {
  if (typeof values === "function") {
    return values;
  }
  const flattenValues = flatten(values);
  if (flattenValues.some(isForwardRef)) {
    return () => flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders);
  } else {
    return flattenValues.map(maybeUnwrapModuleWithProviders);
  }
}
function maybeUnwrapModuleWithProviders(value2) {
  return isModuleWithProviders(value2) ? value2.ngModule : value2;
}
function \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
}
function \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {
  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
}
function \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
}
function \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
}
function \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
}
function \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
}
function \u0275\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
}
function \u0275\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
}
function \u0275\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
  const bindingIndex = getBindingRoot() + slotOffset;
  const lView = getLView();
  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
}
function \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {
  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
}
function getPureFunctionReturnValue(lView, returnValueIndex) {
  ngDevMode && assertIndexInRange(lView, returnValueIndex);
  const lastReturnValue = lView[returnValueIndex];
  return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
}
function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
}
function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
}
function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
}
function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
  const bindingIndex = bindingRoot + slotOffset;
  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
}
function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
  let bindingIndex = bindingRoot + slotOffset;
  let different = false;
  for (let i = 0; i < exps.length; i++) {
    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
  }
  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
}
function \u0275\u0275pipe(index, pipeName) {
  const tView = getTView();
  let pipeDef;
  const adjustedIndex = index + HEADER_OFFSET;
  if (tView.firstCreatePass) {
    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
    tView.data[adjustedIndex] = pipeDef;
    if (pipeDef.onDestroy) {
      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);
    }
  } else {
    pipeDef = tView.data[adjustedIndex];
  }
  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
  let previousInjectorProfilerContext;
  if (ngDevMode) {
    previousInjectorProfilerContext = setInjectorProfilerContext({
      injector: new NodeInjector(getCurrentTNode(), getLView()),
      token: pipeDef.type
    });
  }
  const previousInjectImplementation = setInjectImplementation(\u0275\u0275directiveInject);
  try {
    const previousIncludeViewProviders = setIncludeViewProviders(false);
    const pipeInstance = pipeFactory();
    setIncludeViewProviders(previousIncludeViewProviders);
    store(tView, getLView(), adjustedIndex, pipeInstance);
    return pipeInstance;
  } finally {
    setInjectImplementation(previousInjectImplementation);
    ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext);
  }
}
function getPipeDef(name, registry) {
  if (registry) {
    if (ngDevMode) {
      const pipes = registry.filter((pipe2) => pipe2.name === name);
      if (pipes.length > 1) {
        console.warn(formatRuntimeError(313, getMultipleMatchingPipesMessage(name)));
      }
    }
    for (let i = registry.length - 1; i >= 0; i--) {
      const pipeDef = registry[i];
      if (name === pipeDef.name) {
        return pipeDef;
      }
    }
  }
  if (ngDevMode) {
    throw new RuntimeError(-302, getPipeNotFoundErrorMessage(name));
  }
  return;
}
function getMultipleMatchingPipesMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
  const verifyMessage = `check ${hostIsStandalone ? "'@Component.imports' of this component" : "the imports of this module"}`;
  const errorMessage = `Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function getPipeNotFoundErrorMessage(name) {
  const lView = getLView();
  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
  const context2 = declarationLView[CONTEXT];
  const hostIsStandalone = isHostComponentStandalone(lView);
  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : "";
  const verifyMessage = `Verify that it is ${hostIsStandalone ? "included in the '@Component.imports' of this component" : "declared or imported in this module"}`;
  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;
  return errorMessage;
}
function \u0275\u0275pipeBind1(index, offset2, v1) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), offset2, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
}
function \u0275\u0275pipeBind2(index, slotOffset, v1, v2) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
}
function \u0275\u0275pipeBind3(index, slotOffset, v1, v2, v3) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
}
function \u0275\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
}
function \u0275\u0275pipeBindV(index, slotOffset, values) {
  const adjustedIndex = index + HEADER_OFFSET;
  const lView = getLView();
  const pipeInstance = load(lView, adjustedIndex);
  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
}
function isPure(lView, index) {
  return lView[TVIEW].data[index].pure;
}
function \u0275\u0275templateRefExtractor(tNode, lView) {
  return createTemplateRef(tNode, lView);
}
function \u0275\u0275getComponentDepsFactory(type2, rawImports) {
  return () => {
    try {
      return depsTracker.getComponentDependencies(type2, rawImports).dependencies;
    } catch (e) {
      console.error(`Computing dependencies in local compilation mode for the component "${type2.name}" failed with the exception:`, e);
      throw e;
    }
  };
}
function \u0275setClassDebugInfo(type2, debugInfo) {
  const def = getComponentDef(type2);
  if (def !== null) {
    def.debugInfo = debugInfo;
  }
}
function \u0275\u0275replaceMetadata(type2, applyMetadata, environment2, locals) {
  ngDevMode && assertComponentDef(type2);
  const oldDef = getComponentDef(type2);
  applyMetadata.apply(null, [type2, environment2, ...locals]);
  if (oldDef.tView) {
    const trackedViews = getTrackedLViews().values();
    for (const root3 of trackedViews) {
      if (root3[FLAGS] & 512 && root3[PARENT] === null) {
        recreateMatchingLViews(oldDef, root3);
      }
    }
  }
}
function recreateMatchingLViews(def, rootLView) {
  ngDevMode && assertDefined(def.tView, "Expected a component definition that has been instantiated at least once");
  const tView = rootLView[TVIEW];
  if (tView === def.tView) {
    ngDevMode && assertComponentDef(def.type);
    recreateLView(getComponentDef(def.type), rootLView);
    return;
  }
  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
    const current = rootLView[i];
    if (isLContainer(current)) {
      for (let i2 = CONTAINER_HEADER_OFFSET; i2 < current.length; i2++) {
        recreateMatchingLViews(def, current[i2]);
      }
    } else if (isLView(current)) {
      recreateMatchingLViews(def, current);
    }
  }
}
function clearRendererCache(factory, def) {
  factory.rendererByCompId?.delete(def.id);
}
function recreateLView(def, lView) {
  const instance = lView[CONTEXT];
  const host = lView[HOST];
  const parentLView = lView[PARENT];
  ngDevMode && assertLView(parentLView);
  const tNode = lView[T_HOST];
  ngDevMode && assertTNodeType(
    tNode,
    2
    /* TNodeType.Element */
  );
  const newTView = getOrCreateComponentTView(def);
  const rendererFactory = lView[ENVIRONMENT].rendererFactory;
  clearRendererCache(rendererFactory, def);
  const newLView = createLView(parentLView, newTView, instance, getInitialLViewFlagsFromDef(def), host, tNode, null, rendererFactory.createRenderer(host, def), null, null, null);
  replaceLViewInTree(parentLView, lView, newLView, tNode.index);
  destroyLView(lView[TVIEW], lView);
  removeViewFromDOM(lView[TVIEW], lView);
  resetProjectionState(tNode);
  renderView(newTView, newLView, instance);
  refreshView(newTView, newLView, newTView.template, instance);
}
function replaceLViewInTree(parentLView, oldLView, newLView, index) {
  for (let i = HEADER_OFFSET; i < parentLView[TVIEW].bindingStartIndex; i++) {
    const current = parentLView[i];
    if ((isLView(current) || isLContainer(current)) && current[NEXT] === oldLView) {
      current[NEXT] = newLView;
      break;
    }
  }
  if (parentLView[CHILD_HEAD] === oldLView) {
    parentLView[CHILD_HEAD] = newLView;
  }
  if (parentLView[CHILD_TAIL] === oldLView) {
    parentLView[CHILD_TAIL] = newLView;
  }
  newLView[NEXT] = oldLView[NEXT];
  oldLView[NEXT] = null;
  parentLView[index] = newLView;
}
function resetProjectionState(tNode) {
  if (tNode.projection !== null) {
    for (const current of tNode.projection) {
      if (isTNodeShape(current)) {
        current.projectionNext = null;
        current.flags &= ~2;
      }
    }
    tNode.projection = null;
  }
}
var angularCoreEnv = /* @__PURE__ */ (() => ({
  "\u0275\u0275attribute": \u0275\u0275attribute,
  "\u0275\u0275attributeInterpolate1": \u0275\u0275attributeInterpolate1,
  "\u0275\u0275attributeInterpolate2": \u0275\u0275attributeInterpolate2,
  "\u0275\u0275attributeInterpolate3": \u0275\u0275attributeInterpolate3,
  "\u0275\u0275attributeInterpolate4": \u0275\u0275attributeInterpolate4,
  "\u0275\u0275attributeInterpolate5": \u0275\u0275attributeInterpolate5,
  "\u0275\u0275attributeInterpolate6": \u0275\u0275attributeInterpolate6,
  "\u0275\u0275attributeInterpolate7": \u0275\u0275attributeInterpolate7,
  "\u0275\u0275attributeInterpolate8": \u0275\u0275attributeInterpolate8,
  "\u0275\u0275attributeInterpolateV": \u0275\u0275attributeInterpolateV,
  "\u0275\u0275defineComponent": \u0275\u0275defineComponent,
  "\u0275\u0275defineDirective": \u0275\u0275defineDirective,
  "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
  "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
  "\u0275\u0275defineNgModule": \u0275\u0275defineNgModule,
  "\u0275\u0275definePipe": \u0275\u0275definePipe,
  "\u0275\u0275directiveInject": \u0275\u0275directiveInject,
  "\u0275\u0275getInheritedFactory": \u0275\u0275getInheritedFactory,
  "\u0275\u0275inject": \u0275\u0275inject,
  "\u0275\u0275injectAttribute": \u0275\u0275injectAttribute,
  "\u0275\u0275invalidFactory": \u0275\u0275invalidFactory,
  "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
  "\u0275\u0275templateRefExtractor": \u0275\u0275templateRefExtractor,
  "\u0275\u0275resetView": \u0275\u0275resetView,
  "\u0275\u0275HostDirectivesFeature": \u0275\u0275HostDirectivesFeature,
  "\u0275\u0275NgOnChangesFeature": \u0275\u0275NgOnChangesFeature,
  "\u0275\u0275ProvidersFeature": \u0275\u0275ProvidersFeature,
  "\u0275\u0275CopyDefinitionFeature": \u0275\u0275CopyDefinitionFeature,
  "\u0275\u0275InheritDefinitionFeature": \u0275\u0275InheritDefinitionFeature,
  "\u0275\u0275InputTransformsFeature": \u0275\u0275InputTransformsFeature,
  "\u0275\u0275ExternalStylesFeature": \u0275\u0275ExternalStylesFeature,
  "\u0275\u0275nextContext": \u0275\u0275nextContext,
  "\u0275\u0275namespaceHTML": \u0275\u0275namespaceHTML,
  "\u0275\u0275namespaceMathML": \u0275\u0275namespaceMathML,
  "\u0275\u0275namespaceSVG": \u0275\u0275namespaceSVG,
  "\u0275\u0275enableBindings": \u0275\u0275enableBindings,
  "\u0275\u0275disableBindings": \u0275\u0275disableBindings,
  "\u0275\u0275elementStart": \u0275\u0275elementStart,
  "\u0275\u0275elementEnd": \u0275\u0275elementEnd,
  "\u0275\u0275element": \u0275\u0275element,
  "\u0275\u0275elementContainerStart": \u0275\u0275elementContainerStart,
  "\u0275\u0275elementContainerEnd": \u0275\u0275elementContainerEnd,
  "\u0275\u0275elementContainer": \u0275\u0275elementContainer,
  "\u0275\u0275pureFunction0": \u0275\u0275pureFunction0,
  "\u0275\u0275pureFunction1": \u0275\u0275pureFunction1,
  "\u0275\u0275pureFunction2": \u0275\u0275pureFunction2,
  "\u0275\u0275pureFunction3": \u0275\u0275pureFunction3,
  "\u0275\u0275pureFunction4": \u0275\u0275pureFunction4,
  "\u0275\u0275pureFunction5": \u0275\u0275pureFunction5,
  "\u0275\u0275pureFunction6": \u0275\u0275pureFunction6,
  "\u0275\u0275pureFunction7": \u0275\u0275pureFunction7,
  "\u0275\u0275pureFunction8": \u0275\u0275pureFunction8,
  "\u0275\u0275pureFunctionV": \u0275\u0275pureFunctionV,
  "\u0275\u0275getCurrentView": \u0275\u0275getCurrentView,
  "\u0275\u0275restoreView": \u0275\u0275restoreView,
  "\u0275\u0275listener": \u0275\u0275listener,
  "\u0275\u0275projection": \u0275\u0275projection,
  "\u0275\u0275syntheticHostProperty": \u0275\u0275syntheticHostProperty,
  "\u0275\u0275syntheticHostListener": \u0275\u0275syntheticHostListener,
  "\u0275\u0275pipeBind1": \u0275\u0275pipeBind1,
  "\u0275\u0275pipeBind2": \u0275\u0275pipeBind2,
  "\u0275\u0275pipeBind3": \u0275\u0275pipeBind3,
  "\u0275\u0275pipeBind4": \u0275\u0275pipeBind4,
  "\u0275\u0275pipeBindV": \u0275\u0275pipeBindV,
  "\u0275\u0275projectionDef": \u0275\u0275projectionDef,
  "\u0275\u0275hostProperty": \u0275\u0275hostProperty,
  "\u0275\u0275property": \u0275\u0275property,
  "\u0275\u0275propertyInterpolate": \u0275\u0275propertyInterpolate,
  "\u0275\u0275propertyInterpolate1": \u0275\u0275propertyInterpolate1,
  "\u0275\u0275propertyInterpolate2": \u0275\u0275propertyInterpolate2,
  "\u0275\u0275propertyInterpolate3": \u0275\u0275propertyInterpolate3,
  "\u0275\u0275propertyInterpolate4": \u0275\u0275propertyInterpolate4,
  "\u0275\u0275propertyInterpolate5": \u0275\u0275propertyInterpolate5,
  "\u0275\u0275propertyInterpolate6": \u0275\u0275propertyInterpolate6,
  "\u0275\u0275propertyInterpolate7": \u0275\u0275propertyInterpolate7,
  "\u0275\u0275propertyInterpolate8": \u0275\u0275propertyInterpolate8,
  "\u0275\u0275propertyInterpolateV": \u0275\u0275propertyInterpolateV,
  "\u0275\u0275pipe": \u0275\u0275pipe,
  "\u0275\u0275queryRefresh": \u0275\u0275queryRefresh,
  "\u0275\u0275queryAdvance": \u0275\u0275queryAdvance,
  "\u0275\u0275viewQuery": \u0275\u0275viewQuery,
  "\u0275\u0275viewQuerySignal": \u0275\u0275viewQuerySignal,
  "\u0275\u0275loadQuery": \u0275\u0275loadQuery,
  "\u0275\u0275contentQuery": \u0275\u0275contentQuery,
  "\u0275\u0275contentQuerySignal": \u0275\u0275contentQuerySignal,
  "\u0275\u0275reference": \u0275\u0275reference,
  "\u0275\u0275classMap": \u0275\u0275classMap,
  "\u0275\u0275classMapInterpolate1": \u0275\u0275classMapInterpolate1,
  "\u0275\u0275classMapInterpolate2": \u0275\u0275classMapInterpolate2,
  "\u0275\u0275classMapInterpolate3": \u0275\u0275classMapInterpolate3,
  "\u0275\u0275classMapInterpolate4": \u0275\u0275classMapInterpolate4,
  "\u0275\u0275classMapInterpolate5": \u0275\u0275classMapInterpolate5,
  "\u0275\u0275classMapInterpolate6": \u0275\u0275classMapInterpolate6,
  "\u0275\u0275classMapInterpolate7": \u0275\u0275classMapInterpolate7,
  "\u0275\u0275classMapInterpolate8": \u0275\u0275classMapInterpolate8,
  "\u0275\u0275classMapInterpolateV": \u0275\u0275classMapInterpolateV,
  "\u0275\u0275styleMap": \u0275\u0275styleMap,
  "\u0275\u0275styleMapInterpolate1": \u0275\u0275styleMapInterpolate1,
  "\u0275\u0275styleMapInterpolate2": \u0275\u0275styleMapInterpolate2,
  "\u0275\u0275styleMapInterpolate3": \u0275\u0275styleMapInterpolate3,
  "\u0275\u0275styleMapInterpolate4": \u0275\u0275styleMapInterpolate4,
  "\u0275\u0275styleMapInterpolate5": \u0275\u0275styleMapInterpolate5,
  "\u0275\u0275styleMapInterpolate6": \u0275\u0275styleMapInterpolate6,
  "\u0275\u0275styleMapInterpolate7": \u0275\u0275styleMapInterpolate7,
  "\u0275\u0275styleMapInterpolate8": \u0275\u0275styleMapInterpolate8,
  "\u0275\u0275styleMapInterpolateV": \u0275\u0275styleMapInterpolateV,
  "\u0275\u0275styleProp": \u0275\u0275styleProp,
  "\u0275\u0275stylePropInterpolate1": \u0275\u0275stylePropInterpolate1,
  "\u0275\u0275stylePropInterpolate2": \u0275\u0275stylePropInterpolate2,
  "\u0275\u0275stylePropInterpolate3": \u0275\u0275stylePropInterpolate3,
  "\u0275\u0275stylePropInterpolate4": \u0275\u0275stylePropInterpolate4,
  "\u0275\u0275stylePropInterpolate5": \u0275\u0275stylePropInterpolate5,
  "\u0275\u0275stylePropInterpolate6": \u0275\u0275stylePropInterpolate6,
  "\u0275\u0275stylePropInterpolate7": \u0275\u0275stylePropInterpolate7,
  "\u0275\u0275stylePropInterpolate8": \u0275\u0275stylePropInterpolate8,
  "\u0275\u0275stylePropInterpolateV": \u0275\u0275stylePropInterpolateV,
  "\u0275\u0275classProp": \u0275\u0275classProp,
  "\u0275\u0275advance": \u0275\u0275advance,
  "\u0275\u0275template": \u0275\u0275template,
  "\u0275\u0275conditional": \u0275\u0275conditional,
  "\u0275\u0275defer": \u0275\u0275defer,
  "\u0275\u0275deferWhen": \u0275\u0275deferWhen,
  "\u0275\u0275deferOnIdle": \u0275\u0275deferOnIdle,
  "\u0275\u0275deferOnImmediate": \u0275\u0275deferOnImmediate,
  "\u0275\u0275deferOnTimer": \u0275\u0275deferOnTimer,
  "\u0275\u0275deferOnHover": \u0275\u0275deferOnHover,
  "\u0275\u0275deferOnInteraction": \u0275\u0275deferOnInteraction,
  "\u0275\u0275deferOnViewport": \u0275\u0275deferOnViewport,
  "\u0275\u0275deferPrefetchWhen": \u0275\u0275deferPrefetchWhen,
  "\u0275\u0275deferPrefetchOnIdle": \u0275\u0275deferPrefetchOnIdle,
  "\u0275\u0275deferPrefetchOnImmediate": \u0275\u0275deferPrefetchOnImmediate,
  "\u0275\u0275deferPrefetchOnTimer": \u0275\u0275deferPrefetchOnTimer,
  "\u0275\u0275deferPrefetchOnHover": \u0275\u0275deferPrefetchOnHover,
  "\u0275\u0275deferPrefetchOnInteraction": \u0275\u0275deferPrefetchOnInteraction,
  "\u0275\u0275deferPrefetchOnViewport": \u0275\u0275deferPrefetchOnViewport,
  "\u0275\u0275deferHydrateWhen": \u0275\u0275deferHydrateWhen,
  "\u0275\u0275deferHydrateNever": \u0275\u0275deferHydrateNever,
  "\u0275\u0275deferHydrateOnIdle": \u0275\u0275deferHydrateOnIdle,
  "\u0275\u0275deferHydrateOnImmediate": \u0275\u0275deferHydrateOnImmediate,
  "\u0275\u0275deferHydrateOnTimer": \u0275\u0275deferHydrateOnTimer,
  "\u0275\u0275deferHydrateOnHover": \u0275\u0275deferHydrateOnHover,
  "\u0275\u0275deferHydrateOnInteraction": \u0275\u0275deferHydrateOnInteraction,
  "\u0275\u0275deferHydrateOnViewport": \u0275\u0275deferHydrateOnViewport,
  "\u0275\u0275deferEnableTimerScheduling": \u0275\u0275deferEnableTimerScheduling,
  "\u0275\u0275repeater": \u0275\u0275repeater,
  "\u0275\u0275repeaterCreate": \u0275\u0275repeaterCreate,
  "\u0275\u0275repeaterTrackByIndex": \u0275\u0275repeaterTrackByIndex,
  "\u0275\u0275repeaterTrackByIdentity": \u0275\u0275repeaterTrackByIdentity,
  "\u0275\u0275componentInstance": \u0275\u0275componentInstance,
  "\u0275\u0275text": \u0275\u0275text,
  "\u0275\u0275textInterpolate": \u0275\u0275textInterpolate,
  "\u0275\u0275textInterpolate1": \u0275\u0275textInterpolate1,
  "\u0275\u0275textInterpolate2": \u0275\u0275textInterpolate2,
  "\u0275\u0275textInterpolate3": \u0275\u0275textInterpolate3,
  "\u0275\u0275textInterpolate4": \u0275\u0275textInterpolate4,
  "\u0275\u0275textInterpolate5": \u0275\u0275textInterpolate5,
  "\u0275\u0275textInterpolate6": \u0275\u0275textInterpolate6,
  "\u0275\u0275textInterpolate7": \u0275\u0275textInterpolate7,
  "\u0275\u0275textInterpolate8": \u0275\u0275textInterpolate8,
  "\u0275\u0275textInterpolateV": \u0275\u0275textInterpolateV,
  "\u0275\u0275i18n": \u0275\u0275i18n,
  "\u0275\u0275i18nAttributes": \u0275\u0275i18nAttributes,
  "\u0275\u0275i18nExp": \u0275\u0275i18nExp,
  "\u0275\u0275i18nStart": \u0275\u0275i18nStart,
  "\u0275\u0275i18nEnd": \u0275\u0275i18nEnd,
  "\u0275\u0275i18nApply": \u0275\u0275i18nApply,
  "\u0275\u0275i18nPostprocess": \u0275\u0275i18nPostprocess,
  "\u0275\u0275resolveWindow": \u0275\u0275resolveWindow,
  "\u0275\u0275resolveDocument": \u0275\u0275resolveDocument,
  "\u0275\u0275resolveBody": \u0275\u0275resolveBody,
  "\u0275\u0275setComponentScope": \u0275\u0275setComponentScope,
  "\u0275\u0275setNgModuleScope": \u0275\u0275setNgModuleScope,
  "\u0275\u0275registerNgModuleType": registerNgModuleType,
  "\u0275\u0275getComponentDepsFactory": \u0275\u0275getComponentDepsFactory,
  "\u0275setClassDebugInfo": \u0275setClassDebugInfo,
  "\u0275\u0275declareLet": \u0275\u0275declareLet,
  "\u0275\u0275storeLet": \u0275\u0275storeLet,
  "\u0275\u0275readContextLet": \u0275\u0275readContextLet,
  "\u0275\u0275sanitizeHtml": \u0275\u0275sanitizeHtml,
  "\u0275\u0275sanitizeStyle": \u0275\u0275sanitizeStyle,
  "\u0275\u0275sanitizeResourceUrl": \u0275\u0275sanitizeResourceUrl,
  "\u0275\u0275sanitizeScript": \u0275\u0275sanitizeScript,
  "\u0275\u0275sanitizeUrl": \u0275\u0275sanitizeUrl,
  "\u0275\u0275sanitizeUrlOrResourceUrl": \u0275\u0275sanitizeUrlOrResourceUrl,
  "\u0275\u0275trustConstantHtml": \u0275\u0275trustConstantHtml,
  "\u0275\u0275trustConstantResourceUrl": \u0275\u0275trustConstantResourceUrl,
  "\u0275\u0275validateIframeAttribute": \u0275\u0275validateIframeAttribute,
  "forwardRef": forwardRef,
  "resolveForwardRef": resolveForwardRef,
  "\u0275\u0275twoWayProperty": \u0275\u0275twoWayProperty,
  "\u0275\u0275twoWayBindingSet": \u0275\u0275twoWayBindingSet,
  "\u0275\u0275twoWayListener": \u0275\u0275twoWayListener,
  "\u0275\u0275replaceMetadata": \u0275\u0275replaceMetadata
}))();
var jitOptions = null;
function setJitOptions(options) {
  if (jitOptions !== null) {
    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
      ngDevMode && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
      return;
    }
    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
      ngDevMode && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
      return;
    }
  }
  jitOptions = options;
}
function getJitOptions() {
  return jitOptions;
}
function patchModuleCompilation() {
}
var moduleQueue = [];
function enqueueModuleForDelayedScoping(moduleType, ngModule) {
  moduleQueue.push({
    moduleType,
    ngModule
  });
}
var flushingModuleQueue = false;
function flushModuleScopingQueueAsMuchAsPossible() {
  if (!flushingModuleQueue) {
    flushingModuleQueue = true;
    try {
      for (let i = moduleQueue.length - 1; i >= 0; i--) {
        const {
          moduleType,
          ngModule
        } = moduleQueue[i];
        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
          moduleQueue.splice(i, 1);
          setScopeOnDeclaredComponents(moduleType, ngModule);
        }
      }
    } finally {
      flushingModuleQueue = false;
    }
  }
}
function isResolvedDeclaration(declaration) {
  if (Array.isArray(declaration)) {
    return declaration.every(isResolvedDeclaration);
  }
  return !!resolveForwardRef(declaration);
}
function compileNgModule(moduleType, ngModule = {}) {
  patchModuleCompilation();
  compileNgModuleDefs(moduleType, ngModule);
  if (ngModule.id !== void 0) {
    registerNgModuleType(moduleType, ngModule.id);
  }
  enqueueModuleForDelayedScoping(moduleType, ngModule);
}
function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
  ngDevMode && assertDefined(moduleType, "Required value moduleType");
  ngDevMode && assertDefined(ngModule, "Required value ngModule");
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  let ngModuleDef = null;
  Object.defineProperty(moduleType, NG_MOD_DEF, {
    configurable: true,
    get: () => {
      if (ngModuleDef === null) {
        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
        }
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {
          type: moduleType,
          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
          declarations: declarations.map(resolveForwardRef),
          imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
          id: ngModule.id || null
        });
        if (!ngModuleDef.schemas) {
          ngModuleDef.schemas = [];
        }
      }
      return ngModuleDef;
    }
  });
  let ngFactoryDef = null;
  Object.defineProperty(moduleType, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\u0275fac.js`, {
          name: moduleType.name,
          type: moduleType,
          deps: reflectDependencies(moduleType),
          target: compiler.FactoryTarget.NgModule,
          typeArgumentCount: 0
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  let ngInjectorDef = null;
  Object.defineProperty(moduleType, NG_INJ_DEF, {
    get: () => {
      if (ngInjectorDef === null) {
        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
        const meta = {
          name: moduleType.name,
          type: moduleType,
          providers: ngModule.providers || EMPTY_ARRAY,
          imports: [(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef), (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)]
        };
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "NgModule",
          type: moduleType
        });
        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta);
      }
      return ngInjectorDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function generateStandaloneInDeclarationsError(type2, location2) {
  const prefix = `Unexpected "${stringifyForError(type2)}" found in the "declarations" array of the`;
  const suffix = `"${stringifyForError(type2)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`;
  return `${prefix} ${location2}, ${suffix}`;
}
function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
  if (verifiedNgModule.get(moduleType)) return;
  if (isStandalone(moduleType)) return;
  verifiedNgModule.set(moduleType, true);
  moduleType = resolveForwardRef(moduleType);
  let ngModuleDef;
  if (importingModule) {
    ngModuleDef = getNgModuleDef(moduleType);
    if (!ngModuleDef) {
      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
    }
  } else {
    ngModuleDef = getNgModuleDef(moduleType, true);
  }
  const errors = [];
  const declarations = maybeUnwrapFn(ngModuleDef.declarations);
  const imports = maybeUnwrapFn(ngModuleDef.imports);
  flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt) => {
    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);
    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);
  });
  const exports = maybeUnwrapFn(ngModuleDef.exports);
  declarations.forEach(verifyDeclarationsHaveDefinitions);
  declarations.forEach(verifyDirectivesHaveSelector);
  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));
  const combinedDeclarations = [...declarations.map(resolveForwardRef), ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)];
  exports.forEach(verifyExportsAreDeclaredOrReExported);
  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
  const ngModule = getAnnotation(moduleType, "NgModule");
  if (ngModule) {
    ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
  }
  if (errors.length) {
    throw new Error(errors.join("\n"));
  }
  function verifyDeclarationsHaveDefinitions(type2) {
    type2 = resolveForwardRef(type2);
    const def = getComponentDef(type2) || getDirectiveDef(type2) || getPipeDef$1(type2);
    if (!def) {
      errors.push(`Unexpected value '${stringifyForError(type2)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
    }
  }
  function verifyDirectivesHaveSelector(type2) {
    type2 = resolveForwardRef(type2);
    const def = getDirectiveDef(type2);
    if (!getComponentDef(type2) && def && def.selectors.length == 0) {
      errors.push(`Directive ${stringifyForError(type2)} has no selector, please add it!`);
    }
  }
  function verifyNotStandalone(type2, moduleType2) {
    type2 = resolveForwardRef(type2);
    const def = getComponentDef(type2) || getDirectiveDef(type2) || getPipeDef$1(type2);
    if (def?.standalone) {
      const location2 = `"${stringifyForError(moduleType2)}" NgModule`;
      errors.push(generateStandaloneInDeclarationsError(type2, location2));
    }
  }
  function verifyExportsAreDeclaredOrReExported(type2) {
    type2 = resolveForwardRef(type2);
    const kind = getComponentDef(type2) && "component" || getDirectiveDef(type2) && "directive" || getPipeDef$1(type2) && "pipe";
    if (kind) {
      if (combinedDeclarations.lastIndexOf(type2) === -1) {
        errors.push(`Can't export ${kind} ${stringifyForError(type2)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
      }
    }
  }
  function verifyDeclarationIsUnique(type2, suppressErrors) {
    type2 = resolveForwardRef(type2);
    const existingModule = ownerNgModule.get(type2);
    if (existingModule && existingModule !== moduleType) {
      if (!suppressErrors) {
        const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
        errors.push(`Type ${stringifyForError(type2)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type2)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type2)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
      }
    } else {
      ownerNgModule.set(type2, moduleType);
    }
  }
  function verifyComponentIsPartOfNgModule(type2) {
    type2 = resolveForwardRef(type2);
    const existingModule = ownerNgModule.get(type2);
    if (!existingModule && !isStandalone(type2)) {
      errors.push(`Component ${stringifyForError(type2)} is not part of any NgModule or the module has not been imported into your module.`);
    }
  }
  function verifyCorrectBootstrapType(type2) {
    type2 = resolveForwardRef(type2);
    if (!getComponentDef(type2)) {
      errors.push(`${stringifyForError(type2)} cannot be used as an entry component.`);
    }
    if (isStandalone(type2)) {
      errors.push(`The \`${stringifyForError(type2)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`);
    }
  }
  function verifySemanticsOfNgModuleImport(type2, importingModule2) {
    type2 = resolveForwardRef(type2);
    const directiveDef = getComponentDef(type2) || getDirectiveDef(type2);
    if (directiveDef !== null && !directiveDef.standalone) {
      throw new Error(`Unexpected directive '${type2.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
    const pipeDef = getPipeDef$1(type2);
    if (pipeDef !== null && !pipeDef.standalone) {
      throw new Error(`Unexpected pipe '${type2.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
    }
  }
}
function unwrapModuleWithProvidersImports(typeOrWithProviders) {
  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
  return typeOrWithProviders.ngModule || typeOrWithProviders;
}
function getAnnotation(type2, name) {
  let annotation = null;
  collect(type2.__annotations__);
  collect(type2.decorators);
  return annotation;
  function collect(annotations) {
    if (annotations) {
      annotations.forEach(readAnnotation);
    }
  }
  function readAnnotation(decorator) {
    if (!annotation) {
      const proto = Object.getPrototypeOf(decorator);
      if (proto.ngMetadataName == name) {
        annotation = decorator;
      } else if (decorator.type) {
        const proto2 = Object.getPrototypeOf(decorator.type);
        if (proto2.ngMetadataName == name) {
          annotation = decorator.args[0];
        }
      }
    }
  }
}
var ownerNgModule = /* @__PURE__ */ new WeakMap();
var verifiedNgModule = /* @__PURE__ */ new WeakMap();
function computeCombinedExports(type2) {
  type2 = resolveForwardRef(type2);
  const ngModuleDef = getNgModuleDef(type2);
  if (ngModuleDef === null) {
    return [type2];
  }
  return flatten(maybeUnwrapFn(ngModuleDef.exports).map((type3) => {
    const ngModuleDef2 = getNgModuleDef(type3);
    if (ngModuleDef2) {
      verifySemanticsOfNgModuleDef(type3, false);
      return computeCombinedExports(type3);
    } else {
      return type3;
    }
  }));
}
function setScopeOnDeclaredComponents(moduleType, ngModule) {
  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
  const transitiveScopes = transitiveScopesFor(moduleType);
  declarations.forEach((declaration) => {
    declaration = resolveForwardRef(declaration);
    if (declaration.hasOwnProperty(NG_COMP_DEF)) {
      const component = declaration;
      const componentDef = getComponentDef(component);
      patchComponentDefWithScope(componentDef, transitiveScopes);
    } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
      declaration.ngSelectorScope = moduleType;
    }
  });
}
function patchComponentDefWithScope(componentDef, transitiveScopes) {
  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);
  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe2) => getPipeDef$1(pipe2));
  componentDef.schemas = transitiveScopes.schemas;
  componentDef.tView = null;
}
function transitiveScopesFor(type2) {
  if (isNgModule(type2)) {
    if (USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      const scope = depsTracker.getNgModuleScope(type2);
      const def = getNgModuleDef(type2, true);
      return __spreadValues({
        schemas: def.schemas || null
      }, scope);
    } else {
      return transitiveScopesForNgModule(type2);
    }
  } else if (isStandalone(type2)) {
    const directiveDef = getComponentDef(type2) || getDirectiveDef(type2);
    if (directiveDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set([type2]),
          pipes: /* @__PURE__ */ new Set()
        }
      };
    }
    const pipeDef = getPipeDef$1(type2);
    if (pipeDef !== null) {
      return {
        schemas: null,
        compilation: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set()
        },
        exported: {
          directives: /* @__PURE__ */ new Set(),
          pipes: /* @__PURE__ */ new Set([type2])
        }
      };
    }
  }
  throw new Error(`${type2.name} does not have a module def (\u0275mod property)`);
}
function transitiveScopesForNgModule(moduleType) {
  const def = getNgModuleDef(moduleType, true);
  if (def.transitiveCompileScopes !== null) {
    return def.transitiveCompileScopes;
  }
  const scopes = {
    schemas: def.schemas || null,
    compilation: {
      directives: /* @__PURE__ */ new Set(),
      pipes: /* @__PURE__ */ new Set()
    },
    exported: {
      directives: /* @__PURE__ */ new Set(),
      pipes: /* @__PURE__ */ new Set()
    }
  };
  maybeUnwrapFn(def.imports).forEach((imported) => {
    const importedScope = transitiveScopesFor(imported);
    importedScope.exported.directives.forEach((entry) => scopes.compilation.directives.add(entry));
    importedScope.exported.pipes.forEach((entry) => scopes.compilation.pipes.add(entry));
  });
  maybeUnwrapFn(def.declarations).forEach((declared) => {
    const declaredWithDefs = declared;
    if (getPipeDef$1(declaredWithDefs)) {
      scopes.compilation.pipes.add(declared);
    } else {
      scopes.compilation.directives.add(declared);
    }
  });
  maybeUnwrapFn(def.exports).forEach((exported) => {
    const exportedType = exported;
    if (isNgModule(exportedType)) {
      const exportedScope = transitiveScopesFor(exportedType);
      exportedScope.exported.directives.forEach((entry) => {
        scopes.compilation.directives.add(entry);
        scopes.exported.directives.add(entry);
      });
      exportedScope.exported.pipes.forEach((entry) => {
        scopes.compilation.pipes.add(entry);
        scopes.exported.pipes.add(entry);
      });
    } else if (getPipeDef$1(exportedType)) {
      scopes.exported.pipes.add(exportedType);
    } else {
      scopes.exported.directives.add(exportedType);
    }
  });
  def.transitiveCompileScopes = scopes;
  return scopes;
}
function expandModuleWithProviders(value2) {
  if (isModuleWithProviders(value2)) {
    return value2.ngModule;
  }
  return value2;
}
var compilationDepth = 0;
function compileComponent(type2, metadata) {
  (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
  let ngComponentDef = null;
  maybeQueueResolutionOfComponentResources(type2, metadata);
  addDirectiveFactoryDef(type2, metadata);
  Object.defineProperty(type2, NG_COMP_DEF, {
    get: () => {
      if (ngComponentDef === null) {
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "component",
          type: type2
        });
        if (componentNeedsResolution(metadata)) {
          const error = [`Component '${type2.name}' is not resolved:`];
          if (metadata.templateUrl) {
            error.push(` - templateUrl: ${metadata.templateUrl}`);
          }
          if (metadata.styleUrls && metadata.styleUrls.length) {
            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
          }
          if (metadata.styleUrl) {
            error.push(` - styleUrl: ${metadata.styleUrl}`);
          }
          error.push(`Did you run and wait for 'resolveComponentResources()'?`);
          throw new Error(error.join("\n"));
        }
        const options = getJitOptions();
        let preserveWhitespaces = metadata.preserveWhitespaces;
        if (preserveWhitespaces === void 0) {
          if (options !== null && options.preserveWhitespaces !== void 0) {
            preserveWhitespaces = options.preserveWhitespaces;
          } else {
            preserveWhitespaces = false;
          }
        }
        let encapsulation = metadata.encapsulation;
        if (encapsulation === void 0) {
          if (options !== null && options.defaultEncapsulation !== void 0) {
            encapsulation = options.defaultEncapsulation;
          } else {
            encapsulation = ViewEncapsulation.Emulated;
          }
        }
        const templateUrl = metadata.templateUrl || `ng:///${type2.name}/template.html`;
        const meta = __spreadProps(__spreadValues({}, directiveMetadata(type2, metadata)), {
          typeSourceSpan: compiler.createParseSourceSpan("Component", type2.name, templateUrl),
          template: metadata.template || "",
          preserveWhitespaces,
          styles: typeof metadata.styles === "string" ? [metadata.styles] : metadata.styles || EMPTY_ARRAY,
          animations: metadata.animations,
          // JIT components are always compiled against an empty set of `declarations`. Instead, the
          // `directiveDefs` and `pipeDefs` are updated at a later point:
          //  * for NgModule-based components, they're set when the NgModule which declares the
          //    component resolves in the module scoping queue
          //  * for standalone components, they're set just below, after `compileComponent`.
          declarations: [],
          changeDetection: metadata.changeDetection,
          encapsulation,
          interpolation: metadata.interpolation,
          viewProviders: metadata.viewProviders || null
        });
        compilationDepth++;
        try {
          if (meta.usesInheritance) {
            addDirectiveDefToUndecoratedParents(type2);
          }
          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          if (meta.isStandalone) {
            const imports = flatten(metadata.imports || EMPTY_ARRAY);
            const {
              directiveDefs,
              pipeDefs
            } = getStandaloneDefFunctions(type2, imports);
            ngComponentDef.directiveDefs = directiveDefs;
            ngComponentDef.pipeDefs = pipeDefs;
            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);
          }
        } finally {
          compilationDepth--;
        }
        if (compilationDepth === 0) {
          flushModuleScopingQueueAsMuchAsPossible();
        }
        if (hasSelectorScope(type2)) {
          const scopes = transitiveScopesFor(type2.ngSelectorScope);
          patchComponentDefWithScope(ngComponentDef, scopes);
        }
        if (metadata.schemas) {
          if (meta.isStandalone) {
            ngComponentDef.schemas = metadata.schemas;
          } else {
            throw new Error(`The 'schemas' was specified for the ${stringifyForError(type2)} but is only valid on a component that is standalone.`);
          }
        } else if (meta.isStandalone) {
          ngComponentDef.schemas = [];
        }
      }
      return ngComponentDef;
    },
    set: (def) => {
      ngComponentDef = def;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getStandaloneDefFunctions(type2, imports) {
  let cachedDirectiveDefs = null;
  let cachedPipeDefs = null;
  const directiveDefs = () => {
    if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      if (cachedDirectiveDefs === null) {
        cachedDirectiveDefs = [getComponentDef(type2)];
        const seen = /* @__PURE__ */ new Set([type2]);
        for (const rawDep of imports) {
          ngDevMode && verifyStandaloneImport(rawDep, type2);
          const dep = resolveForwardRef(rawDep);
          if (seen.has(dep)) {
            continue;
          }
          seen.add(dep);
          if (!!getNgModuleDef(dep)) {
            const scope = transitiveScopesFor(dep);
            for (const dir of scope.exported.directives) {
              const def = getComponentDef(dir) || getDirectiveDef(dir);
              if (def && !seen.has(dir)) {
                seen.add(dir);
                cachedDirectiveDefs.push(def);
              }
            }
          } else {
            const def = getComponentDef(dep) || getDirectiveDef(dep);
            if (def) {
              cachedDirectiveDefs.push(def);
            }
          }
        }
      }
      return cachedDirectiveDefs;
    } else {
      if (ngDevMode) {
        for (const rawDep of imports) {
          verifyStandaloneImport(rawDep, type2);
        }
      }
      if (!isComponent(type2)) {
        return [];
      }
      const scope = depsTracker.getStandaloneComponentScope(type2, imports);
      return [...scope.compilation.directives].map((p2) => getComponentDef(p2) || getDirectiveDef(p2)).filter((d) => d !== null);
    }
  };
  const pipeDefs = () => {
    if (!USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {
      if (cachedPipeDefs === null) {
        cachedPipeDefs = [];
        const seen = /* @__PURE__ */ new Set();
        for (const rawDep of imports) {
          const dep = resolveForwardRef(rawDep);
          if (seen.has(dep)) {
            continue;
          }
          seen.add(dep);
          if (!!getNgModuleDef(dep)) {
            const scope = transitiveScopesFor(dep);
            for (const pipe2 of scope.exported.pipes) {
              const def = getPipeDef$1(pipe2);
              if (def && !seen.has(pipe2)) {
                seen.add(pipe2);
                cachedPipeDefs.push(def);
              }
            }
          } else {
            const def = getPipeDef$1(dep);
            if (def) {
              cachedPipeDefs.push(def);
            }
          }
        }
      }
      return cachedPipeDefs;
    } else {
      if (ngDevMode) {
        for (const rawDep of imports) {
          verifyStandaloneImport(rawDep, type2);
        }
      }
      if (!isComponent(type2)) {
        return [];
      }
      const scope = depsTracker.getStandaloneComponentScope(type2, imports);
      return [...scope.compilation.pipes].map((p2) => getPipeDef$1(p2)).filter((d) => d !== null);
    }
  };
  return {
    directiveDefs,
    pipeDefs
  };
}
function hasSelectorScope(component) {
  return component.ngSelectorScope !== void 0;
}
function compileDirective(type2, directive) {
  let ngDirectiveDef = null;
  addDirectiveFactoryDef(type2, directive || {});
  Object.defineProperty(type2, NG_DIR_DEF, {
    get: () => {
      if (ngDirectiveDef === null) {
        const meta = getDirectiveMetadata(type2, directive || {});
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type: type2
        });
        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
      }
      return ngDirectiveDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getDirectiveMetadata(type2, metadata) {
  const name = type2 && type2.name;
  const sourceMapUrl = `ng:///${name}/\u0275dir.js`;
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "directive",
    type: type2
  });
  const facade = directiveMetadata(type2, metadata);
  facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
  if (facade.usesInheritance) {
    addDirectiveDefToUndecoratedParents(type2);
  }
  return {
    metadata: facade,
    sourceMapUrl
  };
}
function addDirectiveFactoryDef(type2, metadata) {
  let ngFactoryDef = null;
  Object.defineProperty(type2, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const meta = getDirectiveMetadata(type2, metadata);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "directive",
          type: type2
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type2.name}/\u0275fac.js`, {
          name: meta.metadata.name,
          type: meta.metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type2),
          target: compiler.FactoryTarget.Directive
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function extendsDirectlyFromObject(type2) {
  return Object.getPrototypeOf(type2.prototype) === Object.prototype;
}
function directiveMetadata(type2, metadata) {
  const reflect = getReflect();
  const propMetadata = reflect.ownPropMetadata(type2);
  return {
    name: type2.name,
    type: type2,
    selector: metadata.selector !== void 0 ? metadata.selector : null,
    host: metadata.host || EMPTY_OBJ,
    propMetadata,
    inputs: metadata.inputs || EMPTY_ARRAY,
    outputs: metadata.outputs || EMPTY_ARRAY,
    queries: extractQueriesMetadata(type2, propMetadata, isContentQuery),
    lifecycle: {
      usesOnChanges: reflect.hasLifecycleHook(type2, "ngOnChanges")
    },
    typeSourceSpan: null,
    usesInheritance: !extendsDirectlyFromObject(type2),
    exportAs: extractExportAs(metadata.exportAs),
    providers: metadata.providers || null,
    viewQueries: extractQueriesMetadata(type2, propMetadata, isViewQuery),
    isStandalone: metadata.standalone === void 0 ? true : !!metadata.standalone,
    isSignal: !!metadata.signals,
    hostDirectives: metadata.hostDirectives?.map((directive) => typeof directive === "function" ? {
      directive
    } : directive) || null
  };
}
function addDirectiveDefToUndecoratedParents(type2) {
  const objPrototype = Object.prototype;
  let parent = Object.getPrototypeOf(type2.prototype).constructor;
  while (parent && parent !== objPrototype) {
    if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {
      compileDirective(parent, null);
    }
    parent = Object.getPrototypeOf(parent);
  }
}
function convertToR3QueryPredicate(selector) {
  return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
}
function convertToR3QueryMetadata(propertyName, ann) {
  return {
    propertyName,
    predicate: convertToR3QueryPredicate(ann.selector),
    descendants: ann.descendants,
    first: ann.first,
    read: ann.read ? ann.read : null,
    static: !!ann.static,
    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,
    isSignal: !!ann.isSignal
  };
}
function extractQueriesMetadata(type2, propMetadata, isQueryAnn) {
  const queriesMeta = [];
  for (const field in propMetadata) {
    if (propMetadata.hasOwnProperty(field)) {
      const annotations = propMetadata[field];
      annotations.forEach((ann) => {
        if (isQueryAnn(ann)) {
          if (!ann.selector) {
            throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type2)}" since the query selector wasn't defined.`);
          }
          if (annotations.some(isInputAnnotation)) {
            throw new Error(`Cannot combine @Input decorators with query decorators`);
          }
          queriesMeta.push(convertToR3QueryMetadata(field, ann));
        }
      });
    }
  }
  return queriesMeta;
}
function extractExportAs(exportAs) {
  return exportAs === void 0 ? null : splitByComma(exportAs);
}
function isContentQuery(value2) {
  const name = value2.ngMetadataName;
  return name === "ContentChild" || name === "ContentChildren";
}
function isViewQuery(value2) {
  const name = value2.ngMetadataName;
  return name === "ViewChild" || name === "ViewChildren";
}
function isInputAnnotation(value2) {
  return value2.ngMetadataName === "Input";
}
function splitByComma(value2) {
  return value2.split(",").map((piece) => piece.trim());
}
var LIFECYCLE_HOOKS = ["ngOnChanges", "ngOnInit", "ngOnDestroy", "ngDoCheck", "ngAfterViewInit", "ngAfterViewChecked", "ngAfterContentInit", "ngAfterContentChecked"];
function shouldAddAbstractDirective(type2) {
  const reflect = getReflect();
  if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type2, hookName))) {
    return true;
  }
  const propMetadata = reflect.propMetadata(type2);
  for (const field in propMetadata) {
    const annotations = propMetadata[field];
    for (let i = 0; i < annotations.length; i++) {
      const current = annotations[i];
      const metadataName = current.ngMetadataName;
      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
        return true;
      }
    }
  }
  return false;
}
function compilePipe(type2, meta) {
  let ngPipeDef = null;
  let ngFactoryDef = null;
  Object.defineProperty(type2, NG_FACTORY_DEF, {
    get: () => {
      if (ngFactoryDef === null) {
        const metadata = getPipeMetadata(type2, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/\u0275fac.js`, {
          name: metadata.name,
          type: metadata.type,
          typeArgumentCount: 0,
          deps: reflectDependencies(type2),
          target: compiler.FactoryTarget.Pipe
        });
      }
      return ngFactoryDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
  Object.defineProperty(type2, NG_PIPE_DEF, {
    get: () => {
      if (ngPipeDef === null) {
        const metadata = getPipeMetadata(type2, meta);
        const compiler = getCompilerFacade({
          usage: 0,
          kind: "pipe",
          type: metadata.type
        });
        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/\u0275pipe.js`, metadata);
      }
      return ngPipeDef;
    },
    // Make the property configurable in dev mode to allow overriding in tests
    configurable: !!ngDevMode
  });
}
function getPipeMetadata(type2, meta) {
  return {
    type: type2,
    name: type2.name,
    pipeName: meta.name,
    pure: meta.pure !== void 0 ? meta.pure : true,
    isStandalone: meta.standalone === void 0 ? true : !!meta.standalone
  };
}
var Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type2, meta) => compileDirective(type2, meta));
var Component = makeDecorator("Component", (c = {}) => __spreadValues({
  changeDetection: ChangeDetectionStrategy.Default
}, c), Directive, void 0, (type2, meta) => compileComponent(type2, meta));
var Pipe = makeDecorator("Pipe", (p2) => __spreadValues({
  pure: true
}, p2), void 0, void 0, (type2, meta) => compilePipe(type2, meta));
var Input = makePropDecorator("Input", (arg) => {
  if (!arg) {
    return {};
  }
  return typeof arg === "string" ? {
    alias: arg
  } : arg;
});
var Output = makePropDecorator("Output", (alias) => ({
  alias
}));
var HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({
  hostPropertyName
}));
var HostListener = makePropDecorator("HostListener", (eventName, args) => ({
  eventName,
  args
}));
var NgModule = makeDecorator(
  "NgModule",
  (ngModule) => ngModule,
  void 0,
  void 0,
  /**
   * Decorator that marks the following class as an NgModule, and supplies
   * configuration metadata for it.
   *
   * * The `declarations` option configures the compiler
   * with information about what belongs to the NgModule.
   * * The `providers` options configures the NgModule's injector to provide
   * dependencies the NgModule members.
   * * The `imports` and `exports` options bring in members from other modules, and make
   * this module's members available to others.
   */
  (type2, meta) => compileNgModule(type2, meta)
);
var Version = class {
  full;
  major;
  minor;
  patch;
  constructor(full) {
    this.full = full;
    const parts = full.split(".");
    this.major = parts[0];
    this.minor = parts[1];
    this.patch = parts.slice(2).join(".");
  }
};
var VERSION = new Version("19.0.1");
var ModuleWithComponentFactories = class {
  ngModuleFactory;
  componentFactories;
  constructor(ngModuleFactory, componentFactories) {
    this.ngModuleFactory = ngModuleFactory;
    this.componentFactories = componentFactories;
  }
};
var Compiler = class _Compiler {
  /**
   * Compiles the given NgModule and all of its components. All templates of the components
   * have to be inlined.
   */
  compileModuleSync(moduleType) {
    return new NgModuleFactory(moduleType);
  }
  /**
   * Compiles the given NgModule and all of its components
   */
  compileModuleAsync(moduleType) {
    return Promise.resolve(this.compileModuleSync(moduleType));
  }
  /**
   * Same as {@link Compiler#compileModuleSync compileModuleSync} but also creates ComponentFactories for all components.
   */
  compileModuleAndAllComponentsSync(moduleType) {
    const ngModuleFactory = this.compileModuleSync(moduleType);
    const moduleDef = getNgModuleDef(moduleType);
    const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
      const componentDef = getComponentDef(declaration);
      componentDef && factories.push(new ComponentFactory(componentDef));
      return factories;
    }, []);
    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
  }
  /**
   * Same as {@link Compiler#compileModuleAsync compileModuleAsync} but also creates ComponentFactories for all components.
   */
  compileModuleAndAllComponentsAsync(moduleType) {
    return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
  }
  /**
   * Clears all caches.
   */
  clearCache() {
  }
  /**
   * Clears the cache for the given component/ngModule.
   */
  clearCacheFor(type2) {
  }
  /**
   * Returns the id for a given NgModule, if one is defined and known to the compiler.
   */
  getModuleId(moduleType) {
    return void 0;
  }
  static \u0275fac = function Compiler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Compiler)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Compiler,
    factory: _Compiler.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var COMPILER_OPTIONS = new InjectionToken(ngDevMode ? "compilerOptions" : "");
function compileNgModuleFactory(injector, options, moduleType) {
  ngDevMode && assertNgModuleType(moduleType);
  const moduleFactory = new NgModuleFactory(moduleType);
  if (true) {
    return Promise.resolve(moduleFactory);
  }
  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
  setJitOptions({
    defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
    preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
  });
  if (isComponentResourceResolutionQueueEmpty()) {
    return Promise.resolve(moduleFactory);
  }
  const compilerProviders = compilerOptions.flatMap((option) => option.providers ?? []);
  if (compilerProviders.length === 0) {
    return Promise.resolve(moduleFactory);
  }
  const compiler = getCompilerFacade({
    usage: 0,
    kind: "NgModule",
    type: moduleType
  });
  const compilerInjector = Injector.create({
    providers: compilerProviders
  });
  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
  return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
}
function _lastDefined(args) {
  for (let i = args.length - 1; i >= 0; i--) {
    if (args[i] !== void 0) {
      return args[i];
    }
  }
  return void 0;
}
var NgZoneChangeDetectionScheduler = class _NgZoneChangeDetectionScheduler {
  zone = inject(NgZone);
  changeDetectionScheduler = inject(ChangeDetectionScheduler);
  applicationRef = inject(ApplicationRef);
  _onMicrotaskEmptySubscription;
  initialize() {
    if (this._onMicrotaskEmptySubscription) {
      return;
    }
    this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({
      next: () => {
        if (this.changeDetectionScheduler.runningTick) {
          return;
        }
        this.zone.run(() => {
          this.applicationRef.tick();
        });
      }
    });
  }
  ngOnDestroy() {
    this._onMicrotaskEmptySubscription?.unsubscribe();
  }
  static \u0275fac = function NgZoneChangeDetectionScheduler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgZoneChangeDetectionScheduler)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NgZoneChangeDetectionScheduler,
    factory: _NgZoneChangeDetectionScheduler.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgZoneChangeDetectionScheduler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PROVIDED_NG_ZONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "provideZoneChangeDetection token" : "", {
  factory: () => false
});
function internalProvideZoneChangeDetection({
  ngZoneFactory,
  ignoreChangesOutsideZone,
  scheduleInRootZone
}) {
  ngZoneFactory ??= () => new NgZone(__spreadProps(__spreadValues({}, getNgZoneOptions()), {
    scheduleInRootZone
  }));
  return [
    {
      provide: NgZone,
      useFactory: ngZoneFactory
    },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const ngZoneChangeDetectionScheduler = inject(NgZoneChangeDetectionScheduler, {
          optional: true
        });
        if ((typeof ngDevMode === "undefined" || ngDevMode) && ngZoneChangeDetectionScheduler === null) {
          throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the \`BrowserModule\` is imported.`);
        }
        return () => ngZoneChangeDetectionScheduler.initialize();
      }
    },
    {
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const service = inject(ZoneStablePendingTask);
        return () => {
          service.initialize();
        };
      }
    },
    // Always disable scheduler whenever explicitly disabled, even if another place called
    // `provideZoneChangeDetection` without the 'ignore' option.
    ignoreChangesOutsideZone === true ? {
      provide: ZONELESS_SCHEDULER_DISABLED,
      useValue: true
    } : [],
    {
      provide: SCHEDULE_IN_ROOT_ZONE,
      useValue: scheduleInRootZone ?? SCHEDULE_IN_ROOT_ZONE_DEFAULT
    }
  ];
}
function getNgZoneOptions(options) {
  return {
    enableLongStackTrace: typeof ngDevMode === "undefined" ? false : !!ngDevMode,
    shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,
    shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false
  };
}
var ZoneStablePendingTask = class _ZoneStablePendingTask {
  subscription = new Subscription();
  initialized = false;
  zone = inject(NgZone);
  pendingTasks = inject(PendingTasksInternal);
  initialize() {
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    let task = null;
    if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
      task = this.pendingTasks.add();
    }
    this.zone.runOutsideAngular(() => {
      this.subscription.add(this.zone.onStable.subscribe(() => {
        NgZone.assertNotInAngularZone();
        queueMicrotask(() => {
          if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {
            this.pendingTasks.remove(task);
            task = null;
          }
        });
      }));
    });
    this.subscription.add(this.zone.onUnstable.subscribe(() => {
      NgZone.assertInAngularZone();
      task ??= this.pendingTasks.add();
    }));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  static \u0275fac = function ZoneStablePendingTask_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ZoneStablePendingTask)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ZoneStablePendingTask,
    factory: _ZoneStablePendingTask.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoneStablePendingTask, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;
var consecutiveMicrotaskNotifications = 0;
var stackFromLastFewNotifications = [];
function trackMicrotaskNotificationForDebugging() {
  consecutiveMicrotaskNotifications++;
  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {
    const stack = new Error().stack;
    if (stack) {
      stackFromLastFewNotifications.push(stack);
    }
  }
  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {
    throw new RuntimeError(103, "Angular could not stabilize because there were endless change notifications within the browser event loop. The stack from the last several notifications: \n" + stackFromLastFewNotifications.join("\n"));
  }
}
var ChangeDetectionSchedulerImpl = class _ChangeDetectionSchedulerImpl {
  appRef = inject(ApplicationRef);
  taskService = inject(PendingTasksInternal);
  ngZone = inject(NgZone);
  zonelessEnabled = inject(ZONELESS_ENABLED);
  tracing = inject(TracingService, {
    optional: true
  });
  disableScheduling = inject(ZONELESS_SCHEDULER_DISABLED, {
    optional: true
  }) ?? false;
  zoneIsDefined = typeof Zone !== "undefined" && !!Zone.root.run;
  schedulerTickApplyArgs = [{
    data: {
      "__scheduler_tick__": true
    }
  }];
  subscriptions = new Subscription();
  angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(angularZoneInstanceIdProperty) : null;
  scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && (inject(SCHEDULE_IN_ROOT_ZONE, {
    optional: true
  }) ?? false);
  cancelScheduledCallback = null;
  useMicrotaskScheduler = false;
  runningTick = false;
  pendingRenderTaskId = null;
  constructor() {
    this.subscriptions.add(this.appRef.afterTick.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {
      if (!this.runningTick) {
        this.cleanup();
      }
    }));
    this.disableScheduling ||= !this.zonelessEnabled && // NoopNgZone without enabling zoneless means no scheduling whatsoever
    (this.ngZone instanceof NoopNgZone || // The same goes for the lack of Zone without enabling zoneless scheduling
    !this.zoneIsDefined);
  }
  notify(source) {
    if (!this.zonelessEnabled && source === 5) {
      return;
    }
    let force = false;
    switch (source) {
      case 0: {
        this.appRef.dirtyFlags |= 2;
        break;
      }
      case 3:
      case 2:
      case 4:
      case 5:
      case 1: {
        this.appRef.dirtyFlags |= 4;
        break;
      }
      case 8: {
        this.appRef.deferredDirtyFlags |= 8;
        break;
      }
      case 6: {
        this.appRef.dirtyFlags |= 2;
        force = true;
        break;
      }
      case 13: {
        this.appRef.dirtyFlags |= 16;
        force = true;
        break;
      }
      case 14: {
        this.appRef.dirtyFlags |= 2;
        force = true;
        break;
      }
      case 12: {
        force = true;
        break;
      }
      case 10:
      case 9:
      case 7:
      case 11:
      default: {
        this.appRef.dirtyFlags |= 8;
      }
    }
    this.appRef.tracingSnapshot = this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null;
    if (!this.shouldScheduleTick(force)) {
      return;
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (this.useMicrotaskScheduler) {
        trackMicrotaskNotificationForDebugging();
      } else {
        consecutiveMicrotaskNotifications = 0;
        stackFromLastFewNotifications.length = 0;
      }
    }
    const scheduleCallback = this.useMicrotaskScheduler ? scheduleCallbackWithMicrotask : scheduleCallbackWithRafRace;
    this.pendingRenderTaskId = this.taskService.add();
    if (this.scheduleInRootZone) {
      this.cancelScheduledCallback = Zone.root.run(() => scheduleCallback(() => this.tick()));
    } else {
      this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => scheduleCallback(() => this.tick()));
    }
  }
  shouldScheduleTick(force) {
    if (this.disableScheduling && !force || this.appRef.destroyed) {
      return false;
    }
    if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {
      return false;
    }
    if (!this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(angularZoneInstanceIdProperty + this.angularZoneId)) {
      return false;
    }
    return true;
  }
  /**
   * Calls ApplicationRef._tick inside the `NgZone`.
   *
   * Calling `tick` directly runs change detection and cancels any change detection that had been
   * scheduled previously.
   *
   * @param shouldRefreshViews Passed directly to `ApplicationRef._tick` and skips straight to
   *     render hooks when `false`.
   */
  tick() {
    if (this.runningTick || this.appRef.destroyed) {
      return;
    }
    if (this.appRef.dirtyFlags === 0) {
      this.cleanup();
      return;
    }
    if (!this.zonelessEnabled && this.appRef.dirtyFlags & 7) {
      this.appRef.dirtyFlags |= 1;
    }
    const task = this.taskService.add();
    try {
      this.ngZone.run(() => {
        this.runningTick = true;
        this.appRef._tick();
      }, void 0, this.schedulerTickApplyArgs);
    } catch (e) {
      this.taskService.remove(task);
      throw e;
    } finally {
      this.cleanup();
    }
    this.useMicrotaskScheduler = true;
    scheduleCallbackWithMicrotask(() => {
      this.useMicrotaskScheduler = false;
      this.taskService.remove(task);
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.cleanup();
  }
  cleanup() {
    this.runningTick = false;
    this.cancelScheduledCallback?.();
    this.cancelScheduledCallback = null;
    if (this.pendingRenderTaskId !== null) {
      const taskId = this.pendingRenderTaskId;
      this.pendingRenderTaskId = null;
      this.taskService.remove(taskId);
    }
  }
  static \u0275fac = function ChangeDetectionSchedulerImpl_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChangeDetectionSchedulerImpl)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ChangeDetectionSchedulerImpl,
    factory: _ChangeDetectionSchedulerImpl.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function getGlobalLocale() {
  if (false) {
    return goog.LOCALE;
  } else {
    return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
  }
}
var LOCALE_ID = new InjectionToken(ngDevMode ? "LocaleId" : "", {
  providedIn: "root",
  factory: () => inject(LOCALE_ID, InjectFlags.Optional | InjectFlags.SkipSelf) || getGlobalLocale()
});
var DEFAULT_CURRENCY_CODE = new InjectionToken(ngDevMode ? "DefaultCurrencyCode" : "", {
  providedIn: "root",
  factory: () => USD_CURRENCY_CODE
});
var TRANSLATIONS = new InjectionToken(ngDevMode ? "Translations" : "");
var TRANSLATIONS_FORMAT = new InjectionToken(ngDevMode ? "TranslationsFormat" : "");
var MissingTranslationStrategy;
(function(MissingTranslationStrategy2) {
  MissingTranslationStrategy2[MissingTranslationStrategy2["Error"] = 0] = "Error";
  MissingTranslationStrategy2[MissingTranslationStrategy2["Warning"] = 1] = "Warning";
  MissingTranslationStrategy2[MissingTranslationStrategy2["Ignore"] = 2] = "Ignore";
})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
var SCAN_DELAY = 200;
var OVERSIZED_IMAGE_TOLERANCE = 1200;
var ImagePerformanceWarning = class _ImagePerformanceWarning {
  // Map of full image URLs -> original `ngSrc` values.
  window = null;
  observer = null;
  options = inject(IMAGE_CONFIG);
  isBrowser = inject(PLATFORM_ID) === "browser";
  lcpImageUrl;
  start() {
    if (!this.isBrowser || typeof PerformanceObserver === "undefined" || this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning) {
      return;
    }
    this.observer = this.initPerformanceObserver();
    const doc = getDocument();
    const win = doc.defaultView;
    if (typeof win !== "undefined") {
      this.window = win;
      const waitToScan = () => {
        setTimeout(this.scanImages.bind(this), SCAN_DELAY);
      };
      const setup = () => {
        if (doc.readyState === "complete") {
          waitToScan();
        } else {
          this.window?.addEventListener("load", waitToScan, {
            once: true
          });
        }
      };
      if (typeof Zone !== "undefined") {
        Zone.root.run(() => setup());
      } else {
        setup();
      }
    }
  }
  ngOnDestroy() {
    this.observer?.disconnect();
  }
  initPerformanceObserver() {
    if (typeof PerformanceObserver === "undefined") {
      return null;
    }
    const observer = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      if (entries.length === 0) return;
      const lcpElement = entries[entries.length - 1];
      const imgSrc = lcpElement.element?.src ?? "";
      if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:")) return;
      this.lcpImageUrl = imgSrc;
    });
    observer.observe({
      type: "largest-contentful-paint",
      buffered: true
    });
    return observer;
  }
  scanImages() {
    const images = getDocument().querySelectorAll("img");
    let lcpElementFound, lcpElementLoadedCorrectly = false;
    images.forEach((image) => {
      if (!this.options?.disableImageSizeWarning) {
        if (!image.getAttribute("ng-img") && this.isOversized(image)) {
          logOversizedImageWarning(image.src);
        }
      }
      if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {
        if (image.src === this.lcpImageUrl) {
          lcpElementFound = true;
          if (image.loading !== "lazy" || image.getAttribute("ng-img")) {
            lcpElementLoadedCorrectly = true;
          }
        }
      }
    });
    if (lcpElementFound && !lcpElementLoadedCorrectly && this.lcpImageUrl && !this.options?.disableImageLazyLoadWarning) {
      logLazyLCPWarning(this.lcpImageUrl);
    }
  }
  isOversized(image) {
    if (!this.window) {
      return false;
    }
    const nonOversizedImageExtentions = [
      // SVG images are vector-based, which means they can scale
      // to any size without losing quality.
      ".svg"
    ];
    const imageSource = (image.src || "").toLowerCase();
    if (nonOversizedImageExtentions.some((extension) => imageSource.endsWith(extension))) {
      return false;
    }
    const computedStyle = this.window.getComputedStyle(image);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
    const boxSizing = computedStyle.getPropertyValue("box-sizing");
    const objectFit = computedStyle.getPropertyValue("object-fit");
    if (objectFit === `cover`) {
      return false;
    }
    if (boxSizing === "border-box") {
      const paddingTop = computedStyle.getPropertyValue("padding-top");
      const paddingRight = computedStyle.getPropertyValue("padding-right");
      const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
      const paddingLeft = computedStyle.getPropertyValue("padding-left");
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const intrinsicWidth = image.naturalWidth;
    const intrinsicHeight = image.naturalHeight;
    const recommendedWidth = this.window.devicePixelRatio * renderedWidth;
    const recommendedHeight = this.window.devicePixelRatio * renderedHeight;
    const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;
    const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;
    return oversizedWidth || oversizedHeight;
  }
  static \u0275fac = function ImagePerformanceWarning_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ImagePerformanceWarning)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ImagePerformanceWarning,
    factory: _ImagePerformanceWarning.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ImagePerformanceWarning, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function logLazyLCPWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} is the Largest Contentful Paint (LCP) element but was given a "loading" value of "lazy", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to "eager", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
function logOversizedImageWarning(src) {
  console.warn(formatRuntimeError(-913, `An image with src ${src} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));
}
var PLATFORM_DESTROY_LISTENERS = new InjectionToken(ngDevMode ? "PlatformDestroyListeners" : "");
function isApplicationBootstrapConfig(config3) {
  return !config3.moduleRef;
}
function bootstrap2(config3) {
  const envInjector = isApplicationBootstrapConfig(config3) ? config3.r3Injector : config3.moduleRef.injector;
  const ngZone = envInjector.get(NgZone);
  return ngZone.run(() => {
    if (isApplicationBootstrapConfig(config3)) {
      config3.r3Injector.resolveInjectorInitializers();
    } else {
      config3.moduleRef.resolveInjectorInitializers();
    }
    const exceptionHandler = envInjector.get(ErrorHandler, null);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (exceptionHandler === null) {
        const errorMessage = isApplicationBootstrapConfig(config3) ? "No `ErrorHandler` found in the Dependency Injection tree." : "No ErrorHandler. Is platform module (BrowserModule) included";
        throw new RuntimeError(402, errorMessage);
      }
      if (envInjector.get(PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {
        throw new RuntimeError(408, "Invalid change detection configuration: provideZoneChangeDetection and provideExperimentalZonelessChangeDetection cannot be used together.");
      }
    }
    let onErrorSubscription;
    ngZone.runOutsideAngular(() => {
      onErrorSubscription = ngZone.onError.subscribe({
        next: (error) => {
          exceptionHandler.handleError(error);
        }
      });
    });
    if (isApplicationBootstrapConfig(config3)) {
      const destroyListener = () => envInjector.destroy();
      const onPlatformDestroyListeners = config3.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      envInjector.onDestroy(() => {
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    } else {
      const destroyListener = () => config3.moduleRef.destroy();
      const onPlatformDestroyListeners = config3.platformInjector.get(PLATFORM_DESTROY_LISTENERS);
      onPlatformDestroyListeners.add(destroyListener);
      config3.moduleRef.onDestroy(() => {
        remove(config3.allPlatformModules, config3.moduleRef);
        onErrorSubscription.unsubscribe();
        onPlatformDestroyListeners.delete(destroyListener);
      });
    }
    return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
      const initStatus = envInjector.get(ApplicationInitStatus);
      initStatus.runInitializers();
      return initStatus.donePromise.then(() => {
        const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
        setLocaleId(localeId || DEFAULT_LOCALE_ID);
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const imagePerformanceService = envInjector.get(ImagePerformanceWarning);
          imagePerformanceService.start();
        }
        if (isApplicationBootstrapConfig(config3)) {
          const appRef = envInjector.get(ApplicationRef);
          if (config3.rootComponent !== void 0) {
            appRef.bootstrap(config3.rootComponent);
          }
          return appRef;
        } else {
          moduleDoBootstrap(config3.moduleRef, config3.allPlatformModules);
          return config3.moduleRef;
        }
      });
    });
  });
}
function moduleDoBootstrap(moduleRef, allPlatformModules) {
  const appRef = moduleRef.injector.get(ApplicationRef);
  if (moduleRef._bootstrapComponents.length > 0) {
    moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));
  } else if (moduleRef.instance.ngDoBootstrap) {
    moduleRef.instance.ngDoBootstrap(appRef);
  } else {
    throw new RuntimeError(-403, ngDevMode && `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
  }
  allPlatformModules.push(moduleRef);
}
var PlatformRef = class _PlatformRef {
  _injector;
  _modules = [];
  _destroyListeners = [];
  _destroyed = false;
  /** @internal */
  constructor(_injector) {
    this._injector = _injector;
  }
  /**
   * Creates an instance of an `@NgModule` for the given platform.
   *
   * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function
   *     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.
   */
  bootstrapModuleFactory(moduleFactory, options) {
    const scheduleInRootZone = options?.scheduleInRootZone;
    const ngZoneFactory = () => getNgZone(options?.ngZone, __spreadProps(__spreadValues({}, getNgZoneOptions({
      eventCoalescing: options?.ngZoneEventCoalescing,
      runCoalescing: options?.ngZoneRunCoalescing
    })), {
      scheduleInRootZone
    }));
    const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;
    const allAppProviders = [internalProvideZoneChangeDetection({
      ngZoneFactory,
      ignoreChangesOutsideZone
    }), {
      provide: ChangeDetectionScheduler,
      useExisting: ChangeDetectionSchedulerImpl
    }];
    const moduleRef = createNgModuleRefWithProviders(moduleFactory.moduleType, this.injector, allAppProviders);
    return bootstrap2({
      moduleRef,
      allPlatformModules: this._modules,
      platformInjector: this.injector
    });
  }
  /**
   * Creates an instance of an `@NgModule` for a given platform.
   *
   * @usageNotes
   * ### Simple Example
   *
   * ```typescript
   * @NgModule({
   *   imports: [BrowserModule]
   * })
   * class MyModule {}
   *
   * let moduleRef = platformBrowser().bootstrapModule(MyModule);
   * ```
   *
   */
  bootstrapModule(moduleType, compilerOptions = []) {
    const options = optionsReducer({}, compilerOptions);
    return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
  }
  /**
   * Registers a listener to be called when the platform is destroyed.
   */
  onDestroy(callback) {
    this._destroyListeners.push(callback);
  }
  /**
   * Retrieves the platform {@link Injector}, which is the parent injector for
   * every Angular application on the page and provides singleton providers.
   */
  get injector() {
    return this._injector;
  }
  /**
   * Destroys the current Angular platform and all Angular applications on the page.
   * Destroys all modules and listeners registered with the platform.
   */
  destroy() {
    if (this._destroyed) {
      throw new RuntimeError(404, ngDevMode && "The platform has already been destroyed!");
    }
    this._modules.slice().forEach((module) => module.destroy());
    this._destroyListeners.forEach((listener2) => listener2());
    const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);
    if (destroyListeners) {
      destroyListeners.forEach((listener2) => listener2());
      destroyListeners.clear();
    }
    this._destroyed = true;
  }
  /**
   * Indicates whether this instance was destroyed.
   */
  get destroyed() {
    return this._destroyed;
  }
  static \u0275fac = function PlatformRef_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PlatformRef)(\u0275\u0275inject(Injector));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _PlatformRef,
    factory: _PlatformRef.\u0275fac,
    providedIn: "platform"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformRef, [{
    type: Injectable,
    args: [{
      providedIn: "platform"
    }]
  }], () => [{
    type: Injector
  }], null);
})();
var _platformInjector = null;
var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken(ngDevMode ? "AllowMultipleToken" : "");
function createPlatform(injector) {
  if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
    throw new RuntimeError(400, ngDevMode && "There can be only one platform. Destroy the previous one to create a new one.");
  }
  publishDefaultGlobalUtils();
  publishSignalConfiguration();
  _platformInjector = injector;
  const platform2 = injector.get(PlatformRef);
  runPlatformInitializers(injector);
  return platform2;
}
function createPlatformFactory(parentPlatformFactory, name, providers2 = []) {
  const desc = `Platform: ${name}`;
  const marker = new InjectionToken(desc);
  return (extraProviders = []) => {
    let platform2 = getPlatform();
    if (!platform2 || platform2.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      const platformProviders = [...providers2, ...extraProviders, {
        provide: marker,
        useValue: true
      }];
      if (parentPlatformFactory) {
        parentPlatformFactory(platformProviders);
      } else {
        createPlatform(createPlatformInjector(platformProviders, desc));
      }
    }
    return assertPlatform(marker);
  };
}
function createPlatformInjector(providers2 = [], name) {
  return Injector.create({
    name,
    providers: [{
      provide: INJECTOR_SCOPE,
      useValue: "platform"
    }, {
      provide: PLATFORM_DESTROY_LISTENERS,
      useValue: /* @__PURE__ */ new Set([() => _platformInjector = null])
    }, ...providers2]
  });
}
function assertPlatform(requiredToken) {
  const platform2 = getPlatform();
  if (!platform2) {
    throw new RuntimeError(401, ngDevMode && "No platform exists!");
  }
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !platform2.injector.get(requiredToken, null)) {
    throw new RuntimeError(400, "A platform with a different configuration has been created. Please destroy it first.");
  }
  return platform2;
}
function getPlatform() {
  return _platformInjector?.get(PlatformRef) ?? null;
}
function runPlatformInitializers(injector) {
  const inits = injector.get(PLATFORM_INITIALIZER, null);
  runInInjectionContext(injector, () => {
    inits?.forEach((init2) => init2());
  });
}
function enableProdMode() {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _global["ngDevMode"] = false;
  }
}
var ChangeDetectorRef = class {
  /**
   * @internal
   * @nocollapse
   */
  static __NG_ELEMENT_ID__ = injectChangeDetectorRef;
};
function injectChangeDetectorRef(flags) {
  return createViewRef(
    getCurrentTNode(),
    getLView(),
    (flags & 16) === 16
    /* InternalInjectFlags.ForPipe */
  );
}
function createViewRef(tNode, lView, isPipe2) {
  if (isComponentHost(tNode) && !isPipe2) {
    const componentView = getComponentLViewByIndex(tNode.index, lView);
    return new ViewRef$1(componentView, componentView);
  } else if (tNode.type & (3 | 12 | 32 | 128)) {
    const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
    return new ViewRef$1(hostComponentView, lView);
  }
  return null;
}
var DefaultIterableDifferFactory = class {
  constructor() {
  }
  supports(obj) {
    return isListLikeIterable(obj);
  }
  create(trackByFn) {
    return new DefaultIterableDiffer(trackByFn);
  }
};
var trackByIdentity = (index, item) => item;
var DefaultIterableDiffer = class {
  length = 0;
  // TODO: confirm the usage of `collection` as it's unused, readonly and on a non public API.
  collection;
  // Keeps track of the used records at any point in time (during & across `_check()` calls)
  _linkedRecords = null;
  // Keeps track of the removed records at any point in time during `_check()` calls.
  _unlinkedRecords = null;
  _previousItHead = null;
  _itHead = null;
  _itTail = null;
  _additionsHead = null;
  _additionsTail = null;
  _movesHead = null;
  _movesTail = null;
  _removalsHead = null;
  _removalsTail = null;
  // Keeps track of records where custom track by is the same, but item identity has changed
  _identityChangesHead = null;
  _identityChangesTail = null;
  _trackByFn;
  constructor(trackByFn) {
    this._trackByFn = trackByFn || trackByIdentity;
  }
  forEachItem(fn) {
    let record;
    for (record = this._itHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachOperation(fn) {
    let nextIt = this._itHead;
    let nextRemove = this._removalsHead;
    let addRemoveOffset = 0;
    let moveOffsets = null;
    while (nextIt || nextRemove) {
      const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
      const currentIndex = record.currentIndex;
      if (record === nextRemove) {
        addRemoveOffset--;
        nextRemove = nextRemove._nextRemoved;
      } else {
        nextIt = nextIt._next;
        if (record.previousIndex == null) {
          addRemoveOffset++;
        } else {
          if (!moveOffsets) moveOffsets = [];
          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
          const localCurrentIndex = currentIndex - addRemoveOffset;
          if (localMovePreviousIndex != localCurrentIndex) {
            for (let i = 0; i < localMovePreviousIndex; i++) {
              const offset2 = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
              const index = offset2 + i;
              if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                moveOffsets[i] = offset2 + 1;
              }
            }
            const previousIndex = record.previousIndex;
            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
          }
        }
      }
      if (adjPreviousIndex !== currentIndex) {
        fn(record, adjPreviousIndex, currentIndex);
      }
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachMovedItem(fn) {
    let record;
    for (record = this._movesHead; record !== null; record = record._nextMoved) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  forEachIdentityChange(fn) {
    let record;
    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
      fn(record);
    }
  }
  diff(collection) {
    if (collection == null) collection = [];
    if (!isListLikeIterable(collection)) {
      throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
    }
    if (this.check(collection)) {
      return this;
    } else {
      return null;
    }
  }
  onDestroy() {
  }
  check(collection) {
    this._reset();
    let record = this._itHead;
    let mayBeDirty = false;
    let index;
    let item;
    let itemTrackBy;
    if (Array.isArray(collection)) {
      this.length = collection.length;
      for (let index2 = 0; index2 < this.length; index2++) {
        item = collection[index2];
        itemTrackBy = this._trackByFn(index2, item);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item, itemTrackBy, index2);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item, itemTrackBy, index2);
          }
          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        }
        record = record._next;
      }
    } else {
      index = 0;
      iterateListLike(collection, (item2) => {
        itemTrackBy = this._trackByFn(index, item2);
        if (record === null || !Object.is(record.trackById, itemTrackBy)) {
          record = this._mismatch(record, item2, itemTrackBy, index);
          mayBeDirty = true;
        } else {
          if (mayBeDirty) {
            record = this._verifyReinsertion(record, item2, itemTrackBy, index);
          }
          if (!Object.is(record.item, item2)) this._addIdentityChange(record, item2);
        }
        record = record._next;
        index++;
      });
      this.length = index;
    }
    this._truncate(record);
    this.collection = collection;
    return this.isDirty;
  }
  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
   * changes.
   */
  get isDirty() {
    return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
  }
  /**
   * Reset the state of the change objects to show no changes. This means set previousKey to
   * currentKey, and clear all of the queues (additions, moves, removals).
   * Set the previousIndexes of moved and added items to their currentIndexes
   * Reset the list of additions, moves and removals
   *
   * @internal
   */
  _reset() {
    if (this.isDirty) {
      let record;
      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        record.previousIndex = record.currentIndex;
      }
      this._additionsHead = this._additionsTail = null;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        record.previousIndex = record.currentIndex;
      }
      this._movesHead = this._movesTail = null;
      this._removalsHead = this._removalsTail = null;
      this._identityChangesHead = this._identityChangesTail = null;
    }
  }
  /**
   * This is the core function which handles differences between collections.
   *
   * - `record` is the record which we saw at this position last time. If null then it is a new
   *   item.
   * - `item` is the current item in the collection
   * - `index` is the position of the item in the collection
   *
   * @internal
   */
  _mismatch(record, item, itemTrackBy, index) {
    let previousRecord;
    if (record === null) {
      previousRecord = this._itTail;
    } else {
      previousRecord = record._prev;
      this._remove(record);
    }
    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (record !== null) {
      if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
      this._reinsertAfter(record, previousRecord, index);
    } else {
      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
      if (record !== null) {
        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);
        this._moveAfter(record, previousRecord, index);
      } else {
        record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
      }
    }
    return record;
  }
  /**
   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
   *
   * Use case: `[a, a]` => `[b, a, a]`
   *
   * If we did not have this check then the insertion of `b` would:
   *   1) evict first `a`
   *   2) insert `b` at `0` index.
   *   3) leave `a` at index `1` as is. <-- this is wrong!
   *   3) reinsert `a` at index 2. <-- this is wrong!
   *
   * The correct behavior is:
   *   1) evict first `a`
   *   2) insert `b` at `0` index.
   *   3) reinsert `a` at index 1.
   *   3) move `a` at from `1` to `2`.
   *
   *
   * Double check that we have not evicted a duplicate item. We need to check if the item type may
   * have already been removed:
   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
   * at the end.
   *
   * @internal
   */
  _verifyReinsertion(record, item, itemTrackBy, index) {
    let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
    if (reinsertRecord !== null) {
      record = this._reinsertAfter(reinsertRecord, record._prev, index);
    } else if (record.currentIndex != index) {
      record.currentIndex = index;
      this._addToMoves(record, index);
    }
    return record;
  }
  /**
   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection
   *
   * - `record` The first excess {@link IterableChangeRecord_}.
   *
   * @internal
   */
  _truncate(record) {
    while (record !== null) {
      const nextRecord = record._next;
      this._addToRemovals(this._unlink(record));
      record = nextRecord;
    }
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.clear();
    }
    if (this._additionsTail !== null) {
      this._additionsTail._nextAdded = null;
    }
    if (this._movesTail !== null) {
      this._movesTail._nextMoved = null;
    }
    if (this._itTail !== null) {
      this._itTail._next = null;
    }
    if (this._removalsTail !== null) {
      this._removalsTail._nextRemoved = null;
    }
    if (this._identityChangesTail !== null) {
      this._identityChangesTail._nextIdentityChange = null;
    }
  }
  /** @internal */
  _reinsertAfter(record, prevRecord, index) {
    if (this._unlinkedRecords !== null) {
      this._unlinkedRecords.remove(record);
    }
    const prev = record._prevRemoved;
    const next = record._nextRemoved;
    if (prev === null) {
      this._removalsHead = next;
    } else {
      prev._nextRemoved = next;
    }
    if (next === null) {
      this._removalsTail = prev;
    } else {
      next._prevRemoved = prev;
    }
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  /** @internal */
  _moveAfter(record, prevRecord, index) {
    this._unlink(record);
    this._insertAfter(record, prevRecord, index);
    this._addToMoves(record, index);
    return record;
  }
  /** @internal */
  _addAfter(record, prevRecord, index) {
    this._insertAfter(record, prevRecord, index);
    if (this._additionsTail === null) {
      this._additionsTail = this._additionsHead = record;
    } else {
      this._additionsTail = this._additionsTail._nextAdded = record;
    }
    return record;
  }
  /** @internal */
  _insertAfter(record, prevRecord, index) {
    const next = prevRecord === null ? this._itHead : prevRecord._next;
    record._next = next;
    record._prev = prevRecord;
    if (next === null) {
      this._itTail = record;
    } else {
      next._prev = record;
    }
    if (prevRecord === null) {
      this._itHead = record;
    } else {
      prevRecord._next = record;
    }
    if (this._linkedRecords === null) {
      this._linkedRecords = new _DuplicateMap();
    }
    this._linkedRecords.put(record);
    record.currentIndex = index;
    return record;
  }
  /** @internal */
  _remove(record) {
    return this._addToRemovals(this._unlink(record));
  }
  /** @internal */
  _unlink(record) {
    if (this._linkedRecords !== null) {
      this._linkedRecords.remove(record);
    }
    const prev = record._prev;
    const next = record._next;
    if (prev === null) {
      this._itHead = next;
    } else {
      prev._next = next;
    }
    if (next === null) {
      this._itTail = prev;
    } else {
      next._prev = prev;
    }
    return record;
  }
  /** @internal */
  _addToMoves(record, toIndex) {
    if (record.previousIndex === toIndex) {
      return record;
    }
    if (this._movesTail === null) {
      this._movesTail = this._movesHead = record;
    } else {
      this._movesTail = this._movesTail._nextMoved = record;
    }
    return record;
  }
  _addToRemovals(record) {
    if (this._unlinkedRecords === null) {
      this._unlinkedRecords = new _DuplicateMap();
    }
    this._unlinkedRecords.put(record);
    record.currentIndex = null;
    record._nextRemoved = null;
    if (this._removalsTail === null) {
      this._removalsTail = this._removalsHead = record;
      record._prevRemoved = null;
    } else {
      record._prevRemoved = this._removalsTail;
      this._removalsTail = this._removalsTail._nextRemoved = record;
    }
    return record;
  }
  /** @internal */
  _addIdentityChange(record, item) {
    record.item = item;
    if (this._identityChangesTail === null) {
      this._identityChangesTail = this._identityChangesHead = record;
    } else {
      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
    }
    return record;
  }
};
var IterableChangeRecord_ = class {
  item;
  trackById;
  currentIndex = null;
  previousIndex = null;
  /** @internal */
  _nextPrevious = null;
  /** @internal */
  _prev = null;
  /** @internal */
  _next = null;
  /** @internal */
  _prevDup = null;
  /** @internal */
  _nextDup = null;
  /** @internal */
  _prevRemoved = null;
  /** @internal */
  _nextRemoved = null;
  /** @internal */
  _nextAdded = null;
  /** @internal */
  _nextMoved = null;
  /** @internal */
  _nextIdentityChange = null;
  constructor(item, trackById) {
    this.item = item;
    this.trackById = trackById;
  }
};
var _DuplicateItemRecordList = class {
  /** @internal */
  _head = null;
  /** @internal */
  _tail = null;
  /**
   * Append the record to the list of duplicates.
   *
   * Note: by design all records in the list of duplicates hold the same value in record.item.
   */
  add(record) {
    if (this._head === null) {
      this._head = this._tail = record;
      record._nextDup = null;
      record._prevDup = null;
    } else {
      this._tail._nextDup = record;
      record._prevDup = this._tail;
      record._nextDup = null;
      this._tail = record;
    }
  }
  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
  // IterableChangeRecord_.currentIndex >= atOrAfterIndex
  get(trackById, atOrAfterIndex) {
    let record;
    for (record = this._head; record !== null; record = record._nextDup) {
      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
        return record;
      }
    }
    return null;
  }
  /**
   * Remove one {@link IterableChangeRecord_} from the list of duplicates.
   *
   * Returns whether the list of duplicates is empty.
   */
  remove(record) {
    const prev = record._prevDup;
    const next = record._nextDup;
    if (prev === null) {
      this._head = next;
    } else {
      prev._nextDup = next;
    }
    if (next === null) {
      this._tail = prev;
    } else {
      next._prevDup = prev;
    }
    return this._head === null;
  }
};
var _DuplicateMap = class {
  map = /* @__PURE__ */ new Map();
  put(record) {
    const key = record.trackById;
    let duplicates = this.map.get(key);
    if (!duplicates) {
      duplicates = new _DuplicateItemRecordList();
      this.map.set(key, duplicates);
    }
    duplicates.add(record);
  }
  /**
   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
   *
   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
   * have any more `a`s needs to return the second `a`.
   */
  get(trackById, atOrAfterIndex) {
    const key = trackById;
    const recordList = this.map.get(key);
    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
  }
  /**
   * Removes a {@link IterableChangeRecord_} from the list of duplicates.
   *
   * The list of duplicates also is removed from the map if it gets empty.
   */
  remove(record) {
    const key = record.trackById;
    const recordList = this.map.get(key);
    if (recordList.remove(record)) {
      this.map.delete(key);
    }
    return record;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
  clear() {
    this.map.clear();
  }
};
function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
  const previousIndex = item.previousIndex;
  if (previousIndex === null) return previousIndex;
  let moveOffset = 0;
  if (moveOffsets && previousIndex < moveOffsets.length) {
    moveOffset = moveOffsets[previousIndex];
  }
  return previousIndex + addRemoveOffset + moveOffset;
}
var DefaultKeyValueDifferFactory = class {
  constructor() {
  }
  supports(obj) {
    return obj instanceof Map || isJsObject(obj);
  }
  create() {
    return new DefaultKeyValueDiffer();
  }
};
var DefaultKeyValueDiffer = class {
  _records = /* @__PURE__ */ new Map();
  _mapHead = null;
  // _appendAfter is used in the check loop
  _appendAfter = null;
  _previousMapHead = null;
  _changesHead = null;
  _changesTail = null;
  _additionsHead = null;
  _additionsTail = null;
  _removalsHead = null;
  _removalsTail = null;
  get isDirty() {
    return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
  }
  forEachItem(fn) {
    let record;
    for (record = this._mapHead; record !== null; record = record._next) {
      fn(record);
    }
  }
  forEachPreviousItem(fn) {
    let record;
    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
      fn(record);
    }
  }
  forEachChangedItem(fn) {
    let record;
    for (record = this._changesHead; record !== null; record = record._nextChanged) {
      fn(record);
    }
  }
  forEachAddedItem(fn) {
    let record;
    for (record = this._additionsHead; record !== null; record = record._nextAdded) {
      fn(record);
    }
  }
  forEachRemovedItem(fn) {
    let record;
    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
      fn(record);
    }
  }
  diff(map3) {
    if (!map3) {
      map3 = /* @__PURE__ */ new Map();
    } else if (!(map3 instanceof Map || isJsObject(map3))) {
      throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(map3)}'. Only maps and objects are allowed`);
    }
    return this.check(map3) ? this : null;
  }
  onDestroy() {
  }
  /**
   * Check the current state of the map vs the previous.
   * The algorithm is optimised for when the keys do no change.
   */
  check(map3) {
    this._reset();
    let insertBefore = this._mapHead;
    this._appendAfter = null;
    this._forEach(map3, (value2, key) => {
      if (insertBefore && insertBefore.key === key) {
        this._maybeAddToChanges(insertBefore, value2);
        this._appendAfter = insertBefore;
        insertBefore = insertBefore._next;
      } else {
        const record = this._getOrCreateRecordForKey(key, value2);
        insertBefore = this._insertBeforeOrAppend(insertBefore, record);
      }
    });
    if (insertBefore) {
      if (insertBefore._prev) {
        insertBefore._prev._next = null;
      }
      this._removalsHead = insertBefore;
      for (let record = insertBefore; record !== null; record = record._nextRemoved) {
        if (record === this._mapHead) {
          this._mapHead = null;
        }
        this._records.delete(record.key);
        record._nextRemoved = record._next;
        record.previousValue = record.currentValue;
        record.currentValue = null;
        record._prev = null;
        record._next = null;
      }
    }
    if (this._changesTail) this._changesTail._nextChanged = null;
    if (this._additionsTail) this._additionsTail._nextAdded = null;
    return this.isDirty;
  }
  /**
   * Inserts a record before `before` or append at the end of the list when `before` is null.
   *
   * Notes:
   * - This method appends at `this._appendAfter`,
   * - This method updates `this._appendAfter`,
   * - The return value is the new value for the insertion pointer.
   */
  _insertBeforeOrAppend(before, record) {
    if (before) {
      const prev = before._prev;
      record._next = before;
      record._prev = prev;
      before._prev = record;
      if (prev) {
        prev._next = record;
      }
      if (before === this._mapHead) {
        this._mapHead = record;
      }
      this._appendAfter = before;
      return before;
    }
    if (this._appendAfter) {
      this._appendAfter._next = record;
      record._prev = this._appendAfter;
    } else {
      this._mapHead = record;
    }
    this._appendAfter = record;
    return null;
  }
  _getOrCreateRecordForKey(key, value2) {
    if (this._records.has(key)) {
      const record2 = this._records.get(key);
      this._maybeAddToChanges(record2, value2);
      const prev = record2._prev;
      const next = record2._next;
      if (prev) {
        prev._next = next;
      }
      if (next) {
        next._prev = prev;
      }
      record2._next = null;
      record2._prev = null;
      return record2;
    }
    const record = new KeyValueChangeRecord_(key);
    this._records.set(key, record);
    record.currentValue = value2;
    this._addToAdditions(record);
    return record;
  }
  /** @internal */
  _reset() {
    if (this.isDirty) {
      let record;
      this._previousMapHead = this._mapHead;
      for (record = this._previousMapHead; record !== null; record = record._next) {
        record._nextPrevious = record._next;
      }
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        record.previousValue = record.currentValue;
      }
      for (record = this._additionsHead; record != null; record = record._nextAdded) {
        record.previousValue = record.currentValue;
      }
      this._changesHead = this._changesTail = null;
      this._additionsHead = this._additionsTail = null;
      this._removalsHead = null;
    }
  }
  // Add the record or a given key to the list of changes only when the value has actually changed
  _maybeAddToChanges(record, newValue) {
    if (!Object.is(newValue, record.currentValue)) {
      record.previousValue = record.currentValue;
      record.currentValue = newValue;
      this._addToChanges(record);
    }
  }
  _addToAdditions(record) {
    if (this._additionsHead === null) {
      this._additionsHead = this._additionsTail = record;
    } else {
      this._additionsTail._nextAdded = record;
      this._additionsTail = record;
    }
  }
  _addToChanges(record) {
    if (this._changesHead === null) {
      this._changesHead = this._changesTail = record;
    } else {
      this._changesTail._nextChanged = record;
      this._changesTail = record;
    }
  }
  /** @internal */
  _forEach(obj, fn) {
    if (obj instanceof Map) {
      obj.forEach(fn);
    } else {
      Object.keys(obj).forEach((k) => fn(obj[k], k));
    }
  }
};
var KeyValueChangeRecord_ = class {
  key;
  previousValue = null;
  currentValue = null;
  /** @internal */
  _nextPrevious = null;
  /** @internal */
  _next = null;
  /** @internal */
  _prev = null;
  /** @internal */
  _nextAdded = null;
  /** @internal */
  _nextRemoved = null;
  /** @internal */
  _nextChanged = null;
  constructor(key) {
    this.key = key;
  }
};
function defaultIterableDiffersFactory() {
  return new IterableDiffers([new DefaultIterableDifferFactory()]);
}
var IterableDiffers = class _IterableDiffers {
  factories;
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _IterableDiffers,
      providedIn: "root",
      factory: defaultIterableDiffersFactory
    })
  );
  constructor(factories) {
    this.factories = factories;
  }
  static create(factories, parent) {
    if (parent != null) {
      const copied = parent.factories.slice();
      factories = factories.concat(copied);
    }
    return new _IterableDiffers(factories);
  }
  /**
   * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
   * inherited {@link IterableDiffers} instance with the provided factories and return a new
   * {@link IterableDiffers} instance.
   *
   * @usageNotes
   * ### Example
   *
   * The following example shows how to extend an existing list of factories,
   * which will only be applied to the injector for this component and its children.
   * This step is all that's required to make a new {@link IterableDiffer} available.
   *
   * ```
   * @Component({
   *   viewProviders: [
   *     IterableDiffers.extend([new ImmutableListDiffer()])
   *   ]
   * })
   * ```
   */
  static extend(factories) {
    return {
      provide: _IterableDiffers,
      useFactory: (parent) => {
        return _IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
      },
      // Dependency technically isn't optional, but we can provide a better error message this way.
      deps: [[_IterableDiffers, new SkipSelf(), new Optional()]]
    };
  }
  find(iterable) {
    const factory = this.factories.find((f) => f.supports(iterable));
    if (factory != null) {
      return factory;
    } else {
      throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
    }
  }
};
function getTypeNameForDebugging(type2) {
  return type2["name"] || typeof type2;
}
function defaultKeyValueDiffersFactory() {
  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
}
var KeyValueDiffers = class _KeyValueDiffers {
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _KeyValueDiffers,
      providedIn: "root",
      factory: defaultKeyValueDiffersFactory
    })
  );
  factories;
  constructor(factories) {
    this.factories = factories;
  }
  static create(factories, parent) {
    if (parent) {
      const copied = parent.factories.slice();
      factories = factories.concat(copied);
    }
    return new _KeyValueDiffers(factories);
  }
  /**
   * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
   * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
   * {@link KeyValueDiffers} instance.
   *
   * @usageNotes
   * ### Example
   *
   * The following example shows how to extend an existing list of factories,
   * which will only be applied to the injector for this component and its children.
   * This step is all that's required to make a new {@link KeyValueDiffer} available.
   *
   * ```
   * @Component({
   *   viewProviders: [
   *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
   *   ]
   * })
   * ```
   */
  static extend(factories) {
    return {
      provide: _KeyValueDiffers,
      useFactory: (parent) => {
        return _KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
      },
      // Dependency technically isn't optional, but we can provide a better error message this way.
      deps: [[_KeyValueDiffers, new SkipSelf(), new Optional()]]
    };
  }
  find(kv) {
    const factory = this.factories.find((f) => f.supports(kv));
    if (factory) {
      return factory;
    }
    throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);
  }
};
var keyValDiff = [new DefaultKeyValueDifferFactory()];
var iterableDiff = [new DefaultIterableDifferFactory()];
var defaultIterableDiffers = new IterableDiffers(iterableDiff);
var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
var platformCore = createPlatformFactory(null, "core", []);
var ApplicationModule = class _ApplicationModule {
  // Inject ApplicationRef to make it eager...
  constructor(appRef) {
  }
  static \u0275fac = function ApplicationModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ApplicationModule)(\u0275\u0275inject(ApplicationRef));
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ApplicationModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationModule, [{
    type: NgModule
  }], () => [{
    type: ApplicationRef
  }], null);
})();
function booleanAttribute(value2) {
  return typeof value2 === "boolean" ? value2 : value2 != null && value2 !== "false";
}
function numberAttribute(value2, fallbackValue = NaN) {
  const isNumberValue = !isNaN(parseFloat(value2)) && !isNaN(Number(value2));
  return isNumberValue ? Number(value2) : fallbackValue;
}
function computed(computation, options) {
  performanceMarkFeature("NgSignals");
  const getter = createComputed(computation);
  if (options?.equal) {
    getter[SIGNAL].equal = options.equal;
  }
  if (ngDevMode) {
    getter.toString = () => `[Computed: ${getter()}]`;
    getter[SIGNAL].debugName = options?.debugName;
  }
  return getter;
}
function untracked(nonReactiveReadsFn) {
  const prevConsumer = setActiveConsumer(null);
  try {
    return nonReactiveReadsFn();
  } finally {
    setActiveConsumer(prevConsumer);
  }
}
var EffectRefImpl = class {
  [SIGNAL];
  constructor(node) {
    this[SIGNAL] = node;
  }
  destroy() {
    this[SIGNAL].destroy();
  }
};
var NOT_SET = Symbol("NOT_SET");
var ResourceStatus;
(function(ResourceStatus2) {
  ResourceStatus2[ResourceStatus2["Idle"] = 0] = "Idle";
  ResourceStatus2[ResourceStatus2["Error"] = 1] = "Error";
  ResourceStatus2[ResourceStatus2["Loading"] = 2] = "Loading";
  ResourceStatus2[ResourceStatus2["Reloading"] = 3] = "Reloading";
  ResourceStatus2[ResourceStatus2["Resolved"] = 4] = "Resolved";
  ResourceStatus2[ResourceStatus2["Local"] = 5] = "Local";
})(ResourceStatus || (ResourceStatus = {}));
function reflectComponentType(component) {
  const componentDef = getComponentDef(component);
  if (!componentDef) return null;
  const factory = new ComponentFactory(componentDef);
  return {
    get selector() {
      return factory.selector;
    },
    get type() {
      return factory.componentType;
    },
    get inputs() {
      return factory.inputs;
    },
    get outputs() {
      return factory.outputs;
    },
    get ngContentSelectors() {
      return factory.ngContentSelectors;
    },
    get isStandalone() {
      return componentDef.standalone;
    },
    get isSignal() {
      return componentDef.signals;
    }
  };
}
var REQUEST = new InjectionToken("REQUEST", {
  providedIn: "platform",
  factory: () => null
});
var RESPONSE_INIT = new InjectionToken("RESPONSE_INIT", {
  providedIn: "platform",
  factory: () => null
});
var REQUEST_CONTEXT = new InjectionToken("REQUEST_CONTEXT", {
  providedIn: "platform",
  factory: () => null
});
if (typeof ngDevMode !== "undefined" && ngDevMode) {
  _global.$localize ??= function() {
    throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)");
  };
}

// node_modules/@angular/common/fesm2022/common.mjs
var _DOM = null;
function getDOM() {
  return _DOM;
}
function setRootDomAdapter(adapter) {
  _DOM ??= adapter;
}
var DomAdapter = class {
};
var PlatformNavigation = class _PlatformNavigation {
  static \u0275fac = function PlatformNavigation_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PlatformNavigation)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _PlatformNavigation,
    factory: () => (() => window.navigation)(),
    providedIn: "platform"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformNavigation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => window.navigation
    }]
  }], null, null);
})();
var DOCUMENT2 = new InjectionToken(ngDevMode ? "DocumentToken" : "");
var PlatformLocation = class _PlatformLocation {
  historyGo(relativePosition) {
    throw new Error(ngDevMode ? "Not implemented" : "");
  }
  static \u0275fac = function PlatformLocation_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PlatformLocation)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _PlatformLocation,
    factory: () => (() => inject(BrowserPlatformLocation))(),
    providedIn: "platform"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformLocation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => inject(BrowserPlatformLocation)
    }]
  }], null, null);
})();
var LOCATION_INITIALIZED = new InjectionToken(ngDevMode ? "Location Initialized" : "");
var BrowserPlatformLocation = class _BrowserPlatformLocation extends PlatformLocation {
  _location;
  _history;
  _doc = inject(DOCUMENT2);
  constructor() {
    super();
    this._location = window.location;
    this._history = window.history;
  }
  getBaseHrefFromDOM() {
    return getDOM().getBaseHref(this._doc);
  }
  onPopState(fn) {
    const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
    window2.addEventListener("popstate", fn, false);
    return () => window2.removeEventListener("popstate", fn);
  }
  onHashChange(fn) {
    const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
    window2.addEventListener("hashchange", fn, false);
    return () => window2.removeEventListener("hashchange", fn);
  }
  get href() {
    return this._location.href;
  }
  get protocol() {
    return this._location.protocol;
  }
  get hostname() {
    return this._location.hostname;
  }
  get port() {
    return this._location.port;
  }
  get pathname() {
    return this._location.pathname;
  }
  get search() {
    return this._location.search;
  }
  get hash() {
    return this._location.hash;
  }
  set pathname(newPath) {
    this._location.pathname = newPath;
  }
  pushState(state2, title, url) {
    this._history.pushState(state2, title, url);
  }
  replaceState(state2, title, url) {
    this._history.replaceState(state2, title, url);
  }
  forward() {
    this._history.forward();
  }
  back() {
    this._history.back();
  }
  historyGo(relativePosition = 0) {
    this._history.go(relativePosition);
  }
  getState() {
    return this._history.state;
  }
  static \u0275fac = function BrowserPlatformLocation_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserPlatformLocation)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _BrowserPlatformLocation,
    factory: () => (() => new _BrowserPlatformLocation())(),
    providedIn: "platform"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserPlatformLocation, [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: () => new BrowserPlatformLocation()
    }]
  }], () => [], null);
})();
function joinWithSlash(start2, end2) {
  if (start2.length == 0) {
    return end2;
  }
  if (end2.length == 0) {
    return start2;
  }
  let slashes = 0;
  if (start2.endsWith("/")) {
    slashes++;
  }
  if (end2.startsWith("/")) {
    slashes++;
  }
  if (slashes == 2) {
    return start2 + end2.substring(1);
  }
  if (slashes == 1) {
    return start2 + end2;
  }
  return start2 + "/" + end2;
}
function stripTrailingSlash(url) {
  const match2 = url.match(/#|\?|$/);
  const pathEndIdx = match2 && match2.index || url.length;
  const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === "/" ? 1 : 0);
  return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
}
function normalizeQueryParams(params) {
  return params && params[0] !== "?" ? "?" + params : params;
}
var LocationStrategy = class _LocationStrategy {
  historyGo(relativePosition) {
    throw new Error(ngDevMode ? "Not implemented" : "");
  }
  static \u0275fac = function LocationStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocationStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _LocationStrategy,
    factory: () => (() => inject(PathLocationStrategy))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocationStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(PathLocationStrategy)
    }]
  }], null, null);
})();
var APP_BASE_HREF = new InjectionToken(ngDevMode ? "appBaseHref" : "");
var PathLocationStrategy = class _PathLocationStrategy extends LocationStrategy {
  _platformLocation;
  _baseHref;
  _removeListenerFns = [];
  constructor(_platformLocation, href) {
    super();
    this._platformLocation = _platformLocation;
    this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? inject(DOCUMENT2).location?.origin ?? "";
  }
  /** @nodoc */
  ngOnDestroy() {
    while (this._removeListenerFns.length) {
      this._removeListenerFns.pop()();
    }
  }
  onPopState(fn) {
    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
  }
  getBaseHref() {
    return this._baseHref;
  }
  prepareExternalUrl(internal) {
    return joinWithSlash(this._baseHref, internal);
  }
  path(includeHash = false) {
    const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
    const hash = this._platformLocation.hash;
    return hash && includeHash ? `${pathname}${hash}` : pathname;
  }
  pushState(state2, title, url, queryParams) {
    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
    this._platformLocation.pushState(state2, title, externalUrl);
  }
  replaceState(state2, title, url, queryParams) {
    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
    this._platformLocation.replaceState(state2, title, externalUrl);
  }
  forward() {
    this._platformLocation.forward();
  }
  back() {
    this._platformLocation.back();
  }
  getState() {
    return this._platformLocation.getState();
  }
  historyGo(relativePosition = 0) {
    this._platformLocation.historyGo?.(relativePosition);
  }
  static \u0275fac = function PathLocationStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PathLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _PathLocationStrategy,
    factory: _PathLocationStrategy.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PathLocationStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: PlatformLocation
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [APP_BASE_HREF]
    }]
  }], null);
})();
var HashLocationStrategy = class _HashLocationStrategy extends LocationStrategy {
  _platformLocation;
  _baseHref = "";
  _removeListenerFns = [];
  constructor(_platformLocation, _baseHref) {
    super();
    this._platformLocation = _platformLocation;
    if (_baseHref != null) {
      this._baseHref = _baseHref;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    while (this._removeListenerFns.length) {
      this._removeListenerFns.pop()();
    }
  }
  onPopState(fn) {
    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));
  }
  getBaseHref() {
    return this._baseHref;
  }
  path(includeHash = false) {
    const path3 = this._platformLocation.hash ?? "#";
    return path3.length > 0 ? path3.substring(1) : path3;
  }
  prepareExternalUrl(internal) {
    const url = joinWithSlash(this._baseHref, internal);
    return url.length > 0 ? "#" + url : url;
  }
  pushState(state2, title, path3, queryParams) {
    let url = this.prepareExternalUrl(path3 + normalizeQueryParams(queryParams));
    if (url.length == 0) {
      url = this._platformLocation.pathname;
    }
    this._platformLocation.pushState(state2, title, url);
  }
  replaceState(state2, title, path3, queryParams) {
    let url = this.prepareExternalUrl(path3 + normalizeQueryParams(queryParams));
    if (url.length == 0) {
      url = this._platformLocation.pathname;
    }
    this._platformLocation.replaceState(state2, title, url);
  }
  forward() {
    this._platformLocation.forward();
  }
  back() {
    this._platformLocation.back();
  }
  getState() {
    return this._platformLocation.getState();
  }
  historyGo(relativePosition = 0) {
    this._platformLocation.historyGo?.(relativePosition);
  }
  static \u0275fac = function HashLocationStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HashLocationStrategy)(\u0275\u0275inject(PlatformLocation), \u0275\u0275inject(APP_BASE_HREF, 8));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HashLocationStrategy,
    factory: _HashLocationStrategy.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HashLocationStrategy, [{
    type: Injectable
  }], () => [{
    type: PlatformLocation
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [APP_BASE_HREF]
    }]
  }], null);
})();
var Location = class _Location {
  /** @internal */
  _subject = new Subject();
  /** @internal */
  _basePath;
  /** @internal */
  _locationStrategy;
  /** @internal */
  _urlChangeListeners = [];
  /** @internal */
  _urlChangeSubscription = null;
  constructor(locationStrategy) {
    this._locationStrategy = locationStrategy;
    const baseHref = this._locationStrategy.getBaseHref();
    this._basePath = _stripOrigin(stripTrailingSlash(_stripIndexHtml(baseHref)));
    this._locationStrategy.onPopState((ev) => {
      this._subject.next({
        "url": this.path(true),
        "pop": true,
        "state": ev.state,
        "type": ev.type
      });
    });
  }
  /** @nodoc */
  ngOnDestroy() {
    this._urlChangeSubscription?.unsubscribe();
    this._urlChangeListeners = [];
  }
  /**
   * Normalizes the URL path for this location.
   *
   * @param includeHash True to include an anchor fragment in the path.
   *
   * @returns The normalized URL path.
   */
  // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
  // removed.
  path(includeHash = false) {
    return this.normalize(this._locationStrategy.path(includeHash));
  }
  /**
   * Reports the current state of the location history.
   * @returns The current value of the `history.state` object.
   */
  getState() {
    return this._locationStrategy.getState();
  }
  /**
   * Normalizes the given path and compares to the current normalized path.
   *
   * @param path The given URL path.
   * @param query Query parameters.
   *
   * @returns True if the given URL path is equal to the current normalized path, false
   * otherwise.
   */
  isCurrentPathEqualTo(path3, query = "") {
    return this.path() == this.normalize(path3 + normalizeQueryParams(query));
  }
  /**
   * Normalizes a URL path by stripping any trailing slashes.
   *
   * @param url String representing a URL.
   *
   * @returns The normalized URL string.
   */
  normalize(url) {
    return _Location.stripTrailingSlash(_stripBasePath(this._basePath, _stripIndexHtml(url)));
  }
  /**
   * Normalizes an external URL path.
   * If the given URL doesn't begin with a leading slash (`'/'`), adds one
   * before normalizing. Adds a hash if `HashLocationStrategy` is
   * in use, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
   *
   * @param url String representing a URL.
   *
   * @returns  A normalized platform-specific URL.
   */
  prepareExternalUrl(url) {
    if (url && url[0] !== "/") {
      url = "/" + url;
    }
    return this._locationStrategy.prepareExternalUrl(url);
  }
  // TODO: rename this method to pushState
  /**
   * Changes the browser's URL to a normalized version of a given URL, and pushes a
   * new item onto the platform's history.
   *
   * @param path  URL path to normalize.
   * @param query Query parameters.
   * @param state Location history state.
   *
   */
  go(path3, query = "", state2 = null) {
    this._locationStrategy.pushState(state2, "", path3, query);
    this._notifyUrlChangeListeners(this.prepareExternalUrl(path3 + normalizeQueryParams(query)), state2);
  }
  /**
   * Changes the browser's URL to a normalized version of the given URL, and replaces
   * the top item on the platform's history stack.
   *
   * @param path  URL path to normalize.
   * @param query Query parameters.
   * @param state Location history state.
   */
  replaceState(path3, query = "", state2 = null) {
    this._locationStrategy.replaceState(state2, "", path3, query);
    this._notifyUrlChangeListeners(this.prepareExternalUrl(path3 + normalizeQueryParams(query)), state2);
  }
  /**
   * Navigates forward in the platform's history.
   */
  forward() {
    this._locationStrategy.forward();
  }
  /**
   * Navigates back in the platform's history.
   */
  back() {
    this._locationStrategy.back();
  }
  /**
   * Navigate to a specific page from session history, identified by its relative position to the
   * current page.
   *
   * @param relativePosition  Position of the target page in the history relative to the current
   *     page.
   * A negative value moves backwards, a positive value moves forwards, e.g. `location.historyGo(2)`
   * moves forward two pages and `location.historyGo(-2)` moves back two pages. When we try to go
   * beyond what's stored in the history session, we stay in the current page. Same behaviour occurs
   * when `relativePosition` equals 0.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/History_API#Moving_to_a_specific_point_in_history
   */
  historyGo(relativePosition = 0) {
    this._locationStrategy.historyGo?.(relativePosition);
  }
  /**
   * Registers a URL change listener. Use to catch updates performed by the Angular
   * framework that are not detectible through "popstate" or "hashchange" events.
   *
   * @param fn The change handler function, which take a URL and a location history state.
   * @returns A function that, when executed, unregisters a URL change listener.
   */
  onUrlChange(fn) {
    this._urlChangeListeners.push(fn);
    this._urlChangeSubscription ??= this.subscribe((v) => {
      this._notifyUrlChangeListeners(v.url, v.state);
    });
    return () => {
      const fnIndex = this._urlChangeListeners.indexOf(fn);
      this._urlChangeListeners.splice(fnIndex, 1);
      if (this._urlChangeListeners.length === 0) {
        this._urlChangeSubscription?.unsubscribe();
        this._urlChangeSubscription = null;
      }
    };
  }
  /** @internal */
  _notifyUrlChangeListeners(url = "", state2) {
    this._urlChangeListeners.forEach((fn) => fn(url, state2));
  }
  /**
   * Subscribes to the platform's `popState` events.
   *
   * Note: `Location.go()` does not trigger the `popState` event in the browser. Use
   * `Location.onUrlChange()` to subscribe to URL changes instead.
   *
   * @param value Event that is triggered when the state history changes.
   * @param exception The exception to throw.
   *
   * @see [onpopstate](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate)
   *
   * @returns Subscribed events.
   */
  subscribe(onNext, onThrow, onReturn) {
    return this._subject.subscribe({
      next: onNext,
      error: onThrow ?? void 0,
      complete: onReturn ?? void 0
    });
  }
  /**
   * Normalizes URL parameters by prepending with `?` if needed.
   *
   * @param  params String of URL parameters.
   *
   * @returns The normalized URL parameters string.
   */
  static normalizeQueryParams = normalizeQueryParams;
  /**
   * Joins two parts of a URL with a slash if needed.
   *
   * @param start  URL string
   * @param end    URL string
   *
   *
   * @returns The joined URL string.
   */
  static joinWithSlash = joinWithSlash;
  /**
   * Removes a trailing slash from a URL string if needed.
   * Looks for the first occurrence of either `#`, `?`, or the end of the
   * line as `/` characters and removes the trailing slash if one exists.
   *
   * @param url URL string.
   *
   * @returns The URL string, modified if needed.
   */
  static stripTrailingSlash = stripTrailingSlash;
  static \u0275fac = function Location_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Location)(\u0275\u0275inject(LocationStrategy));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Location,
    factory: () => createLocation(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Location, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      // See #23917
      useFactory: createLocation
    }]
  }], () => [{
    type: LocationStrategy
  }], null);
})();
function createLocation() {
  return new Location(\u0275\u0275inject(LocationStrategy));
}
function _stripBasePath(basePath, url) {
  if (!basePath || !url.startsWith(basePath)) {
    return url;
  }
  const strippedUrl = url.substring(basePath.length);
  if (strippedUrl === "" || ["/", ";", "?", "#"].includes(strippedUrl[0])) {
    return strippedUrl;
  }
  return url;
}
function _stripIndexHtml(url) {
  return url.replace(/\/index.html$/, "");
}
function _stripOrigin(baseHref) {
  const isAbsoluteUrl2 = new RegExp("^(https?:)?//").test(baseHref);
  if (isAbsoluteUrl2) {
    const [, pathname] = baseHref.split(/\/\/[^\/]+/);
    return pathname;
  }
  return baseHref;
}
var CURRENCIES_EN = {
  "ADP": [void 0, void 0, 0],
  "AFN": [void 0, "\u060B", 0],
  "ALL": [void 0, void 0, 0],
  "AMD": [void 0, "\u058F", 2],
  "AOA": [void 0, "Kz"],
  "ARS": [void 0, "$"],
  "AUD": ["A$", "$"],
  "AZN": [void 0, "\u20BC"],
  "BAM": [void 0, "KM"],
  "BBD": [void 0, "$"],
  "BDT": [void 0, "\u09F3"],
  "BHD": [void 0, void 0, 3],
  "BIF": [void 0, void 0, 0],
  "BMD": [void 0, "$"],
  "BND": [void 0, "$"],
  "BOB": [void 0, "Bs"],
  "BRL": ["R$"],
  "BSD": [void 0, "$"],
  "BWP": [void 0, "P"],
  "BYN": [void 0, void 0, 2],
  "BYR": [void 0, void 0, 0],
  "BZD": [void 0, "$"],
  "CAD": ["CA$", "$", 2],
  "CHF": [void 0, void 0, 2],
  "CLF": [void 0, void 0, 4],
  "CLP": [void 0, "$", 0],
  "CNY": ["CN\xA5", "\xA5"],
  "COP": [void 0, "$", 2],
  "CRC": [void 0, "\u20A1", 2],
  "CUC": [void 0, "$"],
  "CUP": [void 0, "$"],
  "CZK": [void 0, "K\u010D", 2],
  "DJF": [void 0, void 0, 0],
  "DKK": [void 0, "kr", 2],
  "DOP": [void 0, "$"],
  "EGP": [void 0, "E\xA3"],
  "ESP": [void 0, "\u20A7", 0],
  "EUR": ["\u20AC"],
  "FJD": [void 0, "$"],
  "FKP": [void 0, "\xA3"],
  "GBP": ["\xA3"],
  "GEL": [void 0, "\u20BE"],
  "GHS": [void 0, "GH\u20B5"],
  "GIP": [void 0, "\xA3"],
  "GNF": [void 0, "FG", 0],
  "GTQ": [void 0, "Q"],
  "GYD": [void 0, "$", 2],
  "HKD": ["HK$", "$"],
  "HNL": [void 0, "L"],
  "HRK": [void 0, "kn"],
  "HUF": [void 0, "Ft", 2],
  "IDR": [void 0, "Rp", 2],
  "ILS": ["\u20AA"],
  "INR": ["\u20B9"],
  "IQD": [void 0, void 0, 0],
  "IRR": [void 0, void 0, 0],
  "ISK": [void 0, "kr", 0],
  "ITL": [void 0, void 0, 0],
  "JMD": [void 0, "$"],
  "JOD": [void 0, void 0, 3],
  "JPY": ["\xA5", void 0, 0],
  "KHR": [void 0, "\u17DB"],
  "KMF": [void 0, "CF", 0],
  "KPW": [void 0, "\u20A9", 0],
  "KRW": ["\u20A9", void 0, 0],
  "KWD": [void 0, void 0, 3],
  "KYD": [void 0, "$"],
  "KZT": [void 0, "\u20B8"],
  "LAK": [void 0, "\u20AD", 0],
  "LBP": [void 0, "L\xA3", 0],
  "LKR": [void 0, "Rs"],
  "LRD": [void 0, "$"],
  "LTL": [void 0, "Lt"],
  "LUF": [void 0, void 0, 0],
  "LVL": [void 0, "Ls"],
  "LYD": [void 0, void 0, 3],
  "MGA": [void 0, "Ar", 0],
  "MGF": [void 0, void 0, 0],
  "MMK": [void 0, "K", 0],
  "MNT": [void 0, "\u20AE", 2],
  "MRO": [void 0, void 0, 0],
  "MUR": [void 0, "Rs", 2],
  "MXN": ["MX$", "$"],
  "MYR": [void 0, "RM"],
  "NAD": [void 0, "$"],
  "NGN": [void 0, "\u20A6"],
  "NIO": [void 0, "C$"],
  "NOK": [void 0, "kr", 2],
  "NPR": [void 0, "Rs"],
  "NZD": ["NZ$", "$"],
  "OMR": [void 0, void 0, 3],
  "PHP": ["\u20B1"],
  "PKR": [void 0, "Rs", 2],
  "PLN": [void 0, "z\u0142"],
  "PYG": [void 0, "\u20B2", 0],
  "RON": [void 0, "lei"],
  "RSD": [void 0, void 0, 0],
  "RUB": [void 0, "\u20BD"],
  "RWF": [void 0, "RF", 0],
  "SBD": [void 0, "$"],
  "SEK": [void 0, "kr", 2],
  "SGD": [void 0, "$"],
  "SHP": [void 0, "\xA3"],
  "SLE": [void 0, void 0, 2],
  "SLL": [void 0, void 0, 0],
  "SOS": [void 0, void 0, 0],
  "SRD": [void 0, "$"],
  "SSP": [void 0, "\xA3"],
  "STD": [void 0, void 0, 0],
  "STN": [void 0, "Db"],
  "SYP": [void 0, "\xA3", 0],
  "THB": [void 0, "\u0E3F"],
  "TMM": [void 0, void 0, 0],
  "TND": [void 0, void 0, 3],
  "TOP": [void 0, "T$"],
  "TRL": [void 0, void 0, 0],
  "TRY": [void 0, "\u20BA"],
  "TTD": [void 0, "$"],
  "TWD": ["NT$", "$", 2],
  "TZS": [void 0, void 0, 2],
  "UAH": [void 0, "\u20B4"],
  "UGX": [void 0, void 0, 0],
  "USD": ["$"],
  "UYI": [void 0, void 0, 0],
  "UYU": [void 0, "$"],
  "UYW": [void 0, void 0, 4],
  "UZS": [void 0, void 0, 2],
  "VEF": [void 0, "Bs", 2],
  "VND": ["\u20AB", void 0, 0],
  "VUV": [void 0, void 0, 0],
  "XAF": ["FCFA", void 0, 0],
  "XCD": ["EC$", "$"],
  "XOF": ["F\u202FCFA", void 0, 0],
  "XPF": ["CFPF", void 0, 0],
  "XXX": ["\xA4"],
  "YER": [void 0, void 0, 0],
  "ZAR": [void 0, "R"],
  "ZMK": [void 0, void 0, 0],
  "ZMW": [void 0, "ZK"],
  "ZWD": [void 0, void 0, 0]
};
var NumberFormatStyle;
(function(NumberFormatStyle2) {
  NumberFormatStyle2[NumberFormatStyle2["Decimal"] = 0] = "Decimal";
  NumberFormatStyle2[NumberFormatStyle2["Percent"] = 1] = "Percent";
  NumberFormatStyle2[NumberFormatStyle2["Currency"] = 2] = "Currency";
  NumberFormatStyle2[NumberFormatStyle2["Scientific"] = 3] = "Scientific";
})(NumberFormatStyle || (NumberFormatStyle = {}));
var Plural;
(function(Plural2) {
  Plural2[Plural2["Zero"] = 0] = "Zero";
  Plural2[Plural2["One"] = 1] = "One";
  Plural2[Plural2["Two"] = 2] = "Two";
  Plural2[Plural2["Few"] = 3] = "Few";
  Plural2[Plural2["Many"] = 4] = "Many";
  Plural2[Plural2["Other"] = 5] = "Other";
})(Plural || (Plural = {}));
var FormStyle;
(function(FormStyle2) {
  FormStyle2[FormStyle2["Format"] = 0] = "Format";
  FormStyle2[FormStyle2["Standalone"] = 1] = "Standalone";
})(FormStyle || (FormStyle = {}));
var TranslationWidth;
(function(TranslationWidth2) {
  TranslationWidth2[TranslationWidth2["Narrow"] = 0] = "Narrow";
  TranslationWidth2[TranslationWidth2["Abbreviated"] = 1] = "Abbreviated";
  TranslationWidth2[TranslationWidth2["Wide"] = 2] = "Wide";
  TranslationWidth2[TranslationWidth2["Short"] = 3] = "Short";
})(TranslationWidth || (TranslationWidth = {}));
var FormatWidth;
(function(FormatWidth2) {
  FormatWidth2[FormatWidth2["Short"] = 0] = "Short";
  FormatWidth2[FormatWidth2["Medium"] = 1] = "Medium";
  FormatWidth2[FormatWidth2["Long"] = 2] = "Long";
  FormatWidth2[FormatWidth2["Full"] = 3] = "Full";
})(FormatWidth || (FormatWidth = {}));
var NumberSymbol = {
  /**
   * Decimal separator.
   * For `en-US`, the dot character.
   * Example: 2,345`.`67
   */
  Decimal: 0,
  /**
   * Grouping separator, typically for thousands.
   * For `en-US`, the comma character.
   * Example: 2`,`345.67
   */
  Group: 1,
  /**
   * List-item separator.
   * Example: "one, two, and three"
   */
  List: 2,
  /**
   * Sign for percentage (out of 100).
   * Example: 23.4%
   */
  PercentSign: 3,
  /**
   * Sign for positive numbers.
   * Example: +23
   */
  PlusSign: 4,
  /**
   * Sign for negative numbers.
   * Example: -23
   */
  MinusSign: 5,
  /**
   * Computer notation for exponential value (n times a power of 10).
   * Example: 1.2E3
   */
  Exponential: 6,
  /**
   * Human-readable format of exponential.
   * Example: 1.2x103
   */
  SuperscriptingExponent: 7,
  /**
   * Sign for permille (out of 1000).
   * Example: 23.4‰
   */
  PerMille: 8,
  /**
   * Infinity, can be used with plus and minus.
   * Example: ∞, +∞, -∞
   */
  Infinity: 9,
  /**
   * Not a number.
   * Example: NaN
   */
  NaN: 10,
  /**
   * Symbol used between time units.
   * Example: 10:52
   */
  TimeSeparator: 11,
  /**
   * Decimal separator for currency values (fallback to `Decimal`).
   * Example: $2,345.67
   */
  CurrencyDecimal: 12,
  /**
   * Group separator for currency values (fallback to `Group`).
   * Example: $2,345.67
   */
  CurrencyGroup: 13
};
var WeekDay;
(function(WeekDay2) {
  WeekDay2[WeekDay2["Sunday"] = 0] = "Sunday";
  WeekDay2[WeekDay2["Monday"] = 1] = "Monday";
  WeekDay2[WeekDay2["Tuesday"] = 2] = "Tuesday";
  WeekDay2[WeekDay2["Wednesday"] = 3] = "Wednesday";
  WeekDay2[WeekDay2["Thursday"] = 4] = "Thursday";
  WeekDay2[WeekDay2["Friday"] = 5] = "Friday";
  WeekDay2[WeekDay2["Saturday"] = 6] = "Saturday";
})(WeekDay || (WeekDay = {}));
function getLocaleId2(locale3) {
  return findLocaleData(locale3)[LocaleDataIndex.LocaleId];
}
function getLocaleDayPeriods(locale3, formStyle, width) {
  const data = findLocaleData(locale3);
  const amPmData = [data[LocaleDataIndex.DayPeriodsFormat], data[LocaleDataIndex.DayPeriodsStandalone]];
  const amPm = getLastDefinedValue(amPmData, formStyle);
  return getLastDefinedValue(amPm, width);
}
function getLocaleDayNames(locale3, formStyle, width) {
  const data = findLocaleData(locale3);
  const daysData = [data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone]];
  const days2 = getLastDefinedValue(daysData, formStyle);
  return getLastDefinedValue(days2, width);
}
function getLocaleMonthNames(locale3, formStyle, width) {
  const data = findLocaleData(locale3);
  const monthsData = [data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone]];
  const months2 = getLastDefinedValue(monthsData, formStyle);
  return getLastDefinedValue(months2, width);
}
function getLocaleEraNames(locale3, width) {
  const data = findLocaleData(locale3);
  const erasData = data[LocaleDataIndex.Eras];
  return getLastDefinedValue(erasData, width);
}
function getLocaleDateFormat(locale3, width) {
  const data = findLocaleData(locale3);
  return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);
}
function getLocaleTimeFormat(locale3, width) {
  const data = findLocaleData(locale3);
  return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);
}
function getLocaleDateTimeFormat(locale3, width) {
  const data = findLocaleData(locale3);
  const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];
  return getLastDefinedValue(dateTimeFormatData, width);
}
function getLocaleNumberSymbol(locale3, symbol) {
  const data = findLocaleData(locale3);
  const res = data[LocaleDataIndex.NumberSymbols][symbol];
  if (typeof res === "undefined") {
    if (symbol === NumberSymbol.CurrencyDecimal) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
    } else if (symbol === NumberSymbol.CurrencyGroup) {
      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
    }
  }
  return res;
}
function getLocaleNumberFormat(locale3, type2) {
  const data = findLocaleData(locale3);
  return data[LocaleDataIndex.NumberFormats][type2];
}
function getLocaleCurrencies(locale3) {
  const data = findLocaleData(locale3);
  return data[LocaleDataIndex.Currencies];
}
var getLocalePluralCase2 = getLocalePluralCase;
function checkFullData(data) {
  if (!data[LocaleDataIndex.ExtraData]) {
    throw new Error(`Missing extra locale data for the locale "${data[LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
  }
}
function getLocaleExtraDayPeriodRules(locale3) {
  const data = findLocaleData(locale3);
  checkFullData(data);
  const rules = data[LocaleDataIndex.ExtraData][
    2
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodsRules */
  ] || [];
  return rules.map((rule) => {
    if (typeof rule === "string") {
      return extractTime(rule);
    }
    return [extractTime(rule[0]), extractTime(rule[1])];
  });
}
function getLocaleExtraDayPeriods(locale3, formStyle, width) {
  const data = findLocaleData(locale3);
  checkFullData(data);
  const dayPeriodsData = [data[LocaleDataIndex.ExtraData][
    0
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodFormats */
  ], data[LocaleDataIndex.ExtraData][
    1
    /* ɵExtraLocaleDataIndex.ExtraDayPeriodStandalone */
  ]];
  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
  return getLastDefinedValue(dayPeriods, width) || [];
}
function getLastDefinedValue(data, index) {
  for (let i = index; i > -1; i--) {
    if (typeof data[i] !== "undefined") {
      return data[i];
    }
  }
  throw new Error("Locale data API: locale data undefined");
}
function extractTime(time2) {
  const [h, m] = time2.split(":");
  return {
    hours: +h,
    minutes: +m
  };
}
function getCurrencySymbol(code, format2, locale3 = "en") {
  const currency = getLocaleCurrencies(locale3)[code] || CURRENCIES_EN[code] || [];
  const symbolNarrow = currency[
    1
    /* ɵCurrencyIndex.SymbolNarrow */
  ];
  if (format2 === "narrow" && typeof symbolNarrow === "string") {
    return symbolNarrow;
  }
  return currency[
    0
    /* ɵCurrencyIndex.Symbol */
  ] || code;
}
var DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
function getNumberOfCurrencyDigits(code) {
  let digits;
  const currency = CURRENCIES_EN[code];
  if (currency) {
    digits = currency[
      2
      /* ɵCurrencyIndex.NbOfDigits */
    ];
  }
  return typeof digits === "number" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
}
var ISO8601_DATE_REGEX = /^(\d{4,})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
var NAMED_FORMATS = {};
var DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
var ZoneWidth;
(function(ZoneWidth2) {
  ZoneWidth2[ZoneWidth2["Short"] = 0] = "Short";
  ZoneWidth2[ZoneWidth2["ShortGMT"] = 1] = "ShortGMT";
  ZoneWidth2[ZoneWidth2["Long"] = 2] = "Long";
  ZoneWidth2[ZoneWidth2["Extended"] = 3] = "Extended";
})(ZoneWidth || (ZoneWidth = {}));
var DateType;
(function(DateType2) {
  DateType2[DateType2["FullYear"] = 0] = "FullYear";
  DateType2[DateType2["Month"] = 1] = "Month";
  DateType2[DateType2["Date"] = 2] = "Date";
  DateType2[DateType2["Hours"] = 3] = "Hours";
  DateType2[DateType2["Minutes"] = 4] = "Minutes";
  DateType2[DateType2["Seconds"] = 5] = "Seconds";
  DateType2[DateType2["FractionalSeconds"] = 6] = "FractionalSeconds";
  DateType2[DateType2["Day"] = 7] = "Day";
})(DateType || (DateType = {}));
var TranslationType;
(function(TranslationType2) {
  TranslationType2[TranslationType2["DayPeriods"] = 0] = "DayPeriods";
  TranslationType2[TranslationType2["Days"] = 1] = "Days";
  TranslationType2[TranslationType2["Months"] = 2] = "Months";
  TranslationType2[TranslationType2["Eras"] = 3] = "Eras";
})(TranslationType || (TranslationType = {}));
function formatDate(value2, format2, locale3, timezone) {
  let date2 = toDate(value2);
  const namedFormat = getNamedFormat(locale3, format2);
  format2 = namedFormat || format2;
  let parts = [];
  let match2;
  while (format2) {
    match2 = DATE_FORMATS_SPLIT.exec(format2);
    if (match2) {
      parts = parts.concat(match2.slice(1));
      const part = parts.pop();
      if (!part) {
        break;
      }
      format2 = part;
    } else {
      parts.push(format2);
      break;
    }
  }
  let dateTimezoneOffset = date2.getTimezoneOffset();
  if (timezone) {
    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    date2 = convertTimezoneToLocal(date2, timezone, true);
  }
  let text2 = "";
  parts.forEach((value3) => {
    const dateFormatter = getDateFormatter(value3);
    text2 += dateFormatter ? dateFormatter(date2, locale3, dateTimezoneOffset) : value3 === "''" ? "'" : value3.replace(/(^'|'$)/g, "").replace(/''/g, "'");
  });
  return text2;
}
function createDate(year2, month2, date2) {
  const newDate2 = /* @__PURE__ */ new Date(0);
  newDate2.setFullYear(year2, month2, date2);
  newDate2.setHours(0, 0, 0);
  return newDate2;
}
function getNamedFormat(locale3, format2) {
  const localeId = getLocaleId2(locale3);
  NAMED_FORMATS[localeId] ??= {};
  if (NAMED_FORMATS[localeId][format2]) {
    return NAMED_FORMATS[localeId][format2];
  }
  let formatValue2 = "";
  switch (format2) {
    case "shortDate":
      formatValue2 = getLocaleDateFormat(locale3, FormatWidth.Short);
      break;
    case "mediumDate":
      formatValue2 = getLocaleDateFormat(locale3, FormatWidth.Medium);
      break;
    case "longDate":
      formatValue2 = getLocaleDateFormat(locale3, FormatWidth.Long);
      break;
    case "fullDate":
      formatValue2 = getLocaleDateFormat(locale3, FormatWidth.Full);
      break;
    case "shortTime":
      formatValue2 = getLocaleTimeFormat(locale3, FormatWidth.Short);
      break;
    case "mediumTime":
      formatValue2 = getLocaleTimeFormat(locale3, FormatWidth.Medium);
      break;
    case "longTime":
      formatValue2 = getLocaleTimeFormat(locale3, FormatWidth.Long);
      break;
    case "fullTime":
      formatValue2 = getLocaleTimeFormat(locale3, FormatWidth.Full);
      break;
    case "short":
      const shortTime = getNamedFormat(locale3, "shortTime");
      const shortDate = getNamedFormat(locale3, "shortDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale3, FormatWidth.Short), [shortTime, shortDate]);
      break;
    case "medium":
      const mediumTime = getNamedFormat(locale3, "mediumTime");
      const mediumDate = getNamedFormat(locale3, "mediumDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale3, FormatWidth.Medium), [mediumTime, mediumDate]);
      break;
    case "long":
      const longTime = getNamedFormat(locale3, "longTime");
      const longDate = getNamedFormat(locale3, "longDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale3, FormatWidth.Long), [longTime, longDate]);
      break;
    case "full":
      const fullTime = getNamedFormat(locale3, "fullTime");
      const fullDate = getNamedFormat(locale3, "fullDate");
      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale3, FormatWidth.Full), [fullTime, fullDate]);
      break;
  }
  if (formatValue2) {
    NAMED_FORMATS[localeId][format2] = formatValue2;
  }
  return formatValue2;
}
function formatDateTime(str, opt_values) {
  if (opt_values) {
    str = str.replace(/\{([^}]+)}/g, function(match2, key) {
      return opt_values != null && key in opt_values ? opt_values[key] : match2;
    });
  }
  return str;
}
function padNumber(num, digits, minusSign = "-", trim, negWrap) {
  let neg = "";
  if (num < 0 || negWrap && num <= 0) {
    if (negWrap) {
      num = -num + 1;
    } else {
      num = -num;
      neg = minusSign;
    }
  }
  let strNum = String(num);
  while (strNum.length < digits) {
    strNum = "0" + strNum;
  }
  if (trim) {
    strNum = strNum.slice(strNum.length - digits);
  }
  return neg + strNum;
}
function formatFractionalSeconds(milliseconds2, digits) {
  const strMs = padNumber(milliseconds2, 3);
  return strMs.substring(0, digits);
}
function dateGetter(name, size2, offset2 = 0, trim = false, negWrap = false) {
  return function(date2, locale3) {
    let part = getDatePart(name, date2);
    if (offset2 > 0 || part > -offset2) {
      part += offset2;
    }
    if (name === DateType.Hours) {
      if (part === 0 && offset2 === -12) {
        part = 12;
      }
    } else if (name === DateType.FractionalSeconds) {
      return formatFractionalSeconds(part, size2);
    }
    const localeMinus = getLocaleNumberSymbol(locale3, NumberSymbol.MinusSign);
    return padNumber(part, size2, localeMinus, trim, negWrap);
  };
}
function getDatePart(part, date2) {
  switch (part) {
    case DateType.FullYear:
      return date2.getFullYear();
    case DateType.Month:
      return date2.getMonth();
    case DateType.Date:
      return date2.getDate();
    case DateType.Hours:
      return date2.getHours();
    case DateType.Minutes:
      return date2.getMinutes();
    case DateType.Seconds:
      return date2.getSeconds();
    case DateType.FractionalSeconds:
      return date2.getMilliseconds();
    case DateType.Day:
      return date2.getDay();
    default:
      throw new Error(`Unknown DateType value "${part}".`);
  }
}
function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
  return function(date2, locale3) {
    return getDateTranslation(date2, locale3, name, width, form, extended);
  };
}
function getDateTranslation(date2, locale3, name, width, form, extended) {
  switch (name) {
    case TranslationType.Months:
      return getLocaleMonthNames(locale3, form, width)[date2.getMonth()];
    case TranslationType.Days:
      return getLocaleDayNames(locale3, form, width)[date2.getDay()];
    case TranslationType.DayPeriods:
      const currentHours = date2.getHours();
      const currentMinutes = date2.getMinutes();
      if (extended) {
        const rules = getLocaleExtraDayPeriodRules(locale3);
        const dayPeriods = getLocaleExtraDayPeriods(locale3, form, width);
        const index = rules.findIndex((rule) => {
          if (Array.isArray(rule)) {
            const [from2, to] = rule;
            const afterFrom = currentHours >= from2.hours && currentMinutes >= from2.minutes;
            const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
            if (from2.hours < to.hours) {
              if (afterFrom && beforeTo) {
                return true;
              }
            } else if (afterFrom || beforeTo) {
              return true;
            }
          } else {
            if (rule.hours === currentHours && rule.minutes === currentMinutes) {
              return true;
            }
          }
          return false;
        });
        if (index !== -1) {
          return dayPeriods[index];
        }
      }
      return getLocaleDayPeriods(locale3, form, width)[currentHours < 12 ? 0 : 1];
    case TranslationType.Eras:
      return getLocaleEraNames(locale3, width)[date2.getFullYear() <= 0 ? 0 : 1];
    default:
      const unexpected = name;
      throw new Error(`unexpected translation type ${unexpected}`);
  }
}
function timeZoneGetter(width) {
  return function(date2, locale3, offset2) {
    const zone = -1 * offset2;
    const minusSign = getLocaleNumberSymbol(locale3, NumberSymbol.MinusSign);
    const hours2 = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
    switch (width) {
      case ZoneWidth.Short:
        return (zone >= 0 ? "+" : "") + padNumber(hours2, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
      case ZoneWidth.ShortGMT:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours2, 1, minusSign);
      case ZoneWidth.Long:
        return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours2, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
      case ZoneWidth.Extended:
        if (offset2 === 0) {
          return "Z";
        } else {
          return (zone >= 0 ? "+" : "") + padNumber(hours2, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
        }
      default:
        throw new Error(`Unknown zone width "${width}"`);
    }
  };
}
var JANUARY = 0;
var THURSDAY = 4;
function getFirstThursdayOfYear(year2) {
  const firstDayOfYear = createDate(year2, JANUARY, 1).getDay();
  return createDate(year2, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
}
function getThursdayThisIsoWeek(datetime) {
  const currentDay = datetime.getDay();
  const deltaToThursday = currentDay === 0 ? -3 : THURSDAY - currentDay;
  return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + deltaToThursday);
}
function weekGetter(size2, monthBased = false) {
  return function(date2, locale3) {
    let result;
    if (monthBased) {
      const nbDaysBefore1stDayOfMonth = new Date(date2.getFullYear(), date2.getMonth(), 1).getDay() - 1;
      const today = date2.getDate();
      result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
    } else {
      const thisThurs = getThursdayThisIsoWeek(date2);
      const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
      const diff = thisThurs.getTime() - firstThurs.getTime();
      result = 1 + Math.round(diff / 6048e5);
    }
    return padNumber(result, size2, getLocaleNumberSymbol(locale3, NumberSymbol.MinusSign));
  };
}
function weekNumberingYearGetter(size2, trim = false) {
  return function(date2, locale3) {
    const thisThurs = getThursdayThisIsoWeek(date2);
    const weekNumberingYear = thisThurs.getFullYear();
    return padNumber(weekNumberingYear, size2, getLocaleNumberSymbol(locale3, NumberSymbol.MinusSign), trim);
  };
}
var DATE_FORMATS = {};
function getDateFormatter(format2) {
  if (DATE_FORMATS[format2]) {
    return DATE_FORMATS[format2];
  }
  let formatter;
  switch (format2) {
    // Era name (AD/BC)
    case "G":
    case "GG":
    case "GGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
      break;
    case "GGGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
      break;
    case "GGGGG":
      formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
      break;
    // 1 digit representation of the year, e.g. (AD 1 => 1, AD 199 => 199)
    case "y":
      formatter = dateGetter(DateType.FullYear, 1, 0, false, true);
      break;
    // 2 digit representation of the year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
    case "yy":
      formatter = dateGetter(DateType.FullYear, 2, 0, true, true);
      break;
    // 3 digit representation of the year, padded (000-999). (e.g. AD 2001 => 01, AD 2010 => 10)
    case "yyy":
      formatter = dateGetter(DateType.FullYear, 3, 0, false, true);
      break;
    // 4 digit representation of the year (e.g. AD 1 => 0001, AD 2010 => 2010)
    case "yyyy":
      formatter = dateGetter(DateType.FullYear, 4, 0, false, true);
      break;
    // 1 digit representation of the week-numbering year, e.g. (AD 1 => 1, AD 199 => 199)
    case "Y":
      formatter = weekNumberingYearGetter(1);
      break;
    // 2 digit representation of the week-numbering year, padded (00-99). (e.g. AD 2001 => 01, AD
    // 2010 => 10)
    case "YY":
      formatter = weekNumberingYearGetter(2, true);
      break;
    // 3 digit representation of the week-numbering year, padded (000-999). (e.g. AD 1 => 001, AD
    // 2010 => 2010)
    case "YYY":
      formatter = weekNumberingYearGetter(3);
      break;
    // 4 digit representation of the week-numbering year (e.g. AD 1 => 0001, AD 2010 => 2010)
    case "YYYY":
      formatter = weekNumberingYearGetter(4);
      break;
    // Month of the year (1-12), numeric
    case "M":
    case "L":
      formatter = dateGetter(DateType.Month, 1, 1);
      break;
    case "MM":
    case "LL":
      formatter = dateGetter(DateType.Month, 2, 1);
      break;
    // Month of the year (January, ...), string, format
    case "MMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
      break;
    case "MMMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
      break;
    case "MMMMM":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
      break;
    // Month of the year (January, ...), string, standalone
    case "LLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "LLLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "LLLLL":
      formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    // Week of the year (1, ... 52)
    case "w":
      formatter = weekGetter(1);
      break;
    case "ww":
      formatter = weekGetter(2);
      break;
    // Week of the month (1, ...)
    case "W":
      formatter = weekGetter(1, true);
      break;
    // Day of the month (1-31)
    case "d":
      formatter = dateGetter(DateType.Date, 1);
      break;
    case "dd":
      formatter = dateGetter(DateType.Date, 2);
      break;
    // Day of the Week StandAlone (1, 1, Mon, Monday, M, Mo)
    case "c":
    case "cc":
      formatter = dateGetter(DateType.Day, 1);
      break;
    case "ccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated, FormStyle.Standalone);
      break;
    case "cccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide, FormStyle.Standalone);
      break;
    case "ccccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow, FormStyle.Standalone);
      break;
    case "cccccc":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short, FormStyle.Standalone);
      break;
    // Day of the Week
    case "E":
    case "EE":
    case "EEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
      break;
    case "EEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
      break;
    case "EEEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
      break;
    case "EEEEEE":
      formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
      break;
    // Generic period of the day (am-pm)
    case "a":
    case "aa":
    case "aaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
      break;
    case "aaaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
      break;
    case "aaaaa":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
      break;
    // Extended period of the day (midnight, at night, ...), standalone
    case "b":
    case "bb":
    case "bbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
      break;
    case "bbbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, true);
      break;
    case "bbbbb":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, true);
      break;
    // Extended period of the day (midnight, night, ...), standalone
    case "B":
    case "BB":
    case "BBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, true);
      break;
    case "BBBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, true);
      break;
    case "BBBBB":
      formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, true);
      break;
    // Hour in AM/PM, (1-12)
    case "h":
      formatter = dateGetter(DateType.Hours, 1, -12);
      break;
    case "hh":
      formatter = dateGetter(DateType.Hours, 2, -12);
      break;
    // Hour of the day (0-23)
    case "H":
      formatter = dateGetter(DateType.Hours, 1);
      break;
    // Hour in day, padded (00-23)
    case "HH":
      formatter = dateGetter(DateType.Hours, 2);
      break;
    // Minute of the hour (0-59)
    case "m":
      formatter = dateGetter(DateType.Minutes, 1);
      break;
    case "mm":
      formatter = dateGetter(DateType.Minutes, 2);
      break;
    // Second of the minute (0-59)
    case "s":
      formatter = dateGetter(DateType.Seconds, 1);
      break;
    case "ss":
      formatter = dateGetter(DateType.Seconds, 2);
      break;
    // Fractional second
    case "S":
      formatter = dateGetter(DateType.FractionalSeconds, 1);
      break;
    case "SS":
      formatter = dateGetter(DateType.FractionalSeconds, 2);
      break;
    case "SSS":
      formatter = dateGetter(DateType.FractionalSeconds, 3);
      break;
    // Timezone ISO8601 short format (-0430)
    case "Z":
    case "ZZ":
    case "ZZZ":
      formatter = timeZoneGetter(ZoneWidth.Short);
      break;
    // Timezone ISO8601 extended format (-04:30)
    case "ZZZZZ":
      formatter = timeZoneGetter(ZoneWidth.Extended);
      break;
    // Timezone GMT short format (GMT+4)
    case "O":
    case "OO":
    case "OOO":
    // Should be location, but fallback to format O instead because we don't have the data yet
    case "z":
    case "zz":
    case "zzz":
      formatter = timeZoneGetter(ZoneWidth.ShortGMT);
      break;
    // Timezone GMT long format (GMT+0430)
    case "OOOO":
    case "ZZZZ":
    // Should be location, but fallback to format O instead because we don't have the data yet
    case "zzzz":
      formatter = timeZoneGetter(ZoneWidth.Long);
      break;
    default:
      return null;
  }
  DATE_FORMATS[format2] = formatter;
  return formatter;
}
function timezoneToOffset(timezone, fallback) {
  timezone = timezone.replace(/:/g, "");
  const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
}
function addDateMinutes(date2, minutes2) {
  date2 = new Date(date2.getTime());
  date2.setMinutes(date2.getMinutes() + minutes2);
  return date2;
}
function convertTimezoneToLocal(date2, timezone, reverse) {
  const reverseValue = reverse ? -1 : 1;
  const dateTimezoneOffset = date2.getTimezoneOffset();
  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
  return addDateMinutes(date2, reverseValue * (timezoneOffset - dateTimezoneOffset));
}
function toDate(value2) {
  if (isDate(value2)) {
    return value2;
  }
  if (typeof value2 === "number" && !isNaN(value2)) {
    return new Date(value2);
  }
  if (typeof value2 === "string") {
    value2 = value2.trim();
    if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value2)) {
      const [y3, m = 1, d = 1] = value2.split("-").map((val) => +val);
      return createDate(y3, m - 1, d);
    }
    const parsedNb = parseFloat(value2);
    if (!isNaN(value2 - parsedNb)) {
      return new Date(parsedNb);
    }
    let match2;
    if (match2 = value2.match(ISO8601_DATE_REGEX)) {
      return isoStringToDate(match2);
    }
  }
  const date2 = new Date(value2);
  if (!isDate(date2)) {
    throw new Error(`Unable to convert "${value2}" into a date`);
  }
  return date2;
}
function isoStringToDate(match2) {
  const date2 = /* @__PURE__ */ new Date(0);
  let tzHour = 0;
  let tzMin = 0;
  const dateSetter = match2[8] ? date2.setUTCFullYear : date2.setFullYear;
  const timeSetter = match2[8] ? date2.setUTCHours : date2.setHours;
  if (match2[9]) {
    tzHour = Number(match2[9] + match2[10]);
    tzMin = Number(match2[9] + match2[11]);
  }
  dateSetter.call(date2, Number(match2[1]), Number(match2[2]) - 1, Number(match2[3]));
  const h = Number(match2[4] || 0) - tzHour;
  const m = Number(match2[5] || 0) - tzMin;
  const s2 = Number(match2[6] || 0);
  const ms = Math.floor(parseFloat("0." + (match2[7] || 0)) * 1e3);
  timeSetter.call(date2, h, m, s2, ms);
  return date2;
}
function isDate(value2) {
  return value2 instanceof Date && !isNaN(value2.valueOf());
}
var NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
var MAX_DIGITS = 22;
var DECIMAL_SEP = ".";
var ZERO_CHAR = "0";
var PATTERN_SEP = ";";
var GROUP_SEP = ",";
var DIGIT_CHAR = "#";
var CURRENCY_CHAR = "\xA4";
var PERCENT_CHAR = "%";
function formatNumberToLocaleString(value2, pattern, locale3, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
  let formattedText = "";
  let isZero = false;
  if (!isFinite(value2)) {
    formattedText = getLocaleNumberSymbol(locale3, NumberSymbol.Infinity);
  } else {
    let parsedNumber = parseNumber(value2);
    if (isPercent) {
      parsedNumber = toPercent(parsedNumber);
    }
    let minInt = pattern.minInt;
    let minFraction = pattern.minFrac;
    let maxFraction = pattern.maxFrac;
    if (digitsInfo) {
      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
      if (parts === null) {
        throw new Error(`${digitsInfo} is not a valid digit info`);
      }
      const minIntPart = parts[1];
      const minFractionPart = parts[3];
      const maxFractionPart = parts[5];
      if (minIntPart != null) {
        minInt = parseIntAutoRadix(minIntPart);
      }
      if (minFractionPart != null) {
        minFraction = parseIntAutoRadix(minFractionPart);
      }
      if (maxFractionPart != null) {
        maxFraction = parseIntAutoRadix(maxFractionPart);
      } else if (minFractionPart != null && minFraction > maxFraction) {
        maxFraction = minFraction;
      }
    }
    roundNumber(parsedNumber, minFraction, maxFraction);
    let digits = parsedNumber.digits;
    let integerLen = parsedNumber.integerLen;
    const exponent = parsedNumber.exponent;
    let decimals = [];
    isZero = digits.every((d) => !d);
    for (; integerLen < minInt; integerLen++) {
      digits.unshift(0);
    }
    for (; integerLen < 0; integerLen++) {
      digits.unshift(0);
    }
    if (integerLen > 0) {
      decimals = digits.splice(integerLen, digits.length);
    } else {
      decimals = digits;
      digits = [0];
    }
    const groups = [];
    if (digits.length >= pattern.lgSize) {
      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
    }
    while (digits.length > pattern.gSize) {
      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
    }
    if (digits.length) {
      groups.unshift(digits.join(""));
    }
    formattedText = groups.join(getLocaleNumberSymbol(locale3, groupSymbol));
    if (decimals.length) {
      formattedText += getLocaleNumberSymbol(locale3, decimalSymbol) + decimals.join("");
    }
    if (exponent) {
      formattedText += getLocaleNumberSymbol(locale3, NumberSymbol.Exponential) + "+" + exponent;
    }
  }
  if (value2 < 0 && !isZero) {
    formattedText = pattern.negPre + formattedText + pattern.negSuf;
  } else {
    formattedText = pattern.posPre + formattedText + pattern.posSuf;
  }
  return formattedText;
}
function formatCurrency(value2, locale3, currency, currencyCode, digitsInfo) {
  const format2 = getLocaleNumberFormat(locale3, NumberFormatStyle.Currency);
  const pattern = parseNumberFormat(format2, getLocaleNumberSymbol(locale3, NumberSymbol.MinusSign));
  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
  pattern.maxFrac = pattern.minFrac;
  const res = formatNumberToLocaleString(value2, pattern, locale3, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
  return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, "").trim();
}
function formatPercent(value2, locale3, digitsInfo) {
  const format2 = getLocaleNumberFormat(locale3, NumberFormatStyle.Percent);
  const pattern = parseNumberFormat(format2, getLocaleNumberSymbol(locale3, NumberSymbol.MinusSign));
  const res = formatNumberToLocaleString(value2, pattern, locale3, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
  return res.replace(new RegExp(PERCENT_CHAR, "g"), getLocaleNumberSymbol(locale3, NumberSymbol.PercentSign));
}
function formatNumber(value2, locale3, digitsInfo) {
  const format2 = getLocaleNumberFormat(locale3, NumberFormatStyle.Decimal);
  const pattern = parseNumberFormat(format2, getLocaleNumberSymbol(locale3, NumberSymbol.MinusSign));
  return formatNumberToLocaleString(value2, pattern, locale3, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
}
function parseNumberFormat(format2, minusSign = "-") {
  const p2 = {
    minInt: 1,
    minFrac: 0,
    maxFrac: 0,
    posPre: "",
    posSuf: "",
    negPre: "",
    negSuf: "",
    gSize: 0,
    lgSize: 0
  };
  const patternParts = format2.split(PATTERN_SEP);
  const positive = patternParts[0];
  const negative = patternParts[1];
  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)], integer = positiveParts[0], fraction = positiveParts[1] || "";
  p2.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));
  for (let i = 0; i < fraction.length; i++) {
    const ch = fraction.charAt(i);
    if (ch === ZERO_CHAR) {
      p2.minFrac = p2.maxFrac = i + 1;
    } else if (ch === DIGIT_CHAR) {
      p2.maxFrac = i + 1;
    } else {
      p2.posSuf += ch;
    }
  }
  const groups = integer.split(GROUP_SEP);
  p2.gSize = groups[1] ? groups[1].length : 0;
  p2.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
  if (negative) {
    const trunkLen = positive.length - p2.posPre.length - p2.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);
    p2.negPre = negative.substring(0, pos).replace(/'/g, "");
    p2.negSuf = negative.slice(pos + trunkLen).replace(/'/g, "");
  } else {
    p2.negPre = minusSign + p2.posPre;
    p2.negSuf = p2.posSuf;
  }
  return p2;
}
function toPercent(parsedNumber) {
  if (parsedNumber.digits[0] === 0) {
    return parsedNumber;
  }
  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
  if (parsedNumber.exponent) {
    parsedNumber.exponent += 2;
  } else {
    if (fractionLen === 0) {
      parsedNumber.digits.push(0, 0);
    } else if (fractionLen === 1) {
      parsedNumber.digits.push(0);
    }
    parsedNumber.integerLen += 2;
  }
  return parsedNumber;
}
function parseNumber(num) {
  let numStr = Math.abs(num) + "";
  let exponent = 0, digits, integerLen;
  let i, j, zeros;
  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
    numStr = numStr.replace(DECIMAL_SEP, "");
  }
  if ((i = numStr.search(/e/i)) > 0) {
    if (integerLen < 0) integerLen = i;
    integerLen += +numStr.slice(i + 1);
    numStr = numStr.substring(0, i);
  } else if (integerLen < 0) {
    integerLen = numStr.length;
  }
  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
  }
  if (i === (zeros = numStr.length)) {
    digits = [0];
    integerLen = 1;
  } else {
    zeros--;
    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
    integerLen -= i;
    digits = [];
    for (j = 0; i <= zeros; i++, j++) {
      digits[j] = Number(numStr.charAt(i));
    }
  }
  if (integerLen > MAX_DIGITS) {
    digits = digits.splice(0, MAX_DIGITS - 1);
    exponent = integerLen - 1;
    integerLen = 1;
  }
  return {
    digits,
    exponent,
    integerLen
  };
}
function roundNumber(parsedNumber, minFrac, maxFrac) {
  if (minFrac > maxFrac) {
    throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
  }
  let digits = parsedNumber.digits;
  let fractionLen = digits.length - parsedNumber.integerLen;
  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
  let roundAt = fractionSize + parsedNumber.integerLen;
  let digit = digits[roundAt];
  if (roundAt > 0) {
    digits.splice(Math.max(parsedNumber.integerLen, roundAt));
    for (let j = roundAt; j < digits.length; j++) {
      digits[j] = 0;
    }
  } else {
    fractionLen = Math.max(0, fractionLen);
    parsedNumber.integerLen = 1;
    digits.length = Math.max(1, roundAt = fractionSize + 1);
    digits[0] = 0;
    for (let i = 1; i < roundAt; i++) digits[i] = 0;
  }
  if (digit >= 5) {
    if (roundAt - 1 < 0) {
      for (let k = 0; k > roundAt; k--) {
        digits.unshift(0);
        parsedNumber.integerLen++;
      }
      digits.unshift(1);
      parsedNumber.integerLen++;
    } else {
      digits[roundAt - 1]++;
    }
  }
  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
  let dropTrailingZeros = fractionSize !== 0;
  const minLen = minFrac + parsedNumber.integerLen;
  const carry = digits.reduceRight(function(carry2, d, i, digits2) {
    d = d + carry2;
    digits2[i] = d < 10 ? d : d - 10;
    if (dropTrailingZeros) {
      if (digits2[i] === 0 && i >= minLen) {
        digits2.pop();
      } else {
        dropTrailingZeros = false;
      }
    }
    return d >= 10 ? 1 : 0;
  }, 0);
  if (carry) {
    digits.unshift(carry);
    parsedNumber.integerLen++;
  }
}
function parseIntAutoRadix(text2) {
  const result = parseInt(text2);
  if (isNaN(result)) {
    throw new Error("Invalid integer literal when parsing " + text2);
  }
  return result;
}
var NgLocalization = class _NgLocalization {
  static \u0275fac = function NgLocalization_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgLocalization)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NgLocalization,
    factory: function NgLocalization_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new __ngFactoryType__();
      } else {
        __ngConditionalFactory__ = ((locale3) => new NgLocaleLocalization(locale3))(\u0275\u0275inject(LOCALE_ID));
      }
      return __ngConditionalFactory__;
    },
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocalization, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: (locale3) => new NgLocaleLocalization(locale3),
      deps: [LOCALE_ID]
    }]
  }], null, null);
})();
function getPluralCategory(value2, cases, ngLocalization, locale3) {
  let key = `=${value2}`;
  if (cases.indexOf(key) > -1) {
    return key;
  }
  key = ngLocalization.getPluralCategory(value2, locale3);
  if (cases.indexOf(key) > -1) {
    return key;
  }
  if (cases.indexOf("other") > -1) {
    return "other";
  }
  throw new Error(`No plural message found for value "${value2}"`);
}
var NgLocaleLocalization = class _NgLocaleLocalization extends NgLocalization {
  locale;
  constructor(locale3) {
    super();
    this.locale = locale3;
  }
  getPluralCategory(value2, locale3) {
    const plural2 = getLocalePluralCase2(locale3 || this.locale)(value2);
    switch (plural2) {
      case Plural.Zero:
        return "zero";
      case Plural.One:
        return "one";
      case Plural.Two:
        return "two";
      case Plural.Few:
        return "few";
      case Plural.Many:
        return "many";
      default:
        return "other";
    }
  }
  static \u0275fac = function NgLocaleLocalization_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgLocaleLocalization)(\u0275\u0275inject(LOCALE_ID));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NgLocaleLocalization,
    factory: _NgLocaleLocalization.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgLocaleLocalization, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
function parseCookieValue(cookieStr, name) {
  name = encodeURIComponent(name);
  for (const cookie of cookieStr.split(";")) {
    const eqIndex = cookie.indexOf("=");
    const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, ""] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
    if (cookieName.trim() === name) {
      return decodeURIComponent(cookieValue);
    }
  }
  return null;
}
var WS_REGEXP = /\s+/;
var EMPTY_ARRAY2 = [];
var NgClass = class _NgClass {
  _ngEl;
  _renderer;
  initialClasses = EMPTY_ARRAY2;
  rawClass;
  stateMap = /* @__PURE__ */ new Map();
  constructor(_ngEl, _renderer) {
    this._ngEl = _ngEl;
    this._renderer = _renderer;
  }
  set klass(value2) {
    this.initialClasses = value2 != null ? value2.trim().split(WS_REGEXP) : EMPTY_ARRAY2;
  }
  set ngClass(value2) {
    this.rawClass = typeof value2 === "string" ? value2.trim().split(WS_REGEXP) : value2;
  }
  /*
  The NgClass directive uses the custom change detection algorithm for its inputs. The custom
  algorithm is necessary since inputs are represented as complex object or arrays that need to be
  deeply-compared.
     This algorithm is perf-sensitive since NgClass is used very frequently and its poor performance
  might negatively impact runtime performance of the entire change detection cycle. The design of
  this algorithm is making sure that:
  - there is no unnecessary DOM manipulation (CSS classes are added / removed from the DOM only when
  needed), even if references to bound objects change;
  - there is no memory allocation if nothing changes (even relatively modest memory allocation
  during the change detection cycle can result in GC pauses for some of the CD cycles).
     The algorithm works by iterating over the set of bound classes, staring with [class] binding and
  then going over [ngClass] binding. For each CSS class name:
  - check if it was seen before (this information is tracked in the state map) and if its value
  changed;
  - mark it as "touched" - names that are not marked are not present in the latest set of binding
  and we can remove such class name from the internal data structures;
     After iteration over all the CSS class names we've got data structure with all the information
  necessary to synchronize changes to the DOM - it is enough to iterate over the state map, flush
  changes to the DOM and reset internal data structures so those are ready for the next change
  detection cycle.
   */
  ngDoCheck() {
    for (const klass of this.initialClasses) {
      this._updateState(klass, true);
    }
    const rawClass = this.rawClass;
    if (Array.isArray(rawClass) || rawClass instanceof Set) {
      for (const klass of rawClass) {
        this._updateState(klass, true);
      }
    } else if (rawClass != null) {
      for (const klass of Object.keys(rawClass)) {
        this._updateState(klass, Boolean(rawClass[klass]));
      }
    }
    this._applyStateDiff();
  }
  _updateState(klass, nextEnabled) {
    const state2 = this.stateMap.get(klass);
    if (state2 !== void 0) {
      if (state2.enabled !== nextEnabled) {
        state2.changed = true;
        state2.enabled = nextEnabled;
      }
      state2.touched = true;
    } else {
      this.stateMap.set(klass, {
        enabled: nextEnabled,
        changed: true,
        touched: true
      });
    }
  }
  _applyStateDiff() {
    for (const stateEntry of this.stateMap) {
      const klass = stateEntry[0];
      const state2 = stateEntry[1];
      if (state2.changed) {
        this._toggleClass(klass, state2.enabled);
        state2.changed = false;
      } else if (!state2.touched) {
        if (state2.enabled) {
          this._toggleClass(klass, false);
        }
        this.stateMap.delete(klass);
      }
      state2.touched = false;
    }
  }
  _toggleClass(klass, enabled) {
    if (ngDevMode) {
      if (typeof klass !== "string") {
        throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(klass)}`);
      }
    }
    klass = klass.trim();
    if (klass.length > 0) {
      klass.split(WS_REGEXP).forEach((klass2) => {
        if (enabled) {
          this._renderer.addClass(this._ngEl.nativeElement, klass2);
        } else {
          this._renderer.removeClass(this._ngEl.nativeElement, klass2);
        }
      });
    }
  }
  static \u0275fac = function NgClass_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgClass)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgClass,
    selectors: [["", "ngClass", ""]],
    inputs: {
      klass: [0, "class", "klass"],
      ngClass: "ngClass"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgClass, [{
    type: Directive,
    args: [{
      selector: "[ngClass]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    klass: [{
      type: Input,
      args: ["class"]
    }],
    ngClass: [{
      type: Input,
      args: ["ngClass"]
    }]
  });
})();
var NgComponentOutlet = class _NgComponentOutlet {
  _viewContainerRef;
  ngComponentOutlet = null;
  ngComponentOutletInputs;
  ngComponentOutletInjector;
  ngComponentOutletContent;
  ngComponentOutletNgModule;
  /**
   * @deprecated This input is deprecated, use `ngComponentOutletNgModule` instead.
   */
  ngComponentOutletNgModuleFactory;
  _componentRef;
  _moduleRef;
  /**
   * A helper data structure that allows us to track inputs that were part of the
   * ngComponentOutletInputs expression. Tracking inputs is necessary for proper removal of ones
   * that are no longer referenced.
   */
  _inputsUsed = /* @__PURE__ */ new Map();
  constructor(_viewContainerRef) {
    this._viewContainerRef = _viewContainerRef;
  }
  _needToReCreateNgModuleInstance(changes) {
    return changes["ngComponentOutletNgModule"] !== void 0 || changes["ngComponentOutletNgModuleFactory"] !== void 0;
  }
  _needToReCreateComponentInstance(changes) {
    return changes["ngComponentOutlet"] !== void 0 || changes["ngComponentOutletContent"] !== void 0 || changes["ngComponentOutletInjector"] !== void 0 || this._needToReCreateNgModuleInstance(changes);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._needToReCreateComponentInstance(changes)) {
      this._viewContainerRef.clear();
      this._inputsUsed.clear();
      this._componentRef = void 0;
      if (this.ngComponentOutlet) {
        const injector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
        if (this._needToReCreateNgModuleInstance(changes)) {
          this._moduleRef?.destroy();
          if (this.ngComponentOutletNgModule) {
            this._moduleRef = createNgModule(this.ngComponentOutletNgModule, getParentInjector(injector));
          } else if (this.ngComponentOutletNgModuleFactory) {
            this._moduleRef = this.ngComponentOutletNgModuleFactory.create(getParentInjector(injector));
          } else {
            this._moduleRef = void 0;
          }
        }
        this._componentRef = this._viewContainerRef.createComponent(this.ngComponentOutlet, {
          injector,
          ngModuleRef: this._moduleRef,
          projectableNodes: this.ngComponentOutletContent
        });
      }
    }
  }
  /** @nodoc */
  ngDoCheck() {
    if (this._componentRef) {
      if (this.ngComponentOutletInputs) {
        for (const inputName of Object.keys(this.ngComponentOutletInputs)) {
          this._inputsUsed.set(inputName, true);
        }
      }
      this._applyInputStateDiff(this._componentRef);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this._moduleRef?.destroy();
  }
  _applyInputStateDiff(componentRef) {
    for (const [inputName, touched] of this._inputsUsed) {
      if (!touched) {
        componentRef.setInput(inputName, void 0);
        this._inputsUsed.delete(inputName);
      } else {
        componentRef.setInput(inputName, this.ngComponentOutletInputs[inputName]);
        this._inputsUsed.set(inputName, false);
      }
    }
  }
  static \u0275fac = function NgComponentOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgComponentOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgComponentOutlet,
    selectors: [["", "ngComponentOutlet", ""]],
    inputs: {
      ngComponentOutlet: "ngComponentOutlet",
      ngComponentOutletInputs: "ngComponentOutletInputs",
      ngComponentOutletInjector: "ngComponentOutletInjector",
      ngComponentOutletContent: "ngComponentOutletContent",
      ngComponentOutletNgModule: "ngComponentOutletNgModule",
      ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory"
    },
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgComponentOutlet, [{
    type: Directive,
    args: [{
      selector: "[ngComponentOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], {
    ngComponentOutlet: [{
      type: Input
    }],
    ngComponentOutletInputs: [{
      type: Input
    }],
    ngComponentOutletInjector: [{
      type: Input
    }],
    ngComponentOutletContent: [{
      type: Input
    }],
    ngComponentOutletNgModule: [{
      type: Input
    }],
    ngComponentOutletNgModuleFactory: [{
      type: Input
    }]
  });
})();
function getParentInjector(injector) {
  const parentNgModule = injector.get(NgModuleRef$1);
  return parentNgModule.injector;
}
var NgForOfContext = class {
  $implicit;
  ngForOf;
  index;
  count;
  constructor($implicit, ngForOf, index, count3) {
    this.$implicit = $implicit;
    this.ngForOf = ngForOf;
    this.index = index;
    this.count = count3;
  }
  // Indicates whether this is the first item in the collection.
  get first() {
    return this.index === 0;
  }
  // Indicates whether this is the last item in the collection.
  get last() {
    return this.index === this.count - 1;
  }
  // Indicates whether an index of this item in the collection is even.
  get even() {
    return this.index % 2 === 0;
  }
  // Indicates whether an index of this item in the collection is odd.
  get odd() {
    return !this.even;
  }
};
var NgForOf = class _NgForOf {
  _viewContainer;
  _template;
  _differs;
  /**
   * The value of the iterable expression, which can be used as a
   * [template input variable](guide/directives/structural-directives#shorthand).
   */
  set ngForOf(ngForOf) {
    this._ngForOf = ngForOf;
    this._ngForOfDirty = true;
  }
  /**
   * Specifies a custom `TrackByFunction` to compute the identity of items in an iterable.
   *
   * If a custom `TrackByFunction` is not provided, `NgForOf` will use the item's [object
   * identity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)
   * as the key.
   *
   * `NgForOf` uses the computed key to associate items in an iterable with DOM elements
   * it produces for these items.
   *
   * A custom `TrackByFunction` is useful to provide good user experience in cases when items in an
   * iterable rendered using `NgForOf` have a natural identifier (for example, custom ID or a
   * primary key), and this iterable could be updated with new object instances that still
   * represent the same underlying entity (for example, when data is re-fetched from the server,
   * and the iterable is recreated and re-rendered, but most of the data is still the same).
   *
   * @see {@link TrackByFunction}
   */
  set ngForTrackBy(fn) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`);
    }
    this._trackByFn = fn;
  }
  get ngForTrackBy() {
    return this._trackByFn;
  }
  _ngForOf = null;
  _ngForOfDirty = true;
  _differ = null;
  // TODO(issue/24571): remove '!'
  // waiting for microsoft/typescript#43662 to allow the return type `TrackByFunction|undefined` for
  // the getter
  _trackByFn;
  constructor(_viewContainer, _template, _differs) {
    this._viewContainer = _viewContainer;
    this._template = _template;
    this._differs = _differs;
  }
  /**
   * A reference to the template that is stamped out for each item in the iterable.
   * @see [template reference variable](guide/templates/variables#template-reference-variables)
   */
  set ngForTemplate(value2) {
    if (value2) {
      this._template = value2;
    }
  }
  /**
   * Applies the changes when needed.
   * @nodoc
   */
  ngDoCheck() {
    if (this._ngForOfDirty) {
      this._ngForOfDirty = false;
      const value2 = this._ngForOf;
      if (!this._differ && value2) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          try {
            this._differ = this._differs.find(value2).create(this.ngForTrackBy);
          } catch {
            let errorMessage = `Cannot find a differ supporting object '${value2}' of type '${getTypeName(value2)}'. NgFor only supports binding to Iterables, such as Arrays.`;
            if (typeof value2 === "object") {
              errorMessage += " Did you mean to use the keyvalue pipe?";
            }
            throw new RuntimeError(-2200, errorMessage);
          }
        } else {
          this._differ = this._differs.find(value2).create(this.ngForTrackBy);
        }
      }
    }
    if (this._differ) {
      const changes = this._differ.diff(this._ngForOf);
      if (changes) this._applyChanges(changes);
    }
  }
  _applyChanges(changes) {
    const viewContainer = this._viewContainer;
    changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
      if (item.previousIndex == null) {
        viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);
      } else if (currentIndex == null) {
        viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
      } else if (adjustedPreviousIndex !== null) {
        const view = viewContainer.get(adjustedPreviousIndex);
        viewContainer.move(view, currentIndex);
        applyViewChange(view, item);
      }
    });
    for (let i = 0, ilen = viewContainer.length; i < ilen; i++) {
      const viewRef = viewContainer.get(i);
      const context2 = viewRef.context;
      context2.index = i;
      context2.count = ilen;
      context2.ngForOf = this._ngForOf;
    }
    changes.forEachIdentityChange((record) => {
      const viewRef = viewContainer.get(record.currentIndex);
      applyViewChange(viewRef, record);
    });
  }
  /**
   * Asserts the correct type of the context for the template that `NgForOf` will render.
   *
   * The presence of this method is a signal to the Ivy template type-check compiler that the
   * `NgForOf` structural directive renders its template with a specific context type.
   */
  static ngTemplateContextGuard(dir, ctx) {
    return true;
  }
  static \u0275fac = function NgForOf_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgForOf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(IterableDiffers));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgForOf,
    selectors: [["", "ngFor", "", "ngForOf", ""]],
    inputs: {
      ngForOf: "ngForOf",
      ngForTrackBy: "ngForTrackBy",
      ngForTemplate: "ngForTemplate"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForOf, [{
    type: Directive,
    args: [{
      selector: "[ngFor][ngForOf]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: IterableDiffers
  }], {
    ngForOf: [{
      type: Input
    }],
    ngForTrackBy: [{
      type: Input
    }],
    ngForTemplate: [{
      type: Input
    }]
  });
})();
function applyViewChange(view, record) {
  view.context.$implicit = record.item;
}
function getTypeName(type2) {
  return type2["name"] || typeof type2;
}
var NgIf = class _NgIf {
  _viewContainer;
  _context = new NgIfContext();
  _thenTemplateRef = null;
  _elseTemplateRef = null;
  _thenViewRef = null;
  _elseViewRef = null;
  constructor(_viewContainer, templateRef) {
    this._viewContainer = _viewContainer;
    this._thenTemplateRef = templateRef;
  }
  /**
   * The Boolean expression to evaluate as the condition for showing a template.
   */
  set ngIf(condition) {
    this._context.$implicit = this._context.ngIf = condition;
    this._updateView();
  }
  /**
   * A template to show if the condition expression evaluates to true.
   */
  set ngIfThen(templateRef) {
    assertTemplate("ngIfThen", templateRef);
    this._thenTemplateRef = templateRef;
    this._thenViewRef = null;
    this._updateView();
  }
  /**
   * A template to show if the condition expression evaluates to false.
   */
  set ngIfElse(templateRef) {
    assertTemplate("ngIfElse", templateRef);
    this._elseTemplateRef = templateRef;
    this._elseViewRef = null;
    this._updateView();
  }
  _updateView() {
    if (this._context.$implicit) {
      if (!this._thenViewRef) {
        this._viewContainer.clear();
        this._elseViewRef = null;
        if (this._thenTemplateRef) {
          this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
        }
      }
    } else {
      if (!this._elseViewRef) {
        this._viewContainer.clear();
        this._thenViewRef = null;
        if (this._elseTemplateRef) {
          this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
        }
      }
    }
  }
  /** @internal */
  static ngIfUseIfTypeGuard;
  /**
   * Assert the correct type of the expression bound to the `ngIf` input within the template.
   *
   * The presence of this static field is a signal to the Ivy template type check compiler that
   * when the `NgIf` structural directive renders its template, the type of the expression bound
   * to `ngIf` should be narrowed in some way. For `NgIf`, the binding expression itself is used to
   * narrow its type, which allows the strictNullChecks feature of TypeScript to work with `NgIf`.
   */
  static ngTemplateGuard_ngIf;
  /**
   * Asserts the correct type of the context for the template that `NgIf` will render.
   *
   * The presence of this method is a signal to the Ivy template type-check compiler that the
   * `NgIf` structural directive renders its template with a specific context type.
   */
  static ngTemplateContextGuard(dir, ctx) {
    return true;
  }
  static \u0275fac = function NgIf_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgIf)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgIf,
    selectors: [["", "ngIf", ""]],
    inputs: {
      ngIf: "ngIf",
      ngIfThen: "ngIfThen",
      ngIfElse: "ngIfElse"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgIf, [{
    type: Directive,
    args: [{
      selector: "[ngIf]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }], {
    ngIf: [{
      type: Input
    }],
    ngIfThen: [{
      type: Input
    }],
    ngIfElse: [{
      type: Input
    }]
  });
})();
var NgIfContext = class {
  $implicit = null;
  ngIf = null;
};
function assertTemplate(property, templateRef) {
  const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
  if (!isTemplateRefOrNull) {
    throw new Error(`${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
  }
}
var SwitchView = class {
  _viewContainerRef;
  _templateRef;
  _created = false;
  constructor(_viewContainerRef, _templateRef) {
    this._viewContainerRef = _viewContainerRef;
    this._templateRef = _templateRef;
  }
  create() {
    this._created = true;
    this._viewContainerRef.createEmbeddedView(this._templateRef);
  }
  destroy() {
    this._created = false;
    this._viewContainerRef.clear();
  }
  enforceState(created) {
    if (created && !this._created) {
      this.create();
    } else if (!created && this._created) {
      this.destroy();
    }
  }
};
var NgSwitch = class _NgSwitch {
  _defaultViews = [];
  _defaultUsed = false;
  _caseCount = 0;
  _lastCaseCheckIndex = 0;
  _lastCasesMatched = false;
  _ngSwitch;
  set ngSwitch(newValue) {
    this._ngSwitch = newValue;
    if (this._caseCount === 0) {
      this._updateDefaultCases(true);
    }
  }
  /** @internal */
  _addCase() {
    return this._caseCount++;
  }
  /** @internal */
  _addDefault(view) {
    this._defaultViews.push(view);
  }
  /** @internal */
  _matchCase(value2) {
    const matched = value2 === this._ngSwitch;
    this._lastCasesMatched ||= matched;
    this._lastCaseCheckIndex++;
    if (this._lastCaseCheckIndex === this._caseCount) {
      this._updateDefaultCases(!this._lastCasesMatched);
      this._lastCaseCheckIndex = 0;
      this._lastCasesMatched = false;
    }
    return matched;
  }
  _updateDefaultCases(useDefault) {
    if (this._defaultViews.length > 0 && useDefault !== this._defaultUsed) {
      this._defaultUsed = useDefault;
      for (const defaultView of this._defaultViews) {
        defaultView.enforceState(useDefault);
      }
    }
  }
  static \u0275fac = function NgSwitch_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgSwitch)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgSwitch,
    selectors: [["", "ngSwitch", ""]],
    inputs: {
      ngSwitch: "ngSwitch"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitch, [{
    type: Directive,
    args: [{
      selector: "[ngSwitch]",
      standalone: true
    }]
  }], null, {
    ngSwitch: [{
      type: Input
    }]
  });
})();
var NgSwitchCase = class _NgSwitchCase {
  ngSwitch;
  _view;
  /**
   * Stores the HTML template to be selected on match.
   */
  ngSwitchCase;
  constructor(viewContainer, templateRef, ngSwitch) {
    this.ngSwitch = ngSwitch;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
      throwNgSwitchProviderNotFoundError("ngSwitchCase", "NgSwitchCase");
    }
    ngSwitch._addCase();
    this._view = new SwitchView(viewContainer, templateRef);
  }
  /**
   * Performs case matching. For internal use only.
   * @nodoc
   */
  ngDoCheck() {
    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
  }
  static \u0275fac = function NgSwitchCase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgSwitchCase)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgSwitchCase,
    selectors: [["", "ngSwitchCase", ""]],
    inputs: {
      ngSwitchCase: "ngSwitchCase"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchCase, [{
    type: Directive,
    args: [{
      selector: "[ngSwitchCase]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: NgSwitch,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngSwitchCase: [{
      type: Input
    }]
  });
})();
var NgSwitchDefault = class _NgSwitchDefault {
  constructor(viewContainer, templateRef, ngSwitch) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
      throwNgSwitchProviderNotFoundError("ngSwitchDefault", "NgSwitchDefault");
    }
    ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
  }
  static \u0275fac = function NgSwitchDefault_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgSwitchDefault)(\u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(NgSwitch, 9));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgSwitchDefault,
    selectors: [["", "ngSwitchDefault", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSwitchDefault, [{
    type: Directive,
    args: [{
      selector: "[ngSwitchDefault]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: NgSwitch,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], null);
})();
function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
  throw new RuntimeError(2e3, `An element with the "${attrName}" attribute (matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute (matching "NgSwitch" directive)`);
}
var NgPlural = class _NgPlural {
  _localization;
  _activeView;
  _caseViews = {};
  constructor(_localization) {
    this._localization = _localization;
  }
  set ngPlural(value2) {
    this._updateView(value2);
  }
  addCase(value2, switchView) {
    this._caseViews[value2] = switchView;
  }
  _updateView(switchValue) {
    this._clearViews();
    const cases = Object.keys(this._caseViews);
    const key = getPluralCategory(switchValue, cases, this._localization);
    this._activateView(this._caseViews[key]);
  }
  _clearViews() {
    if (this._activeView) this._activeView.destroy();
  }
  _activateView(view) {
    if (view) {
      this._activeView = view;
      this._activeView.create();
    }
  }
  static \u0275fac = function NgPlural_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgPlural)(\u0275\u0275directiveInject(NgLocalization));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgPlural,
    selectors: [["", "ngPlural", ""]],
    inputs: {
      ngPlural: "ngPlural"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPlural, [{
    type: Directive,
    args: [{
      selector: "[ngPlural]",
      standalone: true
    }]
  }], () => [{
    type: NgLocalization
  }], {
    ngPlural: [{
      type: Input
    }]
  });
})();
var NgPluralCase = class _NgPluralCase {
  value;
  constructor(value2, template, viewContainer, ngPlural) {
    this.value = value2;
    const isANumber = !isNaN(Number(value2));
    ngPlural.addCase(isANumber ? `=${value2}` : value2, new SwitchView(viewContainer, template));
  }
  static \u0275fac = function NgPluralCase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgPluralCase)(\u0275\u0275injectAttribute("ngPluralCase"), \u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NgPlural, 1));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgPluralCase,
    selectors: [["", "ngPluralCase", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgPluralCase, [{
    type: Directive,
    args: [{
      selector: "[ngPluralCase]",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["ngPluralCase"]
    }]
  }, {
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: NgPlural,
    decorators: [{
      type: Host
    }]
  }], null);
})();
var NgStyle = class _NgStyle {
  _ngEl;
  _differs;
  _renderer;
  _ngStyle = null;
  _differ = null;
  constructor(_ngEl, _differs, _renderer) {
    this._ngEl = _ngEl;
    this._differs = _differs;
    this._renderer = _renderer;
  }
  set ngStyle(values) {
    this._ngStyle = values;
    if (!this._differ && values) {
      this._differ = this._differs.find(values).create();
    }
  }
  ngDoCheck() {
    if (this._differ) {
      const changes = this._differ.diff(this._ngStyle);
      if (changes) {
        this._applyChanges(changes);
      }
    }
  }
  _setStyle(nameAndUnit, value2) {
    const [name, unit2] = nameAndUnit.split(".");
    const flags = name.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
    if (value2 != null) {
      this._renderer.setStyle(this._ngEl.nativeElement, name, unit2 ? `${value2}${unit2}` : value2, flags);
    } else {
      this._renderer.removeStyle(this._ngEl.nativeElement, name, flags);
    }
  }
  _applyChanges(changes) {
    changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
    changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
    changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
  }
  static \u0275fac = function NgStyle_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgStyle)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(KeyValueDiffers), \u0275\u0275directiveInject(Renderer2));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgStyle,
    selectors: [["", "ngStyle", ""]],
    inputs: {
      ngStyle: "ngStyle"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgStyle, [{
    type: Directive,
    args: [{
      selector: "[ngStyle]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: KeyValueDiffers
  }, {
    type: Renderer2
  }], {
    ngStyle: [{
      type: Input,
      args: ["ngStyle"]
    }]
  });
})();
var NgTemplateOutlet = class _NgTemplateOutlet {
  _viewContainerRef;
  _viewRef = null;
  /**
   * A context object to attach to the {@link EmbeddedViewRef}. This should be an
   * object, the object's keys will be available for binding by the local template `let`
   * declarations.
   * Using the key `$implicit` in the context object will set its value as default.
   */
  ngTemplateOutletContext = null;
  /**
   * A string defining the template reference and optionally the context object for the template.
   */
  ngTemplateOutlet = null;
  /** Injector to be used within the embedded view. */
  ngTemplateOutletInjector = null;
  constructor(_viewContainerRef) {
    this._viewContainerRef = _viewContainerRef;
  }
  ngOnChanges(changes) {
    if (this._shouldRecreateView(changes)) {
      const viewContainerRef = this._viewContainerRef;
      if (this._viewRef) {
        viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
      }
      if (!this.ngTemplateOutlet) {
        this._viewRef = null;
        return;
      }
      const viewContext = this._createContextForwardProxy();
      this._viewRef = viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, viewContext, {
        injector: this.ngTemplateOutletInjector ?? void 0
      });
    }
  }
  /**
   * We need to re-create existing embedded view if either is true:
   * - the outlet changed.
   * - the injector changed.
   */
  _shouldRecreateView(changes) {
    return !!changes["ngTemplateOutlet"] || !!changes["ngTemplateOutletInjector"];
  }
  /**
   * For a given outlet instance, we create a proxy object that delegates
   * to the user-specified context. This allows changing, or swapping out
   * the context object completely without having to destroy/re-create the view.
   */
  _createContextForwardProxy() {
    return new Proxy({}, {
      set: (_target, prop, newValue) => {
        if (!this.ngTemplateOutletContext) {
          return false;
        }
        return Reflect.set(this.ngTemplateOutletContext, prop, newValue);
      },
      get: (_target, prop, receiver) => {
        if (!this.ngTemplateOutletContext) {
          return void 0;
        }
        return Reflect.get(this.ngTemplateOutletContext, prop, receiver);
      }
    });
  }
  static \u0275fac = function NgTemplateOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgTemplateOutlet)(\u0275\u0275directiveInject(ViewContainerRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgTemplateOutlet,
    selectors: [["", "ngTemplateOutlet", ""]],
    inputs: {
      ngTemplateOutletContext: "ngTemplateOutletContext",
      ngTemplateOutlet: "ngTemplateOutlet",
      ngTemplateOutletInjector: "ngTemplateOutletInjector"
    },
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgTemplateOutlet, [{
    type: Directive,
    args: [{
      selector: "[ngTemplateOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], {
    ngTemplateOutletContext: [{
      type: Input
    }],
    ngTemplateOutlet: [{
      type: Input
    }],
    ngTemplateOutletInjector: [{
      type: Input
    }]
  });
})();
var COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];
function invalidPipeArgumentError(type2, value2) {
  return new RuntimeError(2100, ngDevMode && `InvalidPipeArgument: '${value2}' for pipe '${stringify(type2)}'`);
}
var SubscribableStrategy = class {
  createSubscription(async2, updateLatestValue) {
    return untracked(() => async2.subscribe({
      next: updateLatestValue,
      error: (e) => {
        throw e;
      }
    }));
  }
  dispose(subscription) {
    untracked(() => subscription.unsubscribe());
  }
};
var PromiseStrategy = class {
  createSubscription(async2, updateLatestValue) {
    return async2.then(updateLatestValue, (e) => {
      throw e;
    });
  }
  dispose(subscription) {
  }
};
var _promiseStrategy = new PromiseStrategy();
var _subscribableStrategy = new SubscribableStrategy();
var AsyncPipe = class _AsyncPipe {
  _ref;
  _latestValue = null;
  markForCheckOnValueUpdate = true;
  _subscription = null;
  _obj = null;
  _strategy = null;
  constructor(ref) {
    this._ref = ref;
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._dispose();
    }
    this._ref = null;
  }
  transform(obj) {
    if (!this._obj) {
      if (obj) {
        try {
          this.markForCheckOnValueUpdate = false;
          this._subscribe(obj);
        } finally {
          this.markForCheckOnValueUpdate = true;
        }
      }
      return this._latestValue;
    }
    if (obj !== this._obj) {
      this._dispose();
      return this.transform(obj);
    }
    return this._latestValue;
  }
  _subscribe(obj) {
    this._obj = obj;
    this._strategy = this._selectStrategy(obj);
    this._subscription = this._strategy.createSubscription(obj, (value2) => this._updateLatestValue(obj, value2));
  }
  _selectStrategy(obj) {
    if (isPromise2(obj)) {
      return _promiseStrategy;
    }
    if (isSubscribable(obj)) {
      return _subscribableStrategy;
    }
    throw invalidPipeArgumentError(_AsyncPipe, obj);
  }
  _dispose() {
    this._strategy.dispose(this._subscription);
    this._latestValue = null;
    this._subscription = null;
    this._obj = null;
  }
  _updateLatestValue(async2, value2) {
    if (async2 === this._obj) {
      this._latestValue = value2;
      if (this.markForCheckOnValueUpdate) {
        this._ref?.markForCheck();
      }
    }
  }
  static \u0275fac = function AsyncPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AsyncPipe)(\u0275\u0275directiveInject(ChangeDetectorRef, 16));
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "async",
    type: _AsyncPipe,
    pure: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AsyncPipe, [{
    type: Pipe,
    args: [{
      name: "async",
      pure: false,
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], null);
})();
var LowerCasePipe = class _LowerCasePipe {
  transform(value2) {
    if (value2 == null) return null;
    if (typeof value2 !== "string") {
      throw invalidPipeArgumentError(_LowerCasePipe, value2);
    }
    return value2.toLowerCase();
  }
  static \u0275fac = function LowerCasePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LowerCasePipe)();
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "lowercase",
    type: _LowerCasePipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LowerCasePipe, [{
    type: Pipe,
    args: [{
      name: "lowercase",
      standalone: true
    }]
  }], null, null);
})();
var unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
var TitleCasePipe = class _TitleCasePipe {
  transform(value2) {
    if (value2 == null) return null;
    if (typeof value2 !== "string") {
      throw invalidPipeArgumentError(_TitleCasePipe, value2);
    }
    return value2.replace(unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.slice(1).toLowerCase());
  }
  static \u0275fac = function TitleCasePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TitleCasePipe)();
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "titlecase",
    type: _TitleCasePipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleCasePipe, [{
    type: Pipe,
    args: [{
      name: "titlecase",
      standalone: true
    }]
  }], null, null);
})();
var UpperCasePipe = class _UpperCasePipe {
  transform(value2) {
    if (value2 == null) return null;
    if (typeof value2 !== "string") {
      throw invalidPipeArgumentError(_UpperCasePipe, value2);
    }
    return value2.toUpperCase();
  }
  static \u0275fac = function UpperCasePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UpperCasePipe)();
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "uppercase",
    type: _UpperCasePipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UpperCasePipe, [{
    type: Pipe,
    args: [{
      name: "uppercase",
      standalone: true
    }]
  }], null, null);
})();
var DEFAULT_DATE_FORMAT = "mediumDate";
var DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_TIMEZONE" : "");
var DATE_PIPE_DEFAULT_OPTIONS = new InjectionToken(ngDevMode ? "DATE_PIPE_DEFAULT_OPTIONS" : "");
var DatePipe = class _DatePipe {
  locale;
  defaultTimezone;
  defaultOptions;
  constructor(locale3, defaultTimezone, defaultOptions) {
    this.locale = locale3;
    this.defaultTimezone = defaultTimezone;
    this.defaultOptions = defaultOptions;
  }
  transform(value2, format2, timezone, locale3) {
    if (value2 == null || value2 === "" || value2 !== value2) return null;
    try {
      const _format = format2 ?? this.defaultOptions?.dateFormat ?? DEFAULT_DATE_FORMAT;
      const _timezone = timezone ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0;
      return formatDate(value2, _format, locale3 || this.locale, _timezone);
    } catch (error) {
      throw invalidPipeArgumentError(_DatePipe, error.message);
    }
  }
  static \u0275fac = function DatePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DatePipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24), \u0275\u0275directiveInject(DATE_PIPE_DEFAULT_OPTIONS, 24));
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "date",
    type: _DatePipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePipe, [{
    type: Pipe,
    args: [{
      name: "date",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DATE_PIPE_DEFAULT_TIMEZONE]
    }, {
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DATE_PIPE_DEFAULT_OPTIONS]
    }, {
      type: Optional
    }]
  }], null);
})();
var _INTERPOLATION_REGEXP = /#/g;
var I18nPluralPipe = class _I18nPluralPipe {
  _localization;
  constructor(_localization) {
    this._localization = _localization;
  }
  /**
   * @param value the number to be formatted
   * @param pluralMap an object that mimics the ICU format, see
   * https://unicode-org.github.io/icu/userguide/format_parse/messages/.
   * @param locale a `string` defining the locale to use (uses the current {@link LOCALE_ID} by
   * default).
   */
  transform(value2, pluralMap, locale3) {
    if (value2 == null) return "";
    if (typeof pluralMap !== "object" || pluralMap === null) {
      throw invalidPipeArgumentError(_I18nPluralPipe, pluralMap);
    }
    const key = getPluralCategory(value2, Object.keys(pluralMap), this._localization, locale3);
    return pluralMap[key].replace(_INTERPOLATION_REGEXP, value2.toString());
  }
  static \u0275fac = function I18nPluralPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _I18nPluralPipe)(\u0275\u0275directiveInject(NgLocalization, 16));
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "i18nPlural",
    type: _I18nPluralPipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nPluralPipe, [{
    type: Pipe,
    args: [{
      name: "i18nPlural",
      standalone: true
    }]
  }], () => [{
    type: NgLocalization
  }], null);
})();
var I18nSelectPipe = class _I18nSelectPipe {
  /**
   * @param value a string to be internationalized.
   * @param mapping an object that indicates the text that should be displayed
   * for different values of the provided `value`.
   */
  transform(value2, mapping) {
    if (value2 == null) return "";
    if (typeof mapping !== "object" || typeof value2 !== "string") {
      throw invalidPipeArgumentError(_I18nSelectPipe, mapping);
    }
    if (mapping.hasOwnProperty(value2)) {
      return mapping[value2];
    }
    if (mapping.hasOwnProperty("other")) {
      return mapping["other"];
    }
    return "";
  }
  static \u0275fac = function I18nSelectPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _I18nSelectPipe)();
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "i18nSelect",
    type: _I18nSelectPipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(I18nSelectPipe, [{
    type: Pipe,
    args: [{
      name: "i18nSelect",
      standalone: true
    }]
  }], null, null);
})();
var JsonPipe = class _JsonPipe {
  /**
   * @param value A value of any type to convert into a JSON-format string.
   */
  transform(value2) {
    return JSON.stringify(value2, null, 2);
  }
  static \u0275fac = function JsonPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _JsonPipe)();
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "json",
    type: _JsonPipe,
    pure: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonPipe, [{
    type: Pipe,
    args: [{
      name: "json",
      pure: false,
      standalone: true
    }]
  }], null, null);
})();
function makeKeyValuePair(key, value2) {
  return {
    key,
    value: value2
  };
}
var KeyValuePipe = class _KeyValuePipe {
  differs;
  constructor(differs) {
    this.differs = differs;
  }
  differ;
  keyValues = [];
  compareFn = defaultComparator;
  transform(input2, compareFn = defaultComparator) {
    if (!input2 || !(input2 instanceof Map) && typeof input2 !== "object") {
      return null;
    }
    this.differ ??= this.differs.find(input2).create();
    const differChanges = this.differ.diff(input2);
    const compareFnChanged = compareFn !== this.compareFn;
    if (differChanges) {
      this.keyValues = [];
      differChanges.forEachItem((r2) => {
        this.keyValues.push(makeKeyValuePair(r2.key, r2.currentValue));
      });
    }
    if (differChanges || compareFnChanged) {
      if (compareFn) {
        this.keyValues.sort(compareFn);
      }
      this.compareFn = compareFn;
    }
    return this.keyValues;
  }
  static \u0275fac = function KeyValuePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _KeyValuePipe)(\u0275\u0275directiveInject(KeyValueDiffers, 16));
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "keyvalue",
    type: _KeyValuePipe,
    pure: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyValuePipe, [{
    type: Pipe,
    args: [{
      name: "keyvalue",
      pure: false,
      standalone: true
    }]
  }], () => [{
    type: KeyValueDiffers
  }], null);
})();
function defaultComparator(keyValueA, keyValueB) {
  const a = keyValueA.key;
  const b = keyValueB.key;
  if (a === b) return 0;
  if (a === void 0) return 1;
  if (b === void 0) return -1;
  if (a === null) return 1;
  if (b === null) return -1;
  if (typeof a == "string" && typeof b == "string") {
    return a < b ? -1 : 1;
  }
  if (typeof a == "number" && typeof b == "number") {
    return a - b;
  }
  if (typeof a == "boolean" && typeof b == "boolean") {
    return a < b ? -1 : 1;
  }
  const aString = String(a);
  const bString = String(b);
  return aString == bString ? 0 : aString < bString ? -1 : 1;
}
var DecimalPipe = class _DecimalPipe {
  _locale;
  constructor(_locale) {
    this._locale = _locale;
  }
  transform(value2, digitsInfo, locale3) {
    if (!isValue(value2)) return null;
    locale3 ||= this._locale;
    try {
      const num = strToNumber(value2);
      return formatNumber(num, locale3, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_DecimalPipe, error.message);
    }
  }
  static \u0275fac = function DecimalPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DecimalPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "number",
    type: _DecimalPipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecimalPipe, [{
    type: Pipe,
    args: [{
      name: "number",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var PercentPipe = class _PercentPipe {
  _locale;
  constructor(_locale) {
    this._locale = _locale;
  }
  /**
   *
   * @param value The number to be formatted as a percentage.
   * @param digitsInfo Decimal representation options, specified by a string
   * in the following format:<br>
   * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
   *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
   * Default is `1`.
   *   - `minFractionDigits`: The minimum number of digits after the decimal point.
   * Default is `0`.
   *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
   * Default is `0`.
   * @param locale A locale code for the locale format rules to use.
   * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
   * See [Setting your app locale](guide/i18n/locale-id).
   */
  transform(value2, digitsInfo, locale3) {
    if (!isValue(value2)) return null;
    locale3 ||= this._locale;
    try {
      const num = strToNumber(value2);
      return formatPercent(num, locale3, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_PercentPipe, error.message);
    }
  }
  static \u0275fac = function PercentPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PercentPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16));
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "percent",
    type: _PercentPipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PercentPipe, [{
    type: Pipe,
    args: [{
      name: "percent",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var CurrencyPipe = class _CurrencyPipe {
  _locale;
  _defaultCurrencyCode;
  constructor(_locale, _defaultCurrencyCode = "USD") {
    this._locale = _locale;
    this._defaultCurrencyCode = _defaultCurrencyCode;
  }
  transform(value2, currencyCode = this._defaultCurrencyCode, display = "symbol", digitsInfo, locale3) {
    if (!isValue(value2)) return null;
    locale3 ||= this._locale;
    if (typeof display === "boolean") {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && console && console.warn) {
        console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
      }
      display = display ? "symbol" : "code";
    }
    let currency = currencyCode || this._defaultCurrencyCode;
    if (display !== "code") {
      if (display === "symbol" || display === "symbol-narrow") {
        currency = getCurrencySymbol(currency, display === "symbol" ? "wide" : "narrow", locale3);
      } else {
        currency = display;
      }
    }
    try {
      const num = strToNumber(value2);
      return formatCurrency(num, locale3, currency, currencyCode, digitsInfo);
    } catch (error) {
      throw invalidPipeArgumentError(_CurrencyPipe, error.message);
    }
  }
  static \u0275fac = function CurrencyPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CurrencyPipe)(\u0275\u0275directiveInject(LOCALE_ID, 16), \u0275\u0275directiveInject(DEFAULT_CURRENCY_CODE, 16));
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "currency",
    type: _CurrencyPipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CurrencyPipe, [{
    type: Pipe,
    args: [{
      name: "currency",
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DEFAULT_CURRENCY_CODE]
    }]
  }], null);
})();
function isValue(value2) {
  return !(value2 == null || value2 === "" || value2 !== value2);
}
function strToNumber(value2) {
  if (typeof value2 === "string" && !isNaN(Number(value2) - parseFloat(value2))) {
    return Number(value2);
  }
  if (typeof value2 !== "number") {
    throw new Error(`${value2} is not a number`);
  }
  return value2;
}
var SlicePipe = class _SlicePipe {
  transform(value2, start2, end2) {
    if (value2 == null) return null;
    if (!this.supports(value2)) {
      throw invalidPipeArgumentError(_SlicePipe, value2);
    }
    return value2.slice(start2, end2);
  }
  supports(obj) {
    return typeof obj === "string" || Array.isArray(obj);
  }
  static \u0275fac = function SlicePipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SlicePipe)();
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "slice",
    type: _SlicePipe,
    pure: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SlicePipe, [{
    type: Pipe,
    args: [{
      name: "slice",
      pure: false,
      standalone: true
    }]
  }], null, null);
})();
var COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];
var CommonModule = class _CommonModule {
  static \u0275fac = function CommonModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CommonModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _CommonModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommonModule, [{
    type: NgModule,
    args: [{
      imports: [COMMON_DIRECTIVES, COMMON_PIPES],
      exports: [COMMON_DIRECTIVES, COMMON_PIPES]
    }]
  }], null, null);
})();
var PLATFORM_BROWSER_ID = "browser";
var PLATFORM_SERVER_ID = "server";
function isPlatformBrowser(platformId) {
  return platformId === PLATFORM_BROWSER_ID;
}
function isPlatformServer(platformId) {
  return platformId === PLATFORM_SERVER_ID;
}
var VERSION2 = new Version("19.0.1");
var ViewportScroller = class _ViewportScroller {
  // De-sugared tree-shakable injection
  // See #23917
  /** @nocollapse */
  static \u0275prov = (
    /** @pureOrBreakMyCode */
    /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ViewportScroller,
      providedIn: "root",
      factory: () => isPlatformBrowser(inject(PLATFORM_ID)) ? new BrowserViewportScroller(inject(DOCUMENT2), window) : new NullViewportScroller()
    })
  );
};
var BrowserViewportScroller = class {
  document;
  window;
  offset = () => [0, 0];
  constructor(document2, window2) {
    this.document = document2;
    this.window = window2;
  }
  /**
   * Configures the top offset used when scrolling to an anchor.
   * @param offset A position in screen coordinates (a tuple with x and y values)
   * or a function that returns the top offset position.
   *
   */
  setOffset(offset2) {
    if (Array.isArray(offset2)) {
      this.offset = () => offset2;
    } else {
      this.offset = offset2;
    }
  }
  /**
   * Retrieves the current scroll position.
   * @returns The position in screen coordinates.
   */
  getScrollPosition() {
    return [this.window.scrollX, this.window.scrollY];
  }
  /**
   * Sets the scroll position.
   * @param position The new position in screen coordinates.
   */
  scrollToPosition(position) {
    this.window.scrollTo(position[0], position[1]);
  }
  /**
   * Scrolls to an element and attempts to focus the element.
   *
   * Note that the function name here is misleading in that the target string may be an ID for a
   * non-anchor element.
   *
   * @param target The ID of an element or name of the anchor.
   *
   * @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document
   * @see https://html.spec.whatwg.org/#scroll-to-fragid
   */
  scrollToAnchor(target) {
    const elSelected = findAnchorFromDocument(this.document, target);
    if (elSelected) {
      this.scrollToElement(elSelected);
      elSelected.focus();
    }
  }
  /**
   * Disables automatic scroll restoration provided by the browser.
   */
  setHistoryScrollRestoration(scrollRestoration) {
    this.window.history.scrollRestoration = scrollRestoration;
  }
  /**
   * Scrolls to an element using the native offset and the specified offset set on this scroller.
   *
   * The offset can be used when we know that there is a floating header and scrolling naively to an
   * element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.
   */
  scrollToElement(el) {
    const rect = el.getBoundingClientRect();
    const left2 = rect.left + this.window.pageXOffset;
    const top = rect.top + this.window.pageYOffset;
    const offset2 = this.offset();
    this.window.scrollTo(left2 - offset2[0], top - offset2[1]);
  }
};
function findAnchorFromDocument(document2, target) {
  const documentResult = document2.getElementById(target) || document2.getElementsByName(target)[0];
  if (documentResult) {
    return documentResult;
  }
  if (typeof document2.createTreeWalker === "function" && document2.body && typeof document2.body.attachShadow === "function") {
    const treeWalker = document2.createTreeWalker(document2.body, NodeFilter.SHOW_ELEMENT);
    let currentNode = treeWalker.currentNode;
    while (currentNode) {
      const shadowRoot = currentNode.shadowRoot;
      if (shadowRoot) {
        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
        if (result) {
          return result;
        }
      }
      currentNode = treeWalker.nextNode();
    }
  }
  return null;
}
var NullViewportScroller = class {
  /**
   * Empty implementation
   */
  setOffset(offset2) {
  }
  /**
   * Empty implementation
   */
  getScrollPosition() {
    return [0, 0];
  }
  /**
   * Empty implementation
   */
  scrollToPosition(position) {
  }
  /**
   * Empty implementation
   */
  scrollToAnchor(anchor) {
  }
  /**
   * Empty implementation
   */
  setHistoryScrollRestoration(scrollRestoration) {
  }
};
var XhrFactory = class {
};
var PLACEHOLDER_QUALITY = "20";
function getUrl(src, win) {
  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);
}
function isAbsoluteUrl(src) {
  return /^https?:\/\//.test(src);
}
function extractHostname(url) {
  return isAbsoluteUrl(url) ? new URL(url).hostname : url;
}
function isValidPath(path3) {
  const isString = typeof path3 === "string";
  if (!isString || path3.trim() === "") {
    return false;
  }
  try {
    const url = new URL(path3);
    return true;
  } catch {
    return false;
  }
}
function normalizePath(path3) {
  return path3.endsWith("/") ? path3.slice(0, -1) : path3;
}
function normalizeSrc(src) {
  return src.startsWith("/") ? src.slice(1) : src;
}
var noopImageLoader = (config3) => config3.src;
var IMAGE_LOADER = new InjectionToken(ngDevMode ? "ImageLoader" : "", {
  providedIn: "root",
  factory: () => noopImageLoader
});
function createImageLoader(buildUrlFn, exampleUrls) {
  return function provideImageLoader(path3) {
    if (!isValidPath(path3)) {
      throwInvalidPathError(path3, exampleUrls || []);
    }
    path3 = normalizePath(path3);
    const loaderFn = (config3) => {
      if (isAbsoluteUrl(config3.src)) {
        throwUnexpectedAbsoluteUrlError(path3, config3.src);
      }
      return buildUrlFn(path3, __spreadProps(__spreadValues({}, config3), {
        src: normalizeSrc(config3.src)
      }));
    };
    const providers2 = [{
      provide: IMAGE_LOADER,
      useValue: loaderFn
    }];
    return providers2;
  };
}
function throwInvalidPathError(path3, exampleUrls) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\`${path3}\`). To fix this, supply a path using one of the following formats: ${exampleUrls.join(" or ")}`);
}
function throwUnexpectedAbsoluteUrlError(path3, url) {
  throw new RuntimeError(2959, ngDevMode && `Image loader has detected a \`<img>\` tag with an invalid \`ngSrc\` attribute: ${url}. This image loader expects \`ngSrc\` to be a relative URL - however the provided value is an absolute URL. To fix this, provide \`ngSrc\` as a path relative to the base URL configured for this loader (\`${path3}\`).`);
}
var provideCloudflareLoader = createImageLoader(createCloudflareUrl, ngDevMode ? ["https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>"] : void 0);
function createCloudflareUrl(path3, config3) {
  let params = `format=auto`;
  if (config3.width) {
    params += `,width=${config3.width}`;
  }
  if (config3.isPlaceholder) {
    params += `,quality=${PLACEHOLDER_QUALITY}`;
  }
  return `${path3}/cdn-cgi/image/${params}/${config3.src}`;
}
var cloudinaryLoaderInfo = {
  name: "Cloudinary",
  testUrl: isCloudinaryUrl
};
var CLOUDINARY_LOADER_REGEX = /https?\:\/\/[^\/]+\.cloudinary\.com\/.+/;
function isCloudinaryUrl(url) {
  return CLOUDINARY_LOADER_REGEX.test(url);
}
var provideCloudinaryLoader = createImageLoader(createCloudinaryUrl, ngDevMode ? ["https://res.cloudinary.com/mysite", "https://mysite.cloudinary.com", "https://subdomain.mysite.com"] : void 0);
function createCloudinaryUrl(path3, config3) {
  const quality = config3.isPlaceholder ? "q_auto:low" : "q_auto";
  let params = `f_auto,${quality}`;
  if (config3.width) {
    params += `,w_${config3.width}`;
  }
  if (config3.loaderParams?.["rounded"]) {
    params += `,r_max`;
  }
  return `${path3}/image/upload/${params}/${config3.src}`;
}
var imageKitLoaderInfo = {
  name: "ImageKit",
  testUrl: isImageKitUrl
};
var IMAGE_KIT_LOADER_REGEX = /https?\:\/\/[^\/]+\.imagekit\.io\/.+/;
function isImageKitUrl(url) {
  return IMAGE_KIT_LOADER_REGEX.test(url);
}
var provideImageKitLoader = createImageLoader(createImagekitUrl, ngDevMode ? ["https://ik.imagekit.io/mysite", "https://subdomain.mysite.com"] : void 0);
function createImagekitUrl(path3, config3) {
  const {
    src,
    width
  } = config3;
  const params = [];
  if (width) {
    params.push(`w-${width}`);
  }
  if (config3.isPlaceholder) {
    params.push(`q-${PLACEHOLDER_QUALITY}`);
  }
  const urlSegments = params.length ? [path3, `tr:${params.join(",")}`, src] : [path3, src];
  const url = new URL(urlSegments.join("/"));
  return url.href;
}
var imgixLoaderInfo = {
  name: "Imgix",
  testUrl: isImgixUrl
};
var IMGIX_LOADER_REGEX = /https?\:\/\/[^\/]+\.imgix\.net\/.+/;
function isImgixUrl(url) {
  return IMGIX_LOADER_REGEX.test(url);
}
var provideImgixLoader = createImageLoader(createImgixUrl, ngDevMode ? ["https://somepath.imgix.net/"] : void 0);
function createImgixUrl(path3, config3) {
  const url = new URL(`${path3}/${config3.src}`);
  url.searchParams.set("auto", "format");
  if (config3.width) {
    url.searchParams.set("w", config3.width.toString());
  }
  if (config3.isPlaceholder) {
    url.searchParams.set("q", PLACEHOLDER_QUALITY);
  }
  return url.href;
}
var netlifyLoaderInfo = {
  name: "Netlify",
  testUrl: isNetlifyUrl
};
var NETLIFY_LOADER_REGEX = /https?\:\/\/[^\/]+\.netlify\.app\/.+/;
function isNetlifyUrl(url) {
  return NETLIFY_LOADER_REGEX.test(url);
}
function imgDirectiveDetails(ngSrc, includeNgSrc = true) {
  const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \`ngSrc="${ngSrc}"\`) ` : "";
  return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;
}
function assertDevMode(checkName) {
  if (!ngDevMode) {
    throw new RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. Please make sure that the prod mode is enabled for production builds.`);
  }
}
var LCPImageObserver = class _LCPImageObserver {
  // Map of full image URLs -> original `ngSrc` values.
  images = /* @__PURE__ */ new Map();
  window = null;
  observer = null;
  constructor() {
    const isBrowser = isPlatformBrowser(inject(PLATFORM_ID));
    assertDevMode("LCP checker");
    const win = inject(DOCUMENT2).defaultView;
    if (isBrowser && typeof PerformanceObserver !== "undefined") {
      this.window = win;
      this.observer = this.initPerformanceObserver();
    }
  }
  /**
   * Inits PerformanceObserver and subscribes to LCP events.
   * Based on https://web.dev/lcp/#measure-lcp-in-javascript
   */
  initPerformanceObserver() {
    const observer = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      if (entries.length === 0) return;
      const lcpElement = entries[entries.length - 1];
      const imgSrc = lcpElement.element?.src ?? "";
      if (imgSrc.startsWith("data:") || imgSrc.startsWith("blob:")) return;
      const img = this.images.get(imgSrc);
      if (!img) return;
      if (!img.priority && !img.alreadyWarnedPriority) {
        img.alreadyWarnedPriority = true;
        logMissingPriorityError(imgSrc);
      }
      if (img.modified && !img.alreadyWarnedModified) {
        img.alreadyWarnedModified = true;
        logModifiedWarning(imgSrc);
      }
    });
    observer.observe({
      type: "largest-contentful-paint",
      buffered: true
    });
    return observer;
  }
  registerImage(rewrittenSrc, originalNgSrc, isPriority) {
    if (!this.observer) return;
    const newObservedImageState = {
      priority: isPriority,
      modified: false,
      alreadyWarnedModified: false,
      alreadyWarnedPriority: false
    };
    this.images.set(getUrl(rewrittenSrc, this.window).href, newObservedImageState);
  }
  unregisterImage(rewrittenSrc) {
    if (!this.observer) return;
    this.images.delete(getUrl(rewrittenSrc, this.window).href);
  }
  updateImage(originalSrc, newSrc) {
    if (!this.observer) return;
    const originalUrl = getUrl(originalSrc, this.window).href;
    const img = this.images.get(originalUrl);
    if (img) {
      img.modified = true;
      this.images.set(getUrl(newSrc, this.window).href, img);
      this.images.delete(originalUrl);
    }
  }
  ngOnDestroy() {
    if (!this.observer) return;
    this.observer.disconnect();
    this.images.clear();
  }
  static \u0275fac = function LCPImageObserver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LCPImageObserver)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _LCPImageObserver,
    factory: _LCPImageObserver.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LCPImageObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function logMissingPriorityError(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.error(formatRuntimeError(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element but was not marked "priority". This image should be marked "priority" in order to prioritize its loading. To fix this, add the "priority" attribute.`));
}
function logModifiedWarning(ngSrc) {
  const directiveDetails = imgDirectiveDetails(ngSrc);
  console.warn(formatRuntimeError(2964, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element and has had its "ngSrc" attribute modified. This can cause slower loading performance. It is recommended not to modify the "ngSrc" property on any image which could be the LCP element.`));
}
var INTERNAL_PRECONNECT_CHECK_BLOCKLIST = /* @__PURE__ */ new Set(["localhost", "127.0.0.1", "0.0.0.0"]);
var PRECONNECT_CHECK_BLOCKLIST = new InjectionToken(ngDevMode ? "PRECONNECT_CHECK_BLOCKLIST" : "");
var PreconnectLinkChecker = class _PreconnectLinkChecker {
  document = inject(DOCUMENT2);
  isServer = isPlatformServer(inject(PLATFORM_ID));
  /**
   * Set of <link rel="preconnect"> tags found on this page.
   * The `null` value indicates that there was no DOM query operation performed.
   */
  preconnectLinks = null;
  /*
   * Keep track of all already seen origin URLs to avoid repeating the same check.
   */
  alreadySeen = /* @__PURE__ */ new Set();
  window = null;
  blocklist = new Set(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);
  constructor() {
    assertDevMode("preconnect link checker");
    const win = this.document.defaultView;
    if (typeof win !== "undefined") {
      this.window = win;
    }
    const blocklist = inject(PRECONNECT_CHECK_BLOCKLIST, {
      optional: true
    });
    if (blocklist) {
      this.populateBlocklist(blocklist);
    }
  }
  populateBlocklist(origins) {
    if (Array.isArray(origins)) {
      deepForEach2(origins, (origin) => {
        this.blocklist.add(extractHostname(origin));
      });
    } else {
      this.blocklist.add(extractHostname(origins));
    }
  }
  /**
   * Checks that a preconnect resource hint exists in the head for the
   * given src.
   *
   * @param rewrittenSrc src formatted with loader
   * @param originalNgSrc ngSrc value
   */
  assertPreconnect(rewrittenSrc, originalNgSrc) {
    if (this.isServer) return;
    const imgUrl = getUrl(rewrittenSrc, this.window);
    if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin)) return;
    this.alreadySeen.add(imgUrl.origin);
    this.preconnectLinks ??= this.queryPreconnectLinks();
    if (!this.preconnectLinks.has(imgUrl.origin)) {
      console.warn(formatRuntimeError(2956, `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this image. Preconnecting to the origin(s) that serve priority images ensures that these images are delivered as soon as possible. To fix this, please add the following element into the <head> of the document:
  <link rel="preconnect" href="${imgUrl.origin}">`));
    }
  }
  queryPreconnectLinks() {
    const preconnectUrls = /* @__PURE__ */ new Set();
    const selector = "link[rel=preconnect]";
    const links = Array.from(this.document.querySelectorAll(selector));
    for (let link2 of links) {
      const url = getUrl(link2.href, this.window);
      preconnectUrls.add(url.origin);
    }
    return preconnectUrls;
  }
  ngOnDestroy() {
    this.preconnectLinks?.clear();
    this.alreadySeen.clear();
  }
  static \u0275fac = function PreconnectLinkChecker_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PreconnectLinkChecker)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _PreconnectLinkChecker,
    factory: _PreconnectLinkChecker.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreconnectLinkChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function deepForEach2(input2, fn) {
  for (let value2 of input2) {
    Array.isArray(value2) ? deepForEach2(value2, fn) : fn(value2);
  }
}
var DEFAULT_PRELOADED_IMAGES_LIMIT = 5;
var PRELOADED_IMAGES = new InjectionToken("NG_OPTIMIZED_PRELOADED_IMAGES", {
  providedIn: "root",
  factory: () => /* @__PURE__ */ new Set()
});
var PreloadLinkCreator = class _PreloadLinkCreator {
  preloadedImages = inject(PRELOADED_IMAGES);
  document = inject(DOCUMENT2);
  /**
   * @description Add a preload `<link>` to the `<head>` of the `index.html` that is served from the
   * server while using Angular Universal and SSR to kick off image loads for high priority images.
   *
   * The `sizes` (passed in from the user) and `srcset` (parsed and formatted from `ngSrcset`)
   * properties used to set the corresponding attributes, `imagesizes` and `imagesrcset`
   * respectively, on the preload `<link>` tag so that the correctly sized image is preloaded from
   * the CDN.
   *
   * {@link https://web.dev/preload-responsive-images/#imagesrcset-and-imagesizes}
   *
   * @param renderer The `Renderer2` passed in from the directive
   * @param src The original src of the image that is set on the `ngSrc` input.
   * @param srcset The parsed and formatted srcset created from the `ngSrcset` input
   * @param sizes The value of the `sizes` attribute passed in to the `<img>` tag
   */
  createPreloadLinkTag(renderer, src, srcset, sizes) {
    if (ngDevMode) {
      if (this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT) {
        throw new RuntimeError(2961, ngDevMode && `The \`NgOptimizedImage\` directive has detected that more than ${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. This might negatively affect an overall performance of the page. To fix this, remove the "priority" attribute from images with less priority.`);
      }
    }
    if (this.preloadedImages.has(src)) {
      return;
    }
    this.preloadedImages.add(src);
    const preload = renderer.createElement("link");
    renderer.setAttribute(preload, "as", "image");
    renderer.setAttribute(preload, "href", src);
    renderer.setAttribute(preload, "rel", "preload");
    renderer.setAttribute(preload, "fetchpriority", "high");
    if (sizes) {
      renderer.setAttribute(preload, "imageSizes", sizes);
    }
    if (srcset) {
      renderer.setAttribute(preload, "imageSrcset", srcset);
    }
    renderer.appendChild(this.document.head, preload);
  }
  static \u0275fac = function PreloadLinkCreator_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PreloadLinkCreator)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _PreloadLinkCreator,
    factory: _PreloadLinkCreator.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadLinkCreator, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;
var VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\s*\d+w\s*(,|$)){1,})$/;
var VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\s*\d+(\.\d+)?x\s*(,|$)){1,})$/;
var ABSOLUTE_SRCSET_DENSITY_CAP = 3;
var RECOMMENDED_SRCSET_DENSITY_CAP = 2;
var DENSITY_SRCSET_MULTIPLIERS = [1, 2];
var VIEWPORT_BREAKPOINT_CUTOFF = 640;
var ASPECT_RATIO_TOLERANCE = 0.1;
var OVERSIZED_IMAGE_TOLERANCE2 = 1e3;
var FIXED_SRCSET_WIDTH_LIMIT = 1920;
var FIXED_SRCSET_HEIGHT_LIMIT = 1080;
var PLACEHOLDER_BLUR_AMOUNT = 15;
var PLACEHOLDER_DIMENSION_LIMIT = 1e3;
var DATA_URL_WARN_LIMIT = 4e3;
var DATA_URL_ERROR_LIMIT = 1e4;
var BUILT_IN_LOADERS = [imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo, netlifyLoaderInfo];
var PRIORITY_COUNT_THRESHOLD = 10;
var IMGS_WITH_PRIORITY_ATTR_COUNT = 0;
var NgOptimizedImage = class _NgOptimizedImage {
  imageLoader = inject(IMAGE_LOADER);
  config = processConfig(inject(IMAGE_CONFIG));
  renderer = inject(Renderer2);
  imgElement = inject(ElementRef).nativeElement;
  injector = inject(Injector);
  isServer = isPlatformServer(inject(PLATFORM_ID));
  preloadLinkCreator = inject(PreloadLinkCreator);
  // a LCP image observer - should be injected only in the dev mode
  lcpObserver = ngDevMode ? this.injector.get(LCPImageObserver) : null;
  /**
   * Calculate the rewritten `src` once and store it.
   * This is needed to avoid repetitive calculations and make sure the directive cleanup in the
   * `ngOnDestroy` does not rely on the `IMAGE_LOADER` logic (which in turn can rely on some other
   * instance that might be already destroyed).
   */
  _renderedSrc = null;
  /**
   * Name of the source image.
   * Image name will be processed by the image loader and the final URL will be applied as the `src`
   * property of the image.
   */
  ngSrc;
  /**
   * A comma separated list of width or density descriptors.
   * The image name will be taken from `ngSrc` and combined with the list of width or density
   * descriptors to generate the final `srcset` property of the image.
   *
   * Example:
   * ```
   * <img ngSrc="hello.jpg" ngSrcset="100w, 200w" />  =>
   * <img src="path/hello.jpg" srcset="path/hello.jpg?w=100 100w, path/hello.jpg?w=200 200w" />
   * ```
   */
  ngSrcset;
  /**
   * The base `sizes` attribute passed through to the `<img>` element.
   * Providing sizes causes the image to create an automatic responsive srcset.
   */
  sizes;
  /**
   * For responsive images: the intrinsic width of the image in pixels.
   * For fixed size images: the desired rendered width of the image in pixels.
   */
  width;
  /**
   * For responsive images: the intrinsic height of the image in pixels.
   * For fixed size images: the desired rendered height of the image in pixels.
   */
  height;
  /**
   * The desired loading behavior (lazy, eager, or auto). Defaults to `lazy`,
   * which is recommended for most images.
   *
   * Warning: Setting images as loading="eager" or loading="auto" marks them
   * as non-priority images and can hurt loading performance. For images which
   * may be the LCP element, use the `priority` attribute instead of `loading`.
   */
  loading;
  /**
   * Indicates whether this image should have a high priority.
   */
  priority = false;
  /**
   * Data to pass through to custom loaders.
   */
  loaderParams;
  /**
   * Disables automatic srcset generation for this image.
   */
  disableOptimizedSrcset = false;
  /**
   * Sets the image to "fill mode", which eliminates the height/width requirement and adds
   * styles such that the image fills its containing element.
   */
  fill = false;
  /**
   * A URL or data URL for an image to be used as a placeholder while this image loads.
   */
  placeholder;
  /**
   * Configuration object for placeholder settings. Options:
   *   * blur: Setting this to false disables the automatic CSS blur.
   */
  placeholderConfig;
  /**
   * Value of the `src` attribute if set on the host `<img>` element.
   * This input is exclusively read to assert that `src` is not set in conflict
   * with `ngSrc` and that images don't start to load until a lazy loading strategy is set.
   * @internal
   */
  src;
  /**
   * Value of the `srcset` attribute if set on the host `<img>` element.
   * This input is exclusively read to assert that `srcset` is not set in conflict
   * with `ngSrcset` and that images don't start to load until a lazy loading strategy is set.
   * @internal
   */
  srcset;
  /** @nodoc */
  ngOnInit() {
    performanceMarkFeature("NgOptimizedImage");
    if (ngDevMode) {
      const ngZone = this.injector.get(NgZone);
      assertNonEmptyInput(this, "ngSrc", this.ngSrc);
      assertValidNgSrcset(this, this.ngSrcset);
      assertNoConflictingSrc(this);
      if (this.ngSrcset) {
        assertNoConflictingSrcset(this);
      }
      assertNotBase64Image(this);
      assertNotBlobUrl(this);
      if (this.fill) {
        assertEmptyWidthAndHeight(this);
        ngZone.runOutsideAngular(() => assertNonZeroRenderedHeight(this, this.imgElement, this.renderer));
      } else {
        assertNonEmptyWidthAndHeight(this);
        if (this.height !== void 0) {
          assertGreaterThanZero(this, this.height, "height");
        }
        if (this.width !== void 0) {
          assertGreaterThanZero(this, this.width, "width");
        }
        ngZone.runOutsideAngular(() => assertNoImageDistortion(this, this.imgElement, this.renderer));
      }
      assertValidLoadingInput(this);
      if (!this.ngSrcset) {
        assertNoComplexSizes(this);
      }
      assertValidPlaceholder(this, this.imageLoader);
      assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);
      assertNoNgSrcsetWithoutLoader(this, this.imageLoader);
      assertNoLoaderParamsWithoutLoader(this, this.imageLoader);
      if (this.lcpObserver !== null) {
        const ngZone2 = this.injector.get(NgZone);
        ngZone2.runOutsideAngular(() => {
          this.lcpObserver.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);
        });
      }
      if (this.priority) {
        const checker = this.injector.get(PreconnectLinkChecker);
        checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);
        if (!this.isServer) {
          const applicationRef = this.injector.get(ApplicationRef);
          assetPriorityCountBelowThreshold(applicationRef);
        }
      }
    }
    if (this.placeholder) {
      this.removePlaceholderOnLoad(this.imgElement);
    }
    this.setHostAttributes();
  }
  setHostAttributes() {
    if (this.fill) {
      this.sizes ||= "100vw";
    } else {
      this.setHostAttribute("width", this.width.toString());
      this.setHostAttribute("height", this.height.toString());
    }
    this.setHostAttribute("loading", this.getLoadingBehavior());
    this.setHostAttribute("fetchpriority", this.getFetchPriority());
    this.setHostAttribute("ng-img", "true");
    const rewrittenSrcset = this.updateSrcAndSrcset();
    if (this.sizes) {
      if (this.getLoadingBehavior() === "lazy") {
        this.setHostAttribute("sizes", "auto, " + this.sizes);
      } else {
        this.setHostAttribute("sizes", this.sizes);
      }
    } else {
      if (this.ngSrcset && VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset) && this.getLoadingBehavior() === "lazy") {
        this.setHostAttribute("sizes", "auto, 100vw");
      }
    }
    if (this.isServer && this.priority) {
      this.preloadLinkCreator.createPreloadLinkTag(this.renderer, this.getRewrittenSrc(), rewrittenSrcset, this.sizes);
    }
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (ngDevMode) {
      assertNoPostInitInputChange(this, changes, ["ngSrcset", "width", "height", "priority", "fill", "loading", "sizes", "loaderParams", "disableOptimizedSrcset"]);
    }
    if (changes["ngSrc"] && !changes["ngSrc"].isFirstChange()) {
      const oldSrc = this._renderedSrc;
      this.updateSrcAndSrcset(true);
      const newSrc = this._renderedSrc;
      if (this.lcpObserver !== null && oldSrc && newSrc && oldSrc !== newSrc) {
        const ngZone = this.injector.get(NgZone);
        ngZone.runOutsideAngular(() => {
          this.lcpObserver?.updateImage(oldSrc, newSrc);
        });
      }
    }
    if (ngDevMode && changes["placeholder"]?.currentValue && !this.isServer) {
      assertPlaceholderDimensions(this, this.imgElement);
    }
  }
  callImageLoader(configWithoutCustomParams) {
    let augmentedConfig = configWithoutCustomParams;
    if (this.loaderParams) {
      augmentedConfig.loaderParams = this.loaderParams;
    }
    return this.imageLoader(augmentedConfig);
  }
  getLoadingBehavior() {
    if (!this.priority && this.loading !== void 0) {
      return this.loading;
    }
    return this.priority ? "eager" : "lazy";
  }
  getFetchPriority() {
    return this.priority ? "high" : "auto";
  }
  getRewrittenSrc() {
    if (!this._renderedSrc) {
      const imgConfig = {
        src: this.ngSrc
      };
      this._renderedSrc = this.callImageLoader(imgConfig);
    }
    return this._renderedSrc;
  }
  getRewrittenSrcset() {
    const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);
    const finalSrcs = this.ngSrcset.split(",").filter((src) => src !== "").map((srcStr) => {
      srcStr = srcStr.trim();
      const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width;
      return `${this.callImageLoader({
        src: this.ngSrc,
        width
      })} ${srcStr}`;
    });
    return finalSrcs.join(", ");
  }
  getAutomaticSrcset() {
    if (this.sizes) {
      return this.getResponsiveSrcset();
    } else {
      return this.getFixedSrcset();
    }
  }
  getResponsiveSrcset() {
    const {
      breakpoints
    } = this.config;
    let filteredBreakpoints = breakpoints;
    if (this.sizes?.trim() === "100vw") {
      filteredBreakpoints = breakpoints.filter((bp) => bp >= VIEWPORT_BREAKPOINT_CUTOFF);
    }
    const finalSrcs = filteredBreakpoints.map((bp) => `${this.callImageLoader({
      src: this.ngSrc,
      width: bp
    })} ${bp}w`);
    return finalSrcs.join(", ");
  }
  updateSrcAndSrcset(forceSrcRecalc = false) {
    if (forceSrcRecalc) {
      this._renderedSrc = null;
    }
    const rewrittenSrc = this.getRewrittenSrc();
    this.setHostAttribute("src", rewrittenSrc);
    let rewrittenSrcset = void 0;
    if (this.ngSrcset) {
      rewrittenSrcset = this.getRewrittenSrcset();
    } else if (this.shouldGenerateAutomaticSrcset()) {
      rewrittenSrcset = this.getAutomaticSrcset();
    }
    if (rewrittenSrcset) {
      this.setHostAttribute("srcset", rewrittenSrcset);
    }
    return rewrittenSrcset;
  }
  getFixedSrcset() {
    const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map((multiplier) => `${this.callImageLoader({
      src: this.ngSrc,
      width: this.width * multiplier
    })} ${multiplier}x`);
    return finalSrcs.join(", ");
  }
  shouldGenerateAutomaticSrcset() {
    let oversizedImage = false;
    if (!this.sizes) {
      oversizedImage = this.width > FIXED_SRCSET_WIDTH_LIMIT || this.height > FIXED_SRCSET_HEIGHT_LIMIT;
    }
    return !this.disableOptimizedSrcset && !this.srcset && this.imageLoader !== noopImageLoader && !oversizedImage;
  }
  /**
   * Returns an image url formatted for use with the CSS background-image property. Expects one of:
   * * A base64 encoded image, which is wrapped and passed through.
   * * A boolean. If true, calls the image loader to generate a small placeholder url.
   */
  generatePlaceholder(placeholderInput) {
    const {
      placeholderResolution
    } = this.config;
    if (placeholderInput === true) {
      return `url(${this.callImageLoader({
        src: this.ngSrc,
        width: placeholderResolution,
        isPlaceholder: true
      })})`;
    } else if (typeof placeholderInput === "string") {
      return `url(${placeholderInput})`;
    }
    return null;
  }
  /**
   * Determines if blur should be applied, based on an optional boolean
   * property `blur` within the optional configuration object `placeholderConfig`.
   */
  shouldBlurPlaceholder(placeholderConfig) {
    if (!placeholderConfig || !placeholderConfig.hasOwnProperty("blur")) {
      return true;
    }
    return Boolean(placeholderConfig.blur);
  }
  removePlaceholderOnLoad(img) {
    const callback = () => {
      const changeDetectorRef = this.injector.get(ChangeDetectorRef);
      removeLoadListenerFn();
      removeErrorListenerFn();
      this.placeholder = false;
      changeDetectorRef.markForCheck();
    };
    const removeLoadListenerFn = this.renderer.listen(img, "load", callback);
    const removeErrorListenerFn = this.renderer.listen(img, "error", callback);
    callOnLoadIfImageIsLoaded(img, callback);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (ngDevMode) {
      if (!this.priority && this._renderedSrc !== null && this.lcpObserver !== null) {
        this.lcpObserver.unregisterImage(this._renderedSrc);
      }
    }
  }
  setHostAttribute(name, value2) {
    this.renderer.setAttribute(this.imgElement, name, value2);
  }
  static \u0275fac = function NgOptimizedImage_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgOptimizedImage)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgOptimizedImage,
    selectors: [["img", "ngSrc", ""]],
    hostVars: 18,
    hostBindings: function NgOptimizedImage_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275styleProp("position", ctx.fill ? "absolute" : null)("width", ctx.fill ? "100%" : null)("height", ctx.fill ? "100%" : null)("inset", ctx.fill ? "0" : null)("background-size", ctx.placeholder ? "cover" : null)("background-position", ctx.placeholder ? "50% 50%" : null)("background-repeat", ctx.placeholder ? "no-repeat" : null)("background-image", ctx.placeholder ? ctx.generatePlaceholder(ctx.placeholder) : null)("filter", ctx.placeholder && ctx.shouldBlurPlaceholder(ctx.placeholderConfig) ? "blur(15px)" : null);
      }
    },
    inputs: {
      ngSrc: [2, "ngSrc", "ngSrc", unwrapSafeUrl],
      ngSrcset: "ngSrcset",
      sizes: "sizes",
      width: [2, "width", "width", numberAttribute],
      height: [2, "height", "height", numberAttribute],
      loading: "loading",
      priority: [2, "priority", "priority", booleanAttribute],
      loaderParams: "loaderParams",
      disableOptimizedSrcset: [2, "disableOptimizedSrcset", "disableOptimizedSrcset", booleanAttribute],
      fill: [2, "fill", "fill", booleanAttribute],
      placeholder: [2, "placeholder", "placeholder", booleanOrUrlAttribute],
      placeholderConfig: "placeholderConfig",
      src: "src",
      srcset: "srcset"
    },
    features: [\u0275\u0275InputTransformsFeature, \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgOptimizedImage, [{
    type: Directive,
    args: [{
      standalone: true,
      selector: "img[ngSrc]",
      host: {
        "[style.position]": 'fill ? "absolute" : null',
        "[style.width]": 'fill ? "100%" : null',
        "[style.height]": 'fill ? "100%" : null',
        "[style.inset]": 'fill ? "0" : null',
        "[style.background-size]": 'placeholder ? "cover" : null',
        "[style.background-position]": 'placeholder ? "50% 50%" : null',
        "[style.background-repeat]": 'placeholder ? "no-repeat" : null',
        "[style.background-image]": "placeholder ? generatePlaceholder(placeholder) : null",
        "[style.filter]": `placeholder && shouldBlurPlaceholder(placeholderConfig) ? "blur(${PLACEHOLDER_BLUR_AMOUNT}px)" : null`
      }
    }]
  }], null, {
    ngSrc: [{
      type: Input,
      args: [{
        required: true,
        transform: unwrapSafeUrl
      }]
    }],
    ngSrcset: [{
      type: Input
    }],
    sizes: [{
      type: Input
    }],
    width: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    height: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    loading: [{
      type: Input
    }],
    priority: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    loaderParams: [{
      type: Input
    }],
    disableOptimizedSrcset: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    fill: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    placeholder: [{
      type: Input,
      args: [{
        transform: booleanOrUrlAttribute
      }]
    }],
    placeholderConfig: [{
      type: Input
    }],
    src: [{
      type: Input
    }],
    srcset: [{
      type: Input
    }]
  });
})();
function processConfig(config3) {
  let sortedBreakpoints = {};
  if (config3.breakpoints) {
    sortedBreakpoints.breakpoints = config3.breakpoints.sort((a, b) => a - b);
  }
  return Object.assign({}, IMAGE_CONFIG_DEFAULTS, config3, sortedBreakpoints);
}
function assertNoConflictingSrc(dir) {
  if (dir.src) {
    throw new RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \`src\` and \`ngSrc\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`src\` itself based on the value of \`ngSrc\`. To fix this, please remove the \`src\` attribute.`);
  }
}
function assertNoConflictingSrcset(dir) {
  if (dir.srcset) {
    throw new RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \`srcset\` and \`ngSrcset\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \`srcset\` itself based on the value of \`ngSrcset\`. To fix this, please remove the \`srcset\` attribute.`);
  }
}
function assertNotBase64Image(dir) {
  let ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("data:")) {
    if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {
      ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + "...";
    }
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`ngSrc\` is a Base64-encoded string (${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a standard \`src\` attribute instead.`);
  }
}
function assertNoComplexSizes(dir) {
  let sizes = dir.sizes;
  if (sizes?.match(/((\)|,)\s|^)\d+px/)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`sizes\` was set to a string including pixel values. For automatic \`srcset\` generation, \`sizes\` must only include responsive values, such as \`sizes="50vw"\` or \`sizes="(min-width: 768px) 50vw, 100vw"\`. To fix this, modify the \`sizes\` attribute, or provide your own \`ngSrcset\` value directly.`);
  }
}
function assertValidPlaceholder(dir, imageLoader) {
  assertNoPlaceholderConfigWithoutPlaceholder(dir);
  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);
  assertNoOversizedDataUrl(dir);
}
function assertNoPlaceholderConfigWithoutPlaceholder(dir) {
  if (dir.placeholderConfig && !dir.placeholder) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \`placeholderConfig\` options were provided for an image that does not use the \`placeholder\` attribute, and will have no effect.`);
  }
}
function assertNoRelativePlaceholderWithoutLoader(dir, imageLoader) {
  if (dir.placeholder === true && imageLoader === noopImageLoader) {
    throw new RuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to true but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for the primary image and its placeholder. To fix this, provide a loader or remove the \`placeholder\` attribute from the image.`);
  }
}
function assertNoOversizedDataUrl(dir) {
  if (dir.placeholder && typeof dir.placeholder === "string" && dir.placeholder.startsWith("data:")) {
    if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {
      throw new RuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. To fix this, generate a smaller data URL placeholder.`);
    }
    if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {
      console.warn(formatRuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \`placeholder\` attribute is set to a data URL which is longer than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. For better loading performance, generate a smaller data URL placeholder.`));
    }
  }
}
function assertNotBlobUrl(dir) {
  const ngSrc = dir.ngSrc.trim();
  if (ngSrc.startsWith("blob:")) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrc\` was set to a blob URL (${ngSrc}). Blob URLs are not supported by the NgOptimizedImage directive. To fix this, disable the NgOptimizedImage directive for this element by removing \`ngSrc\` and using a regular \`src\` attribute instead.`);
  }
}
function assertNonEmptyInput(dir, name, value2) {
  const isString = typeof value2 === "string";
  const isEmptyString = isString && value2.trim() === "";
  if (!isString || isEmptyString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${name}\` has an invalid value (\`${value2}\`). To fix this, change the value to a non-empty string.`);
  }
}
function assertValidNgSrcset(dir, value2) {
  if (value2 == null) return;
  assertNonEmptyInput(dir, "ngSrcset", value2);
  const stringVal = value2;
  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);
  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);
  if (isValidDensityDescriptor) {
    assertUnderDensityCap(dir, stringVal);
  }
  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;
  if (!isValidSrcset) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`ngSrcset\` has an invalid value (\`${value2}\`). To fix this, supply \`ngSrcset\` using a comma-separated list of one or more width descriptors (e.g. "100w, 200w") or density descriptors (e.g. "1x, 2x").`);
  }
}
function assertUnderDensityCap(dir, value2) {
  const underDensityCap = value2.split(",").every((num) => num === "" || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);
  if (!underDensityCap) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` contains an unsupported image density:\`${value2}\`. NgOptimizedImage generally recommends a max image density of ${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for most use cases. Images that will be pinch-zoomed are typically the primary use case for ${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);
  }
}
function postInitInputChangeError(dir, inputName) {
  let reason;
  if (inputName === "width" || inputName === "height") {
    reason = `Changing \`${inputName}\` may result in different attribute value applied to the underlying image element and cause layout shifts on a page.`;
  } else {
    reason = `Changing the \`${inputName}\` would have no effect on the underlying image element, because the resource loading has already occurred.`;
  }
  return new RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` was updated after initialization. The NgOptimizedImage directive will not react to this input change. ${reason} To fix this, either switch \`${inputName}\` to a static value or wrap the image element in an *ngIf that is gated on the necessary value.`);
}
function assertNoPostInitInputChange(dir, changes, inputs) {
  inputs.forEach((input2) => {
    const isUpdated = changes.hasOwnProperty(input2);
    if (isUpdated && !changes[input2].isFirstChange()) {
      if (input2 === "ngSrc") {
        dir = {
          ngSrc: changes[input2].previousValue
        };
      }
      throw postInitInputChangeError(dir, input2);
    }
  });
}
function assertGreaterThanZero(dir, inputValue, inputName) {
  const validNumber = typeof inputValue === "number" && inputValue > 0;
  const validString = typeof inputValue === "string" && /^\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;
  if (!validNumber && !validString) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \`${inputName}\` has an invalid value. To fix this, provide \`${inputName}\` as a number greater than 0.`);
  }
}
function assertNoImageDistortion(dir, img, renderer) {
  const callback = () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const computedStyle = window.getComputedStyle(img);
    let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
    let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
    const boxSizing = computedStyle.getPropertyValue("box-sizing");
    if (boxSizing === "border-box") {
      const paddingTop = computedStyle.getPropertyValue("padding-top");
      const paddingRight = computedStyle.getPropertyValue("padding-right");
      const paddingBottom = computedStyle.getPropertyValue("padding-bottom");
      const paddingLeft = computedStyle.getPropertyValue("padding-left");
      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);
      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);
    }
    const renderedAspectRatio = renderedWidth / renderedHeight;
    const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;
    const intrinsicWidth = img.naturalWidth;
    const intrinsicHeight = img.naturalHeight;
    const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;
    const suppliedWidth = dir.width;
    const suppliedHeight = dir.height;
    const suppliedAspectRatio = suppliedWidth / suppliedHeight;
    const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;
    const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;
    if (inaccurateDimensions) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match the aspect ratio indicated by the width and height attributes. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Supplied width and height attributes: ${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(suppliedAspectRatio)}). 
To fix this, update the width and height attributes.`));
    } else if (stylingDistortion) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image does not match the image's intrinsic aspect ratio. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ${round(renderedAspectRatio)}). 
This issue can occur if "width" and "height" attributes are added to an image without updating the corresponding image styling. To fix this, adjust image styling. In most cases, adding "height: auto" or "width: auto" to the image styling will fix this issue.`));
    } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {
      const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;
      const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;
      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE2;
      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE2;
      if (oversizedWidth || oversizedHeight) {
        console.warn(formatRuntimeError(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly larger than necessary. 
Rendered image size: ${renderedWidth}w x ${renderedHeight}h. 
Intrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. 
Recommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. 
Note: Recommended intrinsic image size is calculated assuming a maximum DPR of ${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image or consider using the "ngSrcset" and "sizes" attributes.`));
      }
    }
  };
  const removeLoadListenerFn = renderer.listen(img, "load", callback);
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
  callOnLoadIfImageIsLoaded(img, callback);
}
function assertNonEmptyWidthAndHeight(dir) {
  let missingAttributes = [];
  if (dir.width === void 0) missingAttributes.push("width");
  if (dir.height === void 0) missingAttributes.push("height");
  if (missingAttributes.length > 0) {
    throw new RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes are missing: ${missingAttributes.map((attr) => `"${attr}"`).join(", ")}. Including "width" and "height" attributes will prevent image-related layout shifts. To fix this, include "width" and "height" attributes on the image tag or turn on "fill" mode with the \`fill\` attribute.`);
  }
}
function assertEmptyWidthAndHeight(dir) {
  if (dir.width || dir.height) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \`height\` and/or \`width\` are present along with the \`fill\` attribute. Because \`fill\` mode causes an image to fill its containing element, the size attributes have no effect and should be removed.`);
  }
}
function assertNonZeroRenderedHeight(dir, img, renderer) {
  const callback = () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
    const renderedHeight = img.clientHeight;
    if (dir.fill && renderedHeight === 0) {
      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. This is likely because the containing element does not have the CSS 'position' property set to one of the following: "relative", "fixed", or "absolute". To fix this problem, make sure the container element has the CSS 'position' property defined and the height of the element is not zero.`));
    }
  };
  const removeLoadListenerFn = renderer.listen(img, "load", callback);
  const removeErrorListenerFn = renderer.listen(img, "error", () => {
    removeLoadListenerFn();
    removeErrorListenerFn();
  });
  callOnLoadIfImageIsLoaded(img, callback);
}
function assertValidLoadingInput(dir) {
  if (dir.loading && dir.priority) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute was used on an image that was marked "priority". Setting \`loading\` on priority images is not allowed because these images will always be eagerly loaded. To fix this, remove the \u201Cloading\u201D attribute from the priority image.`);
  }
  const validInputs = ["auto", "eager", "lazy"];
  if (typeof dir.loading === "string" && !validInputs.includes(dir.loading)) {
    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \`loading\` attribute has an invalid value (\`${dir.loading}\`). To fix this, provide a valid value ("lazy", "eager", or "auto").`);
  }
}
function assertNotMissingBuiltInLoader(ngSrc, imageLoader) {
  if (imageLoader === noopImageLoader) {
    let builtInLoaderName = "";
    for (const loader of BUILT_IN_LOADERS) {
      if (loader.testUrl(ngSrc)) {
        builtInLoaderName = loader.name;
        break;
      }
    }
    if (builtInLoaderName) {
      console.warn(formatRuntimeError(2962, `NgOptimizedImage: It looks like your images may be hosted on the ${builtInLoaderName} CDN, but your app is not using Angular's built-in loader for that CDN. We recommend switching to use the built-in by calling \`provide${builtInLoaderName}Loader()\` in your \`providers\` and passing it your instance's base URL. If you don't want to use the built-in loader, define a custom loader function using IMAGE_LOADER to silence this warning.`));
    }
  }
}
function assertNoNgSrcsetWithoutLoader(dir, imageLoader) {
  if (dir.ngSrcset && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`ngSrcset\` attribute is present but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for all configured sizes. To fix this, provide a loader or remove the \`ngSrcset\` attribute from the image.`));
  }
}
function assertNoLoaderParamsWithoutLoader(dir, imageLoader) {
  if (dir.loaderParams && imageLoader === noopImageLoader) {
    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \`loaderParams\` attribute is present but no image loader is configured (i.e. the default one is being used), which means that the loaderParams data will not be consumed and will not affect the URL. To fix this, provide a custom loader or remove the \`loaderParams\` attribute from the image.`));
  }
}
function assetPriorityCountBelowThreshold(appRef) {
  return __async(this, null, function* () {
    if (IMGS_WITH_PRIORITY_ATTR_COUNT === 0) {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
      yield appRef.whenStable();
      if (IMGS_WITH_PRIORITY_ATTR_COUNT > PRIORITY_COUNT_THRESHOLD) {
        console.warn(formatRuntimeError(2966, `NgOptimizedImage: The "priority" attribute is set to true more than ${PRIORITY_COUNT_THRESHOLD} times (${IMGS_WITH_PRIORITY_ATTR_COUNT} times). Marking too many images as "high" priority can hurt your application's LCP (https://web.dev/lcp). "Priority" should only be set on the image expected to be the page's LCP element.`));
      }
    } else {
      IMGS_WITH_PRIORITY_ATTR_COUNT++;
    }
  });
}
function assertPlaceholderDimensions(dir, imgElement) {
  const computedStyle = window.getComputedStyle(imgElement);
  let renderedWidth = parseFloat(computedStyle.getPropertyValue("width"));
  let renderedHeight = parseFloat(computedStyle.getPropertyValue("height"));
  if (renderedWidth > PLACEHOLDER_DIMENSION_LIMIT || renderedHeight > PLACEHOLDER_DIMENSION_LIMIT) {
    console.warn(formatRuntimeError(2967, `${imgDirectiveDetails(dir.ngSrc)} it uses a placeholder image, but at least one of the dimensions attribute (height or width) exceeds the limit of ${PLACEHOLDER_DIMENSION_LIMIT}px. To fix this, use a smaller image as a placeholder.`));
  }
}
function callOnLoadIfImageIsLoaded(img, callback) {
  if (img.complete && img.naturalWidth) {
    callback();
  }
}
function round(input2) {
  return Number.isInteger(input2) ? input2 : input2.toFixed(2);
}
function unwrapSafeUrl(value2) {
  if (typeof value2 === "string") {
    return value2;
  }
  return unwrapSafeValue(value2);
}
function booleanOrUrlAttribute(value2) {
  if (typeof value2 === "string" && value2 !== "true" && value2 !== "false" && value2 !== "") {
    return value2;
  }
  return booleanAttribute(value2);
}

// node_modules/@angular/common/fesm2022/http.mjs
var HttpHandler = class {
};
var HttpBackend = class {
};
var HttpHeaders = class _HttpHeaders {
  /**
   * Internal map of lowercase header names to values.
   */
  // TODO(issue/24571): remove '!'.
  headers;
  /**
   * Internal map of lowercased header names to the normalized
   * form of the name (the form seen first).
   */
  normalizedNames = /* @__PURE__ */ new Map();
  /**
   * Complete the lazy initialization of this object (needed before reading).
   */
  lazyInit;
  /**
   * Queued updates to be materialized the next initialization.
   */
  lazyUpdate = null;
  /**  Constructs a new HTTP header object with the given values.*/
  constructor(headers) {
    if (!headers) {
      this.headers = /* @__PURE__ */ new Map();
    } else if (typeof headers === "string") {
      this.lazyInit = () => {
        this.headers = /* @__PURE__ */ new Map();
        headers.split("\n").forEach((line) => {
          const index = line.indexOf(":");
          if (index > 0) {
            const name = line.slice(0, index);
            const value2 = line.slice(index + 1).trim();
            this.addHeaderEntry(name, value2);
          }
        });
      };
    } else if (typeof Headers !== "undefined" && headers instanceof Headers) {
      this.headers = /* @__PURE__ */ new Map();
      headers.forEach((value2, name) => {
        this.addHeaderEntry(name, value2);
      });
    } else {
      this.lazyInit = () => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          assertValidHeaders(headers);
        }
        this.headers = /* @__PURE__ */ new Map();
        Object.entries(headers).forEach(([name, values]) => {
          this.setHeaderEntries(name, values);
        });
      };
    }
  }
  /**
   * Checks for existence of a given header.
   *
   * @param name The header name to check for existence.
   *
   * @returns True if the header exists, false otherwise.
   */
  has(name) {
    this.init();
    return this.headers.has(name.toLowerCase());
  }
  /**
   * Retrieves the first value of a given header.
   *
   * @param name The header name.
   *
   * @returns The value string if the header exists, null otherwise
   */
  get(name) {
    this.init();
    const values = this.headers.get(name.toLowerCase());
    return values && values.length > 0 ? values[0] : null;
  }
  /**
   * Retrieves the names of the headers.
   *
   * @returns A list of header names.
   */
  keys() {
    this.init();
    return Array.from(this.normalizedNames.values());
  }
  /**
   * Retrieves a list of values for a given header.
   *
   * @param name The header name from which to retrieve values.
   *
   * @returns A string of values if the header exists, null otherwise.
   */
  getAll(name) {
    this.init();
    return this.headers.get(name.toLowerCase()) || null;
  }
  /**
   * Appends a new value to the existing set of values for a header
   * and returns them in a clone of the original instance.
   *
   * @param name The header name for which to append the values.
   * @param value The value to append.
   *
   * @returns A clone of the HTTP headers object with the value appended to the given header.
   */
  append(name, value2) {
    return this.clone({
      name,
      value: value2,
      op: "a"
    });
  }
  /**
   * Sets or modifies a value for a given header in a clone of the original instance.
   * If the header already exists, its value is replaced with the given value
   * in the returned object.
   *
   * @param name The header name.
   * @param value The value or values to set or override for the given header.
   *
   * @returns A clone of the HTTP headers object with the newly set header value.
   */
  set(name, value2) {
    return this.clone({
      name,
      value: value2,
      op: "s"
    });
  }
  /**
   * Deletes values for a given header in a clone of the original instance.
   *
   * @param name The header name.
   * @param value The value or values to delete for the given header.
   *
   * @returns A clone of the HTTP headers object with the given value deleted.
   */
  delete(name, value2) {
    return this.clone({
      name,
      value: value2,
      op: "d"
    });
  }
  maybeSetNormalizedName(name, lcName) {
    if (!this.normalizedNames.has(lcName)) {
      this.normalizedNames.set(lcName, name);
    }
  }
  init() {
    if (!!this.lazyInit) {
      if (this.lazyInit instanceof _HttpHeaders) {
        this.copyFrom(this.lazyInit);
      } else {
        this.lazyInit();
      }
      this.lazyInit = null;
      if (!!this.lazyUpdate) {
        this.lazyUpdate.forEach((update) => this.applyUpdate(update));
        this.lazyUpdate = null;
      }
    }
  }
  copyFrom(other) {
    other.init();
    Array.from(other.headers.keys()).forEach((key) => {
      this.headers.set(key, other.headers.get(key));
      this.normalizedNames.set(key, other.normalizedNames.get(key));
    });
  }
  clone(update) {
    const clone = new _HttpHeaders();
    clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof _HttpHeaders ? this.lazyInit : this;
    clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
    return clone;
  }
  applyUpdate(update) {
    const key = update.name.toLowerCase();
    switch (update.op) {
      case "a":
      case "s":
        let value2 = update.value;
        if (typeof value2 === "string") {
          value2 = [value2];
        }
        if (value2.length === 0) {
          return;
        }
        this.maybeSetNormalizedName(update.name, key);
        const base = (update.op === "a" ? this.headers.get(key) : void 0) || [];
        base.push(...value2);
        this.headers.set(key, base);
        break;
      case "d":
        const toDelete = update.value;
        if (!toDelete) {
          this.headers.delete(key);
          this.normalizedNames.delete(key);
        } else {
          let existing = this.headers.get(key);
          if (!existing) {
            return;
          }
          existing = existing.filter((value3) => toDelete.indexOf(value3) === -1);
          if (existing.length === 0) {
            this.headers.delete(key);
            this.normalizedNames.delete(key);
          } else {
            this.headers.set(key, existing);
          }
        }
        break;
    }
  }
  addHeaderEntry(name, value2) {
    const key = name.toLowerCase();
    this.maybeSetNormalizedName(name, key);
    if (this.headers.has(key)) {
      this.headers.get(key).push(value2);
    } else {
      this.headers.set(key, [value2]);
    }
  }
  setHeaderEntries(name, values) {
    const headerValues = (Array.isArray(values) ? values : [values]).map((value2) => value2.toString());
    const key = name.toLowerCase();
    this.headers.set(key, headerValues);
    this.maybeSetNormalizedName(name, key);
  }
  /**
   * @internal
   */
  forEach(fn) {
    this.init();
    Array.from(this.normalizedNames.keys()).forEach((key) => fn(this.normalizedNames.get(key), this.headers.get(key)));
  }
};
function assertValidHeaders(headers) {
  for (const [key, value2] of Object.entries(headers)) {
    if (!(typeof value2 === "string" || typeof value2 === "number") && !Array.isArray(value2)) {
      throw new Error(`Unexpected value of the \`${key}\` header provided. Expecting either a string, a number or an array, but got: \`${value2}\`.`);
    }
  }
}
var HttpUrlEncodingCodec = class {
  /**
   * Encodes a key name for a URL parameter or query-string.
   * @param key The key name.
   * @returns The encoded key name.
   */
  encodeKey(key) {
    return standardEncoding(key);
  }
  /**
   * Encodes the value of a URL parameter or query-string.
   * @param value The value.
   * @returns The encoded value.
   */
  encodeValue(value2) {
    return standardEncoding(value2);
  }
  /**
   * Decodes an encoded URL parameter or query-string key.
   * @param key The encoded key name.
   * @returns The decoded key name.
   */
  decodeKey(key) {
    return decodeURIComponent(key);
  }
  /**
   * Decodes an encoded URL parameter or query-string value.
   * @param value The encoded value.
   * @returns The decoded value.
   */
  decodeValue(value2) {
    return decodeURIComponent(value2);
  }
};
function paramParser(rawParams, codec) {
  const map3 = /* @__PURE__ */ new Map();
  if (rawParams.length > 0) {
    const params = rawParams.replace(/^\?/, "").split("&");
    params.forEach((param) => {
      const eqIdx = param.indexOf("=");
      const [key, val] = eqIdx == -1 ? [codec.decodeKey(param), ""] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];
      const list = map3.get(key) || [];
      list.push(val);
      map3.set(key, list);
    });
  }
  return map3;
}
var STANDARD_ENCODING_REGEX = /%(\d[a-f0-9])/gi;
var STANDARD_ENCODING_REPLACEMENTS = {
  "40": "@",
  "3A": ":",
  "24": "$",
  "2C": ",",
  "3B": ";",
  "3D": "=",
  "3F": "?",
  "2F": "/"
};
function standardEncoding(v) {
  return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s2, t2) => STANDARD_ENCODING_REPLACEMENTS[t2] ?? s2);
}
function valueToString(value2) {
  return `${value2}`;
}
var HttpParams = class _HttpParams {
  map;
  encoder;
  updates = null;
  cloneFrom = null;
  constructor(options = {}) {
    this.encoder = options.encoder || new HttpUrlEncodingCodec();
    if (!!options.fromString) {
      if (!!options.fromObject) {
        throw new Error(`Cannot specify both fromString and fromObject.`);
      }
      this.map = paramParser(options.fromString, this.encoder);
    } else if (!!options.fromObject) {
      this.map = /* @__PURE__ */ new Map();
      Object.keys(options.fromObject).forEach((key) => {
        const value2 = options.fromObject[key];
        const values = Array.isArray(value2) ? value2.map(valueToString) : [valueToString(value2)];
        this.map.set(key, values);
      });
    } else {
      this.map = null;
    }
  }
  /**
   * Reports whether the body includes one or more values for a given parameter.
   * @param param The parameter name.
   * @returns True if the parameter has one or more values,
   * false if it has no value or is not present.
   */
  has(param) {
    this.init();
    return this.map.has(param);
  }
  /**
   * Retrieves the first value for a parameter.
   * @param param The parameter name.
   * @returns The first value of the given parameter,
   * or `null` if the parameter is not present.
   */
  get(param) {
    this.init();
    const res = this.map.get(param);
    return !!res ? res[0] : null;
  }
  /**
   * Retrieves all values for a  parameter.
   * @param param The parameter name.
   * @returns All values in a string array,
   * or `null` if the parameter not present.
   */
  getAll(param) {
    this.init();
    return this.map.get(param) || null;
  }
  /**
   * Retrieves all the parameters for this body.
   * @returns The parameter names in a string array.
   */
  keys() {
    this.init();
    return Array.from(this.map.keys());
  }
  /**
   * Appends a new value to existing values for a parameter.
   * @param param The parameter name.
   * @param value The new value to add.
   * @return A new body with the appended value.
   */
  append(param, value2) {
    return this.clone({
      param,
      value: value2,
      op: "a"
    });
  }
  /**
   * Constructs a new body with appended values for the given parameter name.
   * @param params parameters and values
   * @return A new body with the new value.
   */
  appendAll(params) {
    const updates = [];
    Object.keys(params).forEach((param) => {
      const value2 = params[param];
      if (Array.isArray(value2)) {
        value2.forEach((_value) => {
          updates.push({
            param,
            value: _value,
            op: "a"
          });
        });
      } else {
        updates.push({
          param,
          value: value2,
          op: "a"
        });
      }
    });
    return this.clone(updates);
  }
  /**
   * Replaces the value for a parameter.
   * @param param The parameter name.
   * @param value The new value.
   * @return A new body with the new value.
   */
  set(param, value2) {
    return this.clone({
      param,
      value: value2,
      op: "s"
    });
  }
  /**
   * Removes a given value or all values from a parameter.
   * @param param The parameter name.
   * @param value The value to remove, if provided.
   * @return A new body with the given value removed, or with all values
   * removed if no value is specified.
   */
  delete(param, value2) {
    return this.clone({
      param,
      value: value2,
      op: "d"
    });
  }
  /**
   * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are
   * separated by `&`s.
   */
  toString() {
    this.init();
    return this.keys().map((key) => {
      const eKey = this.encoder.encodeKey(key);
      return this.map.get(key).map((value2) => eKey + "=" + this.encoder.encodeValue(value2)).join("&");
    }).filter((param) => param !== "").join("&");
  }
  clone(update) {
    const clone = new _HttpParams({
      encoder: this.encoder
    });
    clone.cloneFrom = this.cloneFrom || this;
    clone.updates = (this.updates || []).concat(update);
    return clone;
  }
  init() {
    if (this.map === null) {
      this.map = /* @__PURE__ */ new Map();
    }
    if (this.cloneFrom !== null) {
      this.cloneFrom.init();
      this.cloneFrom.keys().forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));
      this.updates.forEach((update) => {
        switch (update.op) {
          case "a":
          case "s":
            const base = (update.op === "a" ? this.map.get(update.param) : void 0) || [];
            base.push(valueToString(update.value));
            this.map.set(update.param, base);
            break;
          case "d":
            if (update.value !== void 0) {
              let base2 = this.map.get(update.param) || [];
              const idx = base2.indexOf(valueToString(update.value));
              if (idx !== -1) {
                base2.splice(idx, 1);
              }
              if (base2.length > 0) {
                this.map.set(update.param, base2);
              } else {
                this.map.delete(update.param);
              }
            } else {
              this.map.delete(update.param);
              break;
            }
        }
      });
      this.cloneFrom = this.updates = null;
    }
  }
};
var HttpContext = class {
  map = /* @__PURE__ */ new Map();
  /**
   * Store a value in the context. If a value is already present it will be overwritten.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   * @param value The value to store.
   *
   * @returns A reference to itself for easy chaining.
   */
  set(token, value2) {
    this.map.set(token, value2);
    return this;
  }
  /**
   * Retrieve the value associated with the given token.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   *
   * @returns The stored value or default if one is defined.
   */
  get(token) {
    if (!this.map.has(token)) {
      this.map.set(token, token.defaultValue());
    }
    return this.map.get(token);
  }
  /**
   * Delete the value associated with the given token.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   *
   * @returns A reference to itself for easy chaining.
   */
  delete(token) {
    this.map.delete(token);
    return this;
  }
  /**
   * Checks for existence of a given token.
   *
   * @param token The reference to an instance of `HttpContextToken`.
   *
   * @returns True if the token exists, false otherwise.
   */
  has(token) {
    return this.map.has(token);
  }
  /**
   * @returns a list of tokens currently stored in the context.
   */
  keys() {
    return this.map.keys();
  }
};
function mightHaveBody(method) {
  switch (method) {
    case "DELETE":
    case "GET":
    case "HEAD":
    case "OPTIONS":
    case "JSONP":
      return false;
    default:
      return true;
  }
}
function isArrayBuffer(value2) {
  return typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer;
}
function isBlob(value2) {
  return typeof Blob !== "undefined" && value2 instanceof Blob;
}
function isFormData(value2) {
  return typeof FormData !== "undefined" && value2 instanceof FormData;
}
function isUrlSearchParams(value2) {
  return typeof URLSearchParams !== "undefined" && value2 instanceof URLSearchParams;
}
var HttpRequest = class _HttpRequest {
  url;
  /**
   * The request body, or `null` if one isn't set.
   *
   * Bodies are not enforced to be immutable, as they can include a reference to any
   * user-defined data type. However, interceptors should take care to preserve
   * idempotence by treating them as such.
   */
  body = null;
  /**
   * Outgoing headers for this request.
   */
  // TODO(issue/24571): remove '!'.
  headers;
  /**
   * Shared and mutable context that can be used by interceptors
   */
  context;
  /**
   * Whether this request should be made in a way that exposes progress events.
   *
   * Progress events are expensive (change detection runs on each event) and so
   * they should only be requested if the consumer intends to monitor them.
   *
   * Note: The `FetchBackend` doesn't support progress report on uploads.
   */
  reportProgress = false;
  /**
   * Whether this request should be sent with outgoing credentials (cookies).
   */
  withCredentials = false;
  /**
   * The expected response type of the server.
   *
   * This is used to parse the response appropriately before returning it to
   * the requestee.
   */
  responseType = "json";
  /**
   * The outgoing HTTP request method.
   */
  method;
  /**
   * Outgoing URL parameters.
   *
   * To pass a string representation of HTTP parameters in the URL-query-string format,
   * the `HttpParamsOptions`' `fromString` may be used. For example:
   *
   * ```
   * new HttpParams({fromString: 'angular=awesome'})
   * ```
   */
  // TODO(issue/24571): remove '!'.
  params;
  /**
   * The outgoing URL with all URL parameters set.
   */
  urlWithParams;
  /**
   * The HttpTransferCache option for the request
   */
  transferCache;
  constructor(method, url, third, fourth) {
    this.url = url;
    this.method = method.toUpperCase();
    let options;
    if (mightHaveBody(this.method) || !!fourth) {
      this.body = third !== void 0 ? third : null;
      options = fourth;
    } else {
      options = third;
    }
    if (options) {
      this.reportProgress = !!options.reportProgress;
      this.withCredentials = !!options.withCredentials;
      if (!!options.responseType) {
        this.responseType = options.responseType;
      }
      if (!!options.headers) {
        this.headers = options.headers;
      }
      if (!!options.context) {
        this.context = options.context;
      }
      if (!!options.params) {
        this.params = options.params;
      }
      this.transferCache = options.transferCache;
    }
    this.headers ??= new HttpHeaders();
    this.context ??= new HttpContext();
    if (!this.params) {
      this.params = new HttpParams();
      this.urlWithParams = url;
    } else {
      const params = this.params.toString();
      if (params.length === 0) {
        this.urlWithParams = url;
      } else {
        const qIdx = url.indexOf("?");
        const sep = qIdx === -1 ? "?" : qIdx < url.length - 1 ? "&" : "";
        this.urlWithParams = url + sep + params;
      }
    }
  }
  /**
   * Transform the free-form body into a serialized format suitable for
   * transmission to the server.
   */
  serializeBody() {
    if (this.body === null) {
      return null;
    }
    if (typeof this.body === "string" || isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body)) {
      return this.body;
    }
    if (this.body instanceof HttpParams) {
      return this.body.toString();
    }
    if (typeof this.body === "object" || typeof this.body === "boolean" || Array.isArray(this.body)) {
      return JSON.stringify(this.body);
    }
    return this.body.toString();
  }
  /**
   * Examine the body and attempt to infer an appropriate MIME type
   * for it.
   *
   * If no such type can be inferred, this method will return `null`.
   */
  detectContentTypeHeader() {
    if (this.body === null) {
      return null;
    }
    if (isFormData(this.body)) {
      return null;
    }
    if (isBlob(this.body)) {
      return this.body.type || null;
    }
    if (isArrayBuffer(this.body)) {
      return null;
    }
    if (typeof this.body === "string") {
      return "text/plain";
    }
    if (this.body instanceof HttpParams) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    }
    if (typeof this.body === "object" || typeof this.body === "number" || typeof this.body === "boolean") {
      return "application/json";
    }
    return null;
  }
  clone(update = {}) {
    const method = update.method || this.method;
    const url = update.url || this.url;
    const responseType = update.responseType || this.responseType;
    const transferCache = update.transferCache ?? this.transferCache;
    const body = update.body !== void 0 ? update.body : this.body;
    const withCredentials = update.withCredentials ?? this.withCredentials;
    const reportProgress = update.reportProgress ?? this.reportProgress;
    let headers = update.headers || this.headers;
    let params = update.params || this.params;
    const context2 = update.context ?? this.context;
    if (update.setHeaders !== void 0) {
      headers = Object.keys(update.setHeaders).reduce((headers2, name) => headers2.set(name, update.setHeaders[name]), headers);
    }
    if (update.setParams) {
      params = Object.keys(update.setParams).reduce((params2, param) => params2.set(param, update.setParams[param]), params);
    }
    return new _HttpRequest(method, url, body, {
      params,
      headers,
      context: context2,
      reportProgress,
      responseType,
      withCredentials,
      transferCache
    });
  }
};
var HttpEventType;
(function(HttpEventType2) {
  HttpEventType2[HttpEventType2["Sent"] = 0] = "Sent";
  HttpEventType2[HttpEventType2["UploadProgress"] = 1] = "UploadProgress";
  HttpEventType2[HttpEventType2["ResponseHeader"] = 2] = "ResponseHeader";
  HttpEventType2[HttpEventType2["DownloadProgress"] = 3] = "DownloadProgress";
  HttpEventType2[HttpEventType2["Response"] = 4] = "Response";
  HttpEventType2[HttpEventType2["User"] = 5] = "User";
})(HttpEventType || (HttpEventType = {}));
var HttpResponseBase = class {
  /**
   * All response headers.
   */
  headers;
  /**
   * Response status code.
   */
  status;
  /**
   * Textual description of response status code, defaults to OK.
   *
   * Do not depend on this.
   */
  statusText;
  /**
   * URL of the resource retrieved, or null if not available.
   */
  url;
  /**
   * Whether the status code falls in the 2xx range.
   */
  ok;
  /**
   * Type of the response, narrowed to either the full response or the header.
   */
  // TODO(issue/24571): remove '!'.
  type;
  /**
   * Super-constructor for all responses.
   *
   * The single parameter accepted is an initialization hash. Any properties
   * of the response passed there will override the default values.
   */
  constructor(init2, defaultStatus = 200, defaultStatusText = "OK") {
    this.headers = init2.headers || new HttpHeaders();
    this.status = init2.status !== void 0 ? init2.status : defaultStatus;
    this.statusText = init2.statusText || defaultStatusText;
    this.url = init2.url || null;
    this.ok = this.status >= 200 && this.status < 300;
  }
};
var HttpHeaderResponse = class _HttpHeaderResponse extends HttpResponseBase {
  /**
   * Create a new `HttpHeaderResponse` with the given parameters.
   */
  constructor(init2 = {}) {
    super(init2);
  }
  type = HttpEventType.ResponseHeader;
  /**
   * Copy this `HttpHeaderResponse`, overriding its contents with the
   * given parameter hash.
   */
  clone(update = {}) {
    return new _HttpHeaderResponse({
      headers: update.headers || this.headers,
      status: update.status !== void 0 ? update.status : this.status,
      statusText: update.statusText || this.statusText,
      url: update.url || this.url || void 0
    });
  }
};
var HttpResponse = class _HttpResponse extends HttpResponseBase {
  /**
   * The response body, or `null` if one was not returned.
   */
  body;
  /**
   * Construct a new `HttpResponse`.
   */
  constructor(init2 = {}) {
    super(init2);
    this.body = init2.body !== void 0 ? init2.body : null;
  }
  type = HttpEventType.Response;
  clone(update = {}) {
    return new _HttpResponse({
      body: update.body !== void 0 ? update.body : this.body,
      headers: update.headers || this.headers,
      status: update.status !== void 0 ? update.status : this.status,
      statusText: update.statusText || this.statusText,
      url: update.url || this.url || void 0
    });
  }
};
var HttpErrorResponse = class extends HttpResponseBase {
  name = "HttpErrorResponse";
  message;
  error;
  /**
   * Errors are never okay, even when the status code is in the 2xx success range.
   */
  ok = false;
  constructor(init2) {
    super(init2, 0, "Unknown Error");
    if (this.status >= 200 && this.status < 300) {
      this.message = `Http failure during parsing for ${init2.url || "(unknown url)"}`;
    } else {
      this.message = `Http failure response for ${init2.url || "(unknown url)"}: ${init2.status} ${init2.statusText}`;
    }
    this.error = init2.error || null;
  }
};
var HTTP_STATUS_CODE_OK = 200;
var HTTP_STATUS_CODE_NO_CONTENT = 204;
var HttpStatusCode;
(function(HttpStatusCode2) {
  HttpStatusCode2[HttpStatusCode2["Continue"] = 100] = "Continue";
  HttpStatusCode2[HttpStatusCode2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
  HttpStatusCode2[HttpStatusCode2["Processing"] = 102] = "Processing";
  HttpStatusCode2[HttpStatusCode2["EarlyHints"] = 103] = "EarlyHints";
  HttpStatusCode2[HttpStatusCode2["Ok"] = 200] = "Ok";
  HttpStatusCode2[HttpStatusCode2["Created"] = 201] = "Created";
  HttpStatusCode2[HttpStatusCode2["Accepted"] = 202] = "Accepted";
  HttpStatusCode2[HttpStatusCode2["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
  HttpStatusCode2[HttpStatusCode2["NoContent"] = 204] = "NoContent";
  HttpStatusCode2[HttpStatusCode2["ResetContent"] = 205] = "ResetContent";
  HttpStatusCode2[HttpStatusCode2["PartialContent"] = 206] = "PartialContent";
  HttpStatusCode2[HttpStatusCode2["MultiStatus"] = 207] = "MultiStatus";
  HttpStatusCode2[HttpStatusCode2["AlreadyReported"] = 208] = "AlreadyReported";
  HttpStatusCode2[HttpStatusCode2["ImUsed"] = 226] = "ImUsed";
  HttpStatusCode2[HttpStatusCode2["MultipleChoices"] = 300] = "MultipleChoices";
  HttpStatusCode2[HttpStatusCode2["MovedPermanently"] = 301] = "MovedPermanently";
  HttpStatusCode2[HttpStatusCode2["Found"] = 302] = "Found";
  HttpStatusCode2[HttpStatusCode2["SeeOther"] = 303] = "SeeOther";
  HttpStatusCode2[HttpStatusCode2["NotModified"] = 304] = "NotModified";
  HttpStatusCode2[HttpStatusCode2["UseProxy"] = 305] = "UseProxy";
  HttpStatusCode2[HttpStatusCode2["Unused"] = 306] = "Unused";
  HttpStatusCode2[HttpStatusCode2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
  HttpStatusCode2[HttpStatusCode2["PermanentRedirect"] = 308] = "PermanentRedirect";
  HttpStatusCode2[HttpStatusCode2["BadRequest"] = 400] = "BadRequest";
  HttpStatusCode2[HttpStatusCode2["Unauthorized"] = 401] = "Unauthorized";
  HttpStatusCode2[HttpStatusCode2["PaymentRequired"] = 402] = "PaymentRequired";
  HttpStatusCode2[HttpStatusCode2["Forbidden"] = 403] = "Forbidden";
  HttpStatusCode2[HttpStatusCode2["NotFound"] = 404] = "NotFound";
  HttpStatusCode2[HttpStatusCode2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
  HttpStatusCode2[HttpStatusCode2["NotAcceptable"] = 406] = "NotAcceptable";
  HttpStatusCode2[HttpStatusCode2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
  HttpStatusCode2[HttpStatusCode2["RequestTimeout"] = 408] = "RequestTimeout";
  HttpStatusCode2[HttpStatusCode2["Conflict"] = 409] = "Conflict";
  HttpStatusCode2[HttpStatusCode2["Gone"] = 410] = "Gone";
  HttpStatusCode2[HttpStatusCode2["LengthRequired"] = 411] = "LengthRequired";
  HttpStatusCode2[HttpStatusCode2["PreconditionFailed"] = 412] = "PreconditionFailed";
  HttpStatusCode2[HttpStatusCode2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
  HttpStatusCode2[HttpStatusCode2["UriTooLong"] = 414] = "UriTooLong";
  HttpStatusCode2[HttpStatusCode2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
  HttpStatusCode2[HttpStatusCode2["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
  HttpStatusCode2[HttpStatusCode2["ExpectationFailed"] = 417] = "ExpectationFailed";
  HttpStatusCode2[HttpStatusCode2["ImATeapot"] = 418] = "ImATeapot";
  HttpStatusCode2[HttpStatusCode2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
  HttpStatusCode2[HttpStatusCode2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
  HttpStatusCode2[HttpStatusCode2["Locked"] = 423] = "Locked";
  HttpStatusCode2[HttpStatusCode2["FailedDependency"] = 424] = "FailedDependency";
  HttpStatusCode2[HttpStatusCode2["TooEarly"] = 425] = "TooEarly";
  HttpStatusCode2[HttpStatusCode2["UpgradeRequired"] = 426] = "UpgradeRequired";
  HttpStatusCode2[HttpStatusCode2["PreconditionRequired"] = 428] = "PreconditionRequired";
  HttpStatusCode2[HttpStatusCode2["TooManyRequests"] = 429] = "TooManyRequests";
  HttpStatusCode2[HttpStatusCode2["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
  HttpStatusCode2[HttpStatusCode2["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
  HttpStatusCode2[HttpStatusCode2["InternalServerError"] = 500] = "InternalServerError";
  HttpStatusCode2[HttpStatusCode2["NotImplemented"] = 501] = "NotImplemented";
  HttpStatusCode2[HttpStatusCode2["BadGateway"] = 502] = "BadGateway";
  HttpStatusCode2[HttpStatusCode2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
  HttpStatusCode2[HttpStatusCode2["GatewayTimeout"] = 504] = "GatewayTimeout";
  HttpStatusCode2[HttpStatusCode2["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
  HttpStatusCode2[HttpStatusCode2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
  HttpStatusCode2[HttpStatusCode2["InsufficientStorage"] = 507] = "InsufficientStorage";
  HttpStatusCode2[HttpStatusCode2["LoopDetected"] = 508] = "LoopDetected";
  HttpStatusCode2[HttpStatusCode2["NotExtended"] = 510] = "NotExtended";
  HttpStatusCode2[HttpStatusCode2["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));
function addBody(options, body) {
  return {
    body,
    headers: options.headers,
    context: options.context,
    observe: options.observe,
    params: options.params,
    reportProgress: options.reportProgress,
    responseType: options.responseType,
    withCredentials: options.withCredentials,
    transferCache: options.transferCache
  };
}
var HttpClient = class _HttpClient {
  handler;
  constructor(handler) {
    this.handler = handler;
  }
  /**
   * Constructs an observable for a generic HTTP request that, when subscribed,
   * fires the request through the chain of registered interceptors and on to the
   * server.
   *
   * You can pass an `HttpRequest` directly as the only parameter. In this case,
   * the call returns an observable of the raw `HttpEvent` stream.
   *
   * Alternatively you can pass an HTTP method as the first parameter,
   * a URL string as the second, and an options hash containing the request body as the third.
   * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the
   * type of returned observable.
   *   * The `responseType` value determines how a successful response body is parsed.
   *   * If `responseType` is the default `json`, you can pass a type interface for the resulting
   * object as a type parameter to the call.
   *
   * The `observe` value determines the return type, according to what you are interested in
   * observing.
   *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including
   * progress events by default.
   *   * An `observe` value of response returns an observable of `HttpResponse<T>`,
   * where the `T` parameter depends on the `responseType` and any optionally provided type
   * parameter.
   *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.
   *
   */
  request(first2, url, options = {}) {
    let req;
    if (first2 instanceof HttpRequest) {
      req = first2;
    } else {
      let headers = void 0;
      if (options.headers instanceof HttpHeaders) {
        headers = options.headers;
      } else {
        headers = new HttpHeaders(options.headers);
      }
      let params = void 0;
      if (!!options.params) {
        if (options.params instanceof HttpParams) {
          params = options.params;
        } else {
          params = new HttpParams({
            fromObject: options.params
          });
        }
      }
      req = new HttpRequest(first2, url, options.body !== void 0 ? options.body : null, {
        headers,
        context: options.context,
        params,
        reportProgress: options.reportProgress,
        // By default, JSON is assumed to be returned for all calls.
        responseType: options.responseType || "json",
        withCredentials: options.withCredentials,
        transferCache: options.transferCache
      });
    }
    const events$ = of(req).pipe(concatMap((req2) => this.handler.handle(req2)));
    if (first2 instanceof HttpRequest || options.observe === "events") {
      return events$;
    }
    const res$ = events$.pipe(filter((event) => event instanceof HttpResponse));
    switch (options.observe || "body") {
      case "body":
        switch (req.responseType) {
          case "arraybuffer":
            return res$.pipe(map((res) => {
              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                throw new Error("Response is not an ArrayBuffer.");
              }
              return res.body;
            }));
          case "blob":
            return res$.pipe(map((res) => {
              if (res.body !== null && !(res.body instanceof Blob)) {
                throw new Error("Response is not a Blob.");
              }
              return res.body;
            }));
          case "text":
            return res$.pipe(map((res) => {
              if (res.body !== null && typeof res.body !== "string") {
                throw new Error("Response is not a string.");
              }
              return res.body;
            }));
          case "json":
          default:
            return res$.pipe(map((res) => res.body));
        }
      case "response":
        return res$;
      default:
        throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);
    }
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `DELETE` request to execute on the server. See the individual overloads for
   * details on the return type.
   *
   * @param url     The endpoint URL.
   * @param options The HTTP options to send with the request.
   *
   */
  delete(url, options = {}) {
    return this.request("DELETE", url, options);
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `GET` request to execute on the server. See the individual overloads for
   * details on the return type.
   */
  get(url, options = {}) {
    return this.request("GET", url, options);
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `HEAD` request to execute on the server. The `HEAD` method returns
   * meta information about the resource without transferring the
   * resource itself. See the individual overloads for
   * details on the return type.
   */
  head(url, options = {}) {
    return this.request("HEAD", url, options);
  }
  /**
   * Constructs an `Observable` that, when subscribed, causes a request with the special method
   * `JSONP` to be dispatched via the interceptor pipeline.
   * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain
   * API endpoints that don't support newer,
   * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.
   * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the
   * requests even if the API endpoint is not located on the same domain (origin) as the client-side
   * application making the request.
   * The endpoint API must support JSONP callback for JSONP requests to work.
   * The resource API returns the JSON response wrapped in a callback function.
   * You can pass the callback function name as one of the query parameters.
   * Note that JSONP requests can only be used with `GET` requests.
   *
   * @param url The resource URL.
   * @param callbackParam The callback function name.
   *
   */
  jsonp(url, callbackParam) {
    return this.request("JSONP", url, {
      params: new HttpParams().append(callbackParam, "JSONP_CALLBACK"),
      observe: "body",
      responseType: "json"
    });
  }
  /**
   * Constructs an `Observable` that, when subscribed, causes the configured
   * `OPTIONS` request to execute on the server. This method allows the client
   * to determine the supported HTTP methods and other capabilities of an endpoint,
   * without implying a resource action. See the individual overloads for
   * details on the return type.
   */
  options(url, options = {}) {
    return this.request("OPTIONS", url, options);
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `PATCH` request to execute on the server. See the individual overloads for
   * details on the return type.
   */
  patch(url, body, options = {}) {
    return this.request("PATCH", url, addBody(options, body));
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `POST` request to execute on the server. The server responds with the location of
   * the replaced resource. See the individual overloads for
   * details on the return type.
   */
  post(url, body, options = {}) {
    return this.request("POST", url, addBody(options, body));
  }
  /**
   * Constructs an observable that, when subscribed, causes the configured
   * `PUT` request to execute on the server. The `PUT` method replaces an existing resource
   * with a new set of values.
   * See the individual overloads for details on the return type.
   */
  put(url, body, options = {}) {
    return this.request("PUT", url, addBody(options, body));
  }
  static \u0275fac = function HttpClient_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpClient)(\u0275\u0275inject(HttpHandler));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpClient,
    factory: _HttpClient.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClient, [{
    type: Injectable
  }], () => [{
    type: HttpHandler
  }], null);
})();
var XSSI_PREFIX$1 = /^\)\]\}',?\n/;
var REQUEST_URL_HEADER = `X-Request-URL`;
function getResponseUrl$1(response) {
  if (response.url) {
    return response.url;
  }
  const xRequestUrl = REQUEST_URL_HEADER.toLocaleLowerCase();
  return response.headers.get(xRequestUrl);
}
var FetchBackend = class _FetchBackend {
  // We use an arrow function to always reference the current global implementation of `fetch`.
  // This is helpful for cases when the global `fetch` implementation is modified by external code,
  // see https://github.com/angular/angular/issues/57527.
  fetchImpl = inject(FetchFactory, {
    optional: true
  })?.fetch ?? ((...args) => globalThis.fetch(...args));
  ngZone = inject(NgZone);
  handle(request) {
    return new Observable((observer) => {
      const aborter = new AbortController();
      this.doRequest(request, aborter.signal, observer).then(noop3, (error) => observer.error(new HttpErrorResponse({
        error
      })));
      return () => aborter.abort();
    });
  }
  doRequest(request, signal2, observer) {
    return __async(this, null, function* () {
      const init2 = this.createRequestInit(request);
      let response;
      try {
        const fetchPromise = this.ngZone.runOutsideAngular(() => this.fetchImpl(request.urlWithParams, __spreadValues({
          signal: signal2
        }, init2)));
        silenceSuperfluousUnhandledPromiseRejection(fetchPromise);
        observer.next({
          type: HttpEventType.Sent
        });
        response = yield fetchPromise;
      } catch (error) {
        observer.error(new HttpErrorResponse({
          error,
          status: error.status ?? 0,
          statusText: error.statusText,
          url: request.urlWithParams,
          headers: error.headers
        }));
        return;
      }
      const headers = new HttpHeaders(response.headers);
      const statusText = response.statusText;
      const url = getResponseUrl$1(response) ?? request.urlWithParams;
      let status = response.status;
      let body = null;
      if (request.reportProgress) {
        observer.next(new HttpHeaderResponse({
          headers,
          status,
          statusText,
          url
        }));
      }
      if (response.body) {
        const contentLength = response.headers.get("content-length");
        const chunks = [];
        const reader = response.body.getReader();
        let receivedLength = 0;
        let decoder;
        let partialText;
        const reqZone = typeof Zone !== "undefined" && Zone.current;
        yield this.ngZone.runOutsideAngular(() => __async(this, null, function* () {
          while (true) {
            const {
              done,
              value: value2
            } = yield reader.read();
            if (done) {
              break;
            }
            chunks.push(value2);
            receivedLength += value2.length;
            if (request.reportProgress) {
              partialText = request.responseType === "text" ? (partialText ?? "") + (decoder ??= new TextDecoder()).decode(value2, {
                stream: true
              }) : void 0;
              const reportProgress = () => observer.next({
                type: HttpEventType.DownloadProgress,
                total: contentLength ? +contentLength : void 0,
                loaded: receivedLength,
                partialText
              });
              reqZone ? reqZone.run(reportProgress) : reportProgress();
            }
          }
        }));
        const chunksAll = this.concatChunks(chunks, receivedLength);
        try {
          const contentType = response.headers.get("Content-Type") ?? "";
          body = this.parseBody(request, chunksAll, contentType);
        } catch (error) {
          observer.error(new HttpErrorResponse({
            error,
            headers: new HttpHeaders(response.headers),
            status: response.status,
            statusText: response.statusText,
            url: getResponseUrl$1(response) ?? request.urlWithParams
          }));
          return;
        }
      }
      if (status === 0) {
        status = body ? HTTP_STATUS_CODE_OK : 0;
      }
      const ok = status >= 200 && status < 300;
      if (ok) {
        observer.next(new HttpResponse({
          body,
          headers,
          status,
          statusText,
          url
        }));
        observer.complete();
      } else {
        observer.error(new HttpErrorResponse({
          error: body,
          headers,
          status,
          statusText,
          url
        }));
      }
    });
  }
  parseBody(request, binContent, contentType) {
    switch (request.responseType) {
      case "json":
        const text2 = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, "");
        return text2 === "" ? null : JSON.parse(text2);
      case "text":
        return new TextDecoder().decode(binContent);
      case "blob":
        return new Blob([binContent], {
          type: contentType
        });
      case "arraybuffer":
        return binContent.buffer;
    }
  }
  createRequestInit(req) {
    const headers = {};
    const credentials = req.withCredentials ? "include" : void 0;
    req.headers.forEach((name, values) => headers[name] = values.join(","));
    if (!req.headers.has("Accept")) {
      headers["Accept"] = "application/json, text/plain, */*";
    }
    if (!req.headers.has("Content-Type")) {
      const detectedType = req.detectContentTypeHeader();
      if (detectedType !== null) {
        headers["Content-Type"] = detectedType;
      }
    }
    return {
      body: req.serializeBody(),
      method: req.method,
      headers,
      credentials
    };
  }
  concatChunks(chunks, totalLength) {
    const chunksAll = new Uint8Array(totalLength);
    let position = 0;
    for (const chunk of chunks) {
      chunksAll.set(chunk, position);
      position += chunk.length;
    }
    return chunksAll;
  }
  static \u0275fac = function FetchBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FetchBackend)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _FetchBackend,
    factory: _FetchBackend.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FetchBackend, [{
    type: Injectable
  }], null, null);
})();
var FetchFactory = class {
};
function noop3() {
}
function silenceSuperfluousUnhandledPromiseRejection(promise) {
  promise.then(noop3, noop3);
}
function interceptorChainEndFn(req, finalHandlerFn) {
  return finalHandlerFn(req);
}
function adaptLegacyInterceptorToChain(chainTailFn, interceptor) {
  return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {
    handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)
  });
}
function chainedInterceptorFn(chainTailFn, interceptorFn, injector) {
  return (initialRequest, finalHandlerFn) => runInInjectionContext(injector, () => interceptorFn(initialRequest, (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)));
}
var HTTP_INTERCEPTORS = new InjectionToken(ngDevMode ? "HTTP_INTERCEPTORS" : "");
var HTTP_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? "HTTP_INTERCEPTOR_FNS" : "");
var HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? "HTTP_ROOT_INTERCEPTOR_FNS" : "");
var REQUESTS_CONTRIBUTE_TO_STABILITY = new InjectionToken(ngDevMode ? "REQUESTS_CONTRIBUTE_TO_STABILITY" : "", {
  providedIn: "root",
  factory: () => true
});
function legacyInterceptorFnFactory() {
  let chain = null;
  return (req, handler) => {
    if (chain === null) {
      const interceptors = inject(HTTP_INTERCEPTORS, {
        optional: true
      }) ?? [];
      chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);
    }
    const pendingTasks = inject(PendingTasksInternal);
    const contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);
    if (contributeToStability) {
      const taskId = pendingTasks.add();
      return chain(req, handler).pipe(finalize(() => pendingTasks.remove(taskId)));
    } else {
      return chain(req, handler);
    }
  };
}
var fetchBackendWarningDisplayed = false;
var HttpInterceptorHandler = class _HttpInterceptorHandler extends HttpHandler {
  backend;
  injector;
  chain = null;
  pendingTasks = inject(PendingTasksInternal);
  contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);
  constructor(backend, injector) {
    super();
    this.backend = backend;
    this.injector = injector;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !fetchBackendWarningDisplayed) {
      const isServer = isPlatformServer(injector.get(PLATFORM_ID));
      if (isServer && !(this.backend instanceof FetchBackend)) {
        fetchBackendWarningDisplayed = true;
        injector.get(Console).warn(formatRuntimeError(2801, "Angular detected that `HttpClient` is not configured to use `fetch` APIs. It's strongly recommended to enable `fetch` for applications that use Server-Side Rendering for better performance and compatibility. To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` call at the root of the application."));
      }
    }
  }
  handle(initialRequest) {
    if (this.chain === null) {
      const dedupedInterceptorFns = Array.from(/* @__PURE__ */ new Set([...this.injector.get(HTTP_INTERCEPTOR_FNS), ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, [])]));
      this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);
    }
    if (this.contributeToStability) {
      const taskId = this.pendingTasks.add();
      return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest)).pipe(finalize(() => this.pendingTasks.remove(taskId)));
    } else {
      return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest));
    }
  }
  static \u0275fac = function HttpInterceptorHandler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpInterceptorHandler)(\u0275\u0275inject(HttpBackend), \u0275\u0275inject(EnvironmentInjector));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpInterceptorHandler,
    factory: _HttpInterceptorHandler.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpInterceptorHandler, [{
    type: Injectable
  }], () => [{
    type: HttpBackend
  }, {
    type: EnvironmentInjector
  }], null);
})();
var nextRequestId = 0;
var foreignDocument;
var JSONP_ERR_NO_CALLBACK = "JSONP injected script did not invoke callback.";
var JSONP_ERR_WRONG_METHOD = "JSONP requests must use JSONP request method.";
var JSONP_ERR_WRONG_RESPONSE_TYPE = "JSONP requests must use Json response type.";
var JSONP_ERR_HEADERS_NOT_SUPPORTED = "JSONP requests do not support headers.";
var JsonpCallbackContext = class {
};
function jsonpCallbackContext() {
  if (typeof window === "object") {
    return window;
  }
  return {};
}
var JsonpClientBackend = class _JsonpClientBackend {
  callbackMap;
  document;
  /**
   * A resolved promise that can be used to schedule microtasks in the event handlers.
   */
  resolvedPromise = Promise.resolve();
  constructor(callbackMap, document2) {
    this.callbackMap = callbackMap;
    this.document = document2;
  }
  /**
   * Get the name of the next callback method, by incrementing the global `nextRequestId`.
   */
  nextCallback() {
    return `ng_jsonp_callback_${nextRequestId++}`;
  }
  /**
   * Processes a JSONP request and returns an event stream of the results.
   * @param req The request object.
   * @returns An observable of the response events.
   *
   */
  handle(req) {
    if (req.method !== "JSONP") {
      throw new Error(JSONP_ERR_WRONG_METHOD);
    } else if (req.responseType !== "json") {
      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
    }
    if (req.headers.keys().length > 0) {
      throw new Error(JSONP_ERR_HEADERS_NOT_SUPPORTED);
    }
    return new Observable((observer) => {
      const callback = this.nextCallback();
      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);
      const node = this.document.createElement("script");
      node.src = url;
      let body = null;
      let finished = false;
      this.callbackMap[callback] = (data) => {
        delete this.callbackMap[callback];
        body = data;
        finished = true;
      };
      const cleanup = () => {
        node.removeEventListener("load", onLoad);
        node.removeEventListener("error", onError);
        node.remove();
        delete this.callbackMap[callback];
      };
      const onLoad = (event) => {
        this.resolvedPromise.then(() => {
          cleanup();
          if (!finished) {
            observer.error(new HttpErrorResponse({
              url,
              status: 0,
              statusText: "JSONP Error",
              error: new Error(JSONP_ERR_NO_CALLBACK)
            }));
            return;
          }
          observer.next(new HttpResponse({
            body,
            status: HTTP_STATUS_CODE_OK,
            statusText: "OK",
            url
          }));
          observer.complete();
        });
      };
      const onError = (error) => {
        cleanup();
        observer.error(new HttpErrorResponse({
          error,
          status: 0,
          statusText: "JSONP Error",
          url
        }));
      };
      node.addEventListener("load", onLoad);
      node.addEventListener("error", onError);
      this.document.body.appendChild(node);
      observer.next({
        type: HttpEventType.Sent
      });
      return () => {
        if (!finished) {
          this.removeListeners(node);
        }
        cleanup();
      };
    });
  }
  removeListeners(script) {
    foreignDocument ??= this.document.implementation.createHTMLDocument();
    foreignDocument.adoptNode(script);
  }
  static \u0275fac = function JsonpClientBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _JsonpClientBackend)(\u0275\u0275inject(JsonpCallbackContext), \u0275\u0275inject(DOCUMENT2));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _JsonpClientBackend,
    factory: _JsonpClientBackend.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpClientBackend, [{
    type: Injectable
  }], () => [{
    type: JsonpCallbackContext
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
function jsonpInterceptorFn(req, next) {
  if (req.method === "JSONP") {
    return inject(JsonpClientBackend).handle(req);
  }
  return next(req);
}
var JsonpInterceptor = class _JsonpInterceptor {
  injector;
  constructor(injector) {
    this.injector = injector;
  }
  /**
   * Identifies and handles a given JSONP request.
   * @param initialRequest The outgoing request object to handle.
   * @param next The next interceptor in the chain, or the backend
   * if no interceptors remain in the chain.
   * @returns An observable of the event stream.
   */
  intercept(initialRequest, next) {
    return runInInjectionContext(this.injector, () => jsonpInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
  }
  static \u0275fac = function JsonpInterceptor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _JsonpInterceptor)(\u0275\u0275inject(EnvironmentInjector));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _JsonpInterceptor,
    factory: _JsonpInterceptor.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpInterceptor, [{
    type: Injectable
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var XSSI_PREFIX = /^\)\]\}',?\n/;
function getResponseUrl(xhr) {
  if ("responseURL" in xhr && xhr.responseURL) {
    return xhr.responseURL;
  }
  if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
    return xhr.getResponseHeader("X-Request-URL");
  }
  return null;
}
var HttpXhrBackend = class _HttpXhrBackend {
  xhrFactory;
  constructor(xhrFactory) {
    this.xhrFactory = xhrFactory;
  }
  /**
   * Processes a request and returns a stream of response events.
   * @param req The request object.
   * @returns An observable of the response events.
   */
  handle(req) {
    if (req.method === "JSONP") {
      throw new RuntimeError(-2800, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \`withJsonpSupport()\` call (if \`provideHttpClient()\` is used) or import the \`HttpClientJsonpModule\` in the root NgModule.`);
    }
    const xhrFactory = this.xhrFactory;
    const source = xhrFactory.\u0275loadImpl ? from(xhrFactory.\u0275loadImpl()) : of(null);
    return source.pipe(switchMap(() => {
      return new Observable((observer) => {
        const xhr = xhrFactory.build();
        xhr.open(req.method, req.urlWithParams);
        if (req.withCredentials) {
          xhr.withCredentials = true;
        }
        req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(",")));
        if (!req.headers.has("Accept")) {
          xhr.setRequestHeader("Accept", "application/json, text/plain, */*");
        }
        if (!req.headers.has("Content-Type")) {
          const detectedType = req.detectContentTypeHeader();
          if (detectedType !== null) {
            xhr.setRequestHeader("Content-Type", detectedType);
          }
        }
        if (req.responseType) {
          const responseType = req.responseType.toLowerCase();
          xhr.responseType = responseType !== "json" ? responseType : "text";
        }
        const reqBody = req.serializeBody();
        let headerResponse = null;
        const partialFromXhr = () => {
          if (headerResponse !== null) {
            return headerResponse;
          }
          const statusText = xhr.statusText || "OK";
          const headers = new HttpHeaders(xhr.getAllResponseHeaders());
          const url = getResponseUrl(xhr) || req.url;
          headerResponse = new HttpHeaderResponse({
            headers,
            status: xhr.status,
            statusText,
            url
          });
          return headerResponse;
        };
        const onLoad = () => {
          let {
            headers,
            status,
            statusText,
            url
          } = partialFromXhr();
          let body = null;
          if (status !== HTTP_STATUS_CODE_NO_CONTENT) {
            body = typeof xhr.response === "undefined" ? xhr.responseText : xhr.response;
          }
          if (status === 0) {
            status = !!body ? HTTP_STATUS_CODE_OK : 0;
          }
          let ok = status >= 200 && status < 300;
          if (req.responseType === "json" && typeof body === "string") {
            const originalBody = body;
            body = body.replace(XSSI_PREFIX, "");
            try {
              body = body !== "" ? JSON.parse(body) : null;
            } catch (error) {
              body = originalBody;
              if (ok) {
                ok = false;
                body = {
                  error,
                  text: body
                };
              }
            }
          }
          if (ok) {
            observer.next(new HttpResponse({
              body,
              headers,
              status,
              statusText,
              url: url || void 0
            }));
            observer.complete();
          } else {
            observer.error(new HttpErrorResponse({
              // The error in this case is the response body (error from the server).
              error: body,
              headers,
              status,
              statusText,
              url: url || void 0
            }));
          }
        };
        const onError = (error) => {
          const {
            url
          } = partialFromXhr();
          const res = new HttpErrorResponse({
            error,
            status: xhr.status || 0,
            statusText: xhr.statusText || "Unknown Error",
            url: url || void 0
          });
          observer.error(res);
        };
        let sentHeaders = false;
        const onDownProgress = (event) => {
          if (!sentHeaders) {
            observer.next(partialFromXhr());
            sentHeaders = true;
          }
          let progressEvent = {
            type: HttpEventType.DownloadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progressEvent.total = event.total;
          }
          if (req.responseType === "text" && !!xhr.responseText) {
            progressEvent.partialText = xhr.responseText;
          }
          observer.next(progressEvent);
        };
        const onUpProgress = (event) => {
          let progress = {
            type: HttpEventType.UploadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progress.total = event.total;
          }
          observer.next(progress);
        };
        xhr.addEventListener("load", onLoad);
        xhr.addEventListener("error", onError);
        xhr.addEventListener("timeout", onError);
        xhr.addEventListener("abort", onError);
        if (req.reportProgress) {
          xhr.addEventListener("progress", onDownProgress);
          if (reqBody !== null && xhr.upload) {
            xhr.upload.addEventListener("progress", onUpProgress);
          }
        }
        xhr.send(reqBody);
        observer.next({
          type: HttpEventType.Sent
        });
        return () => {
          xhr.removeEventListener("error", onError);
          xhr.removeEventListener("abort", onError);
          xhr.removeEventListener("load", onLoad);
          xhr.removeEventListener("timeout", onError);
          if (req.reportProgress) {
            xhr.removeEventListener("progress", onDownProgress);
            if (reqBody !== null && xhr.upload) {
              xhr.upload.removeEventListener("progress", onUpProgress);
            }
          }
          if (xhr.readyState !== xhr.DONE) {
            xhr.abort();
          }
        };
      });
    }));
  }
  static \u0275fac = function HttpXhrBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpXhrBackend)(\u0275\u0275inject(XhrFactory));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpXhrBackend,
    factory: _HttpXhrBackend.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXhrBackend, [{
    type: Injectable
  }], () => [{
    type: XhrFactory
  }], null);
})();
var XSRF_ENABLED = new InjectionToken(ngDevMode ? "XSRF_ENABLED" : "");
var XSRF_DEFAULT_COOKIE_NAME = "XSRF-TOKEN";
var XSRF_COOKIE_NAME = new InjectionToken(ngDevMode ? "XSRF_COOKIE_NAME" : "", {
  providedIn: "root",
  factory: () => XSRF_DEFAULT_COOKIE_NAME
});
var XSRF_DEFAULT_HEADER_NAME = "X-XSRF-TOKEN";
var XSRF_HEADER_NAME = new InjectionToken(ngDevMode ? "XSRF_HEADER_NAME" : "", {
  providedIn: "root",
  factory: () => XSRF_DEFAULT_HEADER_NAME
});
var HttpXsrfTokenExtractor = class {
};
var HttpXsrfCookieExtractor = class _HttpXsrfCookieExtractor {
  doc;
  platform;
  cookieName;
  lastCookieString = "";
  lastToken = null;
  /**
   * @internal for testing
   */
  parseCount = 0;
  constructor(doc, platform2, cookieName) {
    this.doc = doc;
    this.platform = platform2;
    this.cookieName = cookieName;
  }
  getToken() {
    if (this.platform === "server") {
      return null;
    }
    const cookieString = this.doc.cookie || "";
    if (cookieString !== this.lastCookieString) {
      this.parseCount++;
      this.lastToken = parseCookieValue(cookieString, this.cookieName);
      this.lastCookieString = cookieString;
    }
    return this.lastToken;
  }
  static \u0275fac = function HttpXsrfCookieExtractor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpXsrfCookieExtractor)(\u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(XSRF_COOKIE_NAME));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpXsrfCookieExtractor,
    factory: _HttpXsrfCookieExtractor.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfCookieExtractor, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [XSRF_COOKIE_NAME]
    }]
  }], null);
})();
function xsrfInterceptorFn(req, next) {
  const lcUrl = req.url.toLowerCase();
  if (!inject(XSRF_ENABLED) || req.method === "GET" || req.method === "HEAD" || lcUrl.startsWith("http://") || lcUrl.startsWith("https://")) {
    return next(req);
  }
  const token = inject(HttpXsrfTokenExtractor).getToken();
  const headerName = inject(XSRF_HEADER_NAME);
  if (token != null && !req.headers.has(headerName)) {
    req = req.clone({
      headers: req.headers.set(headerName, token)
    });
  }
  return next(req);
}
var HttpXsrfInterceptor = class _HttpXsrfInterceptor {
  injector;
  constructor(injector) {
    this.injector = injector;
  }
  intercept(initialRequest, next) {
    return runInInjectionContext(this.injector, () => xsrfInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
  }
  static \u0275fac = function HttpXsrfInterceptor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpXsrfInterceptor)(\u0275\u0275inject(EnvironmentInjector));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpXsrfInterceptor,
    factory: _HttpXsrfInterceptor.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfInterceptor, [{
    type: Injectable
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var HttpFeatureKind;
(function(HttpFeatureKind2) {
  HttpFeatureKind2[HttpFeatureKind2["Interceptors"] = 0] = "Interceptors";
  HttpFeatureKind2[HttpFeatureKind2["LegacyInterceptors"] = 1] = "LegacyInterceptors";
  HttpFeatureKind2[HttpFeatureKind2["CustomXsrfConfiguration"] = 2] = "CustomXsrfConfiguration";
  HttpFeatureKind2[HttpFeatureKind2["NoXsrfProtection"] = 3] = "NoXsrfProtection";
  HttpFeatureKind2[HttpFeatureKind2["JsonpSupport"] = 4] = "JsonpSupport";
  HttpFeatureKind2[HttpFeatureKind2["RequestsMadeViaParent"] = 5] = "RequestsMadeViaParent";
  HttpFeatureKind2[HttpFeatureKind2["Fetch"] = 6] = "Fetch";
})(HttpFeatureKind || (HttpFeatureKind = {}));
function makeHttpFeature(kind, providers2) {
  return {
    \u0275kind: kind,
    \u0275providers: providers2
  };
}
function provideHttpClient(...features) {
  if (ngDevMode) {
    const featureKinds = new Set(features.map((f) => f.\u0275kind));
    if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) && featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {
      throw new Error(ngDevMode ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.` : "");
    }
  }
  const providers2 = [HttpClient, HttpXhrBackend, HttpInterceptorHandler, {
    provide: HttpHandler,
    useExisting: HttpInterceptorHandler
  }, {
    provide: HttpBackend,
    useFactory: () => {
      return inject(FetchBackend, {
        optional: true
      }) ?? inject(HttpXhrBackend);
    }
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: xsrfInterceptorFn,
    multi: true
  }, {
    provide: XSRF_ENABLED,
    useValue: true
  }, {
    provide: HttpXsrfTokenExtractor,
    useClass: HttpXsrfCookieExtractor
  }];
  for (const feature of features) {
    providers2.push(...feature.\u0275providers);
  }
  return makeEnvironmentProviders(providers2);
}
var LEGACY_INTERCEPTOR_FN = new InjectionToken(ngDevMode ? "LEGACY_INTERCEPTOR_FN" : "");
function withInterceptorsFromDi() {
  return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [{
    provide: LEGACY_INTERCEPTOR_FN,
    useFactory: legacyInterceptorFnFactory
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useExisting: LEGACY_INTERCEPTOR_FN,
    multi: true
  }]);
}
function withXsrfConfiguration({
  cookieName,
  headerName
}) {
  const providers2 = [];
  if (cookieName !== void 0) {
    providers2.push({
      provide: XSRF_COOKIE_NAME,
      useValue: cookieName
    });
  }
  if (headerName !== void 0) {
    providers2.push({
      provide: XSRF_HEADER_NAME,
      useValue: headerName
    });
  }
  return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers2);
}
function withNoXsrfProtection() {
  return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [{
    provide: XSRF_ENABLED,
    useValue: false
  }]);
}
function withJsonpSupport() {
  return makeHttpFeature(HttpFeatureKind.JsonpSupport, [JsonpClientBackend, {
    provide: JsonpCallbackContext,
    useFactory: jsonpCallbackContext
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: jsonpInterceptorFn,
    multi: true
  }]);
}
var HttpClientXsrfModule = class _HttpClientXsrfModule {
  /**
   * Disable the default XSRF protection.
   */
  static disable() {
    return {
      ngModule: _HttpClientXsrfModule,
      providers: [withNoXsrfProtection().\u0275providers]
    };
  }
  /**
   * Configure XSRF protection.
   * @param options An object that can specify either or both
   * cookie name or header name.
   * - Cookie name default is `XSRF-TOKEN`.
   * - Header name default is `X-XSRF-TOKEN`.
   *
   */
  static withOptions(options = {}) {
    return {
      ngModule: _HttpClientXsrfModule,
      providers: withXsrfConfiguration(options).\u0275providers
    };
  }
  static \u0275fac = function HttpClientXsrfModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpClientXsrfModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _HttpClientXsrfModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [HttpXsrfInterceptor, {
      provide: HTTP_INTERCEPTORS,
      useExisting: HttpXsrfInterceptor,
      multi: true
    }, {
      provide: HttpXsrfTokenExtractor,
      useClass: HttpXsrfCookieExtractor
    }, withXsrfConfiguration({
      cookieName: XSRF_DEFAULT_COOKIE_NAME,
      headerName: XSRF_DEFAULT_HEADER_NAME
    }).\u0275providers, {
      provide: XSRF_ENABLED,
      useValue: true
    }]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientXsrfModule, [{
    type: NgModule,
    args: [{
      providers: [HttpXsrfInterceptor, {
        provide: HTTP_INTERCEPTORS,
        useExisting: HttpXsrfInterceptor,
        multi: true
      }, {
        provide: HttpXsrfTokenExtractor,
        useClass: HttpXsrfCookieExtractor
      }, withXsrfConfiguration({
        cookieName: XSRF_DEFAULT_COOKIE_NAME,
        headerName: XSRF_DEFAULT_HEADER_NAME
      }).\u0275providers, {
        provide: XSRF_ENABLED,
        useValue: true
      }]
    }]
  }], null, null);
})();
var HttpClientModule = class _HttpClientModule {
  static \u0275fac = function HttpClientModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpClientModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _HttpClientModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [provideHttpClient(withInterceptorsFromDi())]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientModule, [{
    type: NgModule,
    args: [{
      /**
       * Configures the dependency injector where it is imported
       * with supporting services for HTTP communications.
       */
      providers: [provideHttpClient(withInterceptorsFromDi())]
    }]
  }], null, null);
})();
var HttpClientJsonpModule = class _HttpClientJsonpModule {
  static \u0275fac = function HttpClientJsonpModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpClientJsonpModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _HttpClientJsonpModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [withJsonpSupport().\u0275providers]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientJsonpModule, [{
    type: NgModule,
    args: [{
      providers: [withJsonpSupport().\u0275providers]
    }]
  }], null, null);
})();
var HTTP_TRANSFER_CACHE_ORIGIN_MAP = new InjectionToken(ngDevMode ? "HTTP_TRANSFER_CACHE_ORIGIN_MAP" : "");
var CACHE_OPTIONS = new InjectionToken(ngDevMode ? "HTTP_TRANSFER_STATE_CACHE_OPTIONS" : "");

// node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs
var GenericBrowserDomAdapter = class extends DomAdapter {
  supportsDOMEvents = true;
};
var BrowserDomAdapter = class _BrowserDomAdapter extends GenericBrowserDomAdapter {
  static makeCurrent() {
    setRootDomAdapter(new _BrowserDomAdapter());
  }
  onAndCancel(el, evt, listener2) {
    el.addEventListener(evt, listener2);
    return () => {
      el.removeEventListener(evt, listener2);
    };
  }
  dispatchEvent(el, evt) {
    el.dispatchEvent(evt);
  }
  remove(node) {
    node.remove();
  }
  createElement(tagName, doc) {
    doc = doc || this.getDefaultDocument();
    return doc.createElement(tagName);
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument("fakeTitle");
  }
  getDefaultDocument() {
    return document;
  }
  isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isShadowRoot(node) {
    return node instanceof DocumentFragment;
  }
  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */
  getGlobalEventTarget(doc, target) {
    if (target === "window") {
      return window;
    }
    if (target === "document") {
      return doc;
    }
    if (target === "body") {
      return doc.body;
    }
    return null;
  }
  getBaseHref(doc) {
    const href = getBaseElementHref();
    return href == null ? null : relativePath(href);
  }
  resetBaseElement() {
    baseElement = null;
  }
  getUserAgent() {
    return window.navigator.userAgent;
  }
  getCookie(name) {
    return parseCookieValue(document.cookie, name);
  }
};
var baseElement = null;
function getBaseElementHref() {
  baseElement = baseElement || document.querySelector("base");
  return baseElement ? baseElement.getAttribute("href") : null;
}
function relativePath(url) {
  return new URL(url, document.baseURI).pathname;
}
var BrowserGetTestability = class {
  addToWindow(registry) {
    _global["getAngularTestability"] = (elem, findInAncestors = true) => {
      const testability = registry.findTestabilityInTree(elem, findInAncestors);
      if (testability == null) {
        throw new RuntimeError(5103, (typeof ngDevMode === "undefined" || ngDevMode) && "Could not find testability for element.");
      }
      return testability;
    };
    _global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
    _global["getAllAngularRootElements"] = () => registry.getAllRootElements();
    const whenAllStable = (callback) => {
      const testabilities = _global["getAllAngularTestabilities"]();
      let count3 = testabilities.length;
      const decrement = function() {
        count3--;
        if (count3 == 0) {
          callback();
        }
      };
      testabilities.forEach((testability) => {
        testability.whenStable(decrement);
      });
    };
    if (!_global["frameworkStabilizers"]) {
      _global["frameworkStabilizers"] = [];
    }
    _global["frameworkStabilizers"].push(whenAllStable);
  }
  findTestabilityInTree(registry, elem, findInAncestors) {
    if (elem == null) {
      return null;
    }
    const t2 = registry.getTestability(elem);
    if (t2 != null) {
      return t2;
    } else if (!findInAncestors) {
      return null;
    }
    if (getDOM().isShadowRoot(elem)) {
      return this.findTestabilityInTree(registry, elem.host, true);
    }
    return this.findTestabilityInTree(registry, elem.parentElement, true);
  }
};
var BrowserXhr = class _BrowserXhr {
  build() {
    return new XMLHttpRequest();
  }
  static \u0275fac = function BrowserXhr_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserXhr)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _BrowserXhr,
    factory: _BrowserXhr.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserXhr, [{
    type: Injectable
  }], null, null);
})();
var EVENT_MANAGER_PLUGINS = new InjectionToken(ngDevMode ? "EventManagerPlugins" : "");
var EventManager = class _EventManager {
  _zone;
  _plugins;
  _eventNameToPlugin = /* @__PURE__ */ new Map();
  /**
   * Initializes an instance of the event-manager service.
   */
  constructor(plugins2, _zone) {
    this._zone = _zone;
    plugins2.forEach((plugin) => {
      plugin.manager = this;
    });
    this._plugins = plugins2.slice().reverse();
  }
  /**
   * Registers a handler for a specific element and event.
   *
   * @param element The HTML element to receive event notifications.
   * @param eventName The name of the event to listen for.
   * @param handler A function to call when the notification occurs. Receives the
   * event object as an argument.
   * @returns  A callback function that can be used to remove the handler.
   */
  addEventListener(element, eventName, handler) {
    const plugin = this._findPluginFor(eventName);
    return plugin.addEventListener(element, eventName, handler);
  }
  /**
   * Retrieves the compilation zone in which event listeners are registered.
   */
  getZone() {
    return this._zone;
  }
  /** @internal */
  _findPluginFor(eventName) {
    let plugin = this._eventNameToPlugin.get(eventName);
    if (plugin) {
      return plugin;
    }
    const plugins2 = this._plugins;
    plugin = plugins2.find((plugin2) => plugin2.supports(eventName));
    if (!plugin) {
      throw new RuntimeError(5101, (typeof ngDevMode === "undefined" || ngDevMode) && `No event manager plugin found for event ${eventName}`);
    }
    this._eventNameToPlugin.set(eventName, plugin);
    return plugin;
  }
  static \u0275fac = function EventManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EventManager)(\u0275\u0275inject(EVENT_MANAGER_PLUGINS), \u0275\u0275inject(NgZone));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _EventManager,
    factory: _EventManager.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventManager, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [EVENT_MANAGER_PLUGINS]
    }]
  }, {
    type: NgZone
  }], null);
})();
var EventManagerPlugin = class {
  _doc;
  // TODO: remove (has some usage in G3)
  constructor(_doc) {
    this._doc = _doc;
  }
  // Using non-null assertion because it's set by EventManager's constructor
  manager;
};
var APP_ID_ATTRIBUTE_NAME = "ng-app-id";
function removeElements(elements) {
  for (const element of elements) {
    element.remove();
  }
}
function createStyleElement(style2, doc) {
  const styleElement = doc.createElement("style");
  styleElement.textContent = style2;
  return styleElement;
}
function addServerStyles(doc, appId, usages) {
  const styleElements = doc.head?.querySelectorAll(`style[${APP_ID_ATTRIBUTE_NAME}="${appId}"]`);
  if (styleElements) {
    for (const styleElement of styleElements) {
      if (styleElement.textContent) {
        styleElement.removeAttribute(APP_ID_ATTRIBUTE_NAME);
        usages.set(styleElement.textContent, {
          usage: 0,
          elements: [styleElement]
        });
      }
    }
  }
}
function createLinkElement(url, doc) {
  const linkElement = doc.createElement("link");
  linkElement.setAttribute("rel", "stylesheet");
  linkElement.setAttribute("href", url);
  return linkElement;
}
var SharedStylesHost = class _SharedStylesHost {
  doc;
  appId;
  nonce;
  /**
   * Provides usage information for active inline style content and associated HTML <style> elements.
   * Embedded styles typically originate from the `styles` metadata of a rendered component.
   */
  inline = /* @__PURE__ */ new Map();
  /**
   * Provides usage information for active external style URLs and the associated HTML <link> elements.
   * External styles typically originate from the `ɵɵExternalStylesFeature` of a rendered component.
   */
  external = /* @__PURE__ */ new Map();
  /**
   * Set of host DOM nodes that will have styles attached.
   */
  hosts = /* @__PURE__ */ new Set();
  /**
   * Whether the application code is currently executing on a server.
   */
  isServer;
  constructor(doc, appId, nonce, platformId = {}) {
    this.doc = doc;
    this.appId = appId;
    this.nonce = nonce;
    this.isServer = isPlatformServer(platformId);
    addServerStyles(doc, appId, this.inline);
    this.hosts.add(doc.head);
  }
  /**
   * Adds embedded styles to the DOM via HTML `style` elements.
   * @param styles An array of style content strings.
   */
  addStyles(styles2, urls) {
    for (const value2 of styles2) {
      this.addUsage(value2, this.inline, createStyleElement);
    }
    urls?.forEach((value2) => this.addUsage(value2, this.external, createLinkElement));
  }
  /**
   * Removes embedded styles from the DOM that were added as HTML `style` elements.
   * @param styles An array of style content strings.
   */
  removeStyles(styles2, urls) {
    for (const value2 of styles2) {
      this.removeUsage(value2, this.inline);
    }
    urls?.forEach((value2) => this.removeUsage(value2, this.external));
  }
  addUsage(value2, usages, creator) {
    const record = usages.get(value2);
    if (record) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && record.usage === 0) {
        record.elements.forEach((element) => element.setAttribute("ng-style-reused", ""));
      }
      record.usage++;
    } else {
      usages.set(value2, {
        usage: 1,
        elements: [...this.hosts].map((host) => this.addElement(host, creator(value2, this.doc)))
      });
    }
  }
  removeUsage(value2, usages) {
    const record = usages.get(value2);
    if (record) {
      record.usage--;
      if (record.usage <= 0) {
        removeElements(record.elements);
        usages.delete(value2);
      }
    }
  }
  ngOnDestroy() {
    for (const [, {
      elements
    }] of [...this.inline, ...this.external]) {
      removeElements(elements);
    }
    this.hosts.clear();
  }
  /**
   * Adds a host node to the set of style hosts and adds all existing style usage to
   * the newly added host node.
   *
   * This is currently only used for Shadow DOM encapsulation mode.
   */
  addHost(hostNode) {
    this.hosts.add(hostNode);
    for (const [style2, {
      elements
    }] of this.inline) {
      elements.push(this.addElement(hostNode, createStyleElement(style2, this.doc)));
    }
    for (const [url, {
      elements
    }] of this.external) {
      elements.push(this.addElement(hostNode, createLinkElement(url, this.doc)));
    }
  }
  removeHost(hostNode) {
    this.hosts.delete(hostNode);
  }
  addElement(host, element) {
    if (this.nonce) {
      element.setAttribute("nonce", this.nonce);
    }
    if (this.isServer) {
      element.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);
    }
    return host.appendChild(element);
  }
  static \u0275fac = function SharedStylesHost_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SharedStylesHost)(\u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(APP_ID), \u0275\u0275inject(CSP_NONCE, 8), \u0275\u0275inject(PLATFORM_ID));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _SharedStylesHost,
    factory: _SharedStylesHost.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedStylesHost, [{
    type: Injectable
  }], () => [{
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [APP_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CSP_NONCE]
    }, {
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], null);
})();
var NAMESPACE_URIS = {
  "svg": "http://www.w3.org/2000/svg",
  "xhtml": "http://www.w3.org/1999/xhtml",
  "xlink": "http://www.w3.org/1999/xlink",
  "xml": "http://www.w3.org/XML/1998/namespace",
  "xmlns": "http://www.w3.org/2000/xmlns/",
  "math": "http://www.w3.org/1998/Math/MathML"
};
var COMPONENT_REGEX = /%COMP%/g;
var COMPONENT_VARIABLE = "%COMP%";
var HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
var CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
var REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;
var REMOVE_STYLES_ON_COMPONENT_DESTROY = new InjectionToken(ngDevMode ? "RemoveStylesOnCompDestroy" : "", {
  providedIn: "root",
  factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT
});
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimStylesContent(compId, styles2) {
  return styles2.map((s2) => s2.replace(COMPONENT_REGEX, compId));
}
var DomRendererFactory2 = class _DomRendererFactory2 {
  eventManager;
  sharedStylesHost;
  appId;
  removeStylesOnCompDestroy;
  doc;
  platformId;
  ngZone;
  nonce;
  rendererByCompId = /* @__PURE__ */ new Map();
  defaultRenderer;
  platformIsServer;
  constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc, platformId, ngZone, nonce = null) {
    this.eventManager = eventManager;
    this.sharedStylesHost = sharedStylesHost;
    this.appId = appId;
    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
    this.doc = doc;
    this.platformId = platformId;
    this.ngZone = ngZone;
    this.nonce = nonce;
    this.platformIsServer = isPlatformServer(platformId);
    this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc, ngZone, this.platformIsServer);
  }
  createRenderer(element, type2) {
    if (!element || !type2) {
      return this.defaultRenderer;
    }
    if (this.platformIsServer && type2.encapsulation === ViewEncapsulation.ShadowDom) {
      type2 = __spreadProps(__spreadValues({}, type2), {
        encapsulation: ViewEncapsulation.Emulated
      });
    }
    const renderer = this.getOrCreateRenderer(element, type2);
    if (renderer instanceof EmulatedEncapsulationDomRenderer2) {
      renderer.applyToHost(element);
    } else if (renderer instanceof NoneEncapsulationDomRenderer) {
      renderer.applyStyles();
    }
    return renderer;
  }
  getOrCreateRenderer(element, type2) {
    const rendererByCompId = this.rendererByCompId;
    let renderer = rendererByCompId.get(type2.id);
    if (!renderer) {
      const doc = this.doc;
      const ngZone = this.ngZone;
      const eventManager = this.eventManager;
      const sharedStylesHost = this.sharedStylesHost;
      const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;
      const platformIsServer = this.platformIsServer;
      switch (type2.encapsulation) {
        case ViewEncapsulation.Emulated:
          renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type2, this.appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer);
          break;
        case ViewEncapsulation.ShadowDom:
          return new ShadowDomRenderer(eventManager, sharedStylesHost, element, type2, doc, ngZone, this.nonce, platformIsServer);
        default:
          renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type2, removeStylesOnCompDestroy, doc, ngZone, platformIsServer);
          break;
      }
      rendererByCompId.set(type2.id, renderer);
    }
    return renderer;
  }
  ngOnDestroy() {
    this.rendererByCompId.clear();
  }
  static \u0275fac = function DomRendererFactory2_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomRendererFactory2)(\u0275\u0275inject(EventManager), \u0275\u0275inject(SharedStylesHost), \u0275\u0275inject(APP_ID), \u0275\u0275inject(REMOVE_STYLES_ON_COMPONENT_DESTROY), \u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(PLATFORM_ID), \u0275\u0275inject(NgZone), \u0275\u0275inject(CSP_NONCE));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomRendererFactory2,
    factory: _DomRendererFactory2.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomRendererFactory2, [{
    type: Injectable
  }], () => [{
    type: EventManager
  }, {
    type: SharedStylesHost
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [APP_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]
    }]
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CSP_NONCE]
    }]
  }], null);
})();
var DefaultDomRenderer2 = class {
  eventManager;
  doc;
  ngZone;
  platformIsServer;
  data = /* @__PURE__ */ Object.create(null);
  /**
   * By default this renderer throws when encountering synthetic properties
   * This can be disabled for example by the AsyncAnimationRendererFactory
   */
  throwOnSyntheticProps = true;
  constructor(eventManager, doc, ngZone, platformIsServer) {
    this.eventManager = eventManager;
    this.doc = doc;
    this.ngZone = ngZone;
    this.platformIsServer = platformIsServer;
  }
  destroy() {
  }
  destroyNode = null;
  createElement(name, namespace2) {
    if (namespace2) {
      return this.doc.createElementNS(NAMESPACE_URIS[namespace2] || namespace2, name);
    }
    return this.doc.createElement(name);
  }
  createComment(value2) {
    return this.doc.createComment(value2);
  }
  createText(value2) {
    return this.doc.createTextNode(value2);
  }
  appendChild(parent, newChild) {
    const targetParent = isTemplateNode(parent) ? parent.content : parent;
    targetParent.appendChild(newChild);
  }
  insertBefore(parent, newChild, refChild) {
    if (parent) {
      const targetParent = isTemplateNode(parent) ? parent.content : parent;
      targetParent.insertBefore(newChild, refChild);
    }
  }
  removeChild(_parent, oldChild) {
    oldChild.remove();
  }
  selectRootElement(selectorOrNode, preserveContent) {
    let el = typeof selectorOrNode === "string" ? this.doc.querySelector(selectorOrNode) : selectorOrNode;
    if (!el) {
      throw new RuntimeError(-5104, (typeof ngDevMode === "undefined" || ngDevMode) && `The selector "${selectorOrNode}" did not match any elements`);
    }
    if (!preserveContent) {
      el.textContent = "";
    }
    return el;
  }
  parentNode(node) {
    return node.parentNode;
  }
  nextSibling(node) {
    return node.nextSibling;
  }
  setAttribute(el, name, value2, namespace2) {
    if (namespace2) {
      name = namespace2 + ":" + name;
      const namespaceUri = NAMESPACE_URIS[namespace2];
      if (namespaceUri) {
        el.setAttributeNS(namespaceUri, name, value2);
      } else {
        el.setAttribute(name, value2);
      }
    } else {
      el.setAttribute(name, value2);
    }
  }
  removeAttribute(el, name, namespace2) {
    if (namespace2) {
      const namespaceUri = NAMESPACE_URIS[namespace2];
      if (namespaceUri) {
        el.removeAttributeNS(namespaceUri, name);
      } else {
        el.removeAttribute(`${namespace2}:${name}`);
      }
    } else {
      el.removeAttribute(name);
    }
  }
  addClass(el, name) {
    el.classList.add(name);
  }
  removeClass(el, name) {
    el.classList.remove(name);
  }
  setStyle(el, style2, value2, flags) {
    if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
      el.style.setProperty(style2, value2, flags & RendererStyleFlags2.Important ? "important" : "");
    } else {
      el.style[style2] = value2;
    }
  }
  removeStyle(el, style2, flags) {
    if (flags & RendererStyleFlags2.DashCase) {
      el.style.removeProperty(style2);
    } else {
      el.style[style2] = "";
    }
  }
  setProperty(el, name, value2) {
    if (el == null) {
      return;
    }
    (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(name, "property");
    el[name] = value2;
  }
  setValue(node, value2) {
    node.nodeValue = value2;
  }
  listen(target, event, callback) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(event, "listener");
    if (typeof target === "string") {
      target = getDOM().getGlobalEventTarget(this.doc, target);
      if (!target) {
        throw new Error(`Unsupported event target ${target} for event ${event}`);
      }
    }
    return this.eventManager.addEventListener(target, event, this.decoratePreventDefault(callback));
  }
  decoratePreventDefault(eventHandler) {
    return (event) => {
      if (event === "__ngUnwrap__") {
        return eventHandler;
      }
      const allowDefaultBehavior = this.platformIsServer ? this.ngZone.runGuarded(() => eventHandler(event)) : eventHandler(event);
      if (allowDefaultBehavior === false) {
        event.preventDefault();
      }
      return void 0;
    };
  }
};
var AT_CHARCODE = (() => "@".charCodeAt(0))();
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new RuntimeError(5105, `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Either \`BrowserAnimationsModule\` or \`NoopAnimationsModule\` are imported in your application.
  - There is corresponding configuration for the animation named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.io/api/core/Component#animations).`);
  }
}
function isTemplateNode(node) {
  return node.tagName === "TEMPLATE" && node.content !== void 0;
}
var ShadowDomRenderer = class extends DefaultDomRenderer2 {
  sharedStylesHost;
  hostEl;
  shadowRoot;
  constructor(eventManager, sharedStylesHost, hostEl, component, doc, ngZone, nonce, platformIsServer) {
    super(eventManager, doc, ngZone, platformIsServer);
    this.sharedStylesHost = sharedStylesHost;
    this.hostEl = hostEl;
    this.shadowRoot = hostEl.attachShadow({
      mode: "open"
    });
    this.sharedStylesHost.addHost(this.shadowRoot);
    const styles2 = shimStylesContent(component.id, component.styles);
    for (const style2 of styles2) {
      const styleEl = document.createElement("style");
      if (nonce) {
        styleEl.setAttribute("nonce", nonce);
      }
      styleEl.textContent = style2;
      this.shadowRoot.appendChild(styleEl);
    }
    const styleUrls = component.getExternalStyles?.();
    if (styleUrls) {
      for (const styleUrl of styleUrls) {
        const linkEl = createLinkElement(styleUrl, doc);
        if (nonce) {
          linkEl.setAttribute("nonce", nonce);
        }
        this.shadowRoot.appendChild(linkEl);
      }
    }
  }
  nodeOrShadowRoot(node) {
    return node === this.hostEl ? this.shadowRoot : node;
  }
  appendChild(parent, newChild) {
    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
  }
  insertBefore(parent, newChild, refChild) {
    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
  }
  removeChild(_parent, oldChild) {
    return super.removeChild(null, oldChild);
  }
  parentNode(node) {
    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
  }
  destroy() {
    this.sharedStylesHost.removeHost(this.shadowRoot);
  }
};
var NoneEncapsulationDomRenderer = class extends DefaultDomRenderer2 {
  sharedStylesHost;
  removeStylesOnCompDestroy;
  styles;
  styleUrls;
  constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, compId) {
    super(eventManager, doc, ngZone, platformIsServer);
    this.sharedStylesHost = sharedStylesHost;
    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
    this.styles = compId ? shimStylesContent(compId, component.styles) : component.styles;
    this.styleUrls = component.getExternalStyles?.(compId);
  }
  applyStyles() {
    this.sharedStylesHost.addStyles(this.styles, this.styleUrls);
  }
  destroy() {
    if (!this.removeStylesOnCompDestroy) {
      return;
    }
    this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);
  }
};
var EmulatedEncapsulationDomRenderer2 = class extends NoneEncapsulationDomRenderer {
  contentAttr;
  hostAttr;
  constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer) {
    const compId = appId + "-" + component.id;
    super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, compId);
    this.contentAttr = shimContentAttribute(compId);
    this.hostAttr = shimHostAttribute(compId);
  }
  applyToHost(element) {
    this.applyStyles();
    this.setAttribute(element, this.hostAttr, "");
  }
  createElement(parent, name) {
    const el = super.createElement(parent, name);
    super.setAttribute(el, this.contentAttr, "");
    return el;
  }
};
var DomEventsPlugin = class _DomEventsPlugin extends EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  // This plugin should come last in the list of plugins, because it accepts all
  // events.
  supports(eventName) {
    return true;
  }
  addEventListener(element, eventName, handler) {
    element.addEventListener(eventName, handler, false);
    return () => this.removeEventListener(element, eventName, handler);
  }
  removeEventListener(target, eventName, callback) {
    return target.removeEventListener(eventName, callback);
  }
  static \u0275fac = function DomEventsPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomEventsPlugin)(\u0275\u0275inject(DOCUMENT2));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomEventsPlugin,
    factory: _DomEventsPlugin.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
var MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
var _keyMap = {
  "\b": "Backspace",
  "	": "Tab",
  "\x7F": "Delete",
  "\x1B": "Escape",
  "Del": "Delete",
  "Esc": "Escape",
  "Left": "ArrowLeft",
  "Right": "ArrowRight",
  "Up": "ArrowUp",
  "Down": "ArrowDown",
  "Menu": "ContextMenu",
  "Scroll": "ScrollLock",
  "Win": "OS"
};
var MODIFIER_KEY_GETTERS = {
  "alt": (event) => event.altKey,
  "control": (event) => event.ctrlKey,
  "meta": (event) => event.metaKey,
  "shift": (event) => event.shiftKey
};
var KeyEventsPlugin = class _KeyEventsPlugin extends EventManagerPlugin {
  /**
   * Initializes an instance of the browser plug-in.
   * @param doc The document in which key events will be detected.
   */
  constructor(doc) {
    super(doc);
  }
  /**
   * Reports whether a named key event is supported.
   * @param eventName The event name to query.
   * @return True if the named key event is supported.
   */
  supports(eventName) {
    return _KeyEventsPlugin.parseEventName(eventName) != null;
  }
  /**
   * Registers a handler for a specific element and key event.
   * @param element The HTML element to receive event notifications.
   * @param eventName The name of the key event to listen for.
   * @param handler A function to call when the notification occurs. Receives the
   * event object as an argument.
   * @returns The key event that was registered.
   */
  addEventListener(element, eventName, handler) {
    const parsedEvent = _KeyEventsPlugin.parseEventName(eventName);
    const outsideHandler = _KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
    return this.manager.getZone().runOutsideAngular(() => {
      return getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler);
    });
  }
  /**
   * Parses the user provided full keyboard event definition and normalizes it for
   * later internal use. It ensures the string is all lowercase, converts special
   * characters to a standard spelling, and orders all the values consistently.
   *
   * @param eventName The name of the key event to listen for.
   * @returns an object with the full, normalized string, and the dom event name
   * or null in the case when the event doesn't match a keyboard event.
   */
  static parseEventName(eventName) {
    const parts = eventName.toLowerCase().split(".");
    const domEventName = parts.shift();
    if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
      return null;
    }
    const key = _KeyEventsPlugin._normalizeKey(parts.pop());
    let fullKey = "";
    let codeIX = parts.indexOf("code");
    if (codeIX > -1) {
      parts.splice(codeIX, 1);
      fullKey = "code.";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      const index = parts.indexOf(modifierName);
      if (index > -1) {
        parts.splice(index, 1);
        fullKey += modifierName + ".";
      }
    });
    fullKey += key;
    if (parts.length != 0 || key.length === 0) {
      return null;
    }
    const result = {};
    result["domEventName"] = domEventName;
    result["fullKey"] = fullKey;
    return result;
  }
  /**
   * Determines whether the actual keys pressed match the configured key code string.
   * The `fullKeyCode` event is normalized in the `parseEventName` method when the
   * event is attached to the DOM during the `addEventListener` call. This is unseen
   * by the end user and is normalized for internal consistency and parsing.
   *
   * @param event The keyboard event.
   * @param fullKeyCode The normalized user defined expected key event string
   * @returns boolean.
   */
  static matchEventFullKeyCode(event, fullKeyCode) {
    let keycode = _keyMap[event.key] || event.key;
    let key = "";
    if (fullKeyCode.indexOf("code.") > -1) {
      keycode = event.code;
      key = "code.";
    }
    if (keycode == null || !keycode) return false;
    keycode = keycode.toLowerCase();
    if (keycode === " ") {
      keycode = "space";
    } else if (keycode === ".") {
      keycode = "dot";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      if (modifierName !== keycode) {
        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
        if (modifierGetter(event)) {
          key += modifierName + ".";
        }
      }
    });
    key += keycode;
    return key === fullKeyCode;
  }
  /**
   * Configures a handler callback for a key event.
   * @param fullKey The event name that combines all simultaneous keystrokes.
   * @param handler The function that responds to the key event.
   * @param zone The zone in which the event occurred.
   * @returns A callback function.
   */
  static eventCallback(fullKey, handler, zone) {
    return (event) => {
      if (_KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
        zone.runGuarded(() => handler(event));
      }
    };
  }
  /** @internal */
  static _normalizeKey(keyName) {
    return keyName === "esc" ? "escape" : keyName;
  }
  static \u0275fac = function KeyEventsPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _KeyEventsPlugin)(\u0275\u0275inject(DOCUMENT2));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _KeyEventsPlugin,
    factory: _KeyEventsPlugin.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyEventsPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new ErrorHandler();
}
function _document() {
  setDocument(document);
  return document;
}
var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
  provide: PLATFORM_ID,
  useValue: PLATFORM_BROWSER_ID
}, {
  provide: PLATFORM_INITIALIZER,
  useValue: initDomAdapter,
  multi: true
}, {
  provide: DOCUMENT2,
  useFactory: _document,
  deps: []
}];
var platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
var BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "BrowserModule Providers Marker" : "");
var TESTABILITY_PROVIDERS = [{
  provide: TESTABILITY_GETTER,
  useClass: BrowserGetTestability,
  deps: []
}, {
  provide: TESTABILITY,
  useClass: Testability,
  deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
}, {
  provide: Testability,
  // Also provide as `Testability` for backwards-compatibility.
  useClass: Testability,
  deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]
}];
var BROWSER_MODULE_PROVIDERS = [{
  provide: INJECTOR_SCOPE,
  useValue: "root"
}, {
  provide: ErrorHandler,
  useFactory: errorHandler,
  deps: []
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: DomEventsPlugin,
  multi: true,
  deps: [DOCUMENT2, NgZone, PLATFORM_ID]
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: KeyEventsPlugin,
  multi: true,
  deps: [DOCUMENT2]
}, DomRendererFactory2, SharedStylesHost, EventManager, {
  provide: RendererFactory2,
  useExisting: DomRendererFactory2
}, {
  provide: XhrFactory,
  useClass: BrowserXhr,
  deps: []
}, typeof ngDevMode === "undefined" || ngDevMode ? {
  provide: BROWSER_MODULE_PROVIDERS_MARKER,
  useValue: true
} : []];
var BrowserModule = class _BrowserModule {
  constructor(providersAlreadyPresent) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && providersAlreadyPresent) {
      throw new RuntimeError(5100, `Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
    }
  }
  static \u0275fac = function BrowserModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserModule)(\u0275\u0275inject(BROWSER_MODULE_PROVIDERS_MARKER, 12));
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _BrowserModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
    imports: [CommonModule, ApplicationModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserModule, [{
    type: NgModule,
    args: [{
      providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
      exports: [CommonModule, ApplicationModule]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [BROWSER_MODULE_PROVIDERS_MARKER]
    }]
  }], null);
})();
var Meta = class _Meta {
  _doc;
  _dom;
  constructor(_doc) {
    this._doc = _doc;
    this._dom = getDOM();
  }
  /**
   * Retrieves or creates a specific `<meta>` tag element in the current HTML document.
   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
   * values in the provided tag definition, and verifies that all other attribute values are equal.
   * If an existing element is found, it is returned and is not modified in any way.
   * @param tag The definition of a `<meta>` element to match or create.
   * @param forceCreation True to create a new element without checking whether one already exists.
   * @returns The existing element with the same attributes and values if found,
   * the new element if no match is found, or `null` if the tag parameter is not defined.
   */
  addTag(tag, forceCreation = false) {
    if (!tag) return null;
    return this._getOrCreateElement(tag, forceCreation);
  }
  /**
   * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.
   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
   * values in the provided tag definition, and verifies that all other attribute values are equal.
   * @param tags An array of tag definitions to match or create.
   * @param forceCreation True to create new elements without checking whether they already exist.
   * @returns The matching elements if found, or the new elements.
   */
  addTags(tags, forceCreation = false) {
    if (!tags) return [];
    return tags.reduce((result, tag) => {
      if (tag) {
        result.push(this._getOrCreateElement(tag, forceCreation));
      }
      return result;
    }, []);
  }
  /**
   * Retrieves a `<meta>` tag element in the current HTML document.
   * @param attrSelector The tag attribute and value to match against, in the format
   * `"tag_attribute='value string'"`.
   * @returns The matching element, if any.
   */
  getTag(attrSelector) {
    if (!attrSelector) return null;
    return this._doc.querySelector(`meta[${attrSelector}]`) || null;
  }
  /**
   * Retrieves a set of `<meta>` tag elements in the current HTML document.
   * @param attrSelector The tag attribute and value to match against, in the format
   * `"tag_attribute='value string'"`.
   * @returns The matching elements, if any.
   */
  getTags(attrSelector) {
    if (!attrSelector) return [];
    const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
    return list ? [].slice.call(list) : [];
  }
  /**
   * Modifies an existing `<meta>` tag element in the current HTML document.
   * @param tag The tag description with which to replace the existing tag content.
   * @param selector A tag attribute and value to match against, to identify
   * an existing tag. A string in the format `"tag_attribute=`value string`"`.
   * If not supplied, matches a tag with the same `name` or `property` attribute value as the
   * replacement tag.
   * @return The modified element.
   */
  updateTag(tag, selector) {
    if (!tag) return null;
    selector = selector || this._parseSelector(tag);
    const meta = this.getTag(selector);
    if (meta) {
      return this._setMetaElementAttributes(tag, meta);
    }
    return this._getOrCreateElement(tag, true);
  }
  /**
   * Removes an existing `<meta>` tag element from the current HTML document.
   * @param attrSelector A tag attribute and value to match against, to identify
   * an existing tag. A string in the format `"tag_attribute=`value string`"`.
   */
  removeTag(attrSelector) {
    this.removeTagElement(this.getTag(attrSelector));
  }
  /**
   * Removes an existing `<meta>` tag element from the current HTML document.
   * @param meta The tag definition to match against to identify an existing tag.
   */
  removeTagElement(meta) {
    if (meta) {
      this._dom.remove(meta);
    }
  }
  _getOrCreateElement(meta, forceCreation = false) {
    if (!forceCreation) {
      const selector = this._parseSelector(meta);
      const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
      if (elem !== void 0) return elem;
    }
    const element = this._dom.createElement("meta");
    this._setMetaElementAttributes(meta, element);
    const head = this._doc.getElementsByTagName("head")[0];
    head.appendChild(element);
    return element;
  }
  _setMetaElementAttributes(tag, el) {
    Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
    return el;
  }
  _parseSelector(tag) {
    const attr = tag.name ? "name" : "property";
    return `${attr}="${tag[attr]}"`;
  }
  _containsAttributes(tag, elem) {
    return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
  }
  _getMetaKeyMap(prop) {
    return META_KEYS_MAP[prop] || prop;
  }
  static \u0275fac = function Meta_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Meta)(\u0275\u0275inject(DOCUMENT2));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Meta,
    factory: _Meta.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Meta, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
var META_KEYS_MAP = {
  httpEquiv: "http-equiv"
};
var Title = class _Title {
  _doc;
  constructor(_doc) {
    this._doc = _doc;
  }
  /**
   * Get the title of the current HTML document.
   */
  getTitle() {
    return this._doc.title;
  }
  /**
   * Set the title of the current HTML document.
   * @param newTitle
   */
  setTitle(newTitle) {
    this._doc.title = newTitle || "";
  }
  static \u0275fac = function Title_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Title)(\u0275\u0275inject(DOCUMENT2));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Title,
    factory: _Title.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Title, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
var EVENT_NAMES = {
  // pan
  "pan": true,
  "panstart": true,
  "panmove": true,
  "panend": true,
  "pancancel": true,
  "panleft": true,
  "panright": true,
  "panup": true,
  "pandown": true,
  // pinch
  "pinch": true,
  "pinchstart": true,
  "pinchmove": true,
  "pinchend": true,
  "pinchcancel": true,
  "pinchin": true,
  "pinchout": true,
  // press
  "press": true,
  "pressup": true,
  // rotate
  "rotate": true,
  "rotatestart": true,
  "rotatemove": true,
  "rotateend": true,
  "rotatecancel": true,
  // swipe
  "swipe": true,
  "swipeleft": true,
  "swiperight": true,
  "swipeup": true,
  "swipedown": true,
  // tap
  "tap": true,
  "doubletap": true
};
var HAMMER_GESTURE_CONFIG = new InjectionToken("HammerGestureConfig");
var HAMMER_LOADER = new InjectionToken("HammerLoader");
var HammerGestureConfig = class _HammerGestureConfig {
  /**
   * A set of supported event names for gestures to be used in Angular.
   * Angular supports all built-in recognizers, as listed in
   * [HammerJS documentation](https://hammerjs.github.io/).
   */
  events = [];
  /**
   * Maps gesture event names to a set of configuration options
   * that specify overrides to the default values for specific properties.
   *
   * The key is a supported event name to be configured,
   * and the options object contains a set of properties, with override values
   * to be applied to the named recognizer event.
   * For example, to disable recognition of the rotate event, specify
   *  `{"rotate": {"enable": false}}`.
   *
   * Properties that are not present take the HammerJS default values.
   * For information about which properties are supported for which events,
   * and their allowed and default values, see
   * [HammerJS documentation](https://hammerjs.github.io/).
   *
   */
  overrides = {};
  /**
   * Properties whose default values can be overridden for a given event.
   * Different sets of properties apply to different events.
   * For information about which properties are supported for which events,
   * and their allowed and default values, see
   * [HammerJS documentation](https://hammerjs.github.io/).
   */
  options;
  /**
   * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
   * and attaches it to a given HTML element.
   * @param element The element that will recognize gestures.
   * @returns A HammerJS event-manager object.
   */
  buildHammer(element) {
    const mc = new Hammer(element, this.options);
    mc.get("pinch").set({
      enable: true
    });
    mc.get("rotate").set({
      enable: true
    });
    for (const eventName in this.overrides) {
      mc.get(eventName).set(this.overrides[eventName]);
    }
    return mc;
  }
  static \u0275fac = function HammerGestureConfig_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HammerGestureConfig)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HammerGestureConfig,
    factory: _HammerGestureConfig.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGestureConfig, [{
    type: Injectable
  }], null, null);
})();
var HammerGesturesPlugin = class _HammerGesturesPlugin extends EventManagerPlugin {
  _config;
  console;
  loader;
  _loaderPromise = null;
  constructor(doc, _config2, console2, loader) {
    super(doc);
    this._config = _config2;
    this.console = console2;
    this.loader = loader;
  }
  supports(eventName) {
    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
      return false;
    }
    if (!window.Hammer && !this.loader) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
      }
      return false;
    }
    return true;
  }
  addEventListener(element, eventName, handler) {
    const zone = this.manager.getZone();
    eventName = eventName.toLowerCase();
    if (!window.Hammer && this.loader) {
      this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
      let cancelRegistration = false;
      let deregister = () => {
        cancelRegistration = true;
      };
      zone.runOutsideAngular(() => this._loaderPromise.then(() => {
        if (!window.Hammer) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
          }
          deregister = () => {
          };
          return;
        }
        if (!cancelRegistration) {
          deregister = this.addEventListener(element, eventName, handler);
        }
      }).catch(() => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          this.console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
        }
        deregister = () => {
        };
      }));
      return () => {
        deregister();
      };
    }
    return zone.runOutsideAngular(() => {
      const mc = this._config.buildHammer(element);
      const callback = function(eventObj) {
        zone.runGuarded(function() {
          handler(eventObj);
        });
      };
      mc.on(eventName, callback);
      return () => {
        mc.off(eventName, callback);
        if (typeof mc.destroy === "function") {
          mc.destroy();
        }
      };
    });
  }
  isCustomEvent(eventName) {
    return this._config.events.indexOf(eventName) > -1;
  }
  static \u0275fac = function HammerGesturesPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HammerGesturesPlugin)(\u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(HAMMER_GESTURE_CONFIG), \u0275\u0275inject(Console), \u0275\u0275inject(HAMMER_LOADER, 8));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HammerGesturesPlugin,
    factory: _HammerGesturesPlugin.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGesturesPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }, {
    type: HammerGestureConfig,
    decorators: [{
      type: Inject,
      args: [HAMMER_GESTURE_CONFIG]
    }]
  }, {
    type: Console
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [HAMMER_LOADER]
    }]
  }], null);
})();
var HammerModule = class _HammerModule {
  static \u0275fac = function HammerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HammerModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _HammerModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [{
      provide: EVENT_MANAGER_PLUGINS,
      useClass: HammerGesturesPlugin,
      multi: true,
      deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
    }, {
      provide: HAMMER_GESTURE_CONFIG,
      useClass: HammerGestureConfig,
      deps: []
    }]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: EVENT_MANAGER_PLUGINS,
        useClass: HammerGesturesPlugin,
        multi: true,
        deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
      }, {
        provide: HAMMER_GESTURE_CONFIG,
        useClass: HammerGestureConfig,
        deps: []
      }]
    }]
  }], null, null);
})();
var DomSanitizer = class _DomSanitizer {
  static \u0275fac = function DomSanitizer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomSanitizer)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomSanitizer,
    factory: function DomSanitizer_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new (__ngFactoryType__ || _DomSanitizer)();
      } else {
        __ngConditionalFactory__ = \u0275\u0275inject(DomSanitizerImpl);
      }
      return __ngConditionalFactory__;
    },
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizer, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: forwardRef(() => DomSanitizerImpl)
    }]
  }], null, null);
})();
var DomSanitizerImpl = class _DomSanitizerImpl extends DomSanitizer {
  _doc;
  constructor(_doc) {
    super();
    this._doc = _doc;
  }
  sanitize(ctx, value2) {
    if (value2 == null) return null;
    switch (ctx) {
      case SecurityContext.NONE:
        return value2;
      case SecurityContext.HTML:
        if (allowSanitizationBypassAndThrow(
          value2,
          "HTML"
          /* BypassType.Html */
        )) {
          return unwrapSafeValue(value2);
        }
        return _sanitizeHtml(this._doc, String(value2)).toString();
      case SecurityContext.STYLE:
        if (allowSanitizationBypassAndThrow(
          value2,
          "Style"
          /* BypassType.Style */
        )) {
          return unwrapSafeValue(value2);
        }
        return value2;
      case SecurityContext.SCRIPT:
        if (allowSanitizationBypassAndThrow(
          value2,
          "Script"
          /* BypassType.Script */
        )) {
          return unwrapSafeValue(value2);
        }
        throw new RuntimeError(5200, (typeof ngDevMode === "undefined" || ngDevMode) && "unsafe value used in a script context");
      case SecurityContext.URL:
        if (allowSanitizationBypassAndThrow(
          value2,
          "URL"
          /* BypassType.Url */
        )) {
          return unwrapSafeValue(value2);
        }
        return _sanitizeUrl(String(value2));
      case SecurityContext.RESOURCE_URL:
        if (allowSanitizationBypassAndThrow(
          value2,
          "ResourceURL"
          /* BypassType.ResourceUrl */
        )) {
          return unwrapSafeValue(value2);
        }
        throw new RuntimeError(5201, (typeof ngDevMode === "undefined" || ngDevMode) && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
      default:
        throw new RuntimeError(5202, (typeof ngDevMode === "undefined" || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${XSS_SECURITY_URL})`);
    }
  }
  bypassSecurityTrustHtml(value2) {
    return bypassSanitizationTrustHtml(value2);
  }
  bypassSecurityTrustStyle(value2) {
    return bypassSanitizationTrustStyle(value2);
  }
  bypassSecurityTrustScript(value2) {
    return bypassSanitizationTrustScript(value2);
  }
  bypassSecurityTrustUrl(value2) {
    return bypassSanitizationTrustUrl(value2);
  }
  bypassSecurityTrustResourceUrl(value2) {
    return bypassSanitizationTrustResourceUrl(value2);
  }
  static \u0275fac = function DomSanitizerImpl_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomSanitizerImpl)(\u0275\u0275inject(DOCUMENT2));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomSanitizerImpl,
    factory: _DomSanitizerImpl.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizerImpl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
var HydrationFeatureKind;
(function(HydrationFeatureKind2) {
  HydrationFeatureKind2[HydrationFeatureKind2["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
  HydrationFeatureKind2[HydrationFeatureKind2["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
  HydrationFeatureKind2[HydrationFeatureKind2["I18nSupport"] = 2] = "I18nSupport";
  HydrationFeatureKind2[HydrationFeatureKind2["EventReplay"] = 3] = "EventReplay";
  HydrationFeatureKind2[HydrationFeatureKind2["IncrementalHydration"] = 4] = "IncrementalHydration";
})(HydrationFeatureKind || (HydrationFeatureKind = {}));
var VERSION3 = new Version("19.0.1");

// node_modules/@angular/forms/fesm2022/forms.mjs
var BaseControlValueAccessor = class _BaseControlValueAccessor {
  _renderer;
  _elementRef;
  /**
   * The registered callback function called when a change or input event occurs on the input
   * element.
   * @nodoc
   */
  onChange = (_) => {
  };
  /**
   * The registered callback function called when a blur event occurs on the input element.
   * @nodoc
   */
  onTouched = () => {
  };
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
  }
  /**
   * Helper method that sets a property on a target element using the current Renderer
   * implementation.
   * @nodoc
   */
  setProperty(key, value2) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value2);
  }
  /**
   * Registers a function called when the control is touched.
   * @nodoc
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * Sets the "disabled" property on the range input element.
   * @nodoc
   */
  setDisabledState(isDisabled) {
    this.setProperty("disabled", isDisabled);
  }
  static \u0275fac = function BaseControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _BaseControlValueAccessor
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
var BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275BuiltInControlValueAccessor_BaseFactory;
    return function BuiltInControlValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275BuiltInControlValueAccessor_BaseFactory || (\u0275BuiltInControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_BuiltInControlValueAccessor)))(__ngFactoryType__ || _BuiltInControlValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _BuiltInControlValueAccessor,
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
    type: Directive
  }], null, null);
})();
var NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? "NgValueAccessor" : "");
var CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CheckboxControlValueAccessor),
  multi: true
};
var CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "checked" property on the input element.
   * @nodoc
   */
  writeValue(value2) {
    this.setProperty("checked", value2);
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275CheckboxControlValueAccessor_BaseFactory;
    return function CheckboxControlValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275CheckboxControlValueAccessor_BaseFactory || (\u0275CheckboxControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxControlValueAccessor)))(__ngFactoryType__ || _CheckboxControlValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CheckboxControlValueAccessor,
    selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
    hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.checked);
        })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
      host: {
        "(change)": "onChange($event.target.checked)",
        "(blur)": "onTouched()"
      },
      providers: [CHECKBOX_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent2 = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent2.toLowerCase());
}
var COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? "CompositionEventMode" : "");
var DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
  _compositionMode;
  /** Whether the user is creating a composition string (IME events). */
  _composing = false;
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value2) {
    const normalizedValue = value2 == null ? "" : value2;
    this.setProperty("value", normalizedValue);
  }
  /** @internal */
  _handleInput(value2) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value2);
    }
  }
  /** @internal */
  _compositionStart() {
    this._composing = true;
  }
  /** @internal */
  _compositionEnd(value2) {
    this._composing = false;
    this._compositionMode && this.onChange(value2);
  }
  static \u0275fac = function DefaultValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(COMPOSITION_BUFFER_MODE, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _DefaultValueAccessor,
    selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
    hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([DEFAULT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
      // TODO: vsavkin replace the above selector with the one below it once
      // https://github.com/angular/angular/issues/3011 is implemented
      // selector: '[ngModel],[formControl],[formControlName]',
      host: {
        "(input)": "$any(this)._handleInput($event.target.value)",
        "(blur)": "onTouched()",
        "(compositionstart)": "$any(this)._compositionStart()",
        "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
      },
      providers: [DEFAULT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value2) {
  return value2 == null || (typeof value2 === "string" || Array.isArray(value2)) && value2.length === 0;
}
function hasValidLength(value2) {
  return value2 != null && typeof value2.length === "number";
}
var NG_VALIDATORS = new InjectionToken(ngDevMode ? "NgValidators" : "");
var NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? "NgAsyncValidators" : "");
var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var Validators = class {
  /**
   * @description
   * Validator that requires the control's value to be greater than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a minimum of 3
   *
   * ```typescript
   * const control = new FormControl(2, Validators.min(3));
   *
   * console.log(control.errors); // {min: {min: 3, actual: 2}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `min` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static min(min6) {
    return minValidator(min6);
  }
  /**
   * @description
   * Validator that requires the control's value to be less than or equal to the provided number.
   *
   * @usageNotes
   *
   * ### Validate against a maximum of 15
   *
   * ```typescript
   * const control = new FormControl(16, Validators.max(15));
   *
   * console.log(control.errors); // {max: {max: 15, actual: 16}}
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `max` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static max(max6) {
    return maxValidator(max6);
  }
  /**
   * @description
   * Validator that requires the control have a non-empty value.
   *
   * @usageNotes
   *
   * ### Validate that the field is non-empty
   *
   * ```typescript
   * const control = new FormControl('', Validators.required);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map with the `required` property
   * if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static required(control) {
    return requiredValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value be true. This validator is commonly
   * used for required checkboxes.
   *
   * @usageNotes
   *
   * ### Validate that the field value is true
   *
   * ```typescript
   * const control = new FormControl('some value', Validators.requiredTrue);
   *
   * console.log(control.errors); // {required: true}
   * ```
   *
   * @returns An error map that contains the `required` property
   * set to `true` if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static requiredTrue(control) {
    return requiredTrueValidator(control);
  }
  /**
   * @description
   * Validator that requires the control's value pass an email validation test.
   *
   * Tests the value using a [regular
   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
   * pattern suitable for common use cases. The pattern is based on the definition of a valid email
   * address in the [WHATWG HTML
   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
   * lengths of different parts of the address).
   *
   * The differences from the WHATWG version include:
   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).
   * - Disallow `local-part` to be longer than 64 characters.
   * - Disallow the whole address to be longer than 254 characters.
   *
   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to
   * validate the value against a different pattern.
   *
   * @usageNotes
   *
   * ### Validate that the field matches a valid email pattern
   *
   * ```typescript
   * const control = new FormControl('bad@', Validators.email);
   *
   * console.log(control.errors); // {email: true}
   * ```
   *
   * @returns An error map with the `email` property
   * if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static email(control) {
    return emailValidator(control);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be greater than or equal
   * to the provided minimum length. This validator is also provided by default if you use the
   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays. The
   * `minLength` validator logic is also not invoked for values when their `length` property is 0
   * (for example in case of an empty string or an empty array), to support optional controls. You
   * can use the standard `required` validator if empty values should not be considered valid.
   *
   * @usageNotes
   *
   * ### Validate that the field has a minimum of 3 characters
   *
   * ```typescript
   * const control = new FormControl('ng', Validators.minLength(3));
   *
   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
   * ```
   *
   * ```html
   * <input minlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `minlength` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static minLength(minLength) {
    return minLengthValidator(minLength);
  }
  /**
   * @description
   * Validator that requires the length of the control's value to be less than or equal
   * to the provided maximum length. This validator is also provided by default if you use the
   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used
   * only for types that have a numeric `length` property, such as strings or arrays.
   *
   * @usageNotes
   *
   * ### Validate that the field has maximum of 5 characters
   *
   * ```typescript
   * const control = new FormControl('Angular', Validators.maxLength(5));
   *
   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
   * ```
   *
   * ```html
   * <input maxlength="5">
   * ```
   *
   * @returns A validator function that returns an error map with the
   * `maxlength` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static maxLength(maxLength) {
    return maxLengthValidator(maxLength);
  }
  /**
   * @description
   * Validator that requires the control's value to match a regex pattern. This validator is also
   * provided by default if you use the HTML5 `pattern` attribute.
   *
   * @usageNotes
   *
   * ### Validate that the field only contains letters or spaces
   *
   * ```typescript
   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
   *
   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
   * ```
   *
   * ```html
   * <input pattern="[a-zA-Z ]*">
   * ```
   *
   * ### Pattern matching with the global or sticky flag
   *
   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`
   * can produce different results on the same input when validations are run consecutively. This is
   * due to how the behavior of `RegExp.prototype.test` is
   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)
   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).
   * Due to this behavior, it is recommended that when using
   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky
   * flag enabled.
   *
   * ```typescript
   * // Not recommended (since the `g` flag is used)
   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));
   *
   * // Good
   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));
   * ```
   *
   * @param pattern A regular expression to be used as is to test the values, or a string.
   * If a string is passed, the `^` character is prepended and the `$` character is
   * appended to the provided string (if not already present), and the resulting regular
   * expression is used to test the values.
   *
   * @returns A validator function that returns an error map with the
   * `pattern` property if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static pattern(pattern) {
    return patternValidator(pattern);
  }
  /**
   * @description
   * Validator that performs no operation.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static nullValidator(control) {
    return nullValidator(control);
  }
  static compose(validators) {
    return compose(validators);
  }
  /**
   * @description
   * Compose multiple async validators into a single function that returns the union
   * of the individual error objects for the provided control.
   *
   * @returns A validator function that returns an error map with the
   * merged error objects of the async validators if the validation check fails, otherwise `null`.
   *
   * @see {@link updateValueAndValidity()}
   *
   */
  static composeAsync(validators) {
    return composeAsync(validators);
  }
};
function minValidator(min6) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(min6)) {
      return null;
    }
    const value2 = parseFloat(control.value);
    return !isNaN(value2) && value2 < min6 ? {
      "min": {
        "min": min6,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max6) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(max6)) {
      return null;
    }
    const value2 = parseFloat(control.value);
    return !isNaN(value2) && value2 > max6 ? {
      "max": {
        "max": max6,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
      return null;
    }
    return control.value.length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    return hasValidLength(control.value) && control.value.length > maxLength ? {
      "maxlength": {
        "requiredLength": maxLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^") regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$") regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value2 = control.value;
    return regex.test(value2) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value2
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o2) {
  return o2 != null;
}
function toObservable(value2) {
  const obs = isPromise2(value2) ? from(value2) : value2;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value2 === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
var AbstractControlDirective = class {
  /**
   * @description
   * Reports the value of the control if it is present, otherwise null.
   */
  get value() {
    return this.control ? this.control.value : null;
  }
  /**
   * @description
   * Reports whether the control is valid. A control is considered valid if no
   * validation errors exist with the current value.
   * If the control is not present, null is returned.
   */
  get valid() {
    return this.control ? this.control.valid : null;
  }
  /**
   * @description
   * Reports whether the control is invalid, meaning that an error exists in the input value.
   * If the control is not present, null is returned.
   */
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  /**
   * @description
   * Reports whether a control is pending, meaning that async validation is occurring and
   * errors are not yet available for the input value. If the control is not present, null is
   * returned.
   */
  get pending() {
    return this.control ? this.control.pending : null;
  }
  /**
   * @description
   * Reports whether the control is disabled, meaning that the control is disabled
   * in the UI and is exempt from validation checks and excluded from aggregate
   * values of ancestor controls. If the control is not present, null is returned.
   */
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  /**
   * @description
   * Reports whether the control is enabled, meaning that the control is included in ancestor
   * calculations of validity or value. If the control is not present, null is returned.
   */
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  /**
   * @description
   * Reports the control's validation errors. If the control is not present, null is returned.
   */
  get errors() {
    return this.control ? this.control.errors : null;
  }
  /**
   * @description
   * Reports whether the control is pristine, meaning that the user has not yet changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  /**
   * @description
   * Reports whether the control is dirty, meaning that the user has changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  /**
   * @description
   * Reports whether the control is touched, meaning that the user has triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get touched() {
    return this.control ? this.control.touched : null;
  }
  /**
   * @description
   * Reports the validation status of the control. Possible values include:
   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
   * If the control is not present, null is returned.
   */
  get status() {
    return this.control ? this.control.status : null;
  }
  /**
   * @description
   * Reports whether the control is untouched, meaning that the user has not yet triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  /**
   * @description
   * Returns a multicasting observable that emits a validation status whenever it is
   * calculated for the control. If the control is not present, null is returned.
   */
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  /**
   * @description
   * Returns a multicasting observable of value changes for the control that emits every time the
   * value of the control changes in the UI or programmatically.
   * If the control is not present, null is returned.
   */
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return null;
  }
  /**
   * Contains the result of merging synchronous validators into a single validator function
   * (combined using `Validators.compose`).
   */
  _composedValidatorFn;
  /**
   * Contains the result of merging asynchronous validators into a single validator function
   * (combined using `Validators.composeAsync`).
   */
  _composedAsyncValidatorFn;
  /**
   * Set of synchronous validators as they were provided while calling `setValidators` function.
   * @internal
   */
  _rawValidators = [];
  /**
   * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
   * function.
   * @internal
   */
  _rawAsyncValidators = [];
  /**
   * Sets synchronous validators for this directive.
   * @internal
   */
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  /**
   * Sets asynchronous validators for this directive.
   * @internal
   */
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  /**
   * @description
   * Synchronous validator function composed of all the synchronous validators registered with this
   * directive.
   */
  get validator() {
    return this._composedValidatorFn || null;
  }
  /**
   * @description
   * Asynchronous validator function composed of all the asynchronous validators registered with
   * this directive.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  /*
   * The set of callbacks to be invoked when directive instance is being destroyed.
   */
  _onDestroyCallbacks = [];
  /**
   * Internal function to register callbacks that should be invoked
   * when directive instance is being destroyed.
   * @internal
   */
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  /**
   * Internal function to invoke all registered "on destroy" callbacks.
   * Note: calling this function also clears the list of callbacks.
   * @internal
   */
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach((fn) => fn());
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Resets the control with the provided value if the control is present.
   */
  reset(value2 = void 0) {
    if (this.control) this.control.reset(value2);
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path3) {
    return this.control ? this.control.hasError(errorCode, path3) : false;
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path3) {
    return this.control ? this.control.getError(errorCode, path3) : null;
  }
};
var ControlContainer = class extends AbstractControlDirective {
  /**
   * @description
   * The name for the control
   */
  // TODO(issue/24571): remove '!'.
  name;
  /**
   * @description
   * The top-level form directive for the control.
   */
  get formDirective() {
    return null;
  }
  /**
   * @description
   * The path to this group.
   */
  get path() {
    return null;
  }
};
var NgControl = class extends AbstractControlDirective {
  /**
   * @description
   * The parent form for the control.
   *
   * @internal
   */
  _parent = null;
  /**
   * @description
   * The name for the control
   */
  name = null;
  /**
   * @description
   * The value accessor for the control
   */
  valueAccessor = null;
};
var AbstractControlStatus = class {
  _cd;
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    this._cd?.control?._touched?.();
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    this._cd?.control?._pristine?.();
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    this._cd?.control?._status?.();
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    this._cd?._submitted?.();
    return !!this._cd?.submitted;
  }
};
var ngControlStatusHost = {
  "[class.ng-untouched]": "isUntouched",
  "[class.ng-touched]": "isTouched",
  "[class.ng-pristine]": "isPristine",
  "[class.ng-dirty]": "isDirty",
  "[class.ng-valid]": "isValid",
  "[class.ng-invalid]": "isInvalid",
  "[class.ng-pending]": "isPending"
};
var ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
  "[class.ng-submitted]": "isSubmitted"
});
var NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static \u0275fac = function NgControlStatus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatus)(\u0275\u0275directiveInject(NgControl, 2));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgControlStatus,
    selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
    hostVars: 14,
    hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
      }
    },
    standalone: false,
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
    type: Directive,
    args: [{
      selector: "[formControlName],[ngModel],[formControl]",
      host: ngControlStatusHost,
      standalone: false
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Self
    }]
  }], null);
})();
var NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static \u0275fac = function NgControlStatusGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatusGroup)(\u0275\u0275directiveInject(ControlContainer, 10));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgControlStatusGroup,
    selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
    hostVars: 16,
    hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
      }
    },
    standalone: false,
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
    type: Directive,
    args: [{
      selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
      host: ngGroupStatusHost,
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
var formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
var formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
var ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
var ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException(nameOrIndex) {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive. You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      ${describeFormControl(nameOrIndex)}

    Example:

    ${formControlNameExample}`);
}
function describeFormControl(nameOrIndex) {
  if (nameOrIndex == null || nameOrIndex === "") {
    return "";
  }
  const valueType = typeof nameOrIndex === "string" ? "name" : "index";
  return `Affected Form Control ${valueType}: "${nameOrIndex}"`;
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
var disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
var asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
var VALID = "VALID";
var INVALID = "INVALID";
var PENDING = "PENDING";
var DISABLED = "DISABLED";
var ControlEvent = class {
};
var ValueChangeEvent = class extends ControlEvent {
  value;
  source;
  constructor(value2, source) {
    super();
    this.value = value2;
    this.source = source;
  }
};
var PristineChangeEvent = class extends ControlEvent {
  pristine;
  source;
  constructor(pristine, source) {
    super();
    this.pristine = pristine;
    this.source = source;
  }
};
var TouchedChangeEvent = class extends ControlEvent {
  touched;
  source;
  constructor(touched, source) {
    super();
    this.touched = touched;
    this.source = source;
  }
};
var StatusChangeEvent = class extends ControlEvent {
  status;
  source;
  constructor(status, source) {
    super();
    this.status = status;
    this.source = source;
  }
};
var FormSubmittedEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
var FormResetEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value2) {
  control._forEachChild((_, key) => {
    if (value2[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
var AbstractControl = class {
  /** @internal */
  _pendingDirty = false;
  /**
   * Indicates that a control has its own pending asynchronous validation in progress.
   * It also stores if the control should emit events when the validation status changes.
   *
   * @internal
   */
  _hasOwnPendingAsyncValidator = null;
  /** @internal */
  _pendingTouched = false;
  /** @internal */
  _onCollectionChange = () => {
  };
  /** @internal */
  _updateOn;
  _parent = null;
  _asyncValidationSubscription;
  /**
   * Contains the result of merging synchronous validators into a single validator function
   * (combined using `Validators.compose`).
   *
   * @internal
   */
  _composedValidatorFn;
  /**
   * Contains the result of merging asynchronous validators into a single validator function
   * (combined using `Validators.composeAsync`).
   *
   * @internal
   */
  _composedAsyncValidatorFn;
  /**
   * Synchronous validators as they were provided:
   *  - in `AbstractControl` constructor
   *  - as an argument while calling `setValidators` function
   *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)
   *
   * @internal
   */
  _rawValidators;
  /**
   * Asynchronous validators as they were provided:
   *  - in `AbstractControl` constructor
   *  - as an argument while calling `setAsyncValidators` function
   *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =
   * asyncValidatorFn`)
   *
   * @internal
   */
  _rawAsyncValidators;
  /**
   * The current value of the control.
   *
   * * For a `FormControl`, the current value.
   * * For an enabled `FormGroup`, the values of enabled controls as an object
   * with a key-value pair for each member of the group.
   * * For a disabled `FormGroup`, the values of all controls as an object
   * with a key-value pair for each member of the group.
   * * For a `FormArray`, the values of enabled controls as an array.
   *
   */
  value;
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * The validation status of the control.
   *
   * @see {@link FormControlStatus}
   *
   * These status values are mutually exclusive, so a control cannot be
   * both valid AND invalid or invalid AND disabled.
   */
  get status() {
    return untracked(this.statusReactive);
  }
  set status(v) {
    untracked(() => this.statusReactive.set(v));
  }
  /** @internal */
  _status = computed(() => this.statusReactive());
  statusReactive = signal(void 0);
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * An object containing any errors generated by failing validation,
   * or null if there are no errors.
   */
  errors;
  /**
   * A control is `pristine` if the user has not yet changed
   * the value in the UI.
   *
   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get pristine() {
    return untracked(this.pristineReactive);
  }
  set pristine(v) {
    untracked(() => this.pristineReactive.set(v));
  }
  /** @internal */
  _pristine = computed(() => this.pristineReactive());
  pristineReactive = signal(true);
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control is marked as `touched`.
   *
   * A control is marked `touched` once the user has triggered
   * a `blur` event on it.
   */
  get touched() {
    return untracked(this.touchedReactive);
  }
  set touched(v) {
    untracked(() => this.touchedReactive.set(v));
  }
  /** @internal */
  _touched = computed(() => this.touchedReactive());
  touchedReactive = signal(false);
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Exposed as observable, see below.
   *
   * @internal
   */
  _events = new Subject();
  /**
   * A multicasting observable that emits an event every time the state of the control changes.
   * It emits for value, status, pristine or touched changes.
   *
   * **Note**: On value change, the emit happens right after a value of this control is updated. The
   * value of a parent control (for example if this FormControl is a part of a FormGroup) is updated
   * later, so accessing a value of a parent control (using the `value` property) from the callback
   * of this event might result in getting a value that has not been updated yet. Subscribe to the
   * `events` of the parent control instead.
   * For other event types, the events are emitted after the parent control has been updated.
   *
   */
  events = this._events.asObservable();
  /**
   * A multicasting observable that emits an event every time the value of the control changes, in
   * the UI or programmatically. It also emits an event each time you call enable() or disable()
   * without passing along {emitEvent: false} as a function argument.
   *
   * **Note**: the emit happens right after a value of this control is updated. The value of a
   * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so
   * accessing a value of a parent control (using the `value` property) from the callback of this
   * event might result in getting a value that has not been updated yet. Subscribe to the
   * `valueChanges` event of the parent control instead.
   *
   * TODO: this should be piped from events() but is breaking in G3
   */
  valueChanges;
  /**
   * A multicasting observable that emits an event every time the validation `status` of the control
   * recalculates.
   *
   * @see {@link FormControlStatus}
   * @see {@link AbstractControl.status}
   *
   * TODO: this should be piped from events() but is breaking in G3
   */
  statusChanges;
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._assignValidators(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<string | null>('', Validators.required);
   * ctrl.removeValidators(Validators.required);
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<string | null>('', minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   *
   * ctrl.removeValidators(minValidator);
   * ```
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<number | null>(0, Validators.required);
   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<number | null>(0, minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   * ```
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  markAsTouched(opts = {}) {
    const changed = this.touched === false;
    this.touched = true;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(true, sourceControl));
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see {@link markAsTouched()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `emitEvent`: When true or not supplied (the default), the `events`
   * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.
   * When false, no events are emitted.
   */
  markAllAsTouched(opts = {}) {
    this.markAsTouched({
      onlySelf: true,
      emitEvent: opts.emitEvent,
      sourceControl: this
    });
    this._forEachChild((control) => control.markAllAsTouched(opts));
  }
  markAsUntouched(opts = {}) {
    const changed = this.touched === true;
    this.touched = false;
    this._pendingTouched = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsUntouched({
        onlySelf: true,
        emitEvent: opts.emitEvent,
        sourceControl
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(false, sourceControl));
    }
  }
  markAsDirty(opts = {}) {
    const changed = this.pristine === true;
    this.pristine = false;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(false, sourceControl));
    }
  }
  markAsPristine(opts = {}) {
    const changed = this.pristine === false;
    this.pristine = true;
    this._pendingDirty = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsPristine({
        onlySelf: true,
        emitEvent: opts.emitEvent
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(true, sourceControl));
    }
  }
  markAsPending(opts = {}) {
    this.status = PENDING;
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild((control) => {
      control.disable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,
   * `valueChanges` and `events`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild((control) => {
      control.enable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(false));
  }
  _updateAncestors(opts, sourceControl) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine({}, sourceControl);
      }
      this._parent._updateTouched({}, sourceControl);
    }
  }
  /**
   * Sets the parent of the control
   *
   * @param parent The new parent.
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * The raw value of this control. For most control implementations, the raw value will include
   * disabled children.
   */
  getRawValue() {
    return this.value;
  }
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      const shouldHaveEmitted = this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);
      }
    }
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(shouldHaveEmitted, emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = {
        emitEvent: emitEvent !== false
      };
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe((errors) => {
        this._hasOwnPendingAsyncValidator = null;
        this.setErrors(errors, {
          emitEvent,
          shouldHaveEmitted
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      const shouldHaveEmitted = this._hasOwnPendingAsyncValidator?.emitEvent ?? false;
      this._hasOwnPendingAsyncValidator = null;
      return shouldHaveEmitted;
    }
    return false;
  }
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control. If a string is provided, passing it as a string literal will result in improved type
   * information. Likewise, if an array is provided, passing it `as const` will cause improved type
   * information to be available.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path3) {
    let currPath = path3;
    if (currPath == null) return null;
    if (!Array.isArray(currPath)) currPath = currPath.split(".");
    if (currPath.length === 0) return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path3) {
    const control = path3 ? this.get(path3) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path3) {
    return !!this.getError(errorCode, path3);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x4 = this;
    while (x4._parent) {
      x4 = x4._parent;
    }
    return x4;
  }
  /** @internal */
  _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (emitEvent || shouldHaveEmitted) {
      this._events.next(new StatusChangeEvent(this.status, changedControl));
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new EventEmitter();
    this.statusChanges = new EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls((control) => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls((control) => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls((control) => control.touched);
  }
  /** @internal */
  _updatePristine(opts, changedControl) {
    const newPristine = !this._anyControlsDirty();
    const changed = this.pristine !== newPristine;
    this.pristine = newPristine;
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, changedControl);
    }
    if (changed) {
      this._events.next(new PristineChangeEvent(this.pristine, changedControl));
    }
  }
  /** @internal */
  _updateTouched(opts = {}, changedControl) {
    this.touched = this._anyControlsTouched();
    this._events.next(new TouchedChangeEvent(this.touched, changedControl));
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, changedControl);
    }
  }
  /** @internal */
  _onDisabledChange = [];
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  /** @internal */
  _find(name) {
    return null;
  }
  /**
   * Internal implementation of the `setValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  /**
   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
};
var FormGroup = class extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  registerControl(name, control) {
    if (this.controls[name]) return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group. In a strongly-typed group, required controls cannot be
   * removed.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    if (control) this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value2, options = {}) {
    assertAllValuesPresent(this, true, value2);
    Object.keys(value2).forEach((name) => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value2[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value2, options = {}) {
    if (value2 == null) return;
    Object.keys(value2).forEach((name) => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(
          /* Guaranteed to be present, due to the outer forEach. */
          value2[name],
          {
            onlySelf: true,
            emitEvent: options.emitEvent
          }
        );
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to their default values, or null if no defaults were provided.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value2 = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value2 ? value2[name] : null, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach((key) => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc2, control, name) => {
      if (control.enabled || this.disabled) {
        acc2[name] = control.value;
      }
      return acc2;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
};
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
var FormRecord = class extends FormGroup {
};
var CALL_SET_DISABLED_STATE = new InjectionToken("CallSetDisabledState", {
  providedIn: "root",
  factory: () => setDisabledStateDefault
});
var setDisabledStateDefault = "always";
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control) _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop6 = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop6);
    dir.valueAccessor.registerOnTouched(noop6);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange2) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange2);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop6 = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop6);
  registerOnValidatorChange(dir._rawAsyncValidators, noop6);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change") updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== "submit") control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange2 = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange2);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange2);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path3 = dir.path;
  if (path3 && path3.length > 1) return `path: '${path3.join(" -> ")}'`;
  if (path3?.[0]) return `name: '${path3}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model")) return false;
  const change = changes["model"];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode)) _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function _ngModelWarning(name, type2, instance, warningConfig) {
  if (warningConfig === "never") return;
  if ((warningConfig === null || warningConfig === "once") && !type2._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type2._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
var formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgForm)
};
var resolvedPromise$1 = (() => Promise.resolve())();
var NgForm = class _NgForm extends ControlContainer {
  callSetDisabledState;
  /**
   * @description
   * Returns whether the form submission has been triggered.
   */
  get submitted() {
    return untracked(this.submittedReactive);
  }
  /** @internal */
  _submitted = computed(() => this.submittedReactive());
  submittedReactive = signal(false);
  _directives = /* @__PURE__ */ new Set();
  /**
   * @description
   * The `FormGroup` instance created for this form.
   */
  form;
  /**
   * @description
   * Event emitter for the "ngSubmit" event
   */
  ngSubmit = new EventEmitter();
  /**
   * @description
   * Tracks options for the `NgForm` instance.
   *
   * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it
   * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.
   * Possible values: `'change'` | `'blur'` | `'submit'`.
   *
   */
  // TODO(issue/24571): remove '!'.
  options;
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  /** @nodoc */
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  /**
   * @description
   * The directive instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * The internal `FormGroup` instance.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it is always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Returns a map of the controls in this group.
   */
  get controls() {
    return this.form.controls;
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `NgModel` directive instance.
   */
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `NgModel` directive.
   *
   * @param dir The `NgModel` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `NgModel` instance from the internal list of directives
   *
   * @param dir The `NgModel` directive instance.
   */
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  /**
   * @description
   * Adds a new `NgModelGroup` directive instance to the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group = new FormGroup({});
      setUpFormContainer(group, dir);
      container.registerControl(dir.name, group);
      group.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  /**
   * @description
   * Removes the `NgModelGroup` directive instance from the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `NgControl` directive.
   *
   * @param dir The `NgControl` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value2) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value2);
    });
  }
  /**
   * @description
   * Sets the value for this `FormGroup`.
   *
   * @param value The new value
   */
  setValue(value2) {
    this.control.setValue(value2);
  }
  /**
   * @description
   * Method called when the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submittedReactive.set(true);
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value2 = void 0) {
    this.form.reset(value2);
    this.submittedReactive.set(false);
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path3) {
    path3.pop();
    return path3.length ? this.form.get(path3) : this.form;
  }
  static \u0275fac = function NgForm_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgForm)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgForm,
    selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
    hostBindings: function NgForm_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("submit", function NgForm_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function NgForm_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      options: [0, "ngFormOptions", "options"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formDirectiveProvider$1]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
      providers: [formDirectiveProvider$1],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      outputs: ["ngSubmit"],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: Input,
      args: ["ngFormOptions"]
    }]
  });
})();
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1) list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
var FormControl = class FormControl2 extends AbstractControl {
  /** @publicApi */
  defaultValue = null;
  /** @internal */
  _onChange = [];
  /** @internal */
  _pendingValue;
  /** @internal */
  _pendingChange = false;
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set
      // `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value2, options = {}) {
    this.value = this._pendingValue = value2;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value2, options = {}) {
    this.setValue(value2, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**  @internal */
  _updateValue() {
  }
  /**  @internal */
  _anyControls(condition) {
    return false;
  }
  /**  @internal */
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /** @internal */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /** @internal */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /** @internal */
  _forEachChild(cb) {
  }
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === "submit") {
      if (this._pendingDirty) this.markAsDirty();
      if (this._pendingTouched) this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
var isFormControl = (control) => control instanceof FormControl;
var AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
  /**
   * @description
   * The parent control for the group
   *
   * @internal
   */
  // TODO(issue/24571): remove '!'.
  _parent;
  /** @nodoc */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  /**
   * @description
   * The `FormGroup` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  /**
   * @description
   * The path to this group from the top-level directive.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /** @internal */
  _checkParentType() {
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275AbstractFormGroupDirective_BaseFactory;
    return function AbstractFormGroupDirective_Factory(__ngFactoryType__) {
      return (\u0275AbstractFormGroupDirective_BaseFactory || (\u0275AbstractFormGroupDirective_BaseFactory = \u0275\u0275getInheritedFactory(_AbstractFormGroupDirective)))(__ngFactoryType__ || _AbstractFormGroupDirective);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _AbstractFormGroupDirective,
    standalone: false,
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
    type: Directive,
    args: [{
      standalone: false
    }]
  }], null, null);
})();
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
var modelGroupProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgModelGroup)
};
var NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
  /**
   * @description
   * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds
   * to a key in the parent `NgForm`.
   */
  name = "";
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
  static \u0275fac = function NgModelGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModelGroup)(\u0275\u0275directiveInject(ControlContainer, 5), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgModelGroup,
    selectors: [["", "ngModelGroup", ""]],
    inputs: {
      name: [0, "ngModelGroup", "name"]
    },
    exportAs: ["ngModelGroup"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([modelGroupProvider]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
    type: Directive,
    args: [{
      selector: "[ngModelGroup]",
      providers: [modelGroupProvider],
      exportAs: "ngModelGroup",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["ngModelGroup"]
    }]
  });
})();
var formControlBinding$1 = {
  provide: NgControl,
  useExisting: forwardRef(() => NgModel)
};
var resolvedPromise = (() => Promise.resolve())();
var NgModel = class _NgModel extends NgControl {
  _changeDetectorRef;
  callSetDisabledState;
  control = new FormControl();
  // At runtime we coerce arbitrary values assigned to the "disabled" input to a "boolean".
  // This is not reflected in the type of the property because outside of templates, consumers
  // should only deal with booleans. In templates, a string is allowed for convenience and to
  // match the native "disabled attribute" semantics which can be observed on input elements.
  // This static member tells the compiler that values of type "string" can also be assigned
  // to the input in a template.
  /** @nodoc */
  static ngAcceptInputType_isDisabled;
  /** @internal */
  _registered = false;
  /**
   * Internal reference to the view model value.
   * @nodoc
   */
  viewModel;
  /**
   * @description
   * Tracks the name bound to the directive. If a parent form exists, it
   * uses this name as a key to retrieve this control's value.
   */
  name = "";
  /**
   * @description
   * Tracks whether the control is disabled.
   */
  // TODO(issue/24571): remove '!'.
  isDisabled;
  /**
   * @description
   * Tracks the value bound to this directive.
   */
  model;
  /**
   * @description
   * Tracks the configuration options for this `ngModel` instance.
   *
   * **name**: An alternative to setting the name attribute on the form control element. See
   * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`
   * as a standalone control.
   *
   * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,
   * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option
   * has no effect.
   *
   * **updateOn**: Defines the event upon which the form control value and validity update.
   * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.
   *
   */
  // TODO(issue/24571): remove '!'.
  options;
  /**
   * @description
   * Event emitter for producing the `ngModelChange` event after
   * the view model updates.
   */
  update = new EventEmitter();
  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || "name" in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes["name"].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ("isDisabled" in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return this._getPath(this.name);
  }
  /**
   * @description
   * The top-level directive for this control if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value emitted by `ngModelChange`.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if (!this._isStandalone()) {
      this._checkParentType();
    }
    this._checkName();
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
        throw formGroupNameException();
      } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
        throw modelParentException();
      }
    }
  }
  _checkName() {
    if (this.options && this.options.name) this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value2) {
    resolvedPromise.then(() => {
      this.control.setValue(value2, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes["isDisabled"].currentValue;
    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
  static \u0275fac = function NgModel_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModel)(\u0275\u0275directiveInject(ControlContainer, 9), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(ChangeDetectorRef, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgModel,
    selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
    inputs: {
      name: "name",
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"],
      options: [0, "ngModelOptions", "options"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngModel"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formControlBinding$1]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
    type: Directive,
    args: [{
      selector: "[ngModel]:not([formControlName]):not([formControl])",
      providers: [formControlBinding$1],
      exportAs: "ngModel",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: ChangeDetectorRef,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    options: [{
      type: Input,
      args: ["ngModelOptions"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var \u0275NgNoValidate = class _\u0275NgNoValidate {
  static \u0275fac = function \u0275NgNoValidate_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _\u0275NgNoValidate)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _\u0275NgNoValidate,
    selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
    hostAttrs: ["novalidate", ""],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgNoValidate, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([ngNativeValidate])",
      host: {
        "novalidate": ""
      },
      standalone: false
    }]
  }], null, null);
})();
var NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NumberValueAccessor),
  multi: true
};
var NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value2) {
    const normalizedValue = value2 == null ? "" : value2;
    this.setProperty("value", normalizedValue);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value2) => {
      fn(value2 == "" ? null : parseFloat(value2));
    };
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275NumberValueAccessor_BaseFactory;
    return function NumberValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275NumberValueAccessor_BaseFactory || (\u0275NumberValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_NumberValueAccessor)))(__ngFactoryType__ || _NumberValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NumberValueAccessor,
    selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
    hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([NUMBER_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
      host: {
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [NUMBER_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
var RadioControlRegistry = class _RadioControlRegistry {
  _accessors = [];
  /**
   * @description
   * Adds a control to the internal registry. For internal use only.
   */
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  /**
   * @description
   * Removes a control from the internal registry. For internal use only.
   */
  remove(accessor) {
    for (let i = this._accessors.length - 1; i >= 0; --i) {
      if (this._accessors[i][1] === accessor) {
        this._accessors.splice(i, 1);
        return;
      }
    }
  }
  /**
   * @description
   * Selects a radio button. For internal use only.
   */
  select(accessor) {
    this._accessors.forEach((c) => {
      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
        c[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control) return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
  static \u0275fac = function RadioControlRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlRegistry)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RadioControlRegistry,
    factory: _RadioControlRegistry.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
  _registry;
  _injector;
  /** @internal */
  // TODO(issue/24571): remove '!'.
  _state;
  /** @internal */
  // TODO(issue/24571): remove '!'.
  _control;
  /** @internal */
  // TODO(issue/24571): remove '!'.
  _fn;
  setDisabledStateFired = false;
  /**
   * The registered callback function called when a change event occurs on the input element.
   * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
   * to override the `onChange` function (which expects 1 argument) in the parent
   * `BaseControlValueAccessor` class.
   * @nodoc
   */
  onChange = () => {
  };
  /**
   * @description
   * Tracks the name of the radio input element.
   */
  // TODO(issue/24571): remove '!'.
  name;
  /**
   * @description
   * Tracks the name of the `FormControl` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   */
  // TODO(issue/24571): remove '!'.
  formControlName;
  /**
   * @description
   * Tracks the value of the radio input element
   */
  value;
  callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {
    optional: true
  }) ?? setDisabledStateDefault;
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
  }
  /** @nodoc */
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  /** @nodoc */
  ngOnDestroy() {
    this._registry.remove(this);
  }
  /**
   * Sets the "checked" property value on the radio input element.
   * @nodoc
   */
  writeValue(value2) {
    this._state = value2 === this.value;
    this.setProperty("checked", this._state);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  /** @nodoc */
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
      this.setProperty("disabled", isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  /**
   * Sets the "value" on the radio input element and unchecks it.
   *
   * @param value
   */
  fireUncheck(value2) {
    this.writeValue(value2);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName) this.name = this.formControlName;
  }
  static \u0275fac = function RadioControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(RadioControlRegistry), \u0275\u0275directiveInject(Injector));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RadioControlValueAccessor,
    selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
    hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
          return ctx.onChange();
        })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      name: "name",
      formControlName: "formControlName",
      value: "value"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([RADIO_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
      host: {
        "(change)": "onChange()",
        "(blur)": "onTouched()"
      },
      providers: [RADIO_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: Injector
  }], {
    name: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RangeValueAccessor),
  multi: true
};
var RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value2) {
    this.setProperty("value", parseFloat(value2));
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value2) => {
      fn(value2 == "" ? null : parseFloat(value2));
    };
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275RangeValueAccessor_BaseFactory;
    return function RangeValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275RangeValueAccessor_BaseFactory || (\u0275RangeValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_RangeValueAccessor)))(__ngFactoryType__ || _RangeValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RangeValueAccessor,
    selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
    hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([RANGE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [RANGE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? "NgModelWithFormControlWarning" : "");
var formControlBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlDirective)
};
var FormControlDirective = class _FormControlDirective extends NgControl {
  _ngModelWarningConfig;
  callSetDisabledState;
  /**
   * Internal reference to the view model value.
   * @nodoc
   */
  viewModel;
  /**
   * @description
   * Tracks the `FormControl` instance bound to the directive.
   */
  // TODO(issue/24571): remove '!'.
  form;
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  // TODO(kara): remove next 4 properties once deprecation period is over
  /** @deprecated as of v6 */
  model;
  /** @deprecated as of v6 */
  update = new EventEmitter();
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlDirective. Used to support warning config of "once".
   *
   * @internal
   */
  static _ngModelWarningSentOnce = false;
  /**
   * @description
   * Instance property used to track whether an ngModel warning has been sent out for this
   * particular `FormControlDirective` instance. Used to support warning config of "always".
   *
   * @internal
   */
  _ngModelWarningSent = false;
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes["form"].previousValue;
      if (previousForm) {
        cleanUpControl(
          previousForm,
          this,
          /* validateControlPresenceOnChange */
          false
        );
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(
        this.form,
        this,
        /* validateControlPresenceOnChange */
        false
      );
    }
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * The `FormControl` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty("form");
  }
  static \u0275fac = function FormControlDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormControlDirective,
    selectors: [["", "formControl", ""]],
    inputs: {
      form: [0, "formControl", "form"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formControlBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
    type: Directive,
    args: [{
      selector: "[formControl]",
      providers: [formControlBinding],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formControl"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupDirective)
};
var FormGroupDirective = class _FormGroupDirective extends ControlContainer {
  callSetDisabledState;
  /**
   * @description
   * Reports whether the form submission has been triggered.
   */
  get submitted() {
    return untracked(this._submittedReactive);
  }
  // TODO(atscott): Remove once invalid API usage is cleaned up internally
  set submitted(value2) {
    this._submittedReactive.set(value2);
  }
  /** @internal */
  _submitted = computed(() => this._submittedReactive());
  _submittedReactive = signal(false);
  /**
   * Reference to an old form group input value, which is needed to cleanup
   * old instance in case it was replaced with a new one.
   */
  _oldForm;
  /**
   * Callback that should be invoked when controls in FormGroup or FormArray collection change
   * (added or removed). This callback triggers corresponding DOM updates.
   */
  _onCollectionChange = () => this._updateDomValue();
  /**
   * @description
   * Tracks the list of added `FormControlName` instances
   */
  directives = [];
  /**
   * @description
   * Tracks the `FormGroup` bound to this directive.
   */
  form = null;
  /**
   * @description
   * Emits an event when the form submission has been triggered.
   */
  ngSubmit = new EventEmitter();
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkFormPresent();
    if (changes.hasOwnProperty("form")) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {
        });
      }
    }
  }
  /**
   * @description
   * Returns this directive's instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * Returns the `FormGroup` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `FormControlName` directive instance.
   */
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `FormControlName` directive
   *
   * @param dir The `FormControlName` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `FormControlName` instance from the internal list of directives
   *
   * @param dir The `FormControlName` directive instance.
   */
  removeControl(dir) {
    cleanUpControl(
      dir.control || null,
      dir,
      /* validateControlPresenceOnChange */
      false
    );
    removeListItem$1(this.directives, dir);
  }
  /**
   * Adds a new `FormGroupName` directive instance to the form.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
   *
   * @param dir The `FormGroupName` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `FormControlName` directive.
   *
   * @param dir The `FormControlName` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value2) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value2);
  }
  /**
   * @description
   * Method called with the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this._submittedReactive.set(true);
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value2 = void 0) {
    this.form.reset(value2);
    this._submittedReactive.set(false);
    this.form._events.next(new FormResetEvent(this.form));
  }
  /** @internal */
  _updateDomValue() {
    this.directives.forEach((dir) => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {
      });
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  _checkFormPresent() {
    if (!this.form && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingFormException();
    }
  }
  static \u0275fac = function FormGroupDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormGroupDirective,
    selectors: [["", "formGroup", ""]],
    hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormGroupDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: [0, "formGroup", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formDirectiveProvider]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[formGroup]",
      providers: [formDirectiveProvider],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formGroup"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupName)
};
var FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
  /**
   * @description
   * Tracks the name of the `FormGroup` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form groups to be bound
   * to indices when iterating over groups in a `FormArray`.
   */
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw groupParentException();
    }
  }
  static \u0275fac = function FormGroupName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormGroupName,
    selectors: [["", "formGroupName", ""]],
    inputs: {
      name: [0, "formGroupName", "name"]
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formGroupNameProvider]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
    type: Directive,
    args: [{
      selector: "[formGroupName]",
      providers: [formGroupNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formGroupName"]
    }]
  });
})();
var formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayName)
};
var FormArrayName = class _FormArrayName extends ControlContainer {
  /** @internal */
  _parent;
  /**
   * @description
   * Tracks the name of the `FormArray` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form arrays to be bound
   * to indices when iterating over arrays in a `FormArray`.
   */
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /**
   * A lifecycle method called when the directive's inputs are initialized. For internal use only.
   * @throws If the directive does not have a valid parent.
   * @nodoc
   */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormArray(this);
  }
  /**
   * A lifecycle method called before the directive's instance is destroyed. For internal use only.
   * @nodoc
   */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormArray(this);
    }
  }
  /**
   * @description
   * The `FormArray` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormArray(this);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw arrayParentException();
    }
  }
  static \u0275fac = function FormArrayName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormArrayName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormArrayName,
    selectors: [["", "formArrayName", ""]],
    inputs: {
      name: [0, "formArrayName", "name"]
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formArrayNameProvider]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
    type: Directive,
    args: [{
      selector: "[formArrayName]",
      providers: [formArrayNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formArrayName"]
    }]
  });
})();
function _hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
var controlNameBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlName)
};
var FormControlName = class _FormControlName extends NgControl {
  _ngModelWarningConfig;
  _added = false;
  /**
   * Internal reference to the view model value.
   * @internal
   */
  viewModel;
  /**
   * @description
   * Tracks the `FormControl` instance bound to the directive.
   */
  // TODO(issue/24571): remove '!'.
  control;
  /**
   * @description
   * Tracks the name of the `FormControl` bound to the directive. The name corresponds
   * to a key in the parent `FormGroup` or `FormArray`.
   * Accepts a name as a string or a number.
   * The name in the form of a string is useful for individual forms,
   * while the numerical form allows for form controls to be bound
   * to indices when iterating over controls in a `FormArray`.
   */
  name = null;
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  // TODO(kara): remove next 4 properties once deprecation period is over
  /** @deprecated as of v6 */
  model;
  /** @deprecated as of v6 */
  update = new EventEmitter();
  /**
   * @description
   * Static property used to track whether any ngModel warnings have been sent across
   * all instances of FormControlName. Used to support warning config of "once".
   *
   * @internal
   */
  static _ngModelWarningSentOnce = false;
  /**
   * @description
   * Instance property used to track whether an ngModel warning has been sent out for this
   * particular FormControlName instance. Used to support warning config of "always".
   *
   * @internal
   */
  _ngModelWarningSent = false;
  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (!this._added) this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
        throw ngModelGroupException();
      } else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) && !(this._parent instanceof FormArrayName)) {
        throw controlParentException(this.name);
      }
    }
  }
  _setUpControl() {
    this._checkParentType();
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
  static \u0275fac = function FormControlName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormControlName,
    selectors: [["", "formControlName", ""]],
    inputs: {
      name: [0, "formControlName", "name"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([controlNameBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
    type: Directive,
    args: [{
      selector: "[formControlName]",
      providers: [controlNameBinding],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formControlName"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id3, value2) {
  if (id3 == null) return `${value2}`;
  if (value2 && typeof value2 === "object") value2 = "Object";
  return `${id3}: ${value2}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
var SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
  /** @nodoc */
  value;
  /** @internal */
  _optionMap = /* @__PURE__ */ new Map();
  /** @internal */
  _idCounter = 0;
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  /**
   * Sets the "value" property on the select element.
   * @nodoc
   */
  writeValue(value2) {
    this.value = value2;
    const id3 = this._getOptionId(value2);
    const valueString = _buildValueString$1(id3, value2);
    this.setProperty("value", valueString);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (valueString) => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  /** @internal */
  _registerOption() {
    return (this._idCounter++).toString();
  }
  /** @internal */
  _getOptionId(value2) {
    for (const id3 of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id3), value2)) return id3;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id3 = _extractId$1(valueString);
    return this._optionMap.has(id3) ? this._optionMap.get(id3) : valueString;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275SelectControlValueAccessor_BaseFactory;
    return function SelectControlValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275SelectControlValueAccessor_BaseFactory || (\u0275SelectControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectControlValueAccessor)))(__ngFactoryType__ || _SelectControlValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _SelectControlValueAccessor,
    selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
    hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([SELECT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var NgSelectOption = class _NgSelectOption {
  _element;
  _renderer;
  _select;
  /**
   * @description
   * ID of the option element
   */
  // TODO(issue/24571): remove '!'.
  id;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) this.id = this._select._registerOption();
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value2) {
    if (this._select == null) return;
    this._select._optionMap.set(this.id, value2);
    this._setElementValue(_buildValueString$1(this.id, value2));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value2) {
    this._setElementValue(value2);
    if (this._select) this._select.writeValue(this._select.value);
  }
  /** @internal */
  _setElementValue(value2) {
    this._renderer.setProperty(this._element.nativeElement, "value", value2);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static \u0275fac = function NgSelectOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgSelectOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectControlValueAccessor, 9));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgSelectOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
var SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id3, value2) {
  if (id3 == null) return `${value2}`;
  if (typeof value2 === "string") value2 = `'${value2}'`;
  if (value2 && typeof value2 === "object") value2 = "Object";
  return `${id3}: ${value2}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
var SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * The current value.
   * @nodoc
   */
  value;
  /** @internal */
  _optionMap = /* @__PURE__ */ new Map();
  /** @internal */
  _idCounter = 0;
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  /**
   * Sets the "value" property on one or of more of the select's options.
   * @nodoc
   */
  writeValue(value2) {
    this.value = value2;
    let optionSelectedStateSetter;
    if (Array.isArray(value2)) {
      const ids = value2.map((v) => this._getOptionId(v));
      optionSelectedStateSetter = (opt, o2) => {
        opt._setSelected(ids.indexOf(o2.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o2) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  /**
   * Registers a function called when the control value changes
   * and writes an array of the selected options.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (element) => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== void 0) {
        const options = selectedOptions;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  /** @internal */
  _registerOption(value2) {
    const id3 = (this._idCounter++).toString();
    this._optionMap.set(id3, value2);
    return id3;
  }
  /** @internal */
  _getOptionId(value2) {
    for (const id3 of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id3)._value, value2)) return id3;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id3 = _extractId(valueString);
    return this._optionMap.has(id3) ? this._optionMap.get(id3)._value : valueString;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275SelectMultipleControlValueAccessor_BaseFactory;
    return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275SelectMultipleControlValueAccessor_BaseFactory || (\u0275SelectMultipleControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectMultipleControlValueAccessor)))(__ngFactoryType__ || _SelectMultipleControlValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _SelectMultipleControlValueAccessor,
    selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
    hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
      host: {
        "(change)": "onChange($event.target)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var \u0275NgSelectMultipleOption = class _\u0275NgSelectMultipleOption {
  _element;
  _renderer;
  _select;
  // TODO(issue/24571): remove '!'.
  id;
  /** @internal */
  _value;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value2) {
    if (this._select == null) return;
    this._value = value2;
    this._setElementValue(_buildValueString(this.id, value2));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value2) {
    if (this._select) {
      this._value = value2;
      this._setElementValue(_buildValueString(this.id, value2));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value2);
    }
  }
  /** @internal */
  _setElementValue(value2) {
    this._renderer.setProperty(this._element.nativeElement, "value", value2);
  }
  /** @internal */
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static \u0275fac = function \u0275NgSelectMultipleOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _\u0275NgSelectMultipleOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectMultipleControlValueAccessor, 9));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _\u0275NgSelectMultipleOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgSelectMultipleOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
function toInteger(value2) {
  return typeof value2 === "number" ? value2 : parseInt(value2, 10);
}
function toFloat(value2) {
  return typeof value2 === "number" ? value2 : parseFloat(value2);
}
var AbstractValidatorDirective = class _AbstractValidatorDirective {
  _validator = nullValidator;
  _onChange;
  /**
   * A flag that tracks whether this validator is enabled.
   *
   * Marking it `internal` (vs `protected`), so that this flag can be used in host bindings of
   * directive classes that extend this base class.
   * @internal
   */
  _enabled;
  /** @nodoc */
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input2 = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input2);
      this._validator = this._enabled ? this.createValidator(input2) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  /** @nodoc */
  validate(control) {
    return this._validator(control);
  }
  /** @nodoc */
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  /**
   * @description
   * Determines whether this validator should be active or not based on an input.
   * Base class implementation checks whether an input is defined (if the value is different from
   * `null` and `undefined`). Validator classes that extend this base class can override this
   * function with the logic specific to a particular validator directive.
   */
  enabled(input2) {
    return input2 != null;
  }
  static \u0275fac = function AbstractValidatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AbstractValidatorDirective)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _AbstractValidatorDirective,
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
    type: Directive
  }], null, null);
})();
var MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxValidator),
  multi: true
};
var MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the max bound to this directive.
   */
  max;
  /** @internal */
  inputName = "max";
  /** @internal */
  normalizeInput = (input2) => toFloat(input2);
  /** @internal */
  createValidator = (max6) => maxValidator(max6);
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MaxValidator_BaseFactory;
    return function MaxValidator_Factory(__ngFactoryType__) {
      return (\u0275MaxValidator_BaseFactory || (\u0275MaxValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxValidator)))(__ngFactoryType__ || _MaxValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MaxValidator,
    selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("max", ctx._enabled ? ctx.max : null);
      }
    },
    inputs: {
      max: "max"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([MAX_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
      providers: [MAX_VALIDATOR],
      host: {
        "[attr.max]": "_enabled ? max : null"
      },
      standalone: false
    }]
  }], null, {
    max: [{
      type: Input
    }]
  });
})();
var MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinValidator),
  multi: true
};
var MinValidator = class _MinValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the min bound to this directive.
   */
  min;
  /** @internal */
  inputName = "min";
  /** @internal */
  normalizeInput = (input2) => toFloat(input2);
  /** @internal */
  createValidator = (min6) => minValidator(min6);
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MinValidator_BaseFactory;
    return function MinValidator_Factory(__ngFactoryType__) {
      return (\u0275MinValidator_BaseFactory || (\u0275MinValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinValidator)))(__ngFactoryType__ || _MinValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MinValidator,
    selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("min", ctx._enabled ? ctx.min : null);
      }
    },
    inputs: {
      min: "min"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([MIN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
      providers: [MIN_VALIDATOR],
      host: {
        "[attr.min]": "_enabled ? min : null"
      },
      standalone: false
    }]
  }], null, {
    min: [{
      type: Input
    }]
  });
})();
var REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RequiredValidator),
  multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CheckboxRequiredValidator),
  multi: true
};
var RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the required attribute bound to this directive.
   */
  required;
  /** @internal */
  inputName = "required";
  /** @internal */
  normalizeInput = booleanAttribute;
  /** @internal */
  createValidator = (input2) => requiredValidator;
  /** @nodoc */
  enabled(input2) {
    return input2;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275RequiredValidator_BaseFactory;
    return function RequiredValidator_Factory(__ngFactoryType__) {
      return (\u0275RequiredValidator_BaseFactory || (\u0275RequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_RequiredValidator)))(__ngFactoryType__ || _RequiredValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RequiredValidator,
    selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
    hostVars: 1,
    hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("required", ctx._enabled ? "" : null);
      }
    },
    inputs: {
      required: "required"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
    type: Directive,
    args: [{
      selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
      providers: [REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, {
    required: [{
      type: Input
    }]
  });
})();
var CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
  /** @internal */
  createValidator = (input2) => requiredTrueValidator;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275CheckboxRequiredValidator_BaseFactory;
    return function CheckboxRequiredValidator_Factory(__ngFactoryType__) {
      return (\u0275CheckboxRequiredValidator_BaseFactory || (\u0275CheckboxRequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxRequiredValidator)))(__ngFactoryType__ || _CheckboxRequiredValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CheckboxRequiredValidator,
    selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("required", ctx._enabled ? "" : null);
      }
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, null);
})();
var EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => EmailValidator),
  multi: true
};
var EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the email attribute bound to this directive.
   */
  email;
  /** @internal */
  inputName = "email";
  /** @internal */
  normalizeInput = booleanAttribute;
  /** @internal */
  createValidator = (input2) => emailValidator;
  /** @nodoc */
  enabled(input2) {
    return input2;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275EmailValidator_BaseFactory;
    return function EmailValidator_Factory(__ngFactoryType__) {
      return (\u0275EmailValidator_BaseFactory || (\u0275EmailValidator_BaseFactory = \u0275\u0275getInheritedFactory(_EmailValidator)))(__ngFactoryType__ || _EmailValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _EmailValidator,
    selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
    inputs: {
      email: "email"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([EMAIL_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
    type: Directive,
    args: [{
      selector: "[email][formControlName],[email][formControl],[email][ngModel]",
      providers: [EMAIL_VALIDATOR],
      standalone: false
    }]
  }], null, {
    email: [{
      type: Input
    }]
  });
})();
var MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinLengthValidator),
  multi: true
};
var MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the minimum length bound to this directive.
   */
  minlength;
  /** @internal */
  inputName = "minlength";
  /** @internal */
  normalizeInput = (input2) => toInteger(input2);
  /** @internal */
  createValidator = (minlength) => minLengthValidator(minlength);
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MinLengthValidator_BaseFactory;
    return function MinLengthValidator_Factory(__ngFactoryType__) {
      return (\u0275MinLengthValidator_BaseFactory || (\u0275MinLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinLengthValidator)))(__ngFactoryType__ || _MinLengthValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MinLengthValidator,
    selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("minlength", ctx._enabled ? ctx.minlength : null);
      }
    },
    inputs: {
      minlength: "minlength"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([MIN_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        "[attr.minlength]": "_enabled ? minlength : null"
      },
      standalone: false
    }]
  }], null, {
    minlength: [{
      type: Input
    }]
  });
})();
var MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxLengthValidator),
  multi: true
};
var MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the maximum length bound to this directive.
   */
  maxlength;
  /** @internal */
  inputName = "maxlength";
  /** @internal */
  normalizeInput = (input2) => toInteger(input2);
  /** @internal */
  createValidator = (maxlength) => maxLengthValidator(maxlength);
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MaxLengthValidator_BaseFactory;
    return function MaxLengthValidator_Factory(__ngFactoryType__) {
      return (\u0275MaxLengthValidator_BaseFactory || (\u0275MaxLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxLengthValidator)))(__ngFactoryType__ || _MaxLengthValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MaxLengthValidator,
    selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("maxlength", ctx._enabled ? ctx.maxlength : null);
      }
    },
    inputs: {
      maxlength: "maxlength"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([MAX_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        "[attr.maxlength]": "_enabled ? maxlength : null"
      },
      standalone: false
    }]
  }], null, {
    maxlength: [{
      type: Input
    }]
  });
})();
var PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => PatternValidator),
  multi: true
};
var PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
  /**
   * @description
   * Tracks changes to the pattern bound to this directive.
   */
  pattern;
  // This input is always defined, since the name matches selector.
  /** @internal */
  inputName = "pattern";
  /** @internal */
  normalizeInput = (input2) => input2;
  /** @internal */
  createValidator = (input2) => patternValidator(input2);
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275PatternValidator_BaseFactory;
    return function PatternValidator_Factory(__ngFactoryType__) {
      return (\u0275PatternValidator_BaseFactory || (\u0275PatternValidator_BaseFactory = \u0275\u0275getInheritedFactory(_PatternValidator)))(__ngFactoryType__ || _PatternValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _PatternValidator,
    selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function PatternValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("pattern", ctx._enabled ? ctx.pattern : null);
      }
    },
    inputs: {
      pattern: "pattern"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([PATTERN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
    type: Directive,
    args: [{
      selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
      providers: [PATTERN_VALIDATOR],
      host: {
        "[attr.pattern]": "_enabled ? pattern : null"
      },
      standalone: false
    }]
  }], null, {
    pattern: [{
      type: Input
    }]
  });
})();
var SHARED_FORM_DIRECTIVES = [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
var \u0275InternalFormsSharedModule = class _\u0275InternalFormsSharedModule {
  static \u0275fac = function \u0275InternalFormsSharedModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _\u0275InternalFormsSharedModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _\u0275InternalFormsSharedModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275InternalFormsSharedModule, [{
    type: NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
var FormArray = class extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
   *     around from the back, and if index is greatly negative (less than `-length`), the result is
   * undefined. This behavior is the same as `Array.at(index)`.
   */
  at(index) {
    return this.controls[this._adjustIndex(index)];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
   * This behavior is the same as `Array.splice(index, 0, control)`.
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control.  If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), removes the first
   *     element. This behavior is the same as `Array.splice(index, 1)`.
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
   *     element. This behavior is the same as `Array.splice(index, 1, control)`.
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value2, options = {}) {
    assertAllValuesPresent(this, false, value2);
    value2.forEach((newValue, index) => {
      assertControlPresent(this, false, index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control
   * value is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value2, options = {}) {
    if (value2 == null) return;
    value2.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value2 = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value2[index], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   */
  getRawValue() {
    return this.controls.map((control) => control.getRawValue());
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1) return;
    this._forEachChild((control) => control._registerOnCollectionChange(() => {
    }));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Adjusts a negative index by summing it with the length of the array. For very negative
   * indices, the result may remain negative.
   * @internal
   */
  _adjustIndex(index) {
    return index < 0 ? index + this.length : index;
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some((control) => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => this._registerControl(control));
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled) return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  /** @internal */
  _find(name) {
    return this.at(name) ?? null;
  }
};
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var FormBuilder = class _FormBuilder {
  useNonNullable = false;
  /**
   * @description
   * Returns a FormBuilder in which automatically constructed `FormControl` elements
   * have `{nonNullable: true}` and are non-nullable.
   *
   * **Constructing non-nullable controls**
   *
   * When constructing a control, it will be non-nullable, and will reset to its initial value.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.control('Alex'); // FormControl<string>
   * name.reset();
   * console.log(name); // 'Alex'
   * ```
   *
   * **Constructing non-nullable groups or arrays**
   *
   * When constructing a group or array, all automatically created inner controls will be
   * non-nullable, and will reset to their initial values.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
   * name.reset();
   * console.log(name); // {who: 'Alex'}
   * ```
   * **Constructing *nullable* fields on groups or arrays**
   *
   * It is still possible to have a nullable field. In particular, any `FormControl` which is
   * *already* constructed will not be altered. For example:
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * // FormGroup<{who: FormControl<string|null>}>
   * let name = nnfb.group({who: new FormControl('Alex')});
   * name.reset(); console.log(name); // {who: null}
   * ```
   *
   * Because the inner control is constructed explicitly by the caller, the builder has
   * no control over how it is created, and cannot exclude the `null`.
   */
  get nonNullable() {
    const nnfb = new _FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  /**
   * @description
   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
   * containing all the keys and corresponding inner control types.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param options Configuration options object for the `FormRecord`. The object should have the
   * `AbstractControlOptions` type and might contain the following fields:
   * * `validators`: A synchronous validator function, or an array of validator functions.
   * * `asyncValidators`: A single async validator or array of async validator functions.
   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
   * | submit').
   */
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  /**
   * @description
   * Constructs a new `FormControl` with the given state, validators and options. Sets
   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
   * control will be nullable. Accepts a single generic argument, which is the type  of the
   * control's value.
   *
   * @param formState Initializes the control with an initial state value, or
   * with an object that contains both a value and a disabled status.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or a `FormControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator
   * functions.
   *
   * @usageNotes
   *
   * ### Initialize a control as disabled
   *
   * The following example returns a control with an initial value in a disabled state.
   *
   * <code-example path="forms/ts/formBuilder/form_builder_example.ts" region="disabled-control">
   * </code-example>
   */
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
      nonNullable: true
    }));
  }
  /**
   * Constructs a new `FormArray` from the given array of configurations,
   * validators and options. Accepts a single generic argument, which is the type of each control
   * inside the array.
   *
   * @param controls An array of child controls or control configs. Each child control is given an
   *     index when it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
   *     `AbstractControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions.
   */
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map((c) => this._createControl(c));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  /** @internal */
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach((controlName) => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  /** @internal */
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value2 = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value2, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
  static \u0275fac = function FormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormBuilder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _FormBuilder,
    factory: _FormBuilder.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NonNullableFormBuilder = class _NonNullableFormBuilder {
  static \u0275fac = function NonNullableFormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NonNullableFormBuilder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NonNullableFormBuilder,
    factory: () => (() => inject(FormBuilder).nonNullable)(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(FormBuilder).nonNullable
    }]
  }], null, null);
})();
var UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  /**
   * Like `FormBuilder#control`, except the resulting control is untyped.
   */
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  /**
   * Like `FormBuilder#array`, except the resulting array is untyped.
   */
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275UntypedFormBuilder_BaseFactory;
    return function UntypedFormBuilder_Factory(__ngFactoryType__) {
      return (\u0275UntypedFormBuilder_BaseFactory || (\u0275UntypedFormBuilder_BaseFactory = \u0275\u0275getInheritedFactory(_UntypedFormBuilder)))(__ngFactoryType__ || _UntypedFormBuilder);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _UntypedFormBuilder,
    factory: _UntypedFormBuilder.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var VERSION4 = new Version("19.0.1");
var FormsModule = class _FormsModule {
  /**
   * @description
   * Provides options for configuring the forms module.
   *
   * @param opts An object of configuration options
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static \u0275fac = function FormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormsModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _FormsModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [\u0275InternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
    type: NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [\u0275InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
var ReactiveFormsModule = class _ReactiveFormsModule {
  /**
   * @description
   * Provides options for configuring the reactive forms module.
   *
   * @param opts An object of configuration options
   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
   * binding is used with reactive form directives.
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? "always"
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static \u0275fac = function ReactiveFormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ReactiveFormsModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ReactiveFormsModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [\u0275InternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
    type: NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [\u0275InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();

// node_modules/@fortawesome/free-solid-svg-icons/index.mjs
var faInfo = {
  prefix: "fas",
  iconName: "info",
  icon: [192, 512, [], "f129", "M48 80a48 48 0 1 1 96 0A48 48 0 1 1 48 80zM0 224c0-17.7 14.3-32 32-32l64 0c17.7 0 32 14.3 32 32l0 224 32 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 512c-17.7 0-32-14.3-32-32s14.3-32 32-32l32 0 0-192-32 0c-17.7 0-32-14.3-32-32z"]
};
var faBars = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
};
var faLock = {
  prefix: "fas",
  iconName: "lock",
  icon: [448, 512, [128274], "f023", "M144 144l0 48 160 0 0-48c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192l0-48C80 64.5 144.5 0 224 0s144 64.5 144 144l0 48 16 0c35.3 0 64 28.7 64 64l0 192c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 256c0-35.3 28.7-64 64-64l16 0z"]
};
var faPenToSquare = {
  prefix: "fas",
  iconName: "pen-to-square",
  icon: [512, 512, ["edit"], "f044", "M471.6 21.7c-21.9-21.9-57.3-21.9-79.2 0L362.3 51.7l97.9 97.9 30.1-30.1c21.9-21.9 21.9-57.3 0-79.2L471.6 21.7zm-299.2 220c-6.1 6.1-10.8 13.6-13.5 21.9l-29.6 88.8c-2.9 8.6-.6 18.1 5.8 24.6s15.9 8.7 24.6 5.8l88.8-29.6c8.2-2.7 15.7-7.4 21.9-13.5L437.7 172.3 339.7 74.3 172.4 241.7zM96 64C43 64 0 107 0 160L0 416c0 53 43 96 96 96l256 0c53 0 96-43 96-96l0-96c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7-14.3 32-32 32L96 448c-17.7 0-32-14.3-32-32l0-256c0-17.7 14.3-32 32-32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L96 64z"]
};
var faEdit = faPenToSquare;
var faUser = {
  prefix: "fas",
  iconName: "user",
  icon: [448, 512, [128100, 62144], "f007", "M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512l388.6 0c16.4 0 29.7-13.3 29.7-29.7C448 383.8 368.2 304 269.7 304l-91.4 0z"]
};
var faBan = {
  prefix: "fas",
  iconName: "ban",
  icon: [512, 512, [128683, "cancel"], "f05e", "M367.2 412.5L99.5 144.8C77.1 176.1 64 214.5 64 256c0 106 86 192 192 192c41.5 0 79.9-13.1 111.2-35.5zm45.3-45.3C434.9 335.9 448 297.5 448 256c0-106-86-192-192-192c-41.5 0-79.9 13.1-111.2 35.5L412.5 367.2zM0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256z"]
};
var faAddressCard = {
  prefix: "fas",
  iconName: "address-card",
  icon: [576, 512, [62140, "contact-card", "vcard"], "f2bb", "M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l448 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zm80 256l64 0c44.2 0 80 35.8 80 80c0 8.8-7.2 16-16 16L80 384c-8.8 0-16-7.2-16-16c0-44.2 35.8-80 80-80zm-32-96a64 64 0 1 1 128 0 64 64 0 1 1 -128 0zm256-32l128 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-128 0c-8.8 0-16-7.2-16-16s7.2-16 16-16zm0 64l128 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-128 0c-8.8 0-16-7.2-16-16s7.2-16 16-16zm0 64l128 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-128 0c-8.8 0-16-7.2-16-16s7.2-16 16-16z"]
};
var faMoneyCheckDollar = {
  prefix: "fas",
  iconName: "money-check-dollar",
  icon: [576, 512, ["money-check-alt"], "f53d", "M64 64C28.7 64 0 92.7 0 128L0 384c0 35.3 28.7 64 64 64l448 0c35.3 0 64-28.7 64-64l0-256c0-35.3-28.7-64-64-64L64 64zM272 192l224 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-224 0c-8.8 0-16-7.2-16-16s7.2-16 16-16zM256 304c0-8.8 7.2-16 16-16l224 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-224 0c-8.8 0-16-7.2-16-16zM164 152l0 13.9c7.5 1.2 14.6 2.9 21.1 4.7c10.7 2.8 17 13.8 14.2 24.5s-13.8 17-24.5 14.2c-11-2.9-21.6-5-31.2-5.2c-7.9-.1-16 1.8-21.5 5c-4.8 2.8-6.2 5.6-6.2 9.3c0 1.8 .1 3.5 5.3 6.7c6.3 3.8 15.5 6.7 28.3 10.5l.7 .2c11.2 3.4 25.6 7.7 37.1 15c12.9 8.1 24.3 21.3 24.6 41.6c.3 20.9-10.5 36.1-24.8 45c-7.2 4.5-15.2 7.3-23.2 9l0 13.8c0 11-9 20-20 20s-20-9-20-20l0-14.6c-10.3-2.2-20-5.5-28.2-8.4c0 0 0 0 0 0s0 0 0 0c-2.1-.7-4.1-1.4-6.1-2.1c-10.5-3.5-16.1-14.8-12.6-25.3s14.8-16.1 25.3-12.6c2.5 .8 4.9 1.7 7.2 2.4c13.6 4.6 24 8.1 35.1 8.5c8.6 .3 16.5-1.6 21.4-4.7c4.1-2.5 6-5.5 5.9-10.5c0-2.9-.8-5-5.9-8.2c-6.3-4-15.4-6.9-28-10.7l-1.7-.5c-10.9-3.3-24.6-7.4-35.6-14c-12.7-7.7-24.6-20.5-24.7-40.7c-.1-21.1 11.8-35.7 25.8-43.9c6.9-4.1 14.5-6.8 22.2-8.5l0-14c0-11 9-20 20-20s20 9 20 20z"]
};
var faCircle = {
  prefix: "fas",
  iconName: "circle",
  icon: [512, 512, [128308, 128309, 128992, 128993, 128994, 128995, 128996, 9679, 9898, 9899, 11044, 61708, 61915], "f111", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"]
};
var faEye = {
  prefix: "fas",
  iconName: "eye",
  icon: [576, 512, [128065], "f06e", "M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z"]
};
var faTrash = {
  prefix: "fas",
  iconName: "trash",
  icon: [448, 512, [], "f1f8", "M135.2 17.7L128 32 32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0-7.2-14.3C307.4 6.8 296.3 0 284.2 0L163.8 0c-12.1 0-23.2 6.8-28.6 17.7zM416 128L32 128 53.2 467c1.6 25.3 22.6 45 47.9 45l245.8 0c25.3 0 46.3-19.7 47.9-45L416 128z"]
};
var faArrowLeft = {
  prefix: "fas",
  iconName: "arrow-left",
  icon: [448, 512, [8592], "f060", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"]
};
var faEnvelope = {
  prefix: "fas",
  iconName: "envelope",
  icon: [512, 512, [128386, 9993, 61443], "f0e0", "M48 64C21.5 64 0 85.5 0 112c0 15.1 7.1 29.3 19.2 38.4L236.8 313.6c11.4 8.5 27 8.5 38.4 0L492.8 150.4c12.1-9.1 19.2-23.3 19.2-38.4c0-26.5-21.5-48-48-48L48 64zM0 176L0 384c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-208L294.4 339.2c-22.8 17.1-54 17.1-76.8 0L0 176z"]
};
var faCircleInfo = {
  prefix: "fas",
  iconName: "circle-info",
  icon: [512, 512, ["info-circle"], "f05a", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM216 336l24 0 0-64-24 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l48 0c13.3 0 24 10.7 24 24l0 88 8 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24zm40-208a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"]
};
var faInfoCircle = faCircleInfo;
var faGear = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336a80 80 0 1 0 0-160 80 80 0 1 0 0 160z"]
};
var faClock = {
  prefix: "fas",
  iconName: "clock",
  icon: [512, 512, [128339, "clock-four"], "f017", "M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120l0 136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2 280 120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"]
};
var faDeleteLeft = {
  prefix: "fas",
  iconName: "delete-left",
  icon: [576, 512, [9003, "backspace"], "f55a", "M576 128c0-35.3-28.7-64-64-64L205.3 64c-17 0-33.3 6.7-45.3 18.7L9.4 233.4c-6 6-9.4 14.1-9.4 22.6s3.4 16.6 9.4 22.6L160 429.3c12 12 28.3 18.7 45.3 18.7L512 448c35.3 0 64-28.7 64-64l0-256zM271 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"]
};
var faUpload = {
  prefix: "fas",
  iconName: "upload",
  icon: [512, 512, [], "f093", "M288 109.3L288 352c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-242.7-73.4 73.4c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l128-128c12.5-12.5 32.8-12.5 45.3 0l128 128c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L288 109.3zM64 352l128 0c0 35.3 28.7 64 64 64s64-28.7 64-64l128 0c35.3 0 64 28.7 64 64l0 32c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64l0-32c0-35.3 28.7-64 64-64zM432 456a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"]
};
var faArrowDown = {
  prefix: "fas",
  iconName: "arrow-down",
  icon: [384, 512, [8595], "f063", "M169.4 470.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 370.8 224 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 306.7L54.6 265.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"]
};
var faArrowUp = {
  prefix: "fas",
  iconName: "arrow-up",
  icon: [384, 512, [8593], "f062", "M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2 160 448c0 17.7 14.3 32 32 32s32-14.3 32-32l0-306.7L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z"]
};
var faPlus = {
  prefix: "fas",
  iconName: "plus",
  icon: [448, 512, [10133, 61543, "add"], "2b", "M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 144L48 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0 0 144c0 17.7 14.3 32 32 32s32-14.3 32-32l0-144 144 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-144 0 0-144z"]
};
var faXmark = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"]
};
var faCalendar = {
  prefix: "fas",
  iconName: "calendar",
  icon: [448, 512, [128197, 128198], "f133", "M96 32l0 32L48 64C21.5 64 0 85.5 0 112l0 48 448 0 0-48c0-26.5-21.5-48-48-48l-48 0 0-32c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 32L160 64l0-32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192L0 192 0 464c0 26.5 21.5 48 48 48l352 0c26.5 0 48-21.5 48-48l0-272z"]
};
var faBook = {
  prefix: "fas",
  iconName: "book",
  icon: [448, 512, [128212], "f02d", "M96 0C43 0 0 43 0 96L0 416c0 53 43 96 96 96l288 0 32 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l0-64c17.7 0 32-14.3 32-32l0-320c0-17.7-14.3-32-32-32L384 0 96 0zm0 384l256 0 0 64L96 448c-17.7 0-32-14.3-32-32s14.3-32 32-32zm32-240c0-8.8 7.2-16 16-16l192 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-192 0c-8.8 0-16-7.2-16-16zm16 48l192 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-192 0c-8.8 0-16-7.2-16-16s7.2-16 16-16z"]
};
var faCheck = {
  prefix: "fas",
  iconName: "check",
  icon: [448, 512, [10003, 10004], "f00c", "M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"]
};

// src/app/common/app-constants.ts
var _AppConstants = class _AppConstants {
  static get baseUrl() {
    return "https://waldashop.herokuapp.com";
  }
  static get acceptJson() {
    return new HttpHeaders().set("Accept", "application/json");
  }
  static get contentTypeAndAcceptJson() {
    return this.acceptJson.set("Content-Type", "application/json");
  }
  static get emptyDefaultImage() {
    return "/assets/images/empty-product.png";
  }
};
_AppConstants.iconUser = faUser;
_AppConstants.iconInfo = faInfoCircle;
_AppConstants.iconLock = faLock;
_AppConstants.iconArrowLeft = faArrowLeft;
_AppConstants.iconArrowDown = faArrowDown;
_AppConstants.iconArrowUp = faArrowUp;
_AppConstants.iconUpload = faUpload;
_AppConstants.iconTrash = faTrash;
_AppConstants.iconEdit = faEdit;
_AppConstants.iconEye = faEye;
_AppConstants.iconCircle = faCircle;
_AppConstants.iconBan = faBan;
_AppConstants.iconPlus = faPlus;
_AppConstants.iconBars = faBars;
_AppConstants.iconAddressCard = faAddressCard;
_AppConstants.iconClock = faClock;
_AppConstants.iconMoney = faMoneyCheckDollar;
_AppConstants.iconBook = faBook;
_AppConstants.iconCalendar = faCalendar;
_AppConstants.iconEmail = faEnvelope;
_AppConstants.iconGear = faGear;
_AppConstants.iconDelete = faDeleteLeft;
_AppConstants.iconYes = faCheck;
_AppConstants.iconNo = faXmark;
_AppConstants.toastSuccessDelay = 2100;
_AppConstants.iconInfof = faInfo;
var AppConstants = _AppConstants;

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round2 = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start2, value2, end2) {
  return max(start2, min(value2, end2));
}
function evaluate(value2, param) {
  return typeof value2 === "function" ? value2(param) : value2;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return __spreadProps(__spreadValues({}, rect), {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = (reference, floating, config3) => __async(void 0, null, function* () {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config3;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);
  let rects = yield platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x4,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = yield fn({
      x: x4,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x4 = nextX != null ? nextX : x4;
    y3 = nextY != null ? nextY : y3;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
    });
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? yield platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x4,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x: x4,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
});
function detectOverflow(state2, options) {
  return __async(this, null, function* () {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x4,
      y: y3,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state2;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state2);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({
      element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? __spreadProps(__spreadValues({}, rects.floating), {
      x: x4,
      y: y3
    }) : rects.reference;
    const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);
    const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  });
}
var arrow = (options) => ({
  name: "arrow",
  options,
  fn(state2) {
    return __async(this, null, function* () {
      const {
        x: x4,
        y: y3,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state2;
      const {
        element,
        padding = 0
      } = evaluate(options, state2) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x: x4,
        y: y3
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = yield platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element);
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !(yield platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max6 = clientSize - arrowDimensions[length] - maxPadding;
      const center2 = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset2 = clamp(min$1, center2, max6);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center2 != offset2 && rects.reference[length] / 2 - (center2 < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center2 < min$1 ? center2 - min$1 : center2 - max6 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: __spreadValues({
          [axis]: offset2,
          centerOffset: center2 - offset2 - alignmentOffset
        }, shouldAddOffset && {
          alignmentOffset
        }),
        reset: shouldAddOffset
      };
    });
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
var autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    fn(state2) {
      return __async(this, null, function* () {
        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
        const {
          rects,
          middlewareData,
          placement,
          platform: platform2,
          elements
        } = state2;
        const _a2 = evaluate(options, state2), {
          crossAxis = false,
          alignment,
          allowedPlacements = placements,
          autoAlignment = true
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "crossAxis",
          "alignment",
          "allowedPlacements",
          "autoAlignment"
        ]);
        const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
        const overflow = yield detectOverflow(state2, detectOverflowOptions);
        const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
        const currentPlacement = placements$1[currentIndex];
        if (currentPlacement == null) {
          return {};
        }
        const alignmentSides = getAlignmentSides(currentPlacement, rects, yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        if (placement !== currentPlacement) {
          return {
            reset: {
              placement: placements$1[0]
            }
          };
        }
        const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
        const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
          placement: currentPlacement,
          overflows: currentOverflows
        }];
        const nextPlacement = placements$1[currentIndex + 1];
        if (nextPlacement) {
          return {
            data: {
              index: currentIndex + 1,
              overflows: allOverflows
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        const placementsSortedByMostSpace = allOverflows.map((d) => {
          const alignment2 = getAlignment(d.placement);
          return [d.placement, alignment2 && crossAxis ? (
            // Check along the mainAxis and main crossAxis side.
            d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0)
          ) : (
            // Check only the mainAxis.
            d.overflows[0]
          ), d.overflows];
        }).sort((a, b) => a[1] - b[1]);
        const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) => d[2].slice(
          0,
          // Aligned placements should not check their opposite crossAxis
          // side.
          getAlignment(d[0]) ? 2 : 3
        ).every((v) => v <= 0));
        const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
        if (resetPlacement !== placement) {
          return {
            data: {
              index: currentIndex + 1,
              overflows: allOverflows
            },
            reset: {
              placement: resetPlacement
            }
          };
        }
        return {};
      });
    }
  };
};
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    fn(state2) {
      return __async(this, null, function* () {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state2;
        const _a2 = evaluate(options, state2), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "mainAxis",
          "crossAxis",
          "fallbackPlacements",
          "fallbackStrategy",
          "fallbackAxisSideDirection",
          "flipAlignment"
        ]);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements2 = [initialPlacement, ...fallbackPlacements];
        const overflow = yield detectOverflow(state2, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements2[nextIndex];
          if (nextPlacement) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$map$so;
                const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      });
    }
  };
};
function convertValueToCoords(state2, options) {
  return __async(this, null, function* () {
    const {
      placement,
      platform: platform2,
      elements
    } = state2;
    const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state2);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : __spreadValues({
      mainAxis: 0,
      crossAxis: 0,
      alignmentAxis: null
    }, rawValue);
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  });
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    fn(state2) {
      return __async(this, null, function* () {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x: x4,
          y: y3,
          placement,
          middlewareData
        } = state2;
        const diffCoords = yield convertValueToCoords(state2, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x4 + diffCoords.x,
          y: y3 + diffCoords.y,
          data: __spreadProps(__spreadValues({}, diffCoords), {
            placement
          })
        };
      });
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    fn(state2) {
      return __async(this, null, function* () {
        const {
          x: x4,
          y: y3,
          placement
        } = state2;
        const _a2 = evaluate(options, state2), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x5,
                y: y4
              } = _ref;
              return {
                x: x5,
                y: y4
              };
            }
          }
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "mainAxis",
          "crossAxis",
          "limiter"
        ]);
        const coords = {
          x: x4,
          y: y3
        };
        const overflow = yield detectOverflow(state2, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min6 = mainAxisCoord + overflow[minSide];
          const max6 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min6, mainAxisCoord, max6);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min6 = crossAxisCoord + overflow[minSide];
          const max6 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min6, crossAxisCoord, max6);
        }
        const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state2), {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        }));
        return __spreadProps(__spreadValues({}, limitedCoords), {
          data: {
            x: limitedCoords.x - x4,
            y: limitedCoords.y - y3
          }
        });
      });
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state2) {
      const {
        x: x4,
        y: y3,
        placement,
        rects,
        middlewareData
      } = state2;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state2);
      const coords = {
        x: x4,
        y: y3
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state2);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : __spreadValues({
        mainAxis: 0,
        crossAxis: 0
      }, rawOffset);
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};

// node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
function getNodeName2(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value2) {
  return value2 instanceof Node || value2 instanceof getWindow(value2).Node;
}
function isElement(value2) {
  return value2 instanceof Element || value2 instanceof getWindow(value2).Element;
}
function isHTMLElement(value2) {
  return value2 instanceof HTMLElement || value2 instanceof getWindow(value2).HTMLElement;
}
function isShadowRoot(value2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value2 instanceof ShadowRoot || value2 instanceof getWindow(value2).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName2(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css2 = getComputedStyle2(element);
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value2) => (css2.willChange || "").includes(value2)) || ["paint", "layout", "strict", "content"].some((value2) => (css2.contain || "").includes(value2));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName2(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName2(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css2 = getComputedStyle2(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x4 = ($ ? round2(rect.width) : rect.width) / width;
  let y3 = ($ ? round2(rect.height) : rect.height) / height;
  if (!x4 || !Number.isFinite(x4)) {
    x4 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x4,
    y: y3
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x4 = (clientRect.left + visualOffsets.x) / scale.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle2(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x4 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x4 += left2;
      y3 += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x4,
    y: y3
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement2 = getDocumentElement(offsetParent);
  if (offsetParent === documentElement2) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement(documentElement2)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x4 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x4 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x4 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x4 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left2 = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x4 = left2 * scale.x;
  const y3 = top * scale.y;
  return {
    width,
    height,
    x: x4,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = __spreadProps(__spreadValues({}, clippingAncestor), {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    });
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement2 = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement(documentElement2)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement2) {
      offsets.x = getWindowScrollBarX(documentElement2);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName2(offsetParent) === "html" || getNodeName2(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var getElementRects = function(_ref) {
  return __async(this, null, function* () {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, yield getOffsetParentFn(floating), strategy),
      floating: __spreadValues({
        x: 0,
        y: 0
      }, yield getDimensionsFn(floating))
    };
  });
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root3 = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left: left2,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root3.clientWidth - (left2 + width));
    const insetBottom = floor(root3.clientHeight - (top + height));
    const insetLeft = floor(left2);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, __spreadProps(__spreadValues({}, options), {
        // Handle <iframe>s
        root: root3.ownerDocument
      }));
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = __spreadValues({
    platform
  }, options);
  const platformWithCache = __spreadProps(__spreadValues({}, mergedOptions.platform), {
    _c: cache2
  });
  return computePosition(reference, floating, __spreadProps(__spreadValues({}, mergedOptions), {
    platform: platformWithCache
  }));
};

// node_modules/ngx-popperjs/fesm2022/ngx-popperjs.mjs
var _c0 = ["popperViewRef"];
var _c1 = ["*", "*"];
function NgxPopperjsContentComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275projection(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r0.text, \u0275\u0275sanitizeHtml);
  }
}
function NgxPopperjsContentComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275projection(1, 1);
    \u0275\u0275elementEnd();
  }
}
var NgxPopperjsTriggers;
(function(NgxPopperjsTriggers2) {
  NgxPopperjsTriggers2["click"] = "click";
  NgxPopperjsTriggers2["hover"] = "hover";
  NgxPopperjsTriggers2["mousedown"] = "mousedown";
  NgxPopperjsTriggers2["none"] = "none";
})(NgxPopperjsTriggers || (NgxPopperjsTriggers = {}));
var NgxPopperjsContentComponent = class _NgxPopperjsContentComponent {
  elRef;
  _viewRef;
  _changeDetectorRef;
  static nextId = 0;
  ariaHidden;
  arrowColor = null;
  displayType;
  id = `ngx_poppperjs_${++_NgxPopperjsContentComponent.nextId}`;
  isMouseOver = false;
  onHidden = new EventEmitter();
  onUpdate;
  opacity;
  popperInstance;
  popperOptions = {
    disableAnimation: false,
    disableDefaultStyling: false,
    boundariesElement: "",
    trigger: NgxPopperjsTriggers.hover,
    positionFixed: false,
    appendToBody: false,
    popperModifiers: []
  };
  popperViewRef;
  referenceObject;
  state;
  text;
  _destroy$ = new Subject();
  _resizeCtrl$ = new Subject();
  _styleId = `${this.id}_style`;
  constructor(elRef, _viewRef, _changeDetectorRef) {
    this.elRef = elRef;
    this._viewRef = _viewRef;
    this._changeDetectorRef = _changeDetectorRef;
    this._toggleVisibility(false);
  }
  clean() {
    this.toggleVisibility(false);
    if (!this.popperInstance) {
      return;
    }
    this.popperInstance();
  }
  extractAppliedClassListExpr(classList2 = []) {
    const klassList = Array.isArray(classList2) ? classList2 : typeof classList2 === "string" ? classList2.replace(/ /, "").split(",") : [];
    return klassList.reduce((acc, klass) => {
      acc[klass] = true;
      return acc;
    }, {});
  }
  hide() {
    if (this.popperInstance) {
      this.popperInstance();
    }
    this.toggleVisibility(false);
    this.onHidden.emit();
  }
  ngOnDestroy() {
    this._destroy$.next();
    this.clean();
    if (this.popperOptions.appendTo && this.elRef && this.elRef.nativeElement && this.elRef.nativeElement.parentNode) {
      this._viewRef.detach();
      this.elRef.nativeElement.parentNode.removeChild(this.elRef.nativeElement);
    }
  }
  onDocumentResize() {
    this.update();
  }
  onMouseOver() {
    this.isMouseOver = true;
  }
  show() {
    if (!this.referenceObject) {
      return;
    }
    this._resizeCtrl$.next();
    this._determineArrowColor();
    this.popperInstance = autoUpdate(this.referenceObject, this.popperViewRef.nativeElement, () => {
      this._computePosition();
    });
    fromEvent(document, "resize").pipe(takeUntil(this._resizeCtrl$), takeUntil(this._destroy$)).subscribe({
      next: () => this.onDocumentResize()
    });
  }
  showOnLeave() {
    this.isMouseOver = false;
    if (this.popperOptions.trigger !== NgxPopperjsTriggers.hover && !this.popperOptions.hideOnMouseLeave) {
      return;
    }
    this.hide();
  }
  // Toggle visibility and detect changes - Run only after ngOnInit!
  toggleVisibility(state2) {
    this._toggleVisibility(state2);
    if (!this._changeDetectorRef["destroyed"]) {
      this._changeDetectorRef.detectChanges();
    }
  }
  update() {
    this._computePosition();
  }
  _computePosition() {
    const appendToParent = this.popperOptions.appendTo && document.querySelector(this.popperOptions.appendTo);
    if (appendToParent && this.elRef.nativeElement.parentNode !== appendToParent) {
      this.elRef.nativeElement.parentNode && this.elRef.nativeElement.parentNode.removeChild(this.elRef.nativeElement);
      appendToParent.appendChild(this.elRef.nativeElement);
    }
    const arrowElement = this.elRef.nativeElement.querySelector(".ngxp__arrow");
    const arrowLen = arrowElement.offsetWidth;
    const floatingOffset = Math.sqrt(2 * arrowLen ** 2) / 2;
    const boundaryMiddleware = [];
    if (this.popperOptions.flip) {
      boundaryMiddleware.push(flip());
    }
    if (this.popperOptions.preventOverflow) {
      boundaryMiddleware.push(shift({
        limiter: limitShift()
      }));
    }
    const popperOptions = {
      placement: this.popperOptions.placement,
      strategy: this.popperOptions.positionFixed ? "fixed" : "absolute",
      middleware: [offset(floatingOffset), ...boundaryMiddleware, arrow({
        element: arrowElement,
        padding: 4
      })]
    };
    if (!this.popperOptions.preventOverflow && !popperOptions.placement) {
      const boundariesElement = this.popperOptions.boundariesElement && document.querySelector(this.popperOptions.boundariesElement);
      popperOptions.middleware.push(autoPlacement({
        boundary: boundariesElement
      }));
    }
    computePosition2(this.referenceObject, this.popperViewRef.nativeElement, popperOptions).then(({
      middlewareData,
      x: x4,
      y: y3,
      placement
    }) => {
      const side = placement.split("-")[0];
      this.popperViewRef.nativeElement.setAttribute("data-popper-placement", side);
      if (middlewareData.arrow) {
        const staticSide = {
          top: "bottom",
          right: "left",
          bottom: "top",
          left: "right"
        }[side];
        Object.assign(arrowElement.style, {
          left: middlewareData.arrow.x != null ? `${middlewareData.arrow.x}px` : "",
          top: middlewareData.arrow.y != null ? `${middlewareData.arrow.y}px` : "",
          [staticSide]: `${-arrowLen / 2}px`
        });
      }
      Object.assign(this.popperViewRef.nativeElement.style, {
        left: `${x4}px`,
        top: `${y3}px`
      });
      this.toggleVisibility(true);
      this.onUpdate?.();
    });
  }
  _createArrowSelector() {
    return `div#${this.id}.ngxp__container > .ngxp__arrow.ngxp__force-arrow`;
  }
  _determineArrowColor() {
    if (!this.popperOptions.styles || this.arrowColor) {
      return false;
    }
    const ruleValue = this.popperOptions.styles["background-color"] || this.popperOptions.styles.backgroundColor;
    if (this.arrowColor === ruleValue) {
      return false;
    }
    this.arrowColor = ruleValue;
    let $style = document.querySelector(`#${this._styleId}`);
    const styleContent = this.arrowColor ? `${this._createArrowSelector()}:before { background-color: ${this.arrowColor}; }` : "";
    if (!$style) {
      $style = document.createElement("style");
      $style.id = this._styleId;
      $style.setAttribute("type", "text/css");
      document.head.appendChild($style);
    }
    if ($style["styleSheet"]) {
      $style["styleSheet"].cssText = styleContent;
    } else {
      $style.innerHTML = styleContent;
    }
  }
  _toggleVisibility(state2) {
    this.displayType = ["none", "block"][+state2];
    this.opacity = +state2;
    this.ariaHidden = `${!state2}`;
    this.state = state2;
  }
  /** @nocollapse */
  static \u0275fac = function NgxPopperjsContentComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgxPopperjsContentComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(ChangeDetectorRef));
  };
  /** @nocollapse */
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _NgxPopperjsContentComponent,
    selectors: [["popper-content"]],
    viewQuery: function NgxPopperjsContentComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c0, 7);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.popperViewRef = _t.first);
      }
    },
    hostBindings: function NgxPopperjsContentComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("mouseover", function NgxPopperjsContentComponent_mouseover_HostBindingHandler() {
          return ctx.onMouseOver();
        })("mouseleave", function NgxPopperjsContentComponent_mouseleave_HostBindingHandler() {
          return ctx.showOnLeave();
        });
      }
    },
    exportAs: ["ngxPopperjsContent"],
    ngContentSelectors: _c1,
    decls: 5,
    vars: 19,
    consts: [["popperViewRef", ""], [3, "ngStyle", "ngClass"], ["class", "ngxp__inner", 3, "innerHTML", 4, "ngIf"], ["class", "ngxp__inner", 4, "ngIf"], [1, "ngxp__arrow", 3, "ngClass"], [1, "ngxp__inner", 3, "innerHTML"], [1, "ngxp__inner"]],
    template: function NgxPopperjsContentComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef(_c1);
        \u0275\u0275elementStart(0, "div", 1, 0);
        \u0275\u0275template(2, NgxPopperjsContentComponent_div_2_Template, 2, 1, "div", 2)(3, NgxPopperjsContentComponent_div_3_Template, 2, 0, "div", 3);
        \u0275\u0275element(4, "div", 4);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275styleProp("display", ctx.displayType)("opacity", ctx.opacity);
        \u0275\u0275classProp("ngxp__container", !ctx.popperOptions.disableDefaultStyling)("ngxp__animation", !ctx.popperOptions.disableAnimation);
        \u0275\u0275property("ngStyle", ctx.popperOptions.styles)("ngClass", ctx.extractAppliedClassListExpr(ctx.popperOptions.applyClass));
        \u0275\u0275attribute("id", ctx.id)("aria-hidden", ctx.ariaHidden)("aria-describedby", ctx.popperOptions.ariaDescribe || null)("role", ctx.popperOptions.ariaRole);
        \u0275\u0275advance(2);
        \u0275\u0275property("ngIf", ctx.text);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", !ctx.text);
        \u0275\u0275advance();
        \u0275\u0275classProp("ngxp__force-arrow", ctx.arrowColor);
        \u0275\u0275property("ngClass", ctx.extractAppliedClassListExpr(ctx.popperOptions.applyArrowClass));
      }
    },
    dependencies: [NgStyle, NgClass, NgIf],
    styles: ["popper-content{position:relative;display:block}.ngxp__container{display:none;position:absolute;border-radius:3px;border:1px solid grey;box-shadow:0 0 2px #00000080;padding:10px}.ngxp__container.ngxp__animation{animation:ngxp-fadeIn .15s ease-out}.ngxp__container>.ngxp__arrow{position:absolute;width:10px;height:10px;z-index:-1;transform:rotate(45deg);background-color:red}.ngxp__container[data-popper-placement^=top]>.ngxp__arrow{bottom:-5px}.ngxp__container[data-popper-placement^=bottom]>.ngxp__arrow{top:-5px}.ngxp__container[data-popper-placement^=left]>.ngxp__arrow{right:-5px}.ngxp__container[data-popper-placement^=right]>.ngxp__arrow{left:-5px}@keyframes ngxp-fadeIn{0%{display:none;opacity:0}1%{display:block;opacity:0}to{display:block;opacity:1}}\n"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxPopperjsContentComponent, [{
    type: Component,
    args: [{
      selector: "popper-content",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "ngxPopperjsContent",
      standalone: true,
      imports: [NgStyle, NgClass, NgIf],
      template: '<div #popperViewRef\r\n     [attr.id]="id"\r\n     [class.ngxp__container]="!popperOptions.disableDefaultStyling"\r\n     [class.ngxp__animation]="!popperOptions.disableAnimation"\r\n     [style.display]="displayType"\r\n     [style.opacity]="opacity"\r\n     [ngStyle]="popperOptions.styles"\r\n     [ngClass]="extractAppliedClassListExpr(popperOptions.applyClass)"\r\n     attr.aria-hidden="{{ariaHidden}}"\r\n     [attr.aria-describedby]="popperOptions.ariaDescribe || null"\r\n     attr.role="{{popperOptions.ariaRole}}">\r\n    <div *ngIf="text"\r\n         class="ngxp__inner"\r\n         [innerHTML]="text">\r\n        <ng-content></ng-content>\r\n    </div>\r\n    <div *ngIf="!text"\r\n         class="ngxp__inner">\r\n        <ng-content></ng-content>\r\n    </div>\r\n    <div class="ngxp__arrow"\r\n         [class.ngxp__force-arrow]="arrowColor"\r\n         [ngClass]="extractAppliedClassListExpr(popperOptions.applyArrowClass)"></div>\r\n\r\n</div>\r\n',
      styles: ["popper-content{position:relative;display:block}.ngxp__container{display:none;position:absolute;border-radius:3px;border:1px solid grey;box-shadow:0 0 2px #00000080;padding:10px}.ngxp__container.ngxp__animation{animation:ngxp-fadeIn .15s ease-out}.ngxp__container>.ngxp__arrow{position:absolute;width:10px;height:10px;z-index:-1;transform:rotate(45deg);background-color:red}.ngxp__container[data-popper-placement^=top]>.ngxp__arrow{bottom:-5px}.ngxp__container[data-popper-placement^=bottom]>.ngxp__arrow{top:-5px}.ngxp__container[data-popper-placement^=left]>.ngxp__arrow{right:-5px}.ngxp__container[data-popper-placement^=right]>.ngxp__arrow{left:-5px}@keyframes ngxp-fadeIn{0%{display:none;opacity:0}1%{display:block;opacity:0}to{display:block;opacity:1}}\n"]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }], {
    popperViewRef: [{
      type: ViewChild,
      args: ["popperViewRef", {
        static: true
      }]
    }],
    onMouseOver: [{
      type: HostListener,
      args: ["mouseover"]
    }],
    showOnLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var NGX_POPPERJS_DEFAULTS = new InjectionToken("NGX_POPPERJS_DEFAULTS");
var NgxPopperjsUtils = class {
  /** Coerces a data-bound value (typically a string) to a boolean. */
  static coerceBooleanProperty(value2) {
    return value2 != null && `${value2}` !== "false";
  }
};
var NgxPopperjsDirective = class _NgxPopperjsDirective {
  _changeDetectorRef;
  _elementRef;
  _vcr;
  _popperDefaults;
  static baseOptions = {
    showDelay: 0,
    hideOnClickOutside: true,
    hideOnMouseLeave: false,
    hideOnScroll: false,
    appendTo: void 0,
    ariaRole: "popper",
    ariaDescribe: "",
    styles: {},
    trigger: NgxPopperjsTriggers.click
  };
  set applyClass(newValue) {
    if (newValue === this._applyClass) {
      return;
    }
    this._applyClass = newValue;
    this._checkExisting("applyClass", newValue);
  }
  get applyClass() {
    return this._applyClass;
  }
  set hideOnClickOutside(newValue) {
    this._hideOnClickOutside = NgxPopperjsUtils.coerceBooleanProperty(newValue);
  }
  get hideOnClickOutside() {
    return this._hideOnClickOutside;
  }
  set content(newValue) {
    if (newValue === this._content) {
      return;
    }
    this._content = newValue;
    if (this._popperContent) {
      if (typeof newValue === "string") {
        this._popperContent.text = newValue;
      } else {
        this._popperContent = newValue;
      }
    }
  }
  get content() {
    return this._content;
  }
  set flip(newValue) {
    this._flip = NgxPopperjsUtils.coerceBooleanProperty(newValue);
    this._checkExisting("preventOverflow", this._preventOverflow);
  }
  get flip() {
    return this._flip;
  }
  set placement(newValue) {
    this._placement = newValue;
    this._checkExisting("placement", newValue);
  }
  get placement() {
    return this._placement;
  }
  set preventOverflow(newValue) {
    this._preventOverflow = NgxPopperjsUtils.coerceBooleanProperty(newValue);
    this._checkExisting("preventOverflow", this._preventOverflow);
  }
  get preventOverflow() {
    return this._preventOverflow;
  }
  set popperApplyArrowClass(newValue) {
    if (newValue === this._applyArrowClass) {
      return;
    }
    this._applyArrowClass = newValue;
    if (this._popperContent) {
      this._popperContent.popperOptions.applyArrowClass = newValue;
      if (!this._shown) {
        return;
      }
      this._popperContent.update();
    }
  }
  get popperApplyArrowClass() {
    return this._applyArrowClass;
  }
  set disabled(newValue) {
    if (newValue === this._disabled) {
      return;
    }
    this._disabled = !!newValue;
    if (this._shown) {
      this.hide();
    }
  }
  get disabled() {
    return this._disabled;
  }
  ariaDescribe;
  ariaRole;
  boundariesElement;
  disableAnimation;
  disableStyle;
  hideOnMouseLeave;
  hideOnScroll;
  hideTimeout = 0;
  popperAppendTo;
  popperOnHidden = new EventEmitter();
  popperOnShown = new EventEmitter();
  popperOnUpdate = new EventEmitter();
  positionFixed;
  showDelay;
  showOnStart;
  showTrigger;
  styles;
  targetElement;
  timeoutAfterShow = 0;
  _applyArrowClass;
  _applyClass;
  _content;
  _destroy$ = new Subject();
  _disabled;
  _flip = true;
  _globalEventListenersCtrl$ = new Subject();
  _hideOnClickOutside = true;
  _placement;
  _popperContent;
  _popperContentClass = NgxPopperjsContentComponent;
  _popperContentRef;
  _preventOverflow = true;
  _scheduledHideTimeoutCtrl$ = new Subject();
  _scheduledShowTimeoutCtrl$ = new Subject();
  _shown = false;
  constructor(_changeDetectorRef, _elementRef, _vcr, _popperDefaults = {}) {
    this._changeDetectorRef = _changeDetectorRef;
    this._elementRef = _elementRef;
    this._vcr = _vcr;
    this._popperDefaults = _popperDefaults;
    _NgxPopperjsDirective.baseOptions = __spreadValues(__spreadValues({}, _NgxPopperjsDirective.baseOptions), this._popperDefaults);
  }
  static assignDefined(target, ...sources) {
    for (const source of sources) {
      for (const key of Object.keys(source)) {
        const val = source[key];
        if (val !== void 0) {
          target[key] = val;
        }
      }
    }
    return target;
  }
  applyTriggerListeners() {
    switch (this.showTrigger) {
      case NgxPopperjsTriggers.click:
        this._addListener("click", this.toggle.bind(this));
        break;
      case NgxPopperjsTriggers.mousedown:
        this._addListener("mousedown", this.toggle.bind(this));
        break;
      case NgxPopperjsTriggers.hover:
        this._addListener("mouseenter", this.scheduledShow.bind(this, this.showDelay));
        ["touchend", "touchcancel", "mouseleave"].forEach((eventName) => {
          this._addListener(eventName, this.scheduledHide.bind(this, null, this.hideTimeout));
        });
        break;
    }
    if (this.showTrigger !== NgxPopperjsTriggers.hover && this.hideOnMouseLeave) {
      ["touchend", "touchcancel", "mouseleave"].forEach((eventName) => {
        this._addListener(eventName, this.scheduledHide.bind(this, null, this.hideTimeout));
      });
    }
  }
  getRefElement() {
    return this.targetElement || this._elementRef.nativeElement;
  }
  hide() {
    if (this.disabled) {
      return;
    }
    if (!this._shown) {
      this._scheduledShowTimeoutCtrl$.next();
      return;
    }
    this._shown = false;
    if (this._popperContentRef) {
      this._popperContentRef.instance.hide();
    } else {
      this._popperContent.hide();
    }
    this.popperOnHidden.emit(this);
    this._globalEventListenersCtrl$.next();
  }
  hideOnClickOutsideHandler($event) {
    if (this.disabled || !this.hideOnClickOutside || $event.target === this._popperContent.elRef.nativeElement || this._popperContent.elRef.nativeElement.contains($event.target)) {
      return;
    }
    this.scheduledHide($event, this.hideTimeout);
  }
  hideOnScrollHandler($event) {
    if (this.disabled || !this.hideOnScroll) {
      return;
    }
    this.scheduledHide($event, this.hideTimeout);
  }
  ngOnDestroy() {
    this._destroy$.next();
    this._destroy$.complete();
    this._popperContent && this._popperContent.clean();
  }
  ngOnInit() {
    if (typeof this.content === "string") {
      this._popperContent = this._constructContent();
      this._popperContent.text = this.content;
    } else if (typeof this.content === "undefined") {
      this._popperContent = this._constructContent();
      this._popperContent.text = "";
    } else {
      this._popperContent = this.content;
    }
    const popperRef = this._popperContent;
    popperRef.referenceObject = this.getRefElement();
    this._setContentProperties(popperRef);
    this._setDefaults();
    this.applyTriggerListeners();
    if (this.showOnStart) {
      this.scheduledShow();
    }
  }
  scheduledHide($event = null, delay = this.hideTimeout) {
    if (this.disabled) {
      return;
    }
    this._scheduledShowTimeoutCtrl$.next();
    timer(delay).pipe(takeUntil(this._scheduledHideTimeoutCtrl$), takeUntil(this._destroy$)).subscribe({
      next: () => {
        const toElement = $event ? $event.toElement : null;
        const popperContentView = this._popperContent.popperViewRef ? this._popperContent.popperViewRef.nativeElement : false;
        if (!popperContentView || popperContentView === toElement || popperContentView.contains(toElement) || this.content && this.content.isMouseOver) {
          return;
        }
        this.hide();
        this._applyChanges();
      }
    });
  }
  scheduledShow(delay = this.showDelay) {
    if (this.disabled) {
      return;
    }
    this._scheduledHideTimeoutCtrl$.next();
    timer(delay).pipe(takeUntil(this._scheduledShowTimeoutCtrl$), takeUntil(this._destroy$)).subscribe({
      next: () => {
        this.show();
        this._applyChanges();
      }
    });
  }
  show() {
    if (this._shown) {
      this._scheduledHideTimeoutCtrl$.next();
      return;
    }
    this._shown = true;
    const popperRef = this._popperContent;
    const element = this.getRefElement();
    if (popperRef.referenceObject !== element) {
      popperRef.referenceObject = element;
    }
    this._setContentProperties(popperRef);
    popperRef.show();
    this.popperOnShown.emit(this);
    if (this.timeoutAfterShow > 0) {
      this.scheduledHide(null, this.timeoutAfterShow);
    }
    fromEvent(document, "click").pipe(takeUntil(this._globalEventListenersCtrl$), takeUntil(this._destroy$)).subscribe({
      next: (e) => this.hideOnClickOutsideHandler(e)
    });
    fromEvent(this._getScrollParent(this.getRefElement()), "scroll").pipe(takeUntil(this._globalEventListenersCtrl$), takeUntil(this._destroy$)).subscribe({
      next: (e) => {
        this.hideOnScrollHandler(e);
      }
    });
  }
  toggle() {
    if (this.disabled) {
      return;
    }
    this._shown ? this.scheduledHide(null, this.hideTimeout) : this.scheduledShow();
  }
  _addListener(eventName, cb) {
    fromEvent(this._elementRef.nativeElement, eventName).pipe(takeUntil(this._destroy$)).subscribe({
      next: cb
    });
  }
  _applyChanges() {
    this._changeDetectorRef.markForCheck();
    this._changeDetectorRef.detectChanges();
  }
  _checkExisting(key, newValue) {
    if (this._popperContent) {
      this._popperContent.popperOptions[key] = newValue;
      if (!this._shown) {
        return;
      }
      this._popperContent.update();
    }
  }
  _constructContent() {
    this._popperContentRef = this._vcr.createComponent(this._popperContentClass);
    return this._popperContentRef.instance;
  }
  _getScrollParent(node) {
    const isElement2 = node instanceof HTMLElement;
    const overflowY = isElement2 && window.getComputedStyle(node).overflowY;
    const isScrollable = overflowY !== "visible" && overflowY !== "hidden";
    if (!node) {
      return null;
    } else if (isScrollable && node.scrollHeight > node.clientHeight) {
      return node;
    }
    return this._getScrollParent(node.parentNode) || document;
  }
  _onPopperUpdate(event) {
    this.popperOnUpdate.emit(event);
  }
  _setContentProperties(popperRef) {
    popperRef.popperOptions = _NgxPopperjsDirective.assignDefined(popperRef.popperOptions, _NgxPopperjsDirective.baseOptions, {
      showDelay: this.showDelay,
      disableAnimation: this.disableAnimation,
      disableDefaultStyling: this.disableStyle,
      placement: this.placement,
      boundariesElement: this.boundariesElement,
      trigger: this.showTrigger,
      positionFixed: this.positionFixed,
      ariaDescribe: this.ariaDescribe,
      ariaRole: this.ariaRole,
      applyClass: this.applyClass,
      applyArrowClass: this.popperApplyArrowClass,
      hideOnMouseLeave: this.hideOnMouseLeave,
      styles: this.styles,
      appendTo: this.popperAppendTo,
      preventOverflow: this.preventOverflow
    });
    popperRef.onUpdate = this._onPopperUpdate.bind(this);
    popperRef.onHidden.pipe(takeUntil(this._destroy$)).subscribe(this.hide.bind(this));
  }
  _setDefaults() {
    ["showDelay", "hideOnScroll", "hideOnMouseLeave", "hideOnClickOutside", "ariaRole", "ariaDescribe"].forEach((key) => {
      this[key] = this[key] === void 0 ? _NgxPopperjsDirective.baseOptions[key] : this[key];
    });
    this.showTrigger = this.showTrigger || _NgxPopperjsDirective.baseOptions.trigger;
    this.styles = this.styles === void 0 ? __spreadValues({}, _NgxPopperjsDirective.baseOptions.styles) : this.styles;
  }
  /** @nocollapse */
  static \u0275fac = function NgxPopperjsDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgxPopperjsDirective)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NGX_POPPERJS_DEFAULTS));
  };
  /** @nocollapse */
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgxPopperjsDirective,
    selectors: [["", "popper", ""]],
    inputs: {
      applyClass: [0, "popperApplyClass", "applyClass"],
      hideOnClickOutside: [0, "popperHideOnClickOutside", "hideOnClickOutside"],
      content: [0, "popper", "content"],
      flip: [0, "popperFlip", "flip"],
      placement: [0, "popperPlacement", "placement"],
      preventOverflow: [0, "popperPreventOverflow", "preventOverflow"],
      popperApplyArrowClass: "popperApplyArrowClass",
      disabled: [0, "popperDisabled", "disabled"],
      ariaDescribe: [0, "popperAriaDescribeBy", "ariaDescribe"],
      ariaRole: [0, "popperAriaRole", "ariaRole"],
      boundariesElement: [0, "popperBoundaries", "boundariesElement"],
      disableAnimation: [0, "popperDisableAnimation", "disableAnimation"],
      disableStyle: [0, "popperDisableStyle", "disableStyle"],
      hideOnMouseLeave: [0, "popperHideOnMouseLeave", "hideOnMouseLeave"],
      hideOnScroll: [0, "popperHideOnScroll", "hideOnScroll"],
      hideTimeout: [0, "popperTimeout", "hideTimeout"],
      popperAppendTo: "popperAppendTo",
      positionFixed: [0, "popperPositionFixed", "positionFixed"],
      showDelay: [0, "popperDelay", "showDelay"],
      showOnStart: [0, "popperShowOnStart", "showOnStart"],
      showTrigger: [0, "popperTrigger", "showTrigger"],
      styles: [0, "popperStyles", "styles"],
      targetElement: [0, "popperTarget", "targetElement"],
      timeoutAfterShow: [0, "popperTimeoutAfterShow", "timeoutAfterShow"]
    },
    outputs: {
      popperOnHidden: "popperOnHidden",
      popperOnShown: "popperOnShown",
      popperOnUpdate: "popperOnUpdate"
    },
    exportAs: ["popper"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxPopperjsDirective, [{
    type: Directive,
    args: [{
      // tslint:disable-next-line:directive-selector
      selector: "[popper]",
      exportAs: "popper",
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NGX_POPPERJS_DEFAULTS]
    }]
  }], {
    applyClass: [{
      type: Input,
      args: ["popperApplyClass"]
    }],
    hideOnClickOutside: [{
      type: Input,
      args: ["popperHideOnClickOutside"]
    }],
    content: [{
      type: Input,
      args: ["popper"]
    }],
    flip: [{
      type: Input,
      args: ["popperFlip"]
    }],
    placement: [{
      type: Input,
      args: ["popperPlacement"]
    }],
    preventOverflow: [{
      type: Input,
      args: ["popperPreventOverflow"]
    }],
    popperApplyArrowClass: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: ["popperDisabled"]
    }],
    ariaDescribe: [{
      type: Input,
      args: ["popperAriaDescribeBy"]
    }],
    ariaRole: [{
      type: Input,
      args: ["popperAriaRole"]
    }],
    boundariesElement: [{
      type: Input,
      args: ["popperBoundaries"]
    }],
    disableAnimation: [{
      type: Input,
      args: ["popperDisableAnimation"]
    }],
    disableStyle: [{
      type: Input,
      args: ["popperDisableStyle"]
    }],
    hideOnMouseLeave: [{
      type: Input,
      args: ["popperHideOnMouseLeave"]
    }],
    hideOnScroll: [{
      type: Input,
      args: ["popperHideOnScroll"]
    }],
    hideTimeout: [{
      type: Input,
      args: ["popperTimeout"]
    }],
    popperAppendTo: [{
      type: Input
    }],
    popperOnHidden: [{
      type: Output
    }],
    popperOnShown: [{
      type: Output
    }],
    popperOnUpdate: [{
      type: Output
    }],
    positionFixed: [{
      type: Input,
      args: ["popperPositionFixed"]
    }],
    showDelay: [{
      type: Input,
      args: ["popperDelay"]
    }],
    showOnStart: [{
      type: Input,
      args: ["popperShowOnStart"]
    }],
    showTrigger: [{
      type: Input,
      args: ["popperTrigger"]
    }],
    styles: [{
      type: Input,
      args: ["popperStyles"]
    }],
    targetElement: [{
      type: Input,
      args: ["popperTarget"]
    }],
    timeoutAfterShow: [{
      type: Input,
      args: ["popperTimeoutAfterShow"]
    }]
  });
})();
var NgxPopperjsLooseDirective = class _NgxPopperjsLooseDirective extends NgxPopperjsDirective {
  set popperLoose(newValue) {
    this.content = newValue;
  }
  set popperLoosePlacement(newValue) {
    this.placement = newValue;
  }
  set popperLooseTrigger(newValue) {
    this.showTrigger = newValue;
  }
  constructor(changeDetectorRef, elementRef, vcr, popperDefaults = {}) {
    super(changeDetectorRef, elementRef, vcr, popperDefaults);
  }
  /** @nocollapse */
  static \u0275fac = function NgxPopperjsLooseDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgxPopperjsLooseDirective)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NGX_POPPERJS_DEFAULTS));
  };
  /** @nocollapse */
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgxPopperjsLooseDirective,
    selectors: [["", "popperLoose", ""]],
    inputs: {
      popperLoose: "popperLoose",
      popperLoosePlacement: "popperLoosePlacement",
      popperLooseTrigger: "popperLooseTrigger"
    },
    exportAs: ["popperLoose"],
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxPopperjsLooseDirective, [{
    type: Directive,
    args: [{
      selector: "[popperLoose]",
      exportAs: "popperLoose",
      standalone: true
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NGX_POPPERJS_DEFAULTS]
    }]
  }], {
    popperLoose: [{
      type: Input
    }],
    popperLoosePlacement: [{
      type: Input
    }],
    popperLooseTrigger: [{
      type: Input
    }]
  });
})();
var NgxPopperjsPlacements;
(function(NgxPopperjsPlacements2) {
  NgxPopperjsPlacements2["TOP"] = "top";
  NgxPopperjsPlacements2["BOTTOM"] = "bottom";
  NgxPopperjsPlacements2["LEFT"] = "left";
  NgxPopperjsPlacements2["RIGHT"] = "right";
  NgxPopperjsPlacements2["TOPSTART"] = "top-start";
  NgxPopperjsPlacements2["BOTTOMSTART"] = "bottom-start";
  NgxPopperjsPlacements2["LEFTSTART"] = "left-start";
  NgxPopperjsPlacements2["RIGHTSTART"] = "right-start";
  NgxPopperjsPlacements2["TOPEND"] = "top-end";
  NgxPopperjsPlacements2["BOTTOMEND"] = "bottom-end";
  NgxPopperjsPlacements2["LEFTEND"] = "left-end";
  NgxPopperjsPlacements2["RIGHTEND"] = "right-end";
})(NgxPopperjsPlacements || (NgxPopperjsPlacements = {}));
function provideNgxPopperjsOptions(config3 = {}) {
  return [{
    provide: NGX_POPPERJS_DEFAULTS,
    useValue: config3
  }];
}
var NgxPopperjsModule = class _NgxPopperjsModule {
  static forRoot(popperBaseOptions) {
    return {
      ngModule: _NgxPopperjsModule,
      providers: [provideNgxPopperjsOptions(popperBaseOptions)]
    };
  }
  /** @nocollapse */
  static \u0275fac = function NgxPopperjsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgxPopperjsModule)();
  };
  /** @nocollapse */
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _NgxPopperjsModule
  });
  /** @nocollapse */
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [provideNgxPopperjsOptions()],
    imports: [CommonModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxPopperjsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NgxPopperjsContentComponent, NgxPopperjsDirective, NgxPopperjsLooseDirective],
      exports: [NgxPopperjsContentComponent, NgxPopperjsDirective, NgxPopperjsLooseDirective],
      providers: [provideNgxPopperjsOptions()]
    }]
  }], null, null);
})();

// src/app/service/shared-img.service.ts
var _SharedImgService = class _SharedImgService {
  addLoginImgPath(path3) {
    this.subjectLoginImgStream.next(path3);
  }
  constructor() {
    this.subjectLoginImgStream = new BehaviorSubject("/assets/images/user-white.png");
    this.currentImgPath = this.subjectLoginImgStream.asObservable();
  }
};
_SharedImgService.\u0275fac = function SharedImgService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _SharedImgService)();
};
_SharedImgService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _SharedImgService, factory: _SharedImgService.\u0275fac, providedIn: "root" });
var SharedImgService = _SharedImgService;

// src/app/service/themes.service.ts
var _ThemeService = class _ThemeService {
  get current() {
    return localStorage.getItem("theme") ?? "dark";
  }
  set current(value2) {
    localStorage.setItem("theme", value2);
    this.style.href = `/assets/themes/${value2}.scss`;
  }
  constructor() {
    this.style = document.createElement("link");
    this.style.rel = "stylesheet";
    document.head.appendChild(this.style);
    if (localStorage.getItem("theme") !== void 0) {
      this.style.href = "dark.scss";
    }
  }
};
_ThemeService.\u0275fac = function ThemeService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ThemeService)();
};
_ThemeService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ThemeService, factory: _ThemeService.\u0275fac, providedIn: "root" });
var ThemeService = _ThemeService;

// node_modules/@angular/router/fesm2022/router.mjs
var PRIMARY_OUTLET = "primary";
var RouteTitleKey = /* @__PURE__ */ Symbol("RouteTitle");
var ParamsAsMap = class {
  params;
  constructor(params) {
    this.params = params || {};
  }
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.params, name);
  }
  get(name) {
    if (this.has(name)) {
      const v = this.params[name];
      return Array.isArray(v) ? v[0] : v;
    }
    return null;
  }
  getAll(name) {
    if (this.has(name)) {
      const v = this.params[name];
      return Array.isArray(v) ? v : [v];
    }
    return [];
  }
  get keys() {
    return Object.keys(this.params);
  }
};
function convertToParamMap(params) {
  return new ParamsAsMap(params);
}
function defaultUrlMatcher(segments, segmentGroup, route) {
  const parts = route.path.split("/");
  if (parts.length > segments.length) {
    return null;
  }
  if (route.pathMatch === "full" && (segmentGroup.hasChildren() || parts.length < segments.length)) {
    return null;
  }
  const posParams = {};
  for (let index = 0; index < parts.length; index++) {
    const part = parts[index];
    const segment = segments[index];
    const isParameter = part[0] === ":";
    if (isParameter) {
      posParams[part.substring(1)] = segment;
    } else if (part !== segment.path) {
      return null;
    }
  }
  return {
    consumed: segments.slice(0, parts.length),
    posParams
  };
}
function shallowEqualArrays(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; ++i) {
    if (!shallowEqual(a[i], b[i])) return false;
  }
  return true;
}
function shallowEqual(a, b) {
  const k1 = a ? getDataKeys(a) : void 0;
  const k2 = b ? getDataKeys(b) : void 0;
  if (!k1 || !k2 || k1.length != k2.length) {
    return false;
  }
  let key;
  for (let i = 0; i < k1.length; i++) {
    key = k1[i];
    if (!equalArraysOrString(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
function getDataKeys(obj) {
  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];
}
function equalArraysOrString(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    const aSorted = [...a].sort();
    const bSorted = [...b].sort();
    return aSorted.every((val, index) => bSorted[index] === val);
  } else {
    return a === b;
  }
}
function last3(a) {
  return a.length > 0 ? a[a.length - 1] : null;
}
function wrapIntoObservable(value2) {
  if (isObservable(value2)) {
    return value2;
  }
  if (isPromise2(value2)) {
    return from(Promise.resolve(value2));
  }
  return of(value2);
}
var pathCompareMap = {
  "exact": equalSegmentGroups,
  "subset": containsSegmentGroup
};
var paramCompareMap = {
  "exact": equalParams,
  "subset": containsParams,
  "ignored": () => true
};
function containsTree(container, containee, options) {
  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === "exact" && container.fragment !== containee.fragment);
}
function equalParams(container, containee) {
  return shallowEqual(container, containee);
}
function equalSegmentGroups(container, containee, matrixParams) {
  if (!equalPath(container.segments, containee.segments)) return false;
  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {
    return false;
  }
  if (container.numberOfChildren !== containee.numberOfChildren) return false;
  for (const c in containee.children) {
    if (!container.children[c]) return false;
    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) return false;
  }
  return true;
}
function containsParams(container, containee) {
  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]));
}
function containsSegmentGroup(container, containee, matrixParams) {
  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);
}
function containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {
  if (container.segments.length > containeePaths.length) {
    const current = container.segments.slice(0, containeePaths.length);
    if (!equalPath(current, containeePaths)) return false;
    if (containee.hasChildren()) return false;
    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;
    return true;
  } else if (container.segments.length === containeePaths.length) {
    if (!equalPath(container.segments, containeePaths)) return false;
    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;
    for (const c in containee.children) {
      if (!container.children[c]) return false;
      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {
        return false;
      }
    }
    return true;
  } else {
    const current = containeePaths.slice(0, container.segments.length);
    const next = containeePaths.slice(container.segments.length);
    if (!equalPath(container.segments, current)) return false;
    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;
    if (!container.children[PRIMARY_OUTLET]) return false;
    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);
  }
}
function matrixParamsMatch(containerPaths, containeePaths, options) {
  return containeePaths.every((containeeSegment, i) => {
    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);
  });
}
var UrlTree = class {
  root;
  queryParams;
  fragment;
  /** @internal */
  _queryParamMap;
  constructor(root3 = new UrlSegmentGroup([], {}), queryParams = {}, fragment = null) {
    this.root = root3;
    this.queryParams = queryParams;
    this.fragment = fragment;
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (root3.segments.length > 0) {
        throw new RuntimeError(4015, "The root `UrlSegmentGroup` should not contain `segments`. Instead, these segments belong in the `children` so they can be associated with a named outlet.");
      }
    }
  }
  get queryParamMap() {
    this._queryParamMap ??= convertToParamMap(this.queryParams);
    return this._queryParamMap;
  }
  /** @docsNotRequired */
  toString() {
    return DEFAULT_SERIALIZER.serialize(this);
  }
};
var UrlSegmentGroup = class {
  segments;
  children;
  /** The parent node in the url tree */
  parent = null;
  constructor(segments, children2) {
    this.segments = segments;
    this.children = children2;
    Object.values(children2).forEach((v) => v.parent = this);
  }
  /** Whether the segment has child segments */
  hasChildren() {
    return this.numberOfChildren > 0;
  }
  /** Number of child segments */
  get numberOfChildren() {
    return Object.keys(this.children).length;
  }
  /** @docsNotRequired */
  toString() {
    return serializePaths(this);
  }
};
var UrlSegment = class {
  path;
  parameters;
  /** @internal */
  _parameterMap;
  constructor(path3, parameters) {
    this.path = path3;
    this.parameters = parameters;
  }
  get parameterMap() {
    this._parameterMap ??= convertToParamMap(this.parameters);
    return this._parameterMap;
  }
  /** @docsNotRequired */
  toString() {
    return serializePath(this);
  }
};
function equalSegments(as, bs) {
  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));
}
function equalPath(as, bs) {
  if (as.length !== bs.length) return false;
  return as.every((a, i) => a.path === bs[i].path);
}
function mapChildrenIntoArray(segment, fn) {
  let res = [];
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet === PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet !== PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  return res;
}
var UrlSerializer = class _UrlSerializer {
  static \u0275fac = function UrlSerializer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UrlSerializer)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _UrlSerializer,
    factory: () => (() => new DefaultUrlSerializer())(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlSerializer, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => new DefaultUrlSerializer()
    }]
  }], null, null);
})();
var DefaultUrlSerializer = class {
  /** Parses a url into a `UrlTree` */
  parse(url) {
    const p2 = new UrlParser(url);
    return new UrlTree(p2.parseRootSegment(), p2.parseQueryParams(), p2.parseFragment());
  }
  /** Converts a `UrlTree` into a url */
  serialize(tree2) {
    const segment = `/${serializeSegment(tree2.root, true)}`;
    const query = serializeQueryParams(tree2.queryParams);
    const fragment = typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : "";
    return `${segment}${query}${fragment}`;
  }
};
var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
function serializePaths(segment) {
  return segment.segments.map((p2) => serializePath(p2)).join("/");
}
function serializeSegment(segment, root3) {
  if (!segment.hasChildren()) {
    return serializePaths(segment);
  }
  if (root3) {
    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : "";
    const children2 = [];
    Object.entries(segment.children).forEach(([k, v]) => {
      if (k !== PRIMARY_OUTLET) {
        children2.push(`${k}:${serializeSegment(v, false)}`);
      }
    });
    return children2.length > 0 ? `${primary}(${children2.join("//")})` : primary;
  } else {
    const children2 = mapChildrenIntoArray(segment, (v, k) => {
      if (k === PRIMARY_OUTLET) {
        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
      }
      return [`${k}:${serializeSegment(v, false)}`];
    });
    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
      return `${serializePaths(segment)}/${children2[0]}`;
    }
    return `${serializePaths(segment)}/(${children2.join("//")})`;
  }
}
function encodeUriString(s2) {
  return encodeURIComponent(s2).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",");
}
function encodeUriQuery(s2) {
  return encodeUriString(s2).replace(/%3B/gi, ";");
}
function encodeUriFragment(s2) {
  return encodeURI(s2);
}
function encodeUriSegment(s2) {
  return encodeUriString(s2).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&");
}
function decode(s2) {
  return decodeURIComponent(s2);
}
function decodeQuery(s2) {
  return decode(s2.replace(/\+/g, "%20"));
}
function serializePath(path3) {
  return `${encodeUriSegment(path3.path)}${serializeMatrixParams(path3.parameters)}`;
}
function serializeMatrixParams(params) {
  return Object.entries(params).map(([key, value2]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value2)}`).join("");
}
function serializeQueryParams(params) {
  const strParams = Object.entries(params).map(([name, value2]) => {
    return Array.isArray(value2) ? value2.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join("&") : `${encodeUriQuery(name)}=${encodeUriQuery(value2)}`;
  }).filter((s2) => s2);
  return strParams.length ? `?${strParams.join("&")}` : "";
}
var SEGMENT_RE = /^[^\/()?;#]+/;
function matchSegments(str) {
  const match2 = str.match(SEGMENT_RE);
  return match2 ? match2[0] : "";
}
var MATRIX_PARAM_SEGMENT_RE = /^[^\/()?;=#]+/;
function matchMatrixKeySegments(str) {
  const match2 = str.match(MATRIX_PARAM_SEGMENT_RE);
  return match2 ? match2[0] : "";
}
var QUERY_PARAM_RE = /^[^=?&#]+/;
function matchQueryParams(str) {
  const match2 = str.match(QUERY_PARAM_RE);
  return match2 ? match2[0] : "";
}
var QUERY_PARAM_VALUE_RE = /^[^&#]+/;
function matchUrlQueryParamValue(str) {
  const match2 = str.match(QUERY_PARAM_VALUE_RE);
  return match2 ? match2[0] : "";
}
var UrlParser = class {
  url;
  remaining;
  constructor(url) {
    this.url = url;
    this.remaining = url;
  }
  parseRootSegment() {
    this.consumeOptional("/");
    if (this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#")) {
      return new UrlSegmentGroup([], {});
    }
    return new UrlSegmentGroup([], this.parseChildren());
  }
  parseQueryParams() {
    const params = {};
    if (this.consumeOptional("?")) {
      do {
        this.parseQueryParam(params);
      } while (this.consumeOptional("&"));
    }
    return params;
  }
  parseFragment() {
    return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null;
  }
  parseChildren() {
    if (this.remaining === "") {
      return {};
    }
    this.consumeOptional("/");
    const segments = [];
    if (!this.peekStartsWith("(")) {
      segments.push(this.parseSegment());
    }
    while (this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(")) {
      this.capture("/");
      segments.push(this.parseSegment());
    }
    let children2 = {};
    if (this.peekStartsWith("/(")) {
      this.capture("/");
      children2 = this.parseParens(true);
    }
    let res = {};
    if (this.peekStartsWith("(")) {
      res = this.parseParens(false);
    }
    if (segments.length > 0 || Object.keys(children2).length > 0) {
      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children2);
    }
    return res;
  }
  // parse a segment with its matrix parameters
  // ie `name;k1=v1;k2`
  parseSegment() {
    const path3 = matchSegments(this.remaining);
    if (path3 === "" && this.peekStartsWith(";")) {
      throw new RuntimeError(4009, (typeof ngDevMode === "undefined" || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);
    }
    this.capture(path3);
    return new UrlSegment(decode(path3), this.parseMatrixParams());
  }
  parseMatrixParams() {
    const params = {};
    while (this.consumeOptional(";")) {
      this.parseParam(params);
    }
    return params;
  }
  parseParam(params) {
    const key = matchMatrixKeySegments(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value2 = "";
    if (this.consumeOptional("=")) {
      const valueMatch = matchSegments(this.remaining);
      if (valueMatch) {
        value2 = valueMatch;
        this.capture(value2);
      }
    }
    params[decode(key)] = decode(value2);
  }
  // Parse a single query parameter `name[=value]`
  parseQueryParam(params) {
    const key = matchQueryParams(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value2 = "";
    if (this.consumeOptional("=")) {
      const valueMatch = matchUrlQueryParamValue(this.remaining);
      if (valueMatch) {
        value2 = valueMatch;
        this.capture(value2);
      }
    }
    const decodedKey = decodeQuery(key);
    const decodedVal = decodeQuery(value2);
    if (params.hasOwnProperty(decodedKey)) {
      let currentVal = params[decodedKey];
      if (!Array.isArray(currentVal)) {
        currentVal = [currentVal];
        params[decodedKey] = currentVal;
      }
      currentVal.push(decodedVal);
    } else {
      params[decodedKey] = decodedVal;
    }
  }
  // parse `(a/b//outlet_name:c/d)`
  parseParens(allowPrimary) {
    const segments = {};
    this.capture("(");
    while (!this.consumeOptional(")") && this.remaining.length > 0) {
      const path3 = matchSegments(this.remaining);
      const next = this.remaining[path3.length];
      if (next !== "/" && next !== ")" && next !== ";") {
        throw new RuntimeError(4010, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot parse url '${this.url}'`);
      }
      let outletName = void 0;
      if (path3.indexOf(":") > -1) {
        outletName = path3.slice(0, path3.indexOf(":"));
        this.capture(outletName);
        this.capture(":");
      } else if (allowPrimary) {
        outletName = PRIMARY_OUTLET;
      }
      const children2 = this.parseChildren();
      segments[outletName] = Object.keys(children2).length === 1 ? children2[PRIMARY_OUTLET] : new UrlSegmentGroup([], children2);
      this.consumeOptional("//");
    }
    return segments;
  }
  peekStartsWith(str) {
    return this.remaining.startsWith(str);
  }
  // Consumes the prefix when it is present and returns whether it has been consumed
  consumeOptional(str) {
    if (this.peekStartsWith(str)) {
      this.remaining = this.remaining.substring(str.length);
      return true;
    }
    return false;
  }
  capture(str) {
    if (!this.consumeOptional(str)) {
      throw new RuntimeError(4011, (typeof ngDevMode === "undefined" || ngDevMode) && `Expected "${str}".`);
    }
  }
};
function createRoot(rootCandidate) {
  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {
    [PRIMARY_OUTLET]: rootCandidate
  }) : rootCandidate;
}
function squashSegmentGroup(segmentGroup) {
  const newChildren = {};
  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {
    const childCandidate = squashSegmentGroup(child);
    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {
      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {
        newChildren[grandChildOutlet] = grandChild;
      }
    } else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
      newChildren[childOutlet] = childCandidate;
    }
  }
  const s2 = new UrlSegmentGroup(segmentGroup.segments, newChildren);
  return mergeTrivialChildren(s2);
}
function mergeTrivialChildren(s2) {
  if (s2.numberOfChildren === 1 && s2.children[PRIMARY_OUTLET]) {
    const c = s2.children[PRIMARY_OUTLET];
    return new UrlSegmentGroup(s2.segments.concat(c.segments), c.children);
  }
  return s2;
}
function isUrlTree(v) {
  return v instanceof UrlTree;
}
function createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {
  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);
  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);
}
function createSegmentGroupFromRoute(route) {
  let targetGroup;
  function createSegmentGroupFromRouteRecursive(currentRoute) {
    const childOutlets = {};
    for (const childSnapshot of currentRoute.children) {
      const root3 = createSegmentGroupFromRouteRecursive(childSnapshot);
      childOutlets[childSnapshot.outlet] = root3;
    }
    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);
    if (currentRoute === route) {
      targetGroup = segmentGroup;
    }
    return segmentGroup;
  }
  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);
  const rootSegmentGroup = createRoot(rootCandidate);
  return targetGroup ?? rootSegmentGroup;
}
function createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {
  let root3 = relativeTo;
  while (root3.parent) {
    root3 = root3.parent;
  }
  if (commands.length === 0) {
    return tree(root3, root3, root3, queryParams, fragment);
  }
  const nav = computeNavigation(commands);
  if (nav.toRoot()) {
    return tree(root3, root3, new UrlSegmentGroup([], {}), queryParams, fragment);
  }
  const position = findStartingPositionForTargetGroup(nav, root3, relativeTo);
  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);
  return tree(root3, position.segmentGroup, newSegmentGroup, queryParams, fragment);
}
function isMatrixParams(command) {
  return typeof command === "object" && command != null && !command.outlets && !command.segmentPath;
}
function isCommandWithOutlets(command) {
  return typeof command === "object" && command != null && command.outlets;
}
function tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {
  let qp = {};
  if (queryParams) {
    Object.entries(queryParams).forEach(([name, value2]) => {
      qp[name] = Array.isArray(value2) ? value2.map((v) => `${v}`) : `${value2}`;
    });
  }
  let rootCandidate;
  if (oldRoot === oldSegmentGroup) {
    rootCandidate = newSegmentGroup;
  } else {
    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);
  }
  const newRoot = createRoot(squashSegmentGroup(rootCandidate));
  return new UrlTree(newRoot, qp, fragment);
}
function replaceSegment(current, oldSegment, newSegment) {
  const children2 = {};
  Object.entries(current.children).forEach(([outletName, c]) => {
    if (c === oldSegment) {
      children2[outletName] = newSegment;
    } else {
      children2[outletName] = replaceSegment(c, oldSegment, newSegment);
    }
  });
  return new UrlSegmentGroup(current.segments, children2);
}
var Navigation = class {
  isAbsolute;
  numberOfDoubleDots;
  commands;
  constructor(isAbsolute, numberOfDoubleDots, commands) {
    this.isAbsolute = isAbsolute;
    this.numberOfDoubleDots = numberOfDoubleDots;
    this.commands = commands;
    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
      throw new RuntimeError(4003, (typeof ngDevMode === "undefined" || ngDevMode) && "Root segment cannot have matrix parameters");
    }
    const cmdWithOutlet = commands.find(isCommandWithOutlets);
    if (cmdWithOutlet && cmdWithOutlet !== last3(commands)) {
      throw new RuntimeError(4004, (typeof ngDevMode === "undefined" || ngDevMode) && "{outlets:{}} has to be the last command");
    }
  }
  toRoot() {
    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/";
  }
};
function computeNavigation(commands) {
  if (typeof commands[0] === "string" && commands.length === 1 && commands[0] === "/") {
    return new Navigation(true, 0, commands);
  }
  let numberOfDoubleDots = 0;
  let isAbsolute = false;
  const res = commands.reduce((res2, cmd, cmdIdx) => {
    if (typeof cmd === "object" && cmd != null) {
      if (cmd.outlets) {
        const outlets = {};
        Object.entries(cmd.outlets).forEach(([name, commands2]) => {
          outlets[name] = typeof commands2 === "string" ? commands2.split("/") : commands2;
        });
        return [...res2, {
          outlets
        }];
      }
      if (cmd.segmentPath) {
        return [...res2, cmd.segmentPath];
      }
    }
    if (!(typeof cmd === "string")) {
      return [...res2, cmd];
    }
    if (cmdIdx === 0) {
      cmd.split("/").forEach((urlPart, partIndex) => {
        if (partIndex == 0 && urlPart === ".") {
        } else if (partIndex == 0 && urlPart === "") {
          isAbsolute = true;
        } else if (urlPart === "..") {
          numberOfDoubleDots++;
        } else if (urlPart != "") {
          res2.push(urlPart);
        }
      });
      return res2;
    }
    return [...res2, cmd];
  }, []);
  return new Navigation(isAbsolute, numberOfDoubleDots, res);
}
var Position = class {
  segmentGroup;
  processChildren;
  index;
  constructor(segmentGroup, processChildren, index) {
    this.segmentGroup = segmentGroup;
    this.processChildren = processChildren;
    this.index = index;
  }
};
function findStartingPositionForTargetGroup(nav, root3, target) {
  if (nav.isAbsolute) {
    return new Position(root3, true, 0);
  }
  if (!target) {
    return new Position(root3, false, NaN);
  }
  if (target.parent === null) {
    return new Position(target, true, 0);
  }
  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
  const index = target.segments.length - 1 + modifier;
  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);
}
function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
  let g2 = group;
  let ci = index;
  let dd = numberOfDoubleDots;
  while (dd > ci) {
    dd -= ci;
    g2 = g2.parent;
    if (!g2) {
      throw new RuntimeError(4005, (typeof ngDevMode === "undefined" || ngDevMode) && "Invalid number of '../'");
    }
    ci = g2.segments.length;
  }
  return new Position(g2, false, ci - dd);
}
function getOutlets(commands) {
  if (isCommandWithOutlets(commands[0])) {
    return commands[0].outlets;
  }
  return {
    [PRIMARY_OUTLET]: commands
  };
}
function updateSegmentGroup(segmentGroup, startIndex, commands) {
  segmentGroup ??= new UrlSegmentGroup([], {});
  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
  }
  const m = prefixedWith(segmentGroup, startIndex, commands);
  const slicedCommands = commands.slice(m.commandIndex);
  if (m.match && m.pathIndex < segmentGroup.segments.length) {
    const g2 = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
    g2.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
    return updateSegmentGroupChildren(g2, 0, slicedCommands);
  } else if (m.match && slicedCommands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else if (m.match && !segmentGroup.hasChildren()) {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  } else if (m.match) {
    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
  } else {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  }
}
function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
  if (commands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else {
    const outlets = getOutlets(commands);
    const children2 = {};
    if (Object.keys(outlets).some((o2) => o2 !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {
      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);
      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);
    }
    Object.entries(outlets).forEach(([outlet, commands2]) => {
      if (typeof commands2 === "string") {
        commands2 = [commands2];
      }
      if (commands2 !== null) {
        children2[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);
      }
    });
    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {
      if (outlets[childOutlet] === void 0) {
        children2[childOutlet] = child;
      }
    });
    return new UrlSegmentGroup(segmentGroup.segments, children2);
  }
}
function prefixedWith(segmentGroup, startIndex, commands) {
  let currentCommandIndex = 0;
  let currentPathIndex = startIndex;
  const noMatch2 = {
    match: false,
    pathIndex: 0,
    commandIndex: 0
  };
  while (currentPathIndex < segmentGroup.segments.length) {
    if (currentCommandIndex >= commands.length) return noMatch2;
    const path3 = segmentGroup.segments[currentPathIndex];
    const command = commands[currentCommandIndex];
    if (isCommandWithOutlets(command)) {
      break;
    }
    const curr = `${command}`;
    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
    if (currentPathIndex > 0 && curr === void 0) break;
    if (curr && next && typeof next === "object" && next.outlets === void 0) {
      if (!compare(curr, next, path3)) return noMatch2;
      currentCommandIndex += 2;
    } else {
      if (!compare(curr, {}, path3)) return noMatch2;
      currentCommandIndex++;
    }
    currentPathIndex++;
  }
  return {
    match: true,
    pathIndex: currentPathIndex,
    commandIndex: currentCommandIndex
  };
}
function createNewSegmentGroup(segmentGroup, startIndex, commands) {
  const paths = segmentGroup.segments.slice(0, startIndex);
  let i = 0;
  while (i < commands.length) {
    const command = commands[i];
    if (isCommandWithOutlets(command)) {
      const children2 = createNewSegmentChildren(command.outlets);
      return new UrlSegmentGroup(paths, children2);
    }
    if (i === 0 && isMatrixParams(commands[0])) {
      const p2 = segmentGroup.segments[startIndex];
      paths.push(new UrlSegment(p2.path, stringify2(commands[0])));
      i++;
      continue;
    }
    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;
    const next = i < commands.length - 1 ? commands[i + 1] : null;
    if (curr && next && isMatrixParams(next)) {
      paths.push(new UrlSegment(curr, stringify2(next)));
      i += 2;
    } else {
      paths.push(new UrlSegment(curr, {}));
      i++;
    }
  }
  return new UrlSegmentGroup(paths, {});
}
function createNewSegmentChildren(outlets) {
  const children2 = {};
  Object.entries(outlets).forEach(([outlet, commands]) => {
    if (typeof commands === "string") {
      commands = [commands];
    }
    if (commands !== null) {
      children2[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
    }
  });
  return children2;
}
function stringify2(params) {
  const res = {};
  Object.entries(params).forEach(([k, v]) => res[k] = `${v}`);
  return res;
}
function compare(path3, params, segment) {
  return path3 == segment.path && shallowEqual(params, segment.parameters);
}
var IMPERATIVE_NAVIGATION = "imperative";
var EventType;
(function(EventType2) {
  EventType2[EventType2["NavigationStart"] = 0] = "NavigationStart";
  EventType2[EventType2["NavigationEnd"] = 1] = "NavigationEnd";
  EventType2[EventType2["NavigationCancel"] = 2] = "NavigationCancel";
  EventType2[EventType2["NavigationError"] = 3] = "NavigationError";
  EventType2[EventType2["RoutesRecognized"] = 4] = "RoutesRecognized";
  EventType2[EventType2["ResolveStart"] = 5] = "ResolveStart";
  EventType2[EventType2["ResolveEnd"] = 6] = "ResolveEnd";
  EventType2[EventType2["GuardsCheckStart"] = 7] = "GuardsCheckStart";
  EventType2[EventType2["GuardsCheckEnd"] = 8] = "GuardsCheckEnd";
  EventType2[EventType2["RouteConfigLoadStart"] = 9] = "RouteConfigLoadStart";
  EventType2[EventType2["RouteConfigLoadEnd"] = 10] = "RouteConfigLoadEnd";
  EventType2[EventType2["ChildActivationStart"] = 11] = "ChildActivationStart";
  EventType2[EventType2["ChildActivationEnd"] = 12] = "ChildActivationEnd";
  EventType2[EventType2["ActivationStart"] = 13] = "ActivationStart";
  EventType2[EventType2["ActivationEnd"] = 14] = "ActivationEnd";
  EventType2[EventType2["Scroll"] = 15] = "Scroll";
  EventType2[EventType2["NavigationSkipped"] = 16] = "NavigationSkipped";
})(EventType || (EventType = {}));
var RouterEvent = class {
  id;
  url;
  constructor(id3, url) {
    this.id = id3;
    this.url = url;
  }
};
var NavigationStart = class extends RouterEvent {
  type = EventType.NavigationStart;
  /**
   * Identifies the call or event that triggered the navigation.
   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.
   *
   * @see {@link NavigationEnd}
   * @see {@link NavigationCancel}
   * @see {@link NavigationError}
   */
  navigationTrigger;
  /**
   * The navigation state that was previously supplied to the `pushState` call,
   * when the navigation is triggered by a `popstate` event. Otherwise null.
   *
   * The state object is defined by `NavigationExtras`, and contains any
   * developer-defined state value, as well as a unique ID that
   * the router assigns to every router transition/navigation.
   *
   * From the perspective of the router, the router never "goes back".
   * When the user clicks on the back button in the browser,
   * a new navigation ID is created.
   *
   * Use the ID in this previous-state object to differentiate between a newly created
   * state and one returned to by a `popstate` event, so that you can restore some
   * remembered state, such as scroll position.
   *
   */
  restoredState;
  constructor(id3, url, navigationTrigger = "imperative", restoredState = null) {
    super(id3, url);
    this.navigationTrigger = navigationTrigger;
    this.restoredState = restoredState;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
  }
};
var NavigationEnd = class extends RouterEvent {
  urlAfterRedirects;
  type = EventType.NavigationEnd;
  constructor(id3, url, urlAfterRedirects) {
    super(id3, url);
    this.urlAfterRedirects = urlAfterRedirects;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
  }
};
var NavigationCancellationCode;
(function(NavigationCancellationCode2) {
  NavigationCancellationCode2[NavigationCancellationCode2["Redirect"] = 0] = "Redirect";
  NavigationCancellationCode2[NavigationCancellationCode2["SupersededByNewNavigation"] = 1] = "SupersededByNewNavigation";
  NavigationCancellationCode2[NavigationCancellationCode2["NoDataFromResolver"] = 2] = "NoDataFromResolver";
  NavigationCancellationCode2[NavigationCancellationCode2["GuardRejected"] = 3] = "GuardRejected";
})(NavigationCancellationCode || (NavigationCancellationCode = {}));
var NavigationSkippedCode;
(function(NavigationSkippedCode2) {
  NavigationSkippedCode2[NavigationSkippedCode2["IgnoredSameUrlNavigation"] = 0] = "IgnoredSameUrlNavigation";
  NavigationSkippedCode2[NavigationSkippedCode2["IgnoredByUrlHandlingStrategy"] = 1] = "IgnoredByUrlHandlingStrategy";
})(NavigationSkippedCode || (NavigationSkippedCode = {}));
var NavigationCancel = class extends RouterEvent {
  reason;
  code;
  type = EventType.NavigationCancel;
  constructor(id3, url, reason, code) {
    super(id3, url);
    this.reason = reason;
    this.code = code;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
  }
};
var NavigationSkipped = class extends RouterEvent {
  reason;
  code;
  type = EventType.NavigationSkipped;
  constructor(id3, url, reason, code) {
    super(id3, url);
    this.reason = reason;
    this.code = code;
  }
};
var NavigationError = class extends RouterEvent {
  error;
  target;
  type = EventType.NavigationError;
  constructor(id3, url, error, target) {
    super(id3, url);
    this.error = error;
    this.target = target;
  }
  /** @docsNotRequired */
  toString() {
    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
  }
};
var RoutesRecognized = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.RoutesRecognized;
  constructor(id3, url, urlAfterRedirects, state2) {
    super(id3, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  /** @docsNotRequired */
  toString() {
    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var GuardsCheckStart = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.GuardsCheckStart;
  constructor(id3, url, urlAfterRedirects, state2) {
    super(id3, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  toString() {
    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var GuardsCheckEnd = class extends RouterEvent {
  urlAfterRedirects;
  state;
  shouldActivate;
  type = EventType.GuardsCheckEnd;
  constructor(id3, url, urlAfterRedirects, state2, shouldActivate) {
    super(id3, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
    this.shouldActivate = shouldActivate;
  }
  toString() {
    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
  }
};
var ResolveStart = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.ResolveStart;
  constructor(id3, url, urlAfterRedirects, state2) {
    super(id3, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  toString() {
    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var ResolveEnd = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.ResolveEnd;
  constructor(id3, url, urlAfterRedirects, state2) {
    super(id3, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  toString() {
    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var RouteConfigLoadStart = class {
  route;
  type = EventType.RouteConfigLoadStart;
  constructor(route) {
    this.route = route;
  }
  toString() {
    return `RouteConfigLoadStart(path: ${this.route.path})`;
  }
};
var RouteConfigLoadEnd = class {
  route;
  type = EventType.RouteConfigLoadEnd;
  constructor(route) {
    this.route = route;
  }
  toString() {
    return `RouteConfigLoadEnd(path: ${this.route.path})`;
  }
};
var ChildActivationStart = class {
  snapshot;
  type = EventType.ChildActivationStart;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path3 = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ChildActivationStart(path: '${path3}')`;
  }
};
var ChildActivationEnd = class {
  snapshot;
  type = EventType.ChildActivationEnd;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path3 = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ChildActivationEnd(path: '${path3}')`;
  }
};
var ActivationStart = class {
  snapshot;
  type = EventType.ActivationStart;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path3 = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ActivationStart(path: '${path3}')`;
  }
};
var ActivationEnd = class {
  snapshot;
  type = EventType.ActivationEnd;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path3 = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ActivationEnd(path: '${path3}')`;
  }
};
var Scroll = class {
  routerEvent;
  position;
  anchor;
  type = EventType.Scroll;
  constructor(routerEvent, position, anchor) {
    this.routerEvent = routerEvent;
    this.position = position;
    this.anchor = anchor;
  }
  toString() {
    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
  }
};
var BeforeActivateRoutes = class {
};
var RedirectRequest = class {
  url;
  navigationBehaviorOptions;
  constructor(url, navigationBehaviorOptions) {
    this.url = url;
    this.navigationBehaviorOptions = navigationBehaviorOptions;
  }
};
function stringifyEvent(routerEvent) {
  switch (routerEvent.type) {
    case EventType.ActivationEnd:
      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ActivationStart:
      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationEnd:
      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationStart:
      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.GuardsCheckEnd:
      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;
    case EventType.GuardsCheckStart:
      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.NavigationCancel:
      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationSkipped:
      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationEnd:
      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;
    case EventType.NavigationError:
      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;
    case EventType.NavigationStart:
      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.ResolveEnd:
      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.ResolveStart:
      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.RouteConfigLoadEnd:
      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;
    case EventType.RouteConfigLoadStart:
      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;
    case EventType.RoutesRecognized:
      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.Scroll:
      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;
      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;
  }
}
function getOrCreateRouteInjectorIfNeeded(route, currentInjector) {
  if (route.providers && !route._injector) {
    route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);
  }
  return route._injector ?? currentInjector;
}
function validateConfig(config3, parentPath = "", requireStandaloneComponents = false) {
  for (let i = 0; i < config3.length; i++) {
    const route = config3[i];
    const fullPath = getFullPath(parentPath, route);
    validateNode(route, fullPath, requireStandaloneComponents);
  }
}
function assertStandalone(fullPath, component) {
  if (component && isNgModule(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, but it must be used with standalone components. Use 'loadChildren' instead.`);
  } else if (component && !isStandalone(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);
  }
}
function validateNode(route, fullPath, requireStandaloneComponents) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!route) {
      throw new RuntimeError(4014, `
      Invalid configuration of route '${fullPath}': Encountered undefined route.
      The reason might be an extra comma.

      Example:
      const routes: Routes = [
        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
        { path: 'dashboard',  component: DashboardComponent },, << two commas
        { path: 'detail/:id', component: HeroDetailComponent }
      ];
    `);
    }
    if (Array.isArray(route)) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);
    }
    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
    }
    if (route.redirectTo && route.children) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);
    }
    if (route.redirectTo && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);
    }
    if (route.children && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);
    }
    if (route.redirectTo && (route.component || route.loadComponent)) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);
    }
    if (route.component && route.loadComponent) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);
    }
    if (route.redirectTo && route.canActivate) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation so canActivate will never be executed.`);
    }
    if (route.path && route.matcher) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);
    }
    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);
    }
    if (route.path === void 0 && route.matcher === void 0) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);
    }
    if (typeof route.path === "string" && route.path.charAt(0) === "/") {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);
    }
    if (route.path === "" && route.redirectTo !== void 0 && route.pathMatch === void 0) {
      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
      throw new RuntimeError(4014, `Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
    }
    if (requireStandaloneComponents) {
      assertStandalone(fullPath, route.component);
    }
  }
  if (route.children) {
    validateConfig(route.children, fullPath, requireStandaloneComponents);
  }
}
function getFullPath(parentPath, currentRoute) {
  if (!currentRoute) {
    return parentPath;
  }
  if (!parentPath && !currentRoute.path) {
    return "";
  } else if (parentPath && !currentRoute.path) {
    return `${parentPath}/`;
  } else if (!parentPath && currentRoute.path) {
    return currentRoute.path;
  } else {
    return `${parentPath}/${currentRoute.path}`;
  }
}
function getOutlet(route) {
  return route.outlet || PRIMARY_OUTLET;
}
function sortByMatchingOutlets(routes2, outletName) {
  const sortedConfig = routes2.filter((r2) => getOutlet(r2) === outletName);
  sortedConfig.push(...routes2.filter((r2) => getOutlet(r2) !== outletName));
  return sortedConfig;
}
function getClosestRouteInjector(snapshot) {
  if (!snapshot) return null;
  if (snapshot.routeConfig?._injector) {
    return snapshot.routeConfig._injector;
  }
  for (let s2 = snapshot.parent; s2; s2 = s2.parent) {
    const route = s2.routeConfig;
    if (route?._loadedInjector) return route._loadedInjector;
    if (route?._injector) return route._injector;
  }
  return null;
}
var OutletContext = class {
  rootInjector;
  outlet = null;
  route = null;
  children;
  attachRef = null;
  get injector() {
    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;
  }
  constructor(rootInjector) {
    this.rootInjector = rootInjector;
    this.children = new ChildrenOutletContexts(this.rootInjector);
  }
};
var ChildrenOutletContexts = class _ChildrenOutletContexts {
  rootInjector;
  // contexts for child outlets, by name.
  contexts = /* @__PURE__ */ new Map();
  /** @nodoc */
  constructor(rootInjector) {
    this.rootInjector = rootInjector;
  }
  /** Called when a `RouterOutlet` directive is instantiated */
  onChildOutletCreated(childName, outlet) {
    const context2 = this.getOrCreateContext(childName);
    context2.outlet = outlet;
    this.contexts.set(childName, context2);
  }
  /**
   * Called when a `RouterOutlet` directive is destroyed.
   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
   * re-created later.
   */
  onChildOutletDestroyed(childName) {
    const context2 = this.getContext(childName);
    if (context2) {
      context2.outlet = null;
      context2.attachRef = null;
    }
  }
  /**
   * Called when the corresponding route is deactivated during navigation.
   * Because the component get destroyed, all children outlet are destroyed.
   */
  onOutletDeactivated() {
    const contexts = this.contexts;
    this.contexts = /* @__PURE__ */ new Map();
    return contexts;
  }
  onOutletReAttached(contexts) {
    this.contexts = contexts;
  }
  getOrCreateContext(childName) {
    let context2 = this.getContext(childName);
    if (!context2) {
      context2 = new OutletContext(this.rootInjector);
      this.contexts.set(childName, context2);
    }
    return context2;
  }
  getContext(childName) {
    return this.contexts.get(childName) || null;
  }
  static \u0275fac = function ChildrenOutletContexts_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChildrenOutletContexts)(\u0275\u0275inject(EnvironmentInjector));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ChildrenOutletContexts,
    factory: _ChildrenOutletContexts.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChildrenOutletContexts, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var Tree = class {
  /** @internal */
  _root;
  constructor(root3) {
    this._root = root3;
  }
  get root() {
    return this._root.value;
  }
  /**
   * @internal
   */
  parent(t2) {
    const p2 = this.pathFromRoot(t2);
    return p2.length > 1 ? p2[p2.length - 2] : null;
  }
  /**
   * @internal
   */
  children(t2) {
    const n = findNode(t2, this._root);
    return n ? n.children.map((t3) => t3.value) : [];
  }
  /**
   * @internal
   */
  firstChild(t2) {
    const n = findNode(t2, this._root);
    return n && n.children.length > 0 ? n.children[0].value : null;
  }
  /**
   * @internal
   */
  siblings(t2) {
    const p2 = findPath(t2, this._root);
    if (p2.length < 2) return [];
    const c = p2[p2.length - 2].children.map((c2) => c2.value);
    return c.filter((cc) => cc !== t2);
  }
  /**
   * @internal
   */
  pathFromRoot(t2) {
    return findPath(t2, this._root).map((s2) => s2.value);
  }
};
function findNode(value2, node) {
  if (value2 === node.value) return node;
  for (const child of node.children) {
    const node2 = findNode(value2, child);
    if (node2) return node2;
  }
  return null;
}
function findPath(value2, node) {
  if (value2 === node.value) return [node];
  for (const child of node.children) {
    const path3 = findPath(value2, child);
    if (path3.length) {
      path3.unshift(node);
      return path3;
    }
  }
  return [];
}
var TreeNode = class {
  value;
  children;
  constructor(value2, children2) {
    this.value = value2;
    this.children = children2;
  }
  toString() {
    return `TreeNode(${this.value})`;
  }
};
function nodeChildrenAsMap(node) {
  const map3 = {};
  if (node) {
    node.children.forEach((child) => map3[child.value.outlet] = child);
  }
  return map3;
}
var RouterState = class extends Tree {
  snapshot;
  /** @internal */
  constructor(root3, snapshot) {
    super(root3);
    this.snapshot = snapshot;
    setRouterState(this, root3);
  }
  toString() {
    return this.snapshot.toString();
  }
};
function createEmptyState(rootComponent) {
  const snapshot = createEmptyStateSnapshot(rootComponent);
  const emptyUrl = new BehaviorSubject([new UrlSegment("", {})]);
  const emptyParams = new BehaviorSubject({});
  const emptyData = new BehaviorSubject({});
  const emptyQueryParams = new BehaviorSubject({});
  const fragment = new BehaviorSubject("");
  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
  activated.snapshot = snapshot.root;
  return new RouterState(new TreeNode(activated, []), snapshot);
}
function createEmptyStateSnapshot(rootComponent) {
  const emptyParams = {};
  const emptyData = {};
  const emptyQueryParams = {};
  const fragment = "";
  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});
  return new RouterStateSnapshot("", new TreeNode(activated, []));
}
var ActivatedRoute = class {
  urlSubject;
  paramsSubject;
  queryParamsSubject;
  fragmentSubject;
  dataSubject;
  outlet;
  component;
  /** The current snapshot of this route */
  snapshot;
  /** @internal */
  _futureSnapshot;
  /** @internal */
  _routerState;
  /** @internal */
  _paramMap;
  /** @internal */
  _queryParamMap;
  /** An Observable of the resolved route title */
  title;
  /** An observable of the URL segments matched by this route. */
  url;
  /** An observable of the matrix parameters scoped to this route. */
  params;
  /** An observable of the query parameters shared by all the routes. */
  queryParams;
  /** An observable of the URL fragment shared by all the routes. */
  fragment;
  /** An observable of the static and resolved data of this route. */
  data;
  /** @internal */
  constructor(urlSubject, paramsSubject, queryParamsSubject, fragmentSubject, dataSubject, outlet, component, futureSnapshot) {
    this.urlSubject = urlSubject;
    this.paramsSubject = paramsSubject;
    this.queryParamsSubject = queryParamsSubject;
    this.fragmentSubject = fragmentSubject;
    this.dataSubject = dataSubject;
    this.outlet = outlet;
    this.component = component;
    this._futureSnapshot = futureSnapshot;
    this.title = this.dataSubject?.pipe(map((d) => d[RouteTitleKey])) ?? of(void 0);
    this.url = urlSubject;
    this.params = paramsSubject;
    this.queryParams = queryParamsSubject;
    this.fragment = fragmentSubject;
    this.data = dataSubject;
  }
  /** The configuration used to match this route. */
  get routeConfig() {
    return this._futureSnapshot.routeConfig;
  }
  /** The root of the router state. */
  get root() {
    return this._routerState.root;
  }
  /** The parent of this route in the router state tree. */
  get parent() {
    return this._routerState.parent(this);
  }
  /** The first child of this route in the router state tree. */
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  /** The children of this route in the router state tree. */
  get children() {
    return this._routerState.children(this);
  }
  /** The path from the root of the router state tree to this route. */
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  /**
   * An Observable that contains a map of the required and optional parameters
   * specific to the route.
   * The map supports retrieving single and multiple values from the same parameter.
   */
  get paramMap() {
    this._paramMap ??= this.params.pipe(map((p2) => convertToParamMap(p2)));
    return this._paramMap;
  }
  /**
   * An Observable that contains a map of the query parameters available to all routes.
   * The map supports retrieving single and multiple values from the query parameter.
   */
  get queryParamMap() {
    this._queryParamMap ??= this.queryParams.pipe(map((p2) => convertToParamMap(p2)));
    return this._queryParamMap;
  }
  toString() {
    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
  }
};
function getInherited(route, parent, paramsInheritanceStrategy = "emptyOnly") {
  let inherited;
  const {
    routeConfig
  } = route;
  if (parent !== null && (paramsInheritanceStrategy === "always" || // inherit parent data if route is empty path
  routeConfig?.path === "" || // inherit parent data if parent was componentless
  !parent.component && !parent.routeConfig?.loadComponent)) {
    inherited = {
      params: __spreadValues(__spreadValues({}, parent.params), route.params),
      data: __spreadValues(__spreadValues({}, parent.data), route.data),
      resolve: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, route.data), parent.data), routeConfig?.data), route._resolvedData)
    };
  } else {
    inherited = {
      params: __spreadValues({}, route.params),
      data: __spreadValues({}, route.data),
      resolve: __spreadValues(__spreadValues({}, route.data), route._resolvedData ?? {})
    };
  }
  if (routeConfig && hasStaticTitle(routeConfig)) {
    inherited.resolve[RouteTitleKey] = routeConfig.title;
  }
  return inherited;
}
var ActivatedRouteSnapshot = class {
  url;
  params;
  queryParams;
  fragment;
  data;
  outlet;
  component;
  /** The configuration used to match this route **/
  routeConfig;
  /** @internal */
  _resolve;
  /** @internal */
  _resolvedData;
  /** @internal */
  _routerState;
  /** @internal */
  _paramMap;
  /** @internal */
  _queryParamMap;
  /** The resolved route title */
  get title() {
    return this.data?.[RouteTitleKey];
  }
  /** @internal */
  constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, resolve) {
    this.url = url;
    this.params = params;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.data = data;
    this.outlet = outlet;
    this.component = component;
    this.routeConfig = routeConfig;
    this._resolve = resolve;
  }
  /** The root of the router state */
  get root() {
    return this._routerState.root;
  }
  /** The parent of this route in the router state tree */
  get parent() {
    return this._routerState.parent(this);
  }
  /** The first child of this route in the router state tree */
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  /** The children of this route in the router state tree */
  get children() {
    return this._routerState.children(this);
  }
  /** The path from the root of the router state tree to this route */
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  get paramMap() {
    this._paramMap ??= convertToParamMap(this.params);
    return this._paramMap;
  }
  get queryParamMap() {
    this._queryParamMap ??= convertToParamMap(this.queryParams);
    return this._queryParamMap;
  }
  toString() {
    const url = this.url.map((segment) => segment.toString()).join("/");
    const matched = this.routeConfig ? this.routeConfig.path : "";
    return `Route(url:'${url}', path:'${matched}')`;
  }
};
var RouterStateSnapshot = class extends Tree {
  url;
  /** @internal */
  constructor(url, root3) {
    super(root3);
    this.url = url;
    setRouterState(this, root3);
  }
  toString() {
    return serializeNode(this._root);
  }
};
function setRouterState(state2, node) {
  node.value._routerState = state2;
  node.children.forEach((c) => setRouterState(state2, c));
}
function serializeNode(node) {
  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(", ")} } ` : "";
  return `${node.value}${c}`;
}
function advanceActivatedRoute(route) {
  if (route.snapshot) {
    const currentSnapshot = route.snapshot;
    const nextSnapshot = route._futureSnapshot;
    route.snapshot = nextSnapshot;
    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
      route.queryParamsSubject.next(nextSnapshot.queryParams);
    }
    if (currentSnapshot.fragment !== nextSnapshot.fragment) {
      route.fragmentSubject.next(nextSnapshot.fragment);
    }
    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
      route.paramsSubject.next(nextSnapshot.params);
    }
    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
      route.urlSubject.next(nextSnapshot.url);
    }
    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
      route.dataSubject.next(nextSnapshot.data);
    }
  } else {
    route.snapshot = route._futureSnapshot;
    route.dataSubject.next(route._futureSnapshot.data);
  }
}
function equalParamsAndUrlSegments(a, b) {
  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
  const parentsMismatch = !a.parent !== !b.parent;
  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
}
function hasStaticTitle(config3) {
  return typeof config3.title === "string" || config3.title === null;
}
var ROUTER_OUTLET_DATA = new InjectionToken(ngDevMode ? "RouterOutlet data" : "");
var RouterOutlet = class _RouterOutlet {
  activated = null;
  /** @internal */
  get activatedComponentRef() {
    return this.activated;
  }
  _activatedRoute = null;
  /**
   * The name of the outlet
   *
   */
  name = PRIMARY_OUTLET;
  activateEvents = new EventEmitter();
  deactivateEvents = new EventEmitter();
  /**
   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a
   * previously detached subtree.
   **/
  attachEvents = new EventEmitter();
  /**
   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the
   * subtree.
   */
  detachEvents = new EventEmitter();
  /**
   * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.
   *
   * When unset, the value of the token is `undefined` by default.
   */
  routerOutletData = input(void 0);
  parentContexts = inject(ChildrenOutletContexts);
  location = inject(ViewContainerRef);
  changeDetector = inject(ChangeDetectorRef);
  inputBinder = inject(INPUT_BINDER, {
    optional: true
  });
  /** @nodoc */
  supportsBindingToComponentInputs = true;
  /** @nodoc */
  ngOnChanges(changes) {
    if (changes["name"]) {
      const {
        firstChange,
        previousValue
      } = changes["name"];
      if (firstChange) {
        return;
      }
      if (this.isTrackedInParentContexts(previousValue)) {
        this.deactivate();
        this.parentContexts.onChildOutletDestroyed(previousValue);
      }
      this.initializeOutletWithName();
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.isTrackedInParentContexts(this.name)) {
      this.parentContexts.onChildOutletDestroyed(this.name);
    }
    this.inputBinder?.unsubscribeFromRouteData(this);
  }
  isTrackedInParentContexts(outletName) {
    return this.parentContexts.getContext(outletName)?.outlet === this;
  }
  /** @nodoc */
  ngOnInit() {
    this.initializeOutletWithName();
  }
  initializeOutletWithName() {
    this.parentContexts.onChildOutletCreated(this.name, this);
    if (this.activated) {
      return;
    }
    const context2 = this.parentContexts.getContext(this.name);
    if (context2?.route) {
      if (context2.attachRef) {
        this.attach(context2.attachRef, context2.route);
      } else {
        this.activateWith(context2.route, context2.injector);
      }
    }
  }
  get isActivated() {
    return !!this.activated;
  }
  /**
   * @returns The currently activated component instance.
   * @throws An error if the outlet is not activated.
   */
  get component() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    return this.activated.instance;
  }
  get activatedRoute() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    return this._activatedRoute;
  }
  get activatedRouteData() {
    if (this._activatedRoute) {
      return this._activatedRoute.snapshot.data;
    }
    return {};
  }
  /**
   * Called when the `RouteReuseStrategy` instructs to detach the subtree
   */
  detach() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    this.location.detach();
    const cmp = this.activated;
    this.activated = null;
    this._activatedRoute = null;
    this.detachEvents.emit(cmp.instance);
    return cmp;
  }
  /**
   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
   */
  attach(ref, activatedRoute) {
    this.activated = ref;
    this._activatedRoute = activatedRoute;
    this.location.insert(ref.hostView);
    this.inputBinder?.bindActivatedRouteToOutletComponent(this);
    this.attachEvents.emit(ref.instance);
  }
  deactivate() {
    if (this.activated) {
      const c = this.component;
      this.activated.destroy();
      this.activated = null;
      this._activatedRoute = null;
      this.deactivateEvents.emit(c);
    }
  }
  activateWith(activatedRoute, environmentInjector) {
    if (this.isActivated) {
      throw new RuntimeError(4013, (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot activate an already activated outlet");
    }
    this._activatedRoute = activatedRoute;
    const location2 = this.location;
    const snapshot = activatedRoute.snapshot;
    const component = snapshot.component;
    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
    const injector = new OutletInjector(activatedRoute, childContexts, location2.injector, this.routerOutletData);
    this.activated = location2.createComponent(component, {
      index: location2.length,
      injector,
      environmentInjector
    });
    this.changeDetector.markForCheck();
    this.inputBinder?.bindActivatedRouteToOutletComponent(this);
    this.activateEvents.emit(this.activated.instance);
  }
  static \u0275fac = function RouterOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterOutlet)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RouterOutlet,
    selectors: [["router-outlet"]],
    inputs: {
      name: "name",
      routerOutletData: [1, "routerOutletData"]
    },
    outputs: {
      activateEvents: "activate",
      deactivateEvents: "deactivate",
      attachEvents: "attach",
      detachEvents: "detach"
    },
    exportAs: ["outlet"],
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterOutlet, [{
    type: Directive,
    args: [{
      selector: "router-outlet",
      exportAs: "outlet",
      standalone: true
    }]
  }], null, {
    name: [{
      type: Input
    }],
    activateEvents: [{
      type: Output,
      args: ["activate"]
    }],
    deactivateEvents: [{
      type: Output,
      args: ["deactivate"]
    }],
    attachEvents: [{
      type: Output,
      args: ["attach"]
    }],
    detachEvents: [{
      type: Output,
      args: ["detach"]
    }]
  });
})();
var OutletInjector = class _OutletInjector {
  route;
  childContexts;
  parent;
  outletData;
  /**
   * This injector has a special handing for the `ActivatedRoute` and
   * `ChildrenOutletContexts` tokens: it returns corresponding values for those
   * tokens dynamically. This behavior is different from the regular injector logic,
   * when we initialize and store a value, which is later returned for all inject
   * requests.
   *
   * In some cases (e.g. when using `@defer`), this dynamic behavior requires special
   * handling. This function allows to identify an instance of the `OutletInjector` and
   * create an instance of it without referring to the class itself (so this logic can
   * be invoked from the `core` package). This helps to retain dynamic behavior for the
   * mentioned tokens.
   *
   * Note: it's a temporary solution and we should explore how to support this case better.
   */
  __ngOutletInjector(parentInjector) {
    return new _OutletInjector(this.route, this.childContexts, parentInjector, this.outletData);
  }
  constructor(route, childContexts, parent, outletData) {
    this.route = route;
    this.childContexts = childContexts;
    this.parent = parent;
    this.outletData = outletData;
  }
  get(token, notFoundValue) {
    if (token === ActivatedRoute) {
      return this.route;
    }
    if (token === ChildrenOutletContexts) {
      return this.childContexts;
    }
    if (token === ROUTER_OUTLET_DATA) {
      return this.outletData;
    }
    return this.parent.get(token, notFoundValue);
  }
};
var INPUT_BINDER = new InjectionToken("");
var RoutedComponentInputBinder = class _RoutedComponentInputBinder {
  outletDataSubscriptions = /* @__PURE__ */ new Map();
  bindActivatedRouteToOutletComponent(outlet) {
    this.unsubscribeFromRouteData(outlet);
    this.subscribeToRouteData(outlet);
  }
  unsubscribeFromRouteData(outlet) {
    this.outletDataSubscriptions.get(outlet)?.unsubscribe();
    this.outletDataSubscriptions.delete(outlet);
  }
  subscribeToRouteData(outlet) {
    const {
      activatedRoute
    } = outlet;
    const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index) => {
      data = __spreadValues(__spreadValues(__spreadValues({}, queryParams), params), data);
      if (index === 0) {
        return of(data);
      }
      return Promise.resolve(data);
    })).subscribe((data) => {
      if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {
        this.unsubscribeFromRouteData(outlet);
        return;
      }
      const mirror = reflectComponentType(activatedRoute.component);
      if (!mirror) {
        this.unsubscribeFromRouteData(outlet);
        return;
      }
      for (const {
        templateName
      } of mirror.inputs) {
        outlet.activatedComponentRef.setInput(templateName, data[templateName]);
      }
    });
    this.outletDataSubscriptions.set(outlet, dataSubscription);
  }
  static \u0275fac = function RoutedComponentInputBinder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RoutedComponentInputBinder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RoutedComponentInputBinder,
    factory: _RoutedComponentInputBinder.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RoutedComponentInputBinder, [{
    type: Injectable
  }], null, null);
})();
function createRouterState(routeReuseStrategy, curr, prevState) {
  const root3 = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);
  return new RouterState(root3, curr);
}
function createNode(routeReuseStrategy, curr, prevState) {
  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
    const value2 = prevState.value;
    value2._futureSnapshot = curr.value;
    const children2 = createOrReuseChildren(routeReuseStrategy, curr, prevState);
    return new TreeNode(value2, children2);
  } else {
    if (routeReuseStrategy.shouldAttach(curr.value)) {
      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
      if (detachedRouteHandle !== null) {
        const tree2 = detachedRouteHandle.route;
        tree2.value._futureSnapshot = curr.value;
        tree2.children = curr.children.map((c) => createNode(routeReuseStrategy, c));
        return tree2;
      }
    }
    const value2 = createActivatedRoute(curr.value);
    const children2 = curr.children.map((c) => createNode(routeReuseStrategy, c));
    return new TreeNode(value2, children2);
  }
}
function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
  return curr.children.map((child) => {
    for (const p2 of prevState.children) {
      if (routeReuseStrategy.shouldReuseRoute(child.value, p2.value.snapshot)) {
        return createNode(routeReuseStrategy, child, p2);
      }
    }
    return createNode(routeReuseStrategy, child);
  });
}
function createActivatedRoute(c) {
  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);
}
var RedirectCommand = class {
  redirectTo;
  navigationBehaviorOptions;
  constructor(redirectTo, navigationBehaviorOptions) {
    this.redirectTo = redirectTo;
    this.navigationBehaviorOptions = navigationBehaviorOptions;
  }
};
var NAVIGATION_CANCELING_ERROR = "ngNavigationCancelingError";
function redirectingNavigationError(urlSerializer, redirect) {
  const {
    redirectTo,
    navigationBehaviorOptions
  } = isUrlTree(redirect) ? {
    redirectTo: redirect,
    navigationBehaviorOptions: void 0
  } : redirect;
  const error = navigationCancelingError(ngDevMode && `Redirecting to "${urlSerializer.serialize(redirectTo)}"`, NavigationCancellationCode.Redirect);
  error.url = redirectTo;
  error.navigationBehaviorOptions = navigationBehaviorOptions;
  return error;
}
function navigationCancelingError(message, code) {
  const error = new Error(`NavigationCancelingError: ${message || ""}`);
  error[NAVIGATION_CANCELING_ERROR] = true;
  error.cancellationCode = code;
  return error;
}
function isRedirectingNavigationCancelingError(error) {
  return isNavigationCancelingError(error) && isUrlTree(error.url);
}
function isNavigationCancelingError(error) {
  return !!error && error[NAVIGATION_CANCELING_ERROR];
}
var warnedAboutUnsupportedInputBinding = false;
var activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map((t2) => {
  new ActivateRoutes(routeReuseStrategy, t2.targetRouterState, t2.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);
  return t2;
});
var ActivateRoutes = class {
  routeReuseStrategy;
  futureState;
  currState;
  forwardEvent;
  inputBindingEnabled;
  constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {
    this.routeReuseStrategy = routeReuseStrategy;
    this.futureState = futureState;
    this.currState = currState;
    this.forwardEvent = forwardEvent;
    this.inputBindingEnabled = inputBindingEnabled;
  }
  activate(parentContexts) {
    const futureRoot = this.futureState._root;
    const currRoot = this.currState ? this.currState._root : null;
    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
    advanceActivatedRoute(this.futureState.root);
    this.activateChildRoutes(futureRoot, currRoot, parentContexts);
  }
  // De-activate the child route that are not re-used for the future state
  deactivateChildRoutes(futureNode, currNode, contexts) {
    const children2 = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((futureChild) => {
      const childOutletName = futureChild.value.outlet;
      this.deactivateRoutes(futureChild, children2[childOutletName], contexts);
      delete children2[childOutletName];
    });
    Object.values(children2).forEach((v) => {
      this.deactivateRouteAndItsChildren(v, contexts);
    });
  }
  deactivateRoutes(futureNode, currNode, parentContext) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    if (future === curr) {
      if (future.component) {
        const context2 = parentContext.getContext(future.outlet);
        if (context2) {
          this.deactivateChildRoutes(futureNode, currNode, context2.children);
        }
      } else {
        this.deactivateChildRoutes(futureNode, currNode, parentContext);
      }
    } else {
      if (curr) {
        this.deactivateRouteAndItsChildren(currNode, parentContext);
      }
    }
  }
  deactivateRouteAndItsChildren(route, parentContexts) {
    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
      this.detachAndStoreRouteSubtree(route, parentContexts);
    } else {
      this.deactivateRouteAndOutlet(route, parentContexts);
    }
  }
  detachAndStoreRouteSubtree(route, parentContexts) {
    const context2 = parentContexts.getContext(route.value.outlet);
    const contexts = context2 && route.value.component ? context2.children : parentContexts;
    const children2 = nodeChildrenAsMap(route);
    for (const treeNode of Object.values(children2)) {
      this.deactivateRouteAndItsChildren(treeNode, contexts);
    }
    if (context2 && context2.outlet) {
      const componentRef = context2.outlet.detach();
      const contexts2 = context2.children.onOutletDeactivated();
      this.routeReuseStrategy.store(route.value.snapshot, {
        componentRef,
        route,
        contexts: contexts2
      });
    }
  }
  deactivateRouteAndOutlet(route, parentContexts) {
    const context2 = parentContexts.getContext(route.value.outlet);
    const contexts = context2 && route.value.component ? context2.children : parentContexts;
    const children2 = nodeChildrenAsMap(route);
    for (const treeNode of Object.values(children2)) {
      this.deactivateRouteAndItsChildren(treeNode, contexts);
    }
    if (context2) {
      if (context2.outlet) {
        context2.outlet.deactivate();
        context2.children.onOutletDeactivated();
      }
      context2.attachRef = null;
      context2.route = null;
    }
  }
  activateChildRoutes(futureNode, currNode, contexts) {
    const children2 = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((c) => {
      this.activateRoutes(c, children2[c.value.outlet], contexts);
      this.forwardEvent(new ActivationEnd(c.value.snapshot));
    });
    if (futureNode.children.length) {
      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
    }
  }
  activateRoutes(futureNode, currNode, parentContexts) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    advanceActivatedRoute(future);
    if (future === curr) {
      if (future.component) {
        const context2 = parentContexts.getOrCreateContext(future.outlet);
        this.activateChildRoutes(futureNode, currNode, context2.children);
      } else {
        this.activateChildRoutes(futureNode, currNode, parentContexts);
      }
    } else {
      if (future.component) {
        const context2 = parentContexts.getOrCreateContext(future.outlet);
        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
          const stored = this.routeReuseStrategy.retrieve(future.snapshot);
          this.routeReuseStrategy.store(future.snapshot, null);
          context2.children.onOutletReAttached(stored.contexts);
          context2.attachRef = stored.componentRef;
          context2.route = stored.route.value;
          if (context2.outlet) {
            context2.outlet.attach(stored.componentRef, stored.route.value);
          }
          advanceActivatedRoute(stored.route.value);
          this.activateChildRoutes(futureNode, null, context2.children);
        } else {
          context2.attachRef = null;
          context2.route = future;
          if (context2.outlet) {
            context2.outlet.activateWith(future, context2.injector);
          }
          this.activateChildRoutes(futureNode, null, context2.children);
        }
      } else {
        this.activateChildRoutes(futureNode, null, parentContexts);
      }
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const context2 = parentContexts.getOrCreateContext(future.outlet);
      const outlet = context2.outlet;
      if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {
        console.warn(`'withComponentInputBinding' feature is enabled but this application is using an outlet that may not support binding to component inputs.`);
        warnedAboutUnsupportedInputBinding = true;
      }
    }
  }
};
var CanActivate = class {
  path;
  route;
  constructor(path3) {
    this.path = path3;
    this.route = this.path[this.path.length - 1];
  }
};
var CanDeactivate = class {
  component;
  route;
  constructor(component, route) {
    this.component = component;
    this.route = route;
  }
};
function getAllRouteGuards(future, curr, parentContexts) {
  const futureRoot = future._root;
  const currRoot = curr ? curr._root : null;
  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
}
function getCanActivateChild(p2) {
  const canActivateChild = p2.routeConfig ? p2.routeConfig.canActivateChild : null;
  if (!canActivateChild || canActivateChild.length === 0) return null;
  return {
    node: p2,
    guards: canActivateChild
  };
}
function getTokenOrFunctionIdentity(tokenOrFunction, injector) {
  const NOT_FOUND2 = Symbol();
  const result = injector.get(tokenOrFunction, NOT_FOUND2);
  if (result === NOT_FOUND2) {
    if (typeof tokenOrFunction === "function" && !isInjectable(tokenOrFunction)) {
      return tokenOrFunction;
    } else {
      return injector.get(tokenOrFunction);
    }
  }
  return result;
}
function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const prevChildren = nodeChildrenAsMap(currNode);
  futureNode.children.forEach((c) => {
    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
    delete prevChildren[c.value.outlet];
  });
  Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));
  return checks;
}
function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const future = futureNode.value;
  const curr = currNode ? currNode.value : null;
  const context2 = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
  if (curr && future.routeConfig === curr.routeConfig) {
    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
    if (shouldRun) {
      checks.canActivateChecks.push(new CanActivate(futurePath));
    } else {
      future.data = curr.data;
      future._resolvedData = curr._resolvedData;
    }
    if (future.component) {
      getChildRouteGuards(futureNode, currNode, context2 ? context2.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
    }
    if (shouldRun && context2 && context2.outlet && context2.outlet.isActivated) {
      checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, curr));
    }
  } else {
    if (curr) {
      deactivateRouteAndItsChildren(currNode, context2, checks);
    }
    checks.canActivateChecks.push(new CanActivate(futurePath));
    if (future.component) {
      getChildRouteGuards(futureNode, null, context2 ? context2.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
    }
  }
  return checks;
}
function shouldRunGuardsAndResolvers(curr, future, mode) {
  if (typeof mode === "function") {
    return mode(curr, future);
  }
  switch (mode) {
    case "pathParamsChange":
      return !equalPath(curr.url, future.url);
    case "pathParamsOrQueryParamsChange":
      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);
    case "always":
      return true;
    case "paramsOrQueryParamsChange":
      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);
    case "paramsChange":
    default:
      return !equalParamsAndUrlSegments(curr, future);
  }
}
function deactivateRouteAndItsChildren(route, context2, checks) {
  const children2 = nodeChildrenAsMap(route);
  const r2 = route.value;
  Object.entries(children2).forEach(([childName, node]) => {
    if (!r2.component) {
      deactivateRouteAndItsChildren(node, context2, checks);
    } else if (context2) {
      deactivateRouteAndItsChildren(node, context2.children.getContext(childName), checks);
    } else {
      deactivateRouteAndItsChildren(node, null, checks);
    }
  });
  if (!r2.component) {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r2));
  } else if (context2 && context2.outlet && context2.outlet.isActivated) {
    checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, r2));
  } else {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r2));
  }
}
function isFunction2(v) {
  return typeof v === "function";
}
function isBoolean(v) {
  return typeof v === "boolean";
}
function isCanLoad(guard) {
  return guard && isFunction2(guard.canLoad);
}
function isCanActivate(guard) {
  return guard && isFunction2(guard.canActivate);
}
function isCanActivateChild(guard) {
  return guard && isFunction2(guard.canActivateChild);
}
function isCanDeactivate(guard) {
  return guard && isFunction2(guard.canDeactivate);
}
function isCanMatch(guard) {
  return guard && isFunction2(guard.canMatch);
}
function isEmptyError(e) {
  return e instanceof EmptyError || e?.name === "EmptyError";
}
var INITIAL_VALUE = /* @__PURE__ */ Symbol("INITIAL_VALUE");
function prioritizedGuardValue() {
  return switchMap((obs) => {
    return combineLatest(obs.map((o2) => o2.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map((results) => {
      for (const result of results) {
        if (result === true) {
          continue;
        } else if (result === INITIAL_VALUE) {
          return INITIAL_VALUE;
        } else if (result === false || isRedirect(result)) {
          return result;
        }
      }
      return true;
    }), filter((item) => item !== INITIAL_VALUE), take(1));
  });
}
function isRedirect(val) {
  return isUrlTree(val) || val instanceof RedirectCommand;
}
function checkGuards(injector, forwardEvent) {
  return mergeMap((t2) => {
    const {
      targetSnapshot,
      currentSnapshot,
      guards: {
        canActivateChecks,
        canDeactivateChecks
      }
    } = t2;
    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
      return of(__spreadProps(__spreadValues({}, t2), {
        guardsResult: true
      }));
    }
    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap((canDeactivate) => {
      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of(canDeactivate);
    }), map((guardsResult) => __spreadProps(__spreadValues({}, t2), {
      guardsResult
    })));
  });
}
function runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {
  return from(checks).pipe(mergeMap((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first((result) => {
    return result !== true;
  }, true));
}
function runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {
  return from(checks).pipe(concatMap((check) => {
    return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));
  }), first((result) => {
    return result !== true;
  }, true));
}
function fireActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ActivationStart(snapshot));
  }
  return of(true);
}
function fireChildActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ChildActivationStart(snapshot));
  }
  return of(true);
}
function runCanActivate(futureRSS, futureARS, injector) {
  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
  if (!canActivate || canActivate.length === 0) return of(true);
  const canActivateObservables = canActivate.map((canActivate2) => {
    return defer(() => {
      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
      const guard = getTokenOrFunctionIdentity(canActivate2, closestInjector);
      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
      return wrapIntoObservable(guardVal).pipe(first());
    });
  });
  return of(canActivateObservables).pipe(prioritizedGuardValue());
}
function runCanActivateChild(futureRSS, path3, injector) {
  const futureARS = path3[path3.length - 1];
  const canActivateChildGuards = path3.slice(0, path3.length - 1).reverse().map((p2) => getCanActivateChild(p2)).filter((_) => _ !== null);
  const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {
    return defer(() => {
      const guardsMapped = d.guards.map((canActivateChild) => {
        const closestInjector = getClosestRouteInjector(d.node) ?? injector;
        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);
        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
        return wrapIntoObservable(guardVal).pipe(first());
      });
      return of(guardsMapped).pipe(prioritizedGuardValue());
    });
  });
  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
}
function runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {
  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
  if (!canDeactivate || canDeactivate.length === 0) return of(true);
  const canDeactivateObservables = canDeactivate.map((c) => {
    const closestInjector = getClosestRouteInjector(currARS) ?? injector;
    const guard = getTokenOrFunctionIdentity(c, closestInjector);
    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));
    return wrapIntoObservable(guardVal).pipe(first());
  });
  return of(canDeactivateObservables).pipe(prioritizedGuardValue());
}
function runCanLoadGuards(injector, route, segments, urlSerializer) {
  const canLoad = route.canLoad;
  if (canLoad === void 0 || canLoad.length === 0) {
    return of(true);
  }
  const canLoadObservables = canLoad.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
function redirectIfUrlTree(urlSerializer) {
  return pipe(tap((result) => {
    if (typeof result === "boolean") return;
    throw redirectingNavigationError(urlSerializer, result);
  }), map((result) => result === true));
}
function runCanMatchGuards(injector, route, segments, urlSerializer) {
  const canMatch = route.canMatch;
  if (!canMatch || canMatch.length === 0) return of(true);
  const canMatchObservables = canMatch.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    return wrapIntoObservable(guardVal);
  });
  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
var NoMatch = class {
  segmentGroup;
  constructor(segmentGroup) {
    this.segmentGroup = segmentGroup || null;
  }
};
var AbsoluteRedirect = class extends Error {
  urlTree;
  constructor(urlTree) {
    super();
    this.urlTree = urlTree;
  }
};
function noMatch$1(segmentGroup) {
  return throwError(new NoMatch(segmentGroup));
}
function namedOutletsRedirect(redirectTo) {
  return throwError(new RuntimeError(4e3, (typeof ngDevMode === "undefined" || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));
}
function canLoadFails(route) {
  return throwError(navigationCancelingError((typeof ngDevMode === "undefined" || ngDevMode) && `Cannot load children because the guard of the route "path: '${route.path}'" returned false`, NavigationCancellationCode.GuardRejected));
}
var ApplyRedirects = class {
  urlSerializer;
  urlTree;
  constructor(urlSerializer, urlTree) {
    this.urlSerializer = urlSerializer;
    this.urlTree = urlTree;
  }
  lineralizeSegments(route, urlTree) {
    let res = [];
    let c = urlTree.root;
    while (true) {
      res = res.concat(c.segments);
      if (c.numberOfChildren === 0) {
        return of(res);
      }
      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
        return namedOutletsRedirect(`${route.redirectTo}`);
      }
      c = c.children[PRIMARY_OUTLET];
    }
  }
  applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {
    if (typeof redirectTo !== "string") {
      const redirectToFn = redirectTo;
      const {
        queryParams,
        fragment,
        routeConfig,
        url,
        outlet,
        params,
        data,
        title
      } = currentSnapshot;
      const newRedirect = runInInjectionContext(injector, () => redirectToFn({
        params,
        data,
        queryParams,
        fragment,
        routeConfig,
        url,
        outlet,
        title
      }));
      if (newRedirect instanceof UrlTree) {
        throw new AbsoluteRedirect(newRedirect);
      }
      redirectTo = newRedirect;
    }
    const newTree = this.applyRedirectCreateUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
    if (redirectTo[0] === "/") {
      throw new AbsoluteRedirect(newTree);
    }
    return newTree;
  }
  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {
    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
  }
  createQueryParams(redirectToParams, actualParams) {
    const res = {};
    Object.entries(redirectToParams).forEach(([k, v]) => {
      const copySourceValue = typeof v === "string" && v[0] === ":";
      if (copySourceValue) {
        const sourceName = v.substring(1);
        res[k] = actualParams[sourceName];
      } else {
        res[k] = v;
      }
    });
    return res;
  }
  createSegmentGroup(redirectTo, group, segments, posParams) {
    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
    let children2 = {};
    Object.entries(group.children).forEach(([name, child]) => {
      children2[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
    });
    return new UrlSegmentGroup(updatedSegments, children2);
  }
  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
    return redirectToSegments.map((s2) => s2.path[0] === ":" ? this.findPosParam(redirectTo, s2, posParams) : this.findOrReturn(s2, actualSegments));
  }
  findPosParam(redirectTo, redirectToUrlSegment, posParams) {
    const pos = posParams[redirectToUrlSegment.path.substring(1)];
    if (!pos) throw new RuntimeError(4001, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
    return pos;
  }
  findOrReturn(redirectToUrlSegment, actualSegments) {
    let idx = 0;
    for (const s2 of actualSegments) {
      if (s2.path === redirectToUrlSegment.path) {
        actualSegments.splice(idx);
        return s2;
      }
      idx++;
    }
    return redirectToUrlSegment;
  }
};
var noMatch = {
  matched: false,
  consumedSegments: [],
  remainingSegments: [],
  parameters: {},
  positionalParamSegments: {}
};
function matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {
  const result = match(segmentGroup, route, segments);
  if (!result.matched) {
    return of(result);
  }
  injector = getOrCreateRouteInjectorIfNeeded(route, injector);
  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map((v) => v === true ? result : __spreadValues({}, noMatch)));
}
function match(segmentGroup, route, segments) {
  if (route.path === "**") {
    return createWildcardMatchResult(segments);
  }
  if (route.path === "") {
    if (route.pathMatch === "full" && (segmentGroup.hasChildren() || segments.length > 0)) {
      return __spreadValues({}, noMatch);
    }
    return {
      matched: true,
      consumedSegments: [],
      remainingSegments: segments,
      parameters: {},
      positionalParamSegments: {}
    };
  }
  const matcher = route.matcher || defaultUrlMatcher;
  const res = matcher(segments, segmentGroup, route);
  if (!res) return __spreadValues({}, noMatch);
  const posParams = {};
  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {
    posParams[k] = v.path;
  });
  const parameters = res.consumed.length > 0 ? __spreadValues(__spreadValues({}, posParams), res.consumed[res.consumed.length - 1].parameters) : posParams;
  return {
    matched: true,
    consumedSegments: res.consumed,
    remainingSegments: segments.slice(res.consumed.length),
    // TODO(atscott): investigate combining parameters and positionalParamSegments
    parameters,
    positionalParamSegments: res.posParams ?? {}
  };
}
function createWildcardMatchResult(segments) {
  return {
    matched: true,
    parameters: segments.length > 0 ? last3(segments).parameters : {},
    consumedSegments: segments,
    remainingSegments: [],
    positionalParamSegments: {}
  };
}
function split(segmentGroup, consumedSegments, slicedSegments, config3) {
  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config3)) {
    const s3 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config3, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
    return {
      segmentGroup: s3,
      slicedSegments: []
    };
  }
  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config3)) {
    const s3 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config3, segmentGroup.children));
    return {
      segmentGroup: s3,
      slicedSegments
    };
  }
  const s2 = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
  return {
    segmentGroup: s2,
    slicedSegments
  };
}
function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes2, children2) {
  const res = {};
  for (const r2 of routes2) {
    if (emptyPathMatch(segmentGroup, slicedSegments, r2) && !children2[getOutlet(r2)]) {
      const s2 = new UrlSegmentGroup([], {});
      res[getOutlet(r2)] = s2;
    }
  }
  return __spreadValues(__spreadValues({}, children2), res);
}
function createChildrenForEmptyPaths(routes2, primarySegment) {
  const res = {};
  res[PRIMARY_OUTLET] = primarySegment;
  for (const r2 of routes2) {
    if (r2.path === "" && getOutlet(r2) !== PRIMARY_OUTLET) {
      const s2 = new UrlSegmentGroup([], {});
      res[getOutlet(r2)] = s2;
    }
  }
  return res;
}
function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes2) {
  return routes2.some((r2) => emptyPathMatch(segmentGroup, slicedSegments, r2) && getOutlet(r2) !== PRIMARY_OUTLET);
}
function containsEmptyPathMatches(segmentGroup, slicedSegments, routes2) {
  return routes2.some((r2) => emptyPathMatch(segmentGroup, slicedSegments, r2));
}
function emptyPathMatch(segmentGroup, slicedSegments, r2) {
  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r2.pathMatch === "full") {
    return false;
  }
  return r2.path === "";
}
function noLeftoversInUrl(segmentGroup, segments, outlet) {
  return segments.length === 0 && !segmentGroup.children[outlet];
}
var NoLeftoversInUrl = class {
};
function recognize$1(injector, configLoader, rootComponentType, config3, urlTree, urlSerializer, paramsInheritanceStrategy = "emptyOnly") {
  return new Recognizer(injector, configLoader, rootComponentType, config3, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();
}
var MAX_ALLOWED_REDIRECTS = 31;
var Recognizer = class {
  injector;
  configLoader;
  rootComponentType;
  config;
  urlTree;
  paramsInheritanceStrategy;
  urlSerializer;
  applyRedirects;
  absoluteRedirectCount = 0;
  allowRedirects = true;
  constructor(injector, configLoader, rootComponentType, config3, urlTree, paramsInheritanceStrategy, urlSerializer) {
    this.injector = injector;
    this.configLoader = configLoader;
    this.rootComponentType = rootComponentType;
    this.config = config3;
    this.urlTree = urlTree;
    this.paramsInheritanceStrategy = paramsInheritanceStrategy;
    this.urlSerializer = urlSerializer;
    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);
  }
  noMatchError(e) {
    return new RuntimeError(4002, typeof ngDevMode === "undefined" || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);
  }
  recognize() {
    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
    return this.match(rootSegmentGroup).pipe(map(({
      children: children2,
      rootSnapshot
    }) => {
      const rootNode = new TreeNode(rootSnapshot, children2);
      const routeState = new RouterStateSnapshot("", rootNode);
      const tree2 = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);
      tree2.queryParams = this.urlTree.queryParams;
      routeState.url = this.urlSerializer.serialize(tree2);
      return {
        state: routeState,
        tree: tree2
      };
    }));
  }
  match(rootSegmentGroup) {
    const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});
    return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map((children2) => {
      return {
        children: children2,
        rootSnapshot
      };
    }), catchError((e) => {
      if (e instanceof AbsoluteRedirect) {
        this.urlTree = e.urlTree;
        return this.match(e.urlTree.root);
      }
      if (e instanceof NoMatch) {
        throw this.noMatchError(e);
      }
      throw e;
    }));
  }
  processSegmentGroup(injector, config3, segmentGroup, outlet, parentRoute) {
    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
      return this.processChildren(injector, config3, segmentGroup, parentRoute);
    }
    return this.processSegment(injector, config3, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map((child) => child instanceof TreeNode ? [child] : []));
  }
  /**
   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if
   * we cannot find a match for _any_ of the children.
   *
   * @param config - The `Routes` to match against
   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the
   *     config.
   */
  processChildren(injector, config3, segmentGroup, parentRoute) {
    const childOutlets = [];
    for (const child of Object.keys(segmentGroup.children)) {
      if (child === "primary") {
        childOutlets.unshift(child);
      } else {
        childOutlets.push(child);
      }
    }
    return from(childOutlets).pipe(concatMap((childOutlet) => {
      const child = segmentGroup.children[childOutlet];
      const sortedConfig = sortByMatchingOutlets(config3, childOutlet);
      return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);
    }), scan((children2, outletChildren) => {
      children2.push(...outletChildren);
      return children2;
    }), defaultIfEmpty(null), last2(), mergeMap((children2) => {
      if (children2 === null) return noMatch$1(segmentGroup);
      const mergedChildren = mergeEmptyPathMatches(children2);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        checkOutletNameUniqueness(mergedChildren);
      }
      sortActivatedRouteSnapshots(mergedChildren);
      return of(mergedChildren);
    }));
  }
  processSegment(injector, routes2, segmentGroup, segments, outlet, allowRedirects, parentRoute) {
    return from(routes2).pipe(concatMap((r2) => {
      return this.processSegmentAgainstRoute(r2._injector ?? injector, routes2, r2, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError((e) => {
        if (e instanceof NoMatch) {
          return of(null);
        }
        throw e;
      }));
    }), first((x4) => !!x4), catchError((e) => {
      if (isEmptyError(e)) {
        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
          return of(new NoLeftoversInUrl());
        }
        return noMatch$1(segmentGroup);
      }
      throw e;
    }));
  }
  processSegmentAgainstRoute(injector, routes2, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {
    if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
      return noMatch$1(rawSegment);
    }
    if (route.redirectTo === void 0) {
      return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);
    }
    if (this.allowRedirects && allowRedirects) {
      return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes2, route, segments, outlet, parentRoute);
    }
    return noMatch$1(rawSegment);
  }
  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes2, route, segments, outlet, parentRoute) {
    const {
      matched,
      parameters,
      consumedSegments,
      positionalParamSegments,
      remainingSegments
    } = match(segmentGroup, route, segments);
    if (!matched) return noMatch$1(segmentGroup);
    if (typeof route.redirectTo === "string" && route.redirectTo[0] === "/") {
      this.absoluteRedirectCount++;
      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {
        if (ngDevMode) {
          throw new RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.
This is currently a dev mode only error but will become a call stack size exceeded error in production in a future major version.`);
        }
        this.allowRedirects = false;
      }
    }
    const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);
    currentSnapshot.params = Object.freeze(inherited.params);
    currentSnapshot.data = Object.freeze(inherited.data);
    const newTree = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);
    return this.applyRedirects.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments) => {
      return this.processSegment(injector, routes2, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);
    }));
  }
  matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {
    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);
    if (route.path === "**") {
      rawSegment.children = {};
    }
    return matchResult.pipe(switchMap((result) => {
      if (!result.matched) {
        return noMatch$1(rawSegment);
      }
      injector = route._injector ?? injector;
      return this.getChildConfig(injector, route, segments).pipe(switchMap(({
        routes: childConfig
      }) => {
        const childInjector = route._loadedInjector ?? injector;
        const {
          parameters,
          consumedSegments,
          remainingSegments
        } = result;
        const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));
        const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);
        snapshot.params = Object.freeze(inherited.params);
        snapshot.data = Object.freeze(inherited.data);
        const {
          segmentGroup,
          slicedSegments
        } = split(rawSegment, consumedSegments, remainingSegments, childConfig);
        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
          return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map((children2) => {
            return new TreeNode(snapshot, children2);
          }));
        }
        if (childConfig.length === 0 && slicedSegments.length === 0) {
          return of(new TreeNode(snapshot, []));
        }
        const matchedOnOutlet = getOutlet(route) === outlet;
        return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map((child) => {
          return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);
        }));
      }));
    }));
  }
  getChildConfig(injector, route, segments) {
    if (route.children) {
      return of({
        routes: route.children,
        injector
      });
    }
    if (route.loadChildren) {
      if (route._loadedRoutes !== void 0) {
        return of({
          routes: route._loadedRoutes,
          injector: route._loadedInjector
        });
      }
      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap((shouldLoadResult) => {
        if (shouldLoadResult) {
          return this.configLoader.loadChildren(injector, route).pipe(tap((cfg) => {
            route._loadedRoutes = cfg.routes;
            route._loadedInjector = cfg.injector;
          }));
        }
        return canLoadFails(route);
      }));
    }
    return of({
      routes: [],
      injector
    });
  }
};
function sortActivatedRouteSnapshots(nodes) {
  nodes.sort((a, b) => {
    if (a.value.outlet === PRIMARY_OUTLET) return -1;
    if (b.value.outlet === PRIMARY_OUTLET) return 1;
    return a.value.outlet.localeCompare(b.value.outlet);
  });
}
function hasEmptyPathConfig(node) {
  const config3 = node.value.routeConfig;
  return config3 && config3.path === "";
}
function mergeEmptyPathMatches(nodes) {
  const result = [];
  const mergedNodes = /* @__PURE__ */ new Set();
  for (const node of nodes) {
    if (!hasEmptyPathConfig(node)) {
      result.push(node);
      continue;
    }
    const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);
    if (duplicateEmptyPathNode !== void 0) {
      duplicateEmptyPathNode.children.push(...node.children);
      mergedNodes.add(duplicateEmptyPathNode);
    } else {
      result.push(node);
    }
  }
  for (const mergedNode of mergedNodes) {
    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);
    result.push(new TreeNode(mergedNode.value, mergedChildren));
  }
  return result.filter((n) => !mergedNodes.has(n));
}
function checkOutletNameUniqueness(nodes) {
  const names = {};
  nodes.forEach((n) => {
    const routeWithSameOutletName = names[n.value.outlet];
    if (routeWithSameOutletName) {
      const p2 = routeWithSameOutletName.url.map((s2) => s2.toString()).join("/");
      const c = n.value.url.map((s2) => s2.toString()).join("/");
      throw new RuntimeError(4006, (typeof ngDevMode === "undefined" || ngDevMode) && `Two segments cannot have the same outlet name: '${p2}' and '${c}'.`);
    }
    names[n.value.outlet] = n.value;
  });
}
function getData(route) {
  return route.data || {};
}
function getResolve(route) {
  return route.resolve || {};
}
function recognize(injector, configLoader, rootComponentType, config3, serializer, paramsInheritanceStrategy) {
  return mergeMap((t2) => recognize$1(injector, configLoader, rootComponentType, config3, t2.extractedUrl, serializer, paramsInheritanceStrategy).pipe(map(({
    state: targetSnapshot,
    tree: urlAfterRedirects
  }) => {
    return __spreadProps(__spreadValues({}, t2), {
      targetSnapshot,
      urlAfterRedirects
    });
  })));
}
function resolveData(paramsInheritanceStrategy, injector) {
  return mergeMap((t2) => {
    const {
      targetSnapshot,
      guards: {
        canActivateChecks
      }
    } = t2;
    if (!canActivateChecks.length) {
      return of(t2);
    }
    const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));
    const routesNeedingDataUpdates = /* @__PURE__ */ new Set();
    for (const route of routesWithResolversToRun) {
      if (routesNeedingDataUpdates.has(route)) {
        continue;
      }
      for (const newRoute of flattenRouteTree(route)) {
        routesNeedingDataUpdates.add(newRoute);
      }
    }
    let routesProcessed = 0;
    return from(routesNeedingDataUpdates).pipe(concatMap((route) => {
      if (routesWithResolversToRun.has(route)) {
        return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);
      } else {
        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;
        return of(void 0);
      }
    }), tap(() => routesProcessed++), takeLast(1), mergeMap((_) => routesProcessed === routesNeedingDataUpdates.size ? of(t2) : EMPTY));
  });
}
function flattenRouteTree(route) {
  const descendants = route.children.map((child) => flattenRouteTree(child)).flat();
  return [route, ...descendants];
}
function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {
  const config3 = futureARS.routeConfig;
  const resolve = futureARS._resolve;
  if (config3?.title !== void 0 && !hasStaticTitle(config3)) {
    resolve[RouteTitleKey] = config3.title;
  }
  return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData) => {
    futureARS._resolvedData = resolvedData;
    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;
    return null;
  }));
}
function resolveNode(resolve, futureARS, futureRSS, injector) {
  const keys = getDataKeys(resolve);
  if (keys.length === 0) {
    return of({});
  }
  const data = {};
  return from(keys).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap((value2) => {
    if (value2 instanceof RedirectCommand) {
      throw redirectingNavigationError(new DefaultUrlSerializer(), value2);
    }
    data[key] = value2;
  }))), takeLast(1), mapTo(data), catchError((e) => isEmptyError(e) ? EMPTY : throwError(e)));
}
function getResolver(injectionToken, futureARS, futureRSS, injector) {
  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);
  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));
  return wrapIntoObservable(resolverValue);
}
function switchTap(next) {
  return switchMap((v) => {
    const nextResult = next(v);
    if (nextResult) {
      return from(nextResult).pipe(map(() => v));
    }
    return of(v);
  });
}
var TitleStrategy = class _TitleStrategy {
  /**
   * @returns The `title` of the deepest primary route.
   */
  buildTitle(snapshot) {
    let pageTitle;
    let route = snapshot.root;
    while (route !== void 0) {
      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;
      route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);
    }
    return pageTitle;
  }
  /**
   * Given an `ActivatedRouteSnapshot`, returns the final value of the
   * `Route.title` property, which can either be a static string or a resolved value.
   */
  getResolvedTitleForRoute(snapshot) {
    return snapshot.data[RouteTitleKey];
  }
  static \u0275fac = function TitleStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TitleStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TitleStrategy,
    factory: () => (() => inject(DefaultTitleStrategy))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultTitleStrategy)
    }]
  }], null, null);
})();
var DefaultTitleStrategy = class _DefaultTitleStrategy extends TitleStrategy {
  title;
  constructor(title) {
    super();
    this.title = title;
  }
  /**
   * Sets the title of the browser to the given value.
   *
   * @param title The `pageTitle` from the deepest primary route.
   */
  updateTitle(snapshot) {
    const title = this.buildTitle(snapshot);
    if (title !== void 0) {
      this.title.setTitle(title);
    }
  }
  static \u0275fac = function DefaultTitleStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultTitleStrategy)(\u0275\u0275inject(Title));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DefaultTitleStrategy,
    factory: _DefaultTitleStrategy.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultTitleStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Title
  }], null);
})();
var ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router config" : "", {
  providedIn: "root",
  factory: () => ({})
});
var \u0275EmptyOutletComponent = class _\u0275EmptyOutletComponent {
  static \u0275fac = function \u0275EmptyOutletComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _\u0275EmptyOutletComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _\u0275EmptyOutletComponent,
    selectors: [["ng-component"]],
    decls: 1,
    vars: 0,
    template: function _EmptyOutletComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275element(0, "router-outlet");
      }
    },
    dependencies: [RouterOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275EmptyOutletComponent, [{
    type: Component,
    args: [{
      template: `<router-outlet></router-outlet>`,
      imports: [RouterOutlet],
      standalone: true
    }]
  }], null, null);
})();
function standardizeConfig(r2) {
  const children2 = r2.children && r2.children.map(standardizeConfig);
  const c = children2 ? __spreadProps(__spreadValues({}, r2), {
    children: children2
  }) : __spreadValues({}, r2);
  if (!c.component && !c.loadComponent && (children2 || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {
    c.component = \u0275EmptyOutletComponent;
  }
  return c;
}
var ROUTES = new InjectionToken(ngDevMode ? "ROUTES" : "");
var RouterConfigLoader = class _RouterConfigLoader {
  componentLoaders = /* @__PURE__ */ new WeakMap();
  childrenLoaders = /* @__PURE__ */ new WeakMap();
  onLoadStartListener;
  onLoadEndListener;
  compiler = inject(Compiler);
  loadComponent(route) {
    if (this.componentLoaders.get(route)) {
      return this.componentLoaders.get(route);
    } else if (route._loadedComponent) {
      return of(route._loadedComponent);
    }
    if (this.onLoadStartListener) {
      this.onLoadStartListener(route);
    }
    const loadRunner = wrapIntoObservable(route.loadComponent()).pipe(map(maybeUnwrapDefaultExport), tap((component) => {
      if (this.onLoadEndListener) {
        this.onLoadEndListener(route);
      }
      (typeof ngDevMode === "undefined" || ngDevMode) && assertStandalone(route.path ?? "", component);
      route._loadedComponent = component;
    }), finalize(() => {
      this.componentLoaders.delete(route);
    }));
    const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
    this.componentLoaders.set(route, loader);
    return loader;
  }
  loadChildren(parentInjector, route) {
    if (this.childrenLoaders.get(route)) {
      return this.childrenLoaders.get(route);
    } else if (route._loadedRoutes) {
      return of({
        routes: route._loadedRoutes,
        injector: route._loadedInjector
      });
    }
    if (this.onLoadStartListener) {
      this.onLoadStartListener(route);
    }
    const moduleFactoryOrRoutes$ = loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);
    const loadRunner = moduleFactoryOrRoutes$.pipe(finalize(() => {
      this.childrenLoaders.delete(route);
    }));
    const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
    this.childrenLoaders.set(route, loader);
    return loader;
  }
  static \u0275fac = function RouterConfigLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterConfigLoader)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouterConfigLoader,
    factory: _RouterConfigLoader.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterConfigLoader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function loadChildren(route, compiler, parentInjector, onLoadEndListener) {
  return wrapIntoObservable(route.loadChildren()).pipe(map(maybeUnwrapDefaultExport), mergeMap((t2) => {
    if (t2 instanceof NgModuleFactory$1 || Array.isArray(t2)) {
      return of(t2);
    } else {
      return from(compiler.compileModuleAsync(t2));
    }
  }), map((factoryOrRoutes) => {
    if (onLoadEndListener) {
      onLoadEndListener(route);
    }
    let injector;
    let rawRoutes;
    let requireStandaloneComponents = false;
    if (Array.isArray(factoryOrRoutes)) {
      rawRoutes = factoryOrRoutes;
      requireStandaloneComponents = true;
    } else {
      injector = factoryOrRoutes.create(parentInjector).injector;
      rawRoutes = injector.get(ROUTES, [], {
        optional: true,
        self: true
      }).flat();
    }
    const routes2 = rawRoutes.map(standardizeConfig);
    (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(routes2, route.path, requireStandaloneComponents);
    return {
      routes: routes2,
      injector
    };
  }));
}
function isWrappedDefaultExport(value2) {
  return value2 && typeof value2 === "object" && "default" in value2;
}
function maybeUnwrapDefaultExport(input2) {
  return isWrappedDefaultExport(input2) ? input2["default"] : input2;
}
var UrlHandlingStrategy = class _UrlHandlingStrategy {
  static \u0275fac = function UrlHandlingStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UrlHandlingStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _UrlHandlingStrategy,
    factory: () => (() => inject(DefaultUrlHandlingStrategy))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlHandlingStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultUrlHandlingStrategy)
    }]
  }], null, null);
})();
var DefaultUrlHandlingStrategy = class _DefaultUrlHandlingStrategy {
  shouldProcessUrl(url) {
    return true;
  }
  extract(url) {
    return url;
  }
  merge(newUrlPart, wholeUrl) {
    return newUrlPart;
  }
  static \u0275fac = function DefaultUrlHandlingStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultUrlHandlingStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DefaultUrlHandlingStrategy,
    factory: _DefaultUrlHandlingStrategy.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultUrlHandlingStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? "view transition helper" : "");
var VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? "view transition options" : "");
function createViewTransition(injector, from2, to) {
  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);
  const document2 = injector.get(DOCUMENT2);
  return injector.get(NgZone).runOutsideAngular(() => {
    if (!document2.startViewTransition || transitionOptions.skipNextTransition) {
      transitionOptions.skipNextTransition = false;
      return new Promise((resolve) => setTimeout(resolve));
    }
    let resolveViewTransitionStarted;
    const viewTransitionStarted = new Promise((resolve) => {
      resolveViewTransitionStarted = resolve;
    });
    const transition3 = document2.startViewTransition(() => {
      resolveViewTransitionStarted();
      return createRenderPromise(injector);
    });
    const {
      onViewTransitionCreated
    } = transitionOptions;
    if (onViewTransitionCreated) {
      runInInjectionContext(injector, () => onViewTransitionCreated({
        transition: transition3,
        from: from2,
        to
      }));
    }
    return viewTransitionStarted;
  });
}
function createRenderPromise(injector) {
  return new Promise((resolve) => {
    afterNextRender({
      read: () => setTimeout(resolve)
    }, {
      injector
    });
  });
}
var NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "navigation error handler" : "");
var NavigationTransitions = class _NavigationTransitions {
  currentNavigation = null;
  currentTransition = null;
  lastSuccessfulNavigation = null;
  /**
   * These events are used to communicate back to the Router about the state of the transition. The
   * Router wants to respond to these events in various ways. Because the `NavigationTransition`
   * class is not public, this event subject is not publicly exposed.
   */
  events = new Subject();
  /**
   * Used to abort the current transition with an error.
   */
  transitionAbortSubject = new Subject();
  configLoader = inject(RouterConfigLoader);
  environmentInjector = inject(EnvironmentInjector);
  urlSerializer = inject(UrlSerializer);
  rootContexts = inject(ChildrenOutletContexts);
  location = inject(Location);
  inputBindingEnabled = inject(INPUT_BINDER, {
    optional: true
  }) !== null;
  titleStrategy = inject(TitleStrategy);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly";
  urlHandlingStrategy = inject(UrlHandlingStrategy);
  createViewTransition = inject(CREATE_VIEW_TRANSITION, {
    optional: true
  });
  navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {
    optional: true
  });
  navigationId = 0;
  get hasRequestedNavigation() {
    return this.navigationId !== 0;
  }
  transitions;
  /**
   * Hook that enables you to pause navigation after the preactivation phase.
   * Used by `RouterModule`.
   *
   * @internal
   */
  afterPreactivation = () => of(void 0);
  /** @internal */
  rootComponentType = null;
  constructor() {
    const onLoadStart = (r2) => this.events.next(new RouteConfigLoadStart(r2));
    const onLoadEnd = (r2) => this.events.next(new RouteConfigLoadEnd(r2));
    this.configLoader.onLoadEndListener = onLoadEnd;
    this.configLoader.onLoadStartListener = onLoadStart;
  }
  complete() {
    this.transitions?.complete();
  }
  handleNavigationRequest(request) {
    const id3 = ++this.navigationId;
    this.transitions?.next(__spreadProps(__spreadValues(__spreadValues({}, this.transitions.value), request), {
      id: id3
    }));
  }
  setupNavigations(router, initialUrlTree, initialRouterState) {
    this.transitions = new BehaviorSubject({
      id: 0,
      currentUrlTree: initialUrlTree,
      currentRawUrl: initialUrlTree,
      extractedUrl: this.urlHandlingStrategy.extract(initialUrlTree),
      urlAfterRedirects: this.urlHandlingStrategy.extract(initialUrlTree),
      rawUrl: initialUrlTree,
      extras: {},
      resolve: () => {
      },
      reject: () => {
      },
      promise: Promise.resolve(true),
      source: IMPERATIVE_NAVIGATION,
      restoredState: null,
      currentSnapshot: initialRouterState.snapshot,
      targetSnapshot: null,
      currentRouterState: initialRouterState,
      targetRouterState: null,
      guards: {
        canActivateChecks: [],
        canDeactivateChecks: []
      },
      guardsResult: null
    });
    return this.transitions.pipe(
      filter((t2) => t2.id !== 0),
      // Extract URL
      map((t2) => __spreadProps(__spreadValues({}, t2), {
        extractedUrl: this.urlHandlingStrategy.extract(t2.rawUrl)
      })),
      // Using switchMap so we cancel executing navigations when a new one comes in
      switchMap((overallTransitionState) => {
        let completed = false;
        let errored = false;
        return of(overallTransitionState).pipe(
          switchMap((t2) => {
            if (this.navigationId > overallTransitionState.id) {
              const cancellationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
              this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);
              return EMPTY;
            }
            this.currentTransition = overallTransitionState;
            this.currentNavigation = {
              id: t2.id,
              initialUrl: t2.rawUrl,
              extractedUrl: t2.extractedUrl,
              targetBrowserUrl: typeof t2.extras.browserUrl === "string" ? this.urlSerializer.parse(t2.extras.browserUrl) : t2.extras.browserUrl,
              trigger: t2.source,
              extras: t2.extras,
              previousNavigation: !this.lastSuccessfulNavigation ? null : __spreadProps(__spreadValues({}, this.lastSuccessfulNavigation), {
                previousNavigation: null
              })
            };
            const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();
            const onSameUrlNavigation = t2.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;
            if (!urlTransition && onSameUrlNavigation !== "reload") {
              const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation to ${t2.rawUrl} was ignored because it is the same as the current Router URL.` : "";
              this.events.next(new NavigationSkipped(t2.id, this.urlSerializer.serialize(t2.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));
              t2.resolve(false);
              return EMPTY;
            }
            if (this.urlHandlingStrategy.shouldProcessUrl(t2.rawUrl)) {
              return of(t2).pipe(
                // Fire NavigationStart event
                switchMap((t3) => {
                  const transition3 = this.transitions?.getValue();
                  this.events.next(new NavigationStart(t3.id, this.urlSerializer.serialize(t3.extractedUrl), t3.source, t3.restoredState));
                  if (transition3 !== this.transitions?.getValue()) {
                    return EMPTY;
                  }
                  return Promise.resolve(t3);
                }),
                // Recognize
                recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy),
                // Update URL if in `eager` update mode
                tap((t3) => {
                  overallTransitionState.targetSnapshot = t3.targetSnapshot;
                  overallTransitionState.urlAfterRedirects = t3.urlAfterRedirects;
                  this.currentNavigation = __spreadProps(__spreadValues({}, this.currentNavigation), {
                    finalUrl: t3.urlAfterRedirects
                  });
                  const routesRecognized = new RoutesRecognized(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot);
                  this.events.next(routesRecognized);
                })
              );
            } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t2.currentRawUrl)) {
              const {
                id: id3,
                extractedUrl,
                source,
                restoredState,
                extras
              } = t2;
              const navStart = new NavigationStart(id3, this.urlSerializer.serialize(extractedUrl), source, restoredState);
              this.events.next(navStart);
              const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;
              this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t2), {
                targetSnapshot,
                urlAfterRedirects: extractedUrl,
                extras: __spreadProps(__spreadValues({}, extras), {
                  skipLocationChange: false,
                  replaceUrl: false
                })
              });
              this.currentNavigation.finalUrl = extractedUrl;
              return of(overallTransitionState);
            } else {
              const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy indicated neither the current URL ${t2.currentRawUrl} nor target URL ${t2.rawUrl} should be processed.` : "";
              this.events.next(new NavigationSkipped(t2.id, this.urlSerializer.serialize(t2.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));
              t2.resolve(false);
              return EMPTY;
            }
          }),
          // --- GUARDS ---
          tap((t2) => {
            const guardsStart = new GuardsCheckStart(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);
            this.events.next(guardsStart);
          }),
          map((t2) => {
            this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t2), {
              guards: getAllRouteGuards(t2.targetSnapshot, t2.currentSnapshot, this.rootContexts)
            });
            return overallTransitionState;
          }),
          checkGuards(this.environmentInjector, (evt) => this.events.next(evt)),
          tap((t2) => {
            overallTransitionState.guardsResult = t2.guardsResult;
            if (t2.guardsResult && typeof t2.guardsResult !== "boolean") {
              throw redirectingNavigationError(this.urlSerializer, t2.guardsResult);
            }
            const guardsEnd = new GuardsCheckEnd(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot, !!t2.guardsResult);
            this.events.next(guardsEnd);
          }),
          filter((t2) => {
            if (!t2.guardsResult) {
              this.cancelNavigationTransition(t2, "", NavigationCancellationCode.GuardRejected);
              return false;
            }
            return true;
          }),
          // --- RESOLVE ---
          switchTap((t2) => {
            if (t2.guards.canActivateChecks.length) {
              return of(t2).pipe(tap((t3) => {
                const resolveStart = new ResolveStart(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot);
                this.events.next(resolveStart);
              }), switchMap((t3) => {
                let dataResolved = false;
                return of(t3).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({
                  next: () => dataResolved = true,
                  complete: () => {
                    if (!dataResolved) {
                      this.cancelNavigationTransition(t3, typeof ngDevMode === "undefined" || ngDevMode ? `At least one route resolver didn't emit any value.` : "", NavigationCancellationCode.NoDataFromResolver);
                    }
                  }
                }));
              }), tap((t3) => {
                const resolveEnd = new ResolveEnd(t3.id, this.urlSerializer.serialize(t3.extractedUrl), this.urlSerializer.serialize(t3.urlAfterRedirects), t3.targetSnapshot);
                this.events.next(resolveEnd);
              }));
            }
            return void 0;
          }),
          // --- LOAD COMPONENTS ---
          switchTap((t2) => {
            const loadComponents = (route) => {
              const loaders = [];
              if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {
                loaders.push(this.configLoader.loadComponent(route.routeConfig).pipe(tap((loadedComponent) => {
                  route.component = loadedComponent;
                }), map(() => void 0)));
              }
              for (const child of route.children) {
                loaders.push(...loadComponents(child));
              }
              return loaders;
            };
            return combineLatest(loadComponents(t2.targetSnapshot.root)).pipe(defaultIfEmpty(null), take(1));
          }),
          switchTap(() => this.afterPreactivation()),
          switchMap(() => {
            const {
              currentSnapshot,
              targetSnapshot
            } = overallTransitionState;
            const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);
            return viewTransitionStarted ? from(viewTransitionStarted).pipe(map(() => overallTransitionState)) : of(overallTransitionState);
          }),
          map((t2) => {
            const targetRouterState = createRouterState(router.routeReuseStrategy, t2.targetSnapshot, t2.currentRouterState);
            this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t2), {
              targetRouterState
            });
            this.currentNavigation.targetRouterState = targetRouterState;
            return overallTransitionState;
          }),
          tap(() => {
            this.events.next(new BeforeActivateRoutes());
          }),
          activateRoutes(this.rootContexts, router.routeReuseStrategy, (evt) => this.events.next(evt), this.inputBindingEnabled),
          // Ensure that if some observable used to drive the transition doesn't
          // complete, the navigation still finalizes This should never happen, but
          // this is done as a safety measure to avoid surfacing this error (#49567).
          take(1),
          tap({
            next: (t2) => {
              completed = true;
              this.lastSuccessfulNavigation = this.currentNavigation;
              this.events.next(new NavigationEnd(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects)));
              this.titleStrategy?.updateTitle(t2.targetRouterState.snapshot);
              t2.resolve(true);
            },
            complete: () => {
              completed = true;
            }
          }),
          // There used to be a lot more logic happening directly within the
          // transition Observable. Some of this logic has been refactored out to
          // other places but there may still be errors that happen there. This gives
          // us a way to cancel the transition from the outside. This may also be
          // required in the future to support something like the abort signal of the
          // Navigation API where the navigation gets aborted from outside the
          // transition.
          takeUntil(this.transitionAbortSubject.pipe(tap((err) => {
            throw err;
          }))),
          finalize(() => {
            if (!completed && !errored) {
              const cancelationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
              this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);
            }
            if (this.currentTransition?.id === overallTransitionState.id) {
              this.currentNavigation = null;
              this.currentTransition = null;
            }
          }),
          catchError((e) => {
            errored = true;
            if (isNavigationCancelingError(e)) {
              this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));
              if (!isRedirectingNavigationCancelingError(e)) {
                overallTransitionState.resolve(false);
              } else {
                this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));
              }
            } else {
              const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? void 0);
              try {
                const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));
                if (navigationErrorHandlerResult instanceof RedirectCommand) {
                  const {
                    message,
                    cancellationCode
                  } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);
                  this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));
                  this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));
                } else {
                  this.events.next(navigationError);
                  throw e;
                }
              } catch (ee) {
                if (this.options.resolveNavigationPromiseOnError) {
                  overallTransitionState.resolve(false);
                } else {
                  overallTransitionState.reject(ee);
                }
              }
            }
            return EMPTY;
          })
        );
      })
    );
  }
  cancelNavigationTransition(t2, reason, code) {
    const navCancel = new NavigationCancel(t2.id, this.urlSerializer.serialize(t2.extractedUrl), reason, code);
    this.events.next(navCancel);
    t2.resolve(false);
  }
  /**
   * @returns Whether we're navigating to somewhere that is not what the Router is
   * currently set to.
   */
  isUpdatingInternalState() {
    return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();
  }
  /**
   * @returns Whether we're updating the browser URL to something new (navigation is going
   * to somewhere not displayed in the URL bar and we will update the URL
   * bar if navigation succeeds).
   */
  isUpdatedBrowserUrl() {
    const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));
    const targetBrowserUrl = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl;
    return currentBrowserUrl.toString() !== targetBrowserUrl?.toString() && !this.currentNavigation?.extras.skipLocationChange;
  }
  static \u0275fac = function NavigationTransitions_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationTransitions)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NavigationTransitions,
    factory: _NavigationTransitions.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationTransitions, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function isBrowserTriggeredNavigation(source) {
  return source !== IMPERATIVE_NAVIGATION;
}
var RouteReuseStrategy = class _RouteReuseStrategy {
  static \u0275fac = function RouteReuseStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouteReuseStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouteReuseStrategy,
    factory: () => (() => inject(DefaultRouteReuseStrategy))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouteReuseStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultRouteReuseStrategy)
    }]
  }], null, null);
})();
var BaseRouteReuseStrategy = class {
  /**
   * Whether the given route should detach for later reuse.
   * Always returns false for `BaseRouteReuseStrategy`.
   * */
  shouldDetach(route) {
    return false;
  }
  /**
   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.
   */
  store(route, detachedTree) {
  }
  /** Returns `false`, meaning the route (and its subtree) is never reattached */
  shouldAttach(route) {
    return false;
  }
  /** Returns `null` because this strategy does not store routes for later re-use. */
  retrieve(route) {
    return null;
  }
  /**
   * Determines if a route should be reused.
   * This strategy returns `true` when the future route config and current route config are
   * identical.
   */
  shouldReuseRoute(future, curr) {
    return future.routeConfig === curr.routeConfig;
  }
};
var DefaultRouteReuseStrategy = class _DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275DefaultRouteReuseStrategy_BaseFactory;
    return function DefaultRouteReuseStrategy_Factory(__ngFactoryType__) {
      return (\u0275DefaultRouteReuseStrategy_BaseFactory || (\u0275DefaultRouteReuseStrategy_BaseFactory = \u0275\u0275getInheritedFactory(_DefaultRouteReuseStrategy)))(__ngFactoryType__ || _DefaultRouteReuseStrategy);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DefaultRouteReuseStrategy,
    factory: _DefaultRouteReuseStrategy.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultRouteReuseStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var StateManager = class _StateManager {
  static \u0275fac = function StateManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StateManager)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _StateManager,
    factory: () => (() => inject(HistoryStateManager))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StateManager, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(HistoryStateManager)
    }]
  }], null, null);
})();
var HistoryStateManager = class _HistoryStateManager extends StateManager {
  location = inject(Location);
  urlSerializer = inject(UrlSerializer);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  canceledNavigationResolution = this.options.canceledNavigationResolution || "replace";
  urlHandlingStrategy = inject(UrlHandlingStrategy);
  urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
  currentUrlTree = new UrlTree();
  getCurrentUrlTree() {
    return this.currentUrlTree;
  }
  rawUrlTree = this.currentUrlTree;
  getRawUrlTree() {
    return this.rawUrlTree;
  }
  /**
   * The id of the currently active page in the router.
   * Updated to the transition's target id on a successful navigation.
   *
   * This is used to track what page the router last activated. When an attempted navigation fails,
   * the router can then use this to compute how to restore the state back to the previously active
   * page.
   */
  currentPageId = 0;
  lastSuccessfulId = -1;
  restoredState() {
    return this.location.getState();
  }
  /**
   * The ɵrouterPageId of whatever page is currently active in the browser history. This is
   * important for computing the target page id for new navigations because we need to ensure each
   * page id in the browser history is 1 more than the previous entry.
   */
  get browserPageId() {
    if (this.canceledNavigationResolution !== "computed") {
      return this.currentPageId;
    }
    return this.restoredState()?.\u0275routerPageId ?? this.currentPageId;
  }
  routerState = createEmptyState(null);
  getRouterState() {
    return this.routerState;
  }
  stateMemento = this.createStateMemento();
  createStateMemento() {
    return {
      rawUrlTree: this.rawUrlTree,
      currentUrlTree: this.currentUrlTree,
      routerState: this.routerState
    };
  }
  registerNonRouterCurrentEntryChangeListener(listener2) {
    return this.location.subscribe((event) => {
      if (event["type"] === "popstate") {
        listener2(event["url"], event.state);
      }
    });
  }
  handleRouterEvent(e, currentTransition) {
    if (e instanceof NavigationStart) {
      this.stateMemento = this.createStateMemento();
    } else if (e instanceof NavigationSkipped) {
      this.rawUrlTree = currentTransition.initialUrl;
    } else if (e instanceof RoutesRecognized) {
      if (this.urlUpdateStrategy === "eager") {
        if (!currentTransition.extras.skipLocationChange) {
          const rawUrl = this.urlHandlingStrategy.merge(currentTransition.finalUrl, currentTransition.initialUrl);
          this.setBrowserUrl(currentTransition.targetBrowserUrl ?? rawUrl, currentTransition);
        }
      }
    } else if (e instanceof BeforeActivateRoutes) {
      this.currentUrlTree = currentTransition.finalUrl;
      this.rawUrlTree = this.urlHandlingStrategy.merge(currentTransition.finalUrl, currentTransition.initialUrl);
      this.routerState = currentTransition.targetRouterState;
      if (this.urlUpdateStrategy === "deferred" && !currentTransition.extras.skipLocationChange) {
        this.setBrowserUrl(currentTransition.targetBrowserUrl ?? this.rawUrlTree, currentTransition);
      }
    } else if (e instanceof NavigationCancel && (e.code === NavigationCancellationCode.GuardRejected || e.code === NavigationCancellationCode.NoDataFromResolver)) {
      this.restoreHistory(currentTransition);
    } else if (e instanceof NavigationError) {
      this.restoreHistory(currentTransition, true);
    } else if (e instanceof NavigationEnd) {
      this.lastSuccessfulId = e.id;
      this.currentPageId = this.browserPageId;
    }
  }
  setBrowserUrl(url, transition3) {
    const path3 = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;
    if (this.location.isCurrentPathEqualTo(path3) || !!transition3.extras.replaceUrl) {
      const currentBrowserPageId = this.browserPageId;
      const state2 = __spreadValues(__spreadValues({}, transition3.extras.state), this.generateNgRouterState(transition3.id, currentBrowserPageId));
      this.location.replaceState(path3, "", state2);
    } else {
      const state2 = __spreadValues(__spreadValues({}, transition3.extras.state), this.generateNgRouterState(transition3.id, this.browserPageId + 1));
      this.location.go(path3, "", state2);
    }
  }
  /**
   * Performs the necessary rollback action to restore the browser URL to the
   * state before the transition.
   */
  restoreHistory(navigation, restoringFromCaughtError = false) {
    if (this.canceledNavigationResolution === "computed") {
      const currentBrowserPageId = this.browserPageId;
      const targetPagePosition = this.currentPageId - currentBrowserPageId;
      if (targetPagePosition !== 0) {
        this.location.historyGo(targetPagePosition);
      } else if (this.currentUrlTree === navigation.finalUrl && targetPagePosition === 0) {
        this.resetState(navigation);
        this.resetUrlToCurrentUrlTree();
      } else {
      }
    } else if (this.canceledNavigationResolution === "replace") {
      if (restoringFromCaughtError) {
        this.resetState(navigation);
      }
      this.resetUrlToCurrentUrlTree();
    }
  }
  resetState(navigation) {
    this.routerState = this.stateMemento.routerState;
    this.currentUrlTree = this.stateMemento.currentUrlTree;
    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, navigation.finalUrl ?? this.rawUrlTree);
  }
  resetUrlToCurrentUrlTree() {
    this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));
  }
  generateNgRouterState(navigationId, routerPageId) {
    if (this.canceledNavigationResolution === "computed") {
      return {
        navigationId,
        \u0275routerPageId: routerPageId
      };
    }
    return {
      navigationId
    };
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275HistoryStateManager_BaseFactory;
    return function HistoryStateManager_Factory(__ngFactoryType__) {
      return (\u0275HistoryStateManager_BaseFactory || (\u0275HistoryStateManager_BaseFactory = \u0275\u0275getInheritedFactory(_HistoryStateManager)))(__ngFactoryType__ || _HistoryStateManager);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HistoryStateManager,
    factory: _HistoryStateManager.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HistoryStateManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NavigationResult;
(function(NavigationResult2) {
  NavigationResult2[NavigationResult2["COMPLETE"] = 0] = "COMPLETE";
  NavigationResult2[NavigationResult2["FAILED"] = 1] = "FAILED";
  NavigationResult2[NavigationResult2["REDIRECTING"] = 2] = "REDIRECTING";
})(NavigationResult || (NavigationResult = {}));
function afterNextNavigation(router, action) {
  router.events.pipe(filter((e) => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError || e instanceof NavigationSkipped), map((e) => {
    if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {
      return NavigationResult.COMPLETE;
    }
    const redirecting = e instanceof NavigationCancel ? e.code === NavigationCancellationCode.Redirect || e.code === NavigationCancellationCode.SupersededByNewNavigation : false;
    return redirecting ? NavigationResult.REDIRECTING : NavigationResult.FAILED;
  }), filter((result) => result !== NavigationResult.REDIRECTING), take(1)).subscribe(() => {
    action();
  });
}
var exactMatchOptions = {
  paths: "exact",
  fragment: "ignored",
  matrixParams: "ignored",
  queryParams: "exact"
};
var subsetMatchOptions = {
  paths: "subset",
  fragment: "ignored",
  matrixParams: "ignored",
  queryParams: "subset"
};
var Router = class _Router {
  get currentUrlTree() {
    return this.stateManager.getCurrentUrlTree();
  }
  get rawUrlTree() {
    return this.stateManager.getRawUrlTree();
  }
  disposed = false;
  nonRouterCurrentEntryChangeSubscription;
  console = inject(Console);
  stateManager = inject(StateManager);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  pendingTasks = inject(PendingTasksInternal);
  urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
  navigationTransitions = inject(NavigationTransitions);
  urlSerializer = inject(UrlSerializer);
  location = inject(Location);
  urlHandlingStrategy = inject(UrlHandlingStrategy);
  /**
   * The private `Subject` type for the public events exposed in the getter. This is used internally
   * to push events to. The separate field allows us to expose separate types in the public API
   * (i.e., an Observable rather than the Subject).
   */
  _events = new Subject();
  /**
   * An event stream for routing events.
   */
  get events() {
    return this._events;
  }
  /**
   * The current state of routing in this NgModule.
   */
  get routerState() {
    return this.stateManager.getRouterState();
  }
  /**
   * True if at least one navigation event has occurred,
   * false otherwise.
   */
  navigated = false;
  /**
   * A strategy for re-using routes.
   *
   * @deprecated Configure using `providers` instead:
   *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.
   */
  routeReuseStrategy = inject(RouteReuseStrategy);
  /**
   * How to handle a navigation request to the current URL.
   *
   *
   * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.
   * @see {@link withRouterConfig}
   * @see {@link provideRouter}
   * @see {@link RouterModule}
   */
  onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore";
  config = inject(ROUTES, {
    optional: true
  })?.flat() ?? [];
  /**
   * Indicates whether the application has opted in to binding Router data to component inputs.
   *
   * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or
   * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.
   */
  componentInputBindingEnabled = !!inject(INPUT_BINDER, {
    optional: true
  });
  constructor() {
    this.resetConfig(this.config);
    this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe({
      error: (e) => {
        this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);
      }
    });
    this.subscribeToNavigationEvents();
  }
  eventsSubscription = new Subscription();
  subscribeToNavigationEvents() {
    const subscription = this.navigationTransitions.events.subscribe((e) => {
      try {
        const currentTransition = this.navigationTransitions.currentTransition;
        const currentNavigation = this.navigationTransitions.currentNavigation;
        if (currentTransition !== null && currentNavigation !== null) {
          this.stateManager.handleRouterEvent(e, currentNavigation);
          if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.Redirect && e.code !== NavigationCancellationCode.SupersededByNewNavigation) {
            this.navigated = true;
          } else if (e instanceof NavigationEnd) {
            this.navigated = true;
          } else if (e instanceof RedirectRequest) {
            const opts = e.navigationBehaviorOptions;
            const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);
            const extras = __spreadValues({
              browserUrl: currentTransition.extras.browserUrl,
              info: currentTransition.extras.info,
              skipLocationChange: currentTransition.extras.skipLocationChange,
              // The URL is already updated at this point if we have 'eager' URL
              // updates or if the navigation was triggered by the browser (back
              // button, URL bar, etc). We want to replace that item in history
              // if the navigation is rejected.
              replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === "eager" || isBrowserTriggeredNavigation(currentTransition.source)
            }, opts);
            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {
              resolve: currentTransition.resolve,
              reject: currentTransition.reject,
              promise: currentTransition.promise
            });
          }
        }
        if (isPublicRouterEvent(e)) {
          this._events.next(e);
        }
      } catch (e3) {
        this.navigationTransitions.transitionAbortSubject.next(e3);
      }
    });
    this.eventsSubscription.add(subscription);
  }
  /** @internal */
  resetRootComponentType(rootComponentType) {
    this.routerState.root.component = rootComponentType;
    this.navigationTransitions.rootComponentType = rootComponentType;
  }
  /**
   * Sets up the location change listener and performs the initial navigation.
   */
  initialNavigation() {
    this.setUpLocationChangeListener();
    if (!this.navigationTransitions.hasRequestedNavigation) {
      this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());
    }
  }
  /**
   * Sets up the location change listener. This listener detects navigations triggered from outside
   * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router
   * navigation so that the correct events, guards, etc. are triggered.
   */
  setUpLocationChangeListener() {
    this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state2) => {
      setTimeout(() => {
        this.navigateToSyncWithBrowser(url, "popstate", state2);
      }, 0);
    });
  }
  /**
   * Schedules a router navigation to synchronize Router state with the browser state.
   *
   * This is done as a response to a popstate event and the initial navigation. These
   * two scenarios represent times when the browser URL/state has been updated and
   * the Router needs to respond to ensure its internal state matches.
   */
  navigateToSyncWithBrowser(url, source, state2) {
    const extras = {
      replaceUrl: true
    };
    const restoredState = state2?.navigationId ? state2 : null;
    if (state2) {
      const stateCopy = __spreadValues({}, state2);
      delete stateCopy.navigationId;
      delete stateCopy.\u0275routerPageId;
      if (Object.keys(stateCopy).length !== 0) {
        extras.state = stateCopy;
      }
    }
    const urlTree = this.parseUrl(url);
    this.scheduleNavigation(urlTree, source, restoredState, extras);
  }
  /** The current URL. */
  get url() {
    return this.serializeUrl(this.currentUrlTree);
  }
  /**
   * Returns the current `Navigation` object when the router is navigating,
   * and `null` when idle.
   */
  getCurrentNavigation() {
    return this.navigationTransitions.currentNavigation;
  }
  /**
   * The `Navigation` object of the most recent navigation to succeed and `null` if there
   *     has not been a successful navigation yet.
   */
  get lastSuccessfulNavigation() {
    return this.navigationTransitions.lastSuccessfulNavigation;
  }
  /**
   * Resets the route configuration used for navigation and generating links.
   *
   * @param config The route array for the new configuration.
   *
   * @usageNotes
   *
   * ```
   * router.resetConfig([
   *  { path: 'team/:id', component: TeamCmp, children: [
   *    { path: 'simple', component: SimpleCmp },
   *    { path: 'user/:name', component: UserCmp }
   *  ]}
   * ]);
   * ```
   */
  resetConfig(config3) {
    (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(config3);
    this.config = config3.map(standardizeConfig);
    this.navigated = false;
  }
  /** @nodoc */
  ngOnDestroy() {
    this.dispose();
  }
  /** Disposes of the router. */
  dispose() {
    this.navigationTransitions.complete();
    if (this.nonRouterCurrentEntryChangeSubscription) {
      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();
      this.nonRouterCurrentEntryChangeSubscription = void 0;
    }
    this.disposed = true;
    this.eventsSubscription.unsubscribe();
  }
  /**
   * Appends URL segments to the current URL tree to create a new URL tree.
   *
   * @param commands An array of URL fragments with which to construct the new URL tree.
   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path
   * segments, followed by the parameters for each segment.
   * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`
   * property of the options object, if supplied.
   * @param navigationExtras Options that control the navigation strategy.
   * @returns The new URL tree.
   *
   * @usageNotes
   *
   * ```
   * // create /team/33/user/11
   * router.createUrlTree(['/team', 33, 'user', 11]);
   *
   * // create /team/33;expand=true/user/11
   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
   *
   * // you can collapse static segments like this (this works only with the first passed-in value):
   * router.createUrlTree(['/team/33/user', userId]);
   *
   * // If the first segment can contain slashes, and you do not want the router to split it,
   * // you can do the following:
   * router.createUrlTree([{segmentPath: '/one/two'}]);
   *
   * // create /team/33/(user/11//right:chat)
   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
   *
   * // remove the right secondary node
   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
   *
   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
   *
   * // navigate to /team/33/user/11/details
   * router.createUrlTree(['details'], {relativeTo: route});
   *
   * // navigate to /team/33/user/22
   * router.createUrlTree(['../22'], {relativeTo: route});
   *
   * // navigate to /team/44/user/22
   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
   *
   * Note that a value of `null` or `undefined` for `relativeTo` indicates that the
   * tree should be created relative to the root.
   * ```
   */
  createUrlTree(commands, navigationExtras = {}) {
    const {
      relativeTo,
      queryParams,
      fragment,
      queryParamsHandling,
      preserveFragment
    } = navigationExtras;
    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;
    let q = null;
    switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {
      case "merge":
        q = __spreadValues(__spreadValues({}, this.currentUrlTree.queryParams), queryParams);
        break;
      case "preserve":
        q = this.currentUrlTree.queryParams;
        break;
      default:
        q = queryParams || null;
    }
    if (q !== null) {
      q = this.removeEmptyProps(q);
    }
    let relativeToUrlSegmentGroup;
    try {
      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;
      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);
    } catch (e) {
      if (typeof commands[0] !== "string" || commands[0][0] !== "/") {
        commands = [];
      }
      relativeToUrlSegmentGroup = this.currentUrlTree.root;
    }
    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);
  }
  /**
   * Navigates to a view using an absolute route path.
   *
   * @param url An absolute path for a defined route. The function does not apply any delta to the
   *     current URL.
   * @param extras An object containing properties that modify the navigation strategy.
   *
   * @returns A Promise that resolves to 'true' when navigation succeeds,
   * to 'false' when navigation fails, or is rejected on error.
   *
   * @usageNotes
   *
   * The following calls request navigation to an absolute path.
   *
   * ```
   * router.navigateByUrl("/team/33/user/11");
   *
   * // Navigate without updating the URL
   * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
   * ```
   *
   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)
   *
   */
  navigateByUrl(url, extras = {
    skipLocationChange: false
  }) {
    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);
  }
  /**
   * Navigate based on the provided array of commands and a starting point.
   * If no starting route is provided, the navigation is absolute.
   *
   * @param commands An array of URL fragments with which to construct the target URL.
   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path
   * segments, followed by the parameters for each segment.
   * The fragments are applied to the current URL or the one provided  in the `relativeTo` property
   * of the options object, if supplied.
   * @param extras An options object that determines how the URL should be constructed or
   *     interpreted.
   *
   * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation
   *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is
   * not `true`.
   *
   * @usageNotes
   *
   * The following calls request navigation to a dynamic route path relative to the current URL.
   *
   * ```
   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
   *
   * // Navigate without updating the URL, overriding the default behavior
   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
   * ```
   *
   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)
   *
   */
  navigate(commands, extras = {
    skipLocationChange: false
  }) {
    validateCommands(commands);
    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
  }
  /** Serializes a `UrlTree` into a string */
  serializeUrl(url) {
    return this.urlSerializer.serialize(url);
  }
  /** Parses a string into a `UrlTree` */
  parseUrl(url) {
    try {
      return this.urlSerializer.parse(url);
    } catch {
      return this.urlSerializer.parse("/");
    }
  }
  isActive(url, matchOptions) {
    let options;
    if (matchOptions === true) {
      options = __spreadValues({}, exactMatchOptions);
    } else if (matchOptions === false) {
      options = __spreadValues({}, subsetMatchOptions);
    } else {
      options = matchOptions;
    }
    if (isUrlTree(url)) {
      return containsTree(this.currentUrlTree, url, options);
    }
    const urlTree = this.parseUrl(url);
    return containsTree(this.currentUrlTree, urlTree, options);
  }
  removeEmptyProps(params) {
    return Object.entries(params).reduce((result, [key, value2]) => {
      if (value2 !== null && value2 !== void 0) {
        result[key] = value2;
      }
      return result;
    }, {});
  }
  scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
    if (this.disposed) {
      return Promise.resolve(false);
    }
    let resolve;
    let reject;
    let promise;
    if (priorPromise) {
      resolve = priorPromise.resolve;
      reject = priorPromise.reject;
      promise = priorPromise.promise;
    } else {
      promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
    }
    const taskId = this.pendingTasks.add();
    afterNextNavigation(this, () => {
      queueMicrotask(() => this.pendingTasks.remove(taskId));
    });
    this.navigationTransitions.handleNavigationRequest({
      source,
      restoredState,
      currentUrlTree: this.currentUrlTree,
      currentRawUrl: this.currentUrlTree,
      rawUrl,
      extras,
      resolve,
      reject,
      promise,
      currentSnapshot: this.routerState.snapshot,
      currentRouterState: this.routerState
    });
    return promise.catch((e) => {
      return Promise.reject(e);
    });
  }
  static \u0275fac = function Router_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Router)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Router,
    factory: _Router.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Router, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function validateCommands(commands) {
  for (let i = 0; i < commands.length; i++) {
    const cmd = commands[i];
    if (cmd == null) {
      throw new RuntimeError(4008, (typeof ngDevMode === "undefined" || ngDevMode) && `The requested path contains ${cmd} segment at index ${i}`);
    }
  }
}
function isPublicRouterEvent(e) {
  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);
}
var RouterLink = class _RouterLink {
  router;
  route;
  tabIndexAttribute;
  renderer;
  el;
  locationStrategy;
  /**
   * Represents an `href` attribute value applied to a host element,
   * when a host element is `<a>`. For other tags, the value is `null`.
   */
  href = null;
  /**
   * Represents the `target` attribute on a host element.
   * This is only used when the host element is an `<a>` tag.
   */
  target;
  /**
   * Passed to {@link Router#createUrlTree} as part of the
   * `UrlCreationOptions`.
   * @see {@link UrlCreationOptions#queryParams}
   * @see {@link Router#createUrlTree}
   */
  queryParams;
  /**
   * Passed to {@link Router#createUrlTree} as part of the
   * `UrlCreationOptions`.
   * @see {@link UrlCreationOptions#fragment}
   * @see {@link Router#createUrlTree}
   */
  fragment;
  /**
   * Passed to {@link Router#createUrlTree} as part of the
   * `UrlCreationOptions`.
   * @see {@link UrlCreationOptions#queryParamsHandling}
   * @see {@link Router#createUrlTree}
   */
  queryParamsHandling;
  /**
   * Passed to {@link Router#navigateByUrl} as part of the
   * `NavigationBehaviorOptions`.
   * @see {@link NavigationBehaviorOptions#state}
   * @see {@link Router#navigateByUrl}
   */
  state;
  /**
   * Passed to {@link Router#navigateByUrl} as part of the
   * `NavigationBehaviorOptions`.
   * @see {@link NavigationBehaviorOptions#info}
   * @see {@link Router#navigateByUrl}
   */
  info;
  /**
   * Passed to {@link Router#createUrlTree} as part of the
   * `UrlCreationOptions`.
   * Specify a value here when you do not want to use the default value
   * for `routerLink`, which is the current activated route.
   * Note that a value of `undefined` here will use the `routerLink` default.
   * @see {@link UrlCreationOptions#relativeTo}
   * @see {@link Router#createUrlTree}
   */
  relativeTo;
  /** Whether a host element is an `<a>` tag. */
  isAnchorElement;
  subscription;
  /** @internal */
  onChanges = new Subject();
  constructor(router, route, tabIndexAttribute, renderer, el, locationStrategy) {
    this.router = router;
    this.route = route;
    this.tabIndexAttribute = tabIndexAttribute;
    this.renderer = renderer;
    this.el = el;
    this.locationStrategy = locationStrategy;
    const tagName = el.nativeElement.tagName?.toLowerCase();
    this.isAnchorElement = tagName === "a" || tagName === "area";
    if (this.isAnchorElement) {
      this.subscription = router.events.subscribe((s2) => {
        if (s2 instanceof NavigationEnd) {
          this.updateHref();
        }
      });
    } else {
      this.setTabIndexIfNotOnNativeEl("0");
    }
  }
  /**
   * Passed to {@link Router#createUrlTree} as part of the
   * `UrlCreationOptions`.
   * @see {@link UrlCreationOptions#preserveFragment}
   * @see {@link Router#createUrlTree}
   */
  preserveFragment = false;
  /**
   * Passed to {@link Router#navigateByUrl} as part of the
   * `NavigationBehaviorOptions`.
   * @see {@link NavigationBehaviorOptions#skipLocationChange}
   * @see {@link Router#navigateByUrl}
   */
  skipLocationChange = false;
  /**
   * Passed to {@link Router#navigateByUrl} as part of the
   * `NavigationBehaviorOptions`.
   * @see {@link NavigationBehaviorOptions#replaceUrl}
   * @see {@link Router#navigateByUrl}
   */
  replaceUrl = false;
  /**
   * Modifies the tab index if there was not a tabindex attribute on the element during
   * instantiation.
   */
  setTabIndexIfNotOnNativeEl(newTabIndex) {
    if (this.tabIndexAttribute != null || this.isAnchorElement) {
      return;
    }
    this.applyAttributeValue("tabindex", newTabIndex);
  }
  /** @nodoc */
  // TODO(atscott): Remove changes parameter in major version as a breaking change.
  ngOnChanges(changes) {
    if (ngDevMode && isUrlTree(this.routerLinkInput) && (this.fragment !== void 0 || this.queryParams || this.queryParamsHandling || this.preserveFragment || this.relativeTo)) {
      throw new RuntimeError(4016, "Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.");
    }
    if (this.isAnchorElement) {
      this.updateHref();
    }
    this.onChanges.next(this);
  }
  routerLinkInput = null;
  /**
   * Commands to pass to {@link Router#createUrlTree} or a `UrlTree`.
   *   - **array**: commands to pass to {@link Router#createUrlTree}.
   *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`
   *   - **UrlTree**: a `UrlTree` for this link rather than creating one from the commands
   *     and other inputs that correspond to properties of `UrlCreationOptions`.
   *   - **null|undefined**: effectively disables the `routerLink`
   * @see {@link Router#createUrlTree}
   */
  set routerLink(commandsOrUrlTree) {
    if (commandsOrUrlTree == null) {
      this.routerLinkInput = null;
      this.setTabIndexIfNotOnNativeEl(null);
    } else {
      if (isUrlTree(commandsOrUrlTree)) {
        this.routerLinkInput = commandsOrUrlTree;
      } else {
        this.routerLinkInput = Array.isArray(commandsOrUrlTree) ? commandsOrUrlTree : [commandsOrUrlTree];
      }
      this.setTabIndexIfNotOnNativeEl("0");
    }
  }
  /** @nodoc */
  onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
    const urlTree = this.urlTree;
    if (urlTree === null) {
      return true;
    }
    if (this.isAnchorElement) {
      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
        return true;
      }
      if (typeof this.target === "string" && this.target != "_self") {
        return true;
      }
    }
    const extras = {
      skipLocationChange: this.skipLocationChange,
      replaceUrl: this.replaceUrl,
      state: this.state,
      info: this.info
    };
    this.router.navigateByUrl(urlTree, extras);
    return !this.isAnchorElement;
  }
  /** @nodoc */
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  updateHref() {
    const urlTree = this.urlTree;
    this.href = urlTree !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) : null;
    const sanitizedValue = this.href === null ? null : (
      // This class represents a directive that can be added to both `<a>` elements,
      // as well as other elements. As a result, we can't define security context at
      // compile time. So the security context is deferred to runtime.
      // The `ɵɵsanitizeUrlOrResourceUrl` selects the necessary sanitizer function
      // based on the tag and property names. The logic mimics the one from
      // `packages/compiler/src/schema/dom_security_schema.ts`, which is used at compile time.
      //
      // Note: we should investigate whether we can switch to using `@HostBinding('attr.href')`
      // instead of applying a value via a renderer, after a final merge of the
      // `RouterLinkWithHref` directive.
      \u0275\u0275sanitizeUrlOrResourceUrl(this.href, this.el.nativeElement.tagName.toLowerCase(), "href")
    );
    this.applyAttributeValue("href", sanitizedValue);
  }
  applyAttributeValue(attrName, attrValue) {
    const renderer = this.renderer;
    const nativeElement = this.el.nativeElement;
    if (attrValue !== null) {
      renderer.setAttribute(nativeElement, attrName, attrValue);
    } else {
      renderer.removeAttribute(nativeElement, attrName);
    }
  }
  get urlTree() {
    if (this.routerLinkInput === null) {
      return null;
    } else if (isUrlTree(this.routerLinkInput)) {
      return this.routerLinkInput;
    }
    return this.router.createUrlTree(this.routerLinkInput, {
      // If the `relativeTo` input is not defined, we want to use `this.route` by default.
      // Otherwise, we should use the value provided by the user in the input.
      relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
      queryParams: this.queryParams,
      fragment: this.fragment,
      queryParamsHandling: this.queryParamsHandling,
      preserveFragment: this.preserveFragment
    });
  }
  static \u0275fac = function RouterLink_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterLink)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275injectAttribute("tabindex"), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(LocationStrategy));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RouterLink,
    selectors: [["", "routerLink", ""]],
    hostVars: 1,
    hostBindings: function RouterLink_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("click", function RouterLink_click_HostBindingHandler($event) {
          return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);
        });
      }
      if (rf & 2) {
        \u0275\u0275attribute("target", ctx.target);
      }
    },
    inputs: {
      target: "target",
      queryParams: "queryParams",
      fragment: "fragment",
      queryParamsHandling: "queryParamsHandling",
      state: "state",
      info: "info",
      relativeTo: "relativeTo",
      preserveFragment: [2, "preserveFragment", "preserveFragment", booleanAttribute],
      skipLocationChange: [2, "skipLocationChange", "skipLocationChange", booleanAttribute],
      replaceUrl: [2, "replaceUrl", "replaceUrl", booleanAttribute],
      routerLink: "routerLink"
    },
    features: [\u0275\u0275InputTransformsFeature, \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLink, [{
    type: Directive,
    args: [{
      selector: "[routerLink]",
      standalone: true
    }]
  }], () => [{
    type: Router
  }, {
    type: ActivatedRoute
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["tabindex"]
    }]
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: LocationStrategy
  }], {
    target: [{
      type: HostBinding,
      args: ["attr.target"]
    }, {
      type: Input
    }],
    queryParams: [{
      type: Input
    }],
    fragment: [{
      type: Input
    }],
    queryParamsHandling: [{
      type: Input
    }],
    state: [{
      type: Input
    }],
    info: [{
      type: Input
    }],
    relativeTo: [{
      type: Input
    }],
    preserveFragment: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    skipLocationChange: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    replaceUrl: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    routerLink: [{
      type: Input
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event.button", "$event.ctrlKey", "$event.shiftKey", "$event.altKey", "$event.metaKey"]]
    }]
  });
})();
var RouterLinkActive = class _RouterLinkActive {
  router;
  element;
  renderer;
  cdr;
  link;
  links;
  classes = [];
  routerEventsSubscription;
  linkInputChangesSubscription;
  _isActive = false;
  get isActive() {
    return this._isActive;
  }
  /**
   * Options to configure how to determine if the router link is active.
   *
   * These options are passed to the `Router.isActive()` function.
   *
   * @see {@link Router#isActive}
   */
  routerLinkActiveOptions = {
    exact: false
  };
  /**
   * Aria-current attribute to apply when the router link is active.
   *
   * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}
   */
  ariaCurrentWhenActive;
  /**
   *
   * You can use the output `isActiveChange` to get notified each time the link becomes
   * active or inactive.
   *
   * Emits:
   * true  -> Route is active
   * false -> Route is inactive
   *
   * ```
   * <a
   *  routerLink="/user/bob"
   *  routerLinkActive="active-link"
   *  (isActiveChange)="this.onRouterLinkActive($event)">Bob</a>
   * ```
   */
  isActiveChange = new EventEmitter();
  constructor(router, element, renderer, cdr, link2) {
    this.router = router;
    this.element = element;
    this.renderer = renderer;
    this.cdr = cdr;
    this.link = link2;
    this.routerEventsSubscription = router.events.subscribe((s2) => {
      if (s2 instanceof NavigationEnd) {
        this.update();
      }
    });
  }
  /** @nodoc */
  ngAfterContentInit() {
    of(this.links.changes, of(null)).pipe(mergeAll()).subscribe((_) => {
      this.update();
      this.subscribeToEachLinkOnChanges();
    });
  }
  subscribeToEachLinkOnChanges() {
    this.linkInputChangesSubscription?.unsubscribe();
    const allLinkChanges = [...this.links.toArray(), this.link].filter((link2) => !!link2).map((link2) => link2.onChanges);
    this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe((link2) => {
      if (this._isActive !== this.isLinkActive(this.router)(link2)) {
        this.update();
      }
    });
  }
  set routerLinkActive(data) {
    const classes = Array.isArray(data) ? data : data.split(" ");
    this.classes = classes.filter((c) => !!c);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this.update();
  }
  /** @nodoc */
  ngOnDestroy() {
    this.routerEventsSubscription.unsubscribe();
    this.linkInputChangesSubscription?.unsubscribe();
  }
  update() {
    if (!this.links || !this.router.navigated) return;
    queueMicrotask(() => {
      const hasActiveLinks = this.hasActiveLinks();
      this.classes.forEach((c) => {
        if (hasActiveLinks) {
          this.renderer.addClass(this.element.nativeElement, c);
        } else {
          this.renderer.removeClass(this.element.nativeElement, c);
        }
      });
      if (hasActiveLinks && this.ariaCurrentWhenActive !== void 0) {
        this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString());
      } else {
        this.renderer.removeAttribute(this.element.nativeElement, "aria-current");
      }
      if (this._isActive !== hasActiveLinks) {
        this._isActive = hasActiveLinks;
        this.cdr.markForCheck();
        this.isActiveChange.emit(hasActiveLinks);
      }
    });
  }
  isLinkActive(router) {
    const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : (
      // While the types should disallow `undefined` here, it's possible without strict inputs
      this.routerLinkActiveOptions.exact || false
    );
    return (link2) => {
      const urlTree = link2.urlTree;
      return urlTree ? router.isActive(urlTree, options) : false;
    };
  }
  hasActiveLinks() {
    const isActiveCheckFn = this.isLinkActive(this.router);
    return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);
  }
  static \u0275fac = function RouterLinkActive_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterLinkActive)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(RouterLink, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RouterLinkActive,
    selectors: [["", "routerLinkActive", ""]],
    contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, RouterLink, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.links = _t);
      }
    },
    inputs: {
      routerLinkActiveOptions: "routerLinkActiveOptions",
      ariaCurrentWhenActive: "ariaCurrentWhenActive",
      routerLinkActive: "routerLinkActive"
    },
    outputs: {
      isActiveChange: "isActiveChange"
    },
    exportAs: ["routerLinkActive"],
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLinkActive, [{
    type: Directive,
    args: [{
      selector: "[routerLinkActive]",
      exportAs: "routerLinkActive",
      standalone: true
    }]
  }], () => [{
    type: Router
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }, {
    type: RouterLink,
    decorators: [{
      type: Optional
    }]
  }], {
    links: [{
      type: ContentChildren,
      args: [RouterLink, {
        descendants: true
      }]
    }],
    routerLinkActiveOptions: [{
      type: Input
    }],
    ariaCurrentWhenActive: [{
      type: Input
    }],
    isActiveChange: [{
      type: Output
    }],
    routerLinkActive: [{
      type: Input
    }]
  });
})();
function isActiveMatchOptions(options) {
  return !!options.paths;
}
var PreloadingStrategy = class {
};
var PreloadAllModules = class _PreloadAllModules {
  preload(route, fn) {
    return fn().pipe(catchError(() => of(null)));
  }
  static \u0275fac = function PreloadAllModules_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PreloadAllModules)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _PreloadAllModules,
    factory: _PreloadAllModules.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadAllModules, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NoPreloading = class _NoPreloading {
  preload(route, fn) {
    return of(null);
  }
  static \u0275fac = function NoPreloading_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoPreloading)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NoPreloading,
    factory: _NoPreloading.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoPreloading, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var RouterPreloader = class _RouterPreloader {
  router;
  injector;
  preloadingStrategy;
  loader;
  subscription;
  constructor(router, compiler, injector, preloadingStrategy, loader) {
    this.router = router;
    this.injector = injector;
    this.preloadingStrategy = preloadingStrategy;
    this.loader = loader;
  }
  setUpPreloading() {
    this.subscription = this.router.events.pipe(filter((e) => e instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {
    });
  }
  preload() {
    return this.processRoutes(this.injector, this.router.config);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  processRoutes(injector, routes2) {
    const res = [];
    for (const route of routes2) {
      if (route.providers && !route._injector) {
        route._injector = createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);
      }
      const injectorForCurrentRoute = route._injector ?? injector;
      const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;
      if (route.loadChildren && !route._loadedRoutes && route.canLoad === void 0 || route.loadComponent && !route._loadedComponent) {
        res.push(this.preloadConfig(injectorForCurrentRoute, route));
      }
      if (route.children || route._loadedRoutes) {
        res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));
      }
    }
    return from(res).pipe(mergeAll());
  }
  preloadConfig(injector, route) {
    return this.preloadingStrategy.preload(route, () => {
      let loadedChildren$;
      if (route.loadChildren && route.canLoad === void 0) {
        loadedChildren$ = this.loader.loadChildren(injector, route);
      } else {
        loadedChildren$ = of(null);
      }
      const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap((config3) => {
        if (config3 === null) {
          return of(void 0);
        }
        route._loadedRoutes = config3.routes;
        route._loadedInjector = config3.injector;
        return this.processRoutes(config3.injector ?? injector, config3.routes);
      }));
      if (route.loadComponent && !route._loadedComponent) {
        const loadComponent$ = this.loader.loadComponent(route);
        return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());
      } else {
        return recursiveLoadChildren$;
      }
    });
  }
  static \u0275fac = function RouterPreloader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterPreloader)(\u0275\u0275inject(Router), \u0275\u0275inject(Compiler), \u0275\u0275inject(EnvironmentInjector), \u0275\u0275inject(PreloadingStrategy), \u0275\u0275inject(RouterConfigLoader));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouterPreloader,
    factory: _RouterPreloader.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterPreloader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Router
  }, {
    type: Compiler
  }, {
    type: EnvironmentInjector
  }, {
    type: PreloadingStrategy
  }, {
    type: RouterConfigLoader
  }], null);
})();
var ROUTER_SCROLLER = new InjectionToken("");
var RouterScroller = class _RouterScroller {
  urlSerializer;
  transitions;
  viewportScroller;
  zone;
  options;
  routerEventsSubscription;
  scrollEventsSubscription;
  lastId = 0;
  lastSource = "imperative";
  restoredId = 0;
  store = {};
  /** @nodoc */
  constructor(urlSerializer, transitions, viewportScroller, zone, options = {}) {
    this.urlSerializer = urlSerializer;
    this.transitions = transitions;
    this.viewportScroller = viewportScroller;
    this.zone = zone;
    this.options = options;
    options.scrollPositionRestoration ||= "disabled";
    options.anchorScrolling ||= "disabled";
  }
  init() {
    if (this.options.scrollPositionRestoration !== "disabled") {
      this.viewportScroller.setHistoryScrollRestoration("manual");
    }
    this.routerEventsSubscription = this.createScrollEvents();
    this.scrollEventsSubscription = this.consumeScrollEvents();
  }
  createScrollEvents() {
    return this.transitions.events.subscribe((e) => {
      if (e instanceof NavigationStart) {
        this.store[this.lastId] = this.viewportScroller.getScrollPosition();
        this.lastSource = e.navigationTrigger;
        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
      } else if (e instanceof NavigationEnd) {
        this.lastId = e.id;
        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);
      } else if (e instanceof NavigationSkipped && e.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {
        this.lastSource = void 0;
        this.restoredId = 0;
        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);
      }
    });
  }
  consumeScrollEvents() {
    return this.transitions.events.subscribe((e) => {
      if (!(e instanceof Scroll)) return;
      if (e.position) {
        if (this.options.scrollPositionRestoration === "top") {
          this.viewportScroller.scrollToPosition([0, 0]);
        } else if (this.options.scrollPositionRestoration === "enabled") {
          this.viewportScroller.scrollToPosition(e.position);
        }
      } else {
        if (e.anchor && this.options.anchorScrolling === "enabled") {
          this.viewportScroller.scrollToAnchor(e.anchor);
        } else if (this.options.scrollPositionRestoration !== "disabled") {
          this.viewportScroller.scrollToPosition([0, 0]);
        }
      }
    });
  }
  scheduleScrollEvent(routerEvent, anchor) {
    this.zone.runOutsideAngular(() => {
      setTimeout(() => {
        this.zone.run(() => {
          this.transitions.events.next(new Scroll(routerEvent, this.lastSource === "popstate" ? this.store[this.restoredId] : null, anchor));
        });
      }, 0);
    });
  }
  /** @nodoc */
  ngOnDestroy() {
    this.routerEventsSubscription?.unsubscribe();
    this.scrollEventsSubscription?.unsubscribe();
  }
  static \u0275fac = function RouterScroller_Factory(__ngFactoryType__) {
    \u0275\u0275invalidFactory();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouterScroller,
    factory: _RouterScroller.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterScroller, [{
    type: Injectable
  }], () => [{
    type: UrlSerializer
  }, {
    type: NavigationTransitions
  }, {
    type: ViewportScroller
  }, {
    type: NgZone
  }, {
    type: void 0
  }], null);
})();
function rootRoute(router) {
  return router.routerState.root;
}
function routerFeature(kind, providers2) {
  return {
    \u0275kind: kind,
    \u0275providers: providers2
  };
}
var ROUTER_IS_PROVIDED = new InjectionToken("", {
  providedIn: "root",
  factory: () => false
});
function getBootstrapListener() {
  const injector = inject(Injector);
  return (bootstrappedComponentRef) => {
    const ref = injector.get(ApplicationRef);
    if (bootstrappedComponentRef !== ref.components[0]) {
      return;
    }
    const router = injector.get(Router);
    const bootstrapDone = injector.get(BOOTSTRAP_DONE);
    if (injector.get(INITIAL_NAVIGATION) === 1) {
      router.initialNavigation();
    }
    injector.get(ROUTER_PRELOADER, null, InjectFlags.Optional)?.setUpPreloading();
    injector.get(ROUTER_SCROLLER, null, InjectFlags.Optional)?.init();
    router.resetRootComponentType(ref.componentTypes[0]);
    if (!bootstrapDone.closed) {
      bootstrapDone.next();
      bootstrapDone.complete();
      bootstrapDone.unsubscribe();
    }
  };
}
var BOOTSTRAP_DONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "bootstrap done indicator" : "", {
  factory: () => {
    return new Subject();
  }
});
var INITIAL_NAVIGATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "initial navigation" : "", {
  providedIn: "root",
  factory: () => 1
  /* InitialNavigation.EnabledNonBlocking */
});
function withEnabledBlockingInitialNavigation() {
  const providers2 = [{
    provide: INITIAL_NAVIGATION,
    useValue: 0
    /* InitialNavigation.EnabledBlocking */
  }, {
    provide: APP_INITIALIZER,
    multi: true,
    deps: [Injector],
    useFactory: (injector) => {
      const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());
      return () => {
        return locationInitialized.then(() => {
          return new Promise((resolve) => {
            const router = injector.get(Router);
            const bootstrapDone = injector.get(BOOTSTRAP_DONE);
            afterNextNavigation(router, () => {
              resolve(true);
            });
            injector.get(NavigationTransitions).afterPreactivation = () => {
              resolve(true);
              return bootstrapDone.closed ? of(void 0) : bootstrapDone;
            };
            router.initialNavigation();
          });
        });
      };
    }
  }];
  return routerFeature(2, providers2);
}
function withDisabledInitialNavigation() {
  const providers2 = [{
    provide: APP_INITIALIZER,
    multi: true,
    useFactory: () => {
      const router = inject(Router);
      return () => {
        router.setUpLocationChangeListener();
      };
    }
  }, {
    provide: INITIAL_NAVIGATION,
    useValue: 2
    /* InitialNavigation.Disabled */
  }];
  return routerFeature(3, providers2);
}
function withDebugTracing() {
  let providers2 = [];
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    providers2 = [{
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const router = inject(Router);
        return () => router.events.subscribe((e) => {
          console.group?.(`Router Event: ${e.constructor.name}`);
          console.log(stringifyEvent(e));
          console.log(e);
          console.groupEnd?.();
        });
      }
    }];
  } else {
    providers2 = [];
  }
  return routerFeature(1, providers2);
}
var ROUTER_PRELOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router preloader" : "");
function withPreloading(preloadingStrategy) {
  const providers2 = [{
    provide: ROUTER_PRELOADER,
    useExisting: RouterPreloader
  }, {
    provide: PreloadingStrategy,
    useExisting: preloadingStrategy
  }];
  return routerFeature(0, providers2);
}
function withComponentInputBinding() {
  const providers2 = [RoutedComponentInputBinder, {
    provide: INPUT_BINDER,
    useExisting: RoutedComponentInputBinder
  }];
  return routerFeature(8, providers2);
}
function withViewTransitions(options) {
  const providers2 = [{
    provide: CREATE_VIEW_TRANSITION,
    useValue: createViewTransition
  }, {
    provide: VIEW_TRANSITION_OPTIONS,
    useValue: __spreadValues({
      skipNextTransition: !!options?.skipInitialTransition
    }, options)
  }];
  return routerFeature(9, providers2);
}
var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent];
var ROUTER_FORROOT_GUARD = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router duplicate forRoot guard" : "ROUTER_FORROOT_GUARD");
var ROUTER_PROVIDERS = [
  Location,
  {
    provide: UrlSerializer,
    useClass: DefaultUrlSerializer
  },
  Router,
  ChildrenOutletContexts,
  {
    provide: ActivatedRoute,
    useFactory: rootRoute,
    deps: [Router]
  },
  RouterConfigLoader,
  // Only used to warn when `provideRoutes` is used without `RouterModule` or `provideRouter`. Can
  // be removed when `provideRoutes` is removed.
  typeof ngDevMode === "undefined" || ngDevMode ? {
    provide: ROUTER_IS_PROVIDED,
    useValue: true
  } : []
];
var RouterModule = class _RouterModule {
  constructor(guard) {
  }
  /**
   * Creates and configures a module with all the router providers and directives.
   * Optionally sets up an application listener to perform an initial navigation.
   *
   * When registering the NgModule at the root, import as follows:
   *
   * ```
   * @NgModule({
   *   imports: [RouterModule.forRoot(ROUTES)]
   * })
   * class MyNgModule {}
   * ```
   *
   * @param routes An array of `Route` objects that define the navigation paths for the application.
   * @param config An `ExtraOptions` configuration object that controls how navigation is performed.
   * @return The new `NgModule`.
   *
   */
  static forRoot(routes2, config3) {
    return {
      ngModule: _RouterModule,
      providers: [ROUTER_PROVIDERS, typeof ngDevMode === "undefined" || ngDevMode ? config3?.enableTracing ? withDebugTracing().\u0275providers : [] : [], {
        provide: ROUTES,
        multi: true,
        useValue: routes2
      }, {
        provide: ROUTER_FORROOT_GUARD,
        useFactory: provideForRootGuard,
        deps: [[Router, new Optional(), new SkipSelf()]]
      }, config3?.errorHandler ? {
        provide: NAVIGATION_ERROR_HANDLER,
        useValue: config3.errorHandler
      } : [], {
        provide: ROUTER_CONFIGURATION,
        useValue: config3 ? config3 : {}
      }, config3?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config3?.preloadingStrategy ? withPreloading(config3.preloadingStrategy).\u0275providers : [], config3?.initialNavigation ? provideInitialNavigation(config3) : [], config3?.bindToComponentInputs ? withComponentInputBinding().\u0275providers : [], config3?.enableViewTransitions ? withViewTransitions().\u0275providers : [], provideRouterInitializer()]
    };
  }
  /**
   * Creates a module with all the router directives and a provider registering routes,
   * without creating a new Router service.
   * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:
   *
   * ```
   * @NgModule({
   *   imports: [RouterModule.forChild(ROUTES)]
   * })
   * class MyNgModule {}
   * ```
   *
   * @param routes An array of `Route` objects that define the navigation paths for the submodule.
   * @return The new NgModule.
   *
   */
  static forChild(routes2) {
    return {
      ngModule: _RouterModule,
      providers: [{
        provide: ROUTES,
        multi: true,
        useValue: routes2
      }]
    };
  }
  static \u0275fac = function RouterModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterModule)(\u0275\u0275inject(ROUTER_FORROOT_GUARD, 8));
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _RouterModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterModule, [{
    type: NgModule,
    args: [{
      imports: ROUTER_DIRECTIVES,
      exports: ROUTER_DIRECTIVES
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ROUTER_FORROOT_GUARD]
    }]
  }], null);
})();
function provideRouterScroller() {
  return {
    provide: ROUTER_SCROLLER,
    useFactory: () => {
      const viewportScroller = inject(ViewportScroller);
      const zone = inject(NgZone);
      const config3 = inject(ROUTER_CONFIGURATION);
      const transitions = inject(NavigationTransitions);
      const urlSerializer = inject(UrlSerializer);
      if (config3.scrollOffset) {
        viewportScroller.setOffset(config3.scrollOffset);
      }
      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config3);
    }
  };
}
function provideHashLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: HashLocationStrategy
  };
}
function providePathLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: PathLocationStrategy
  };
}
function provideForRootGuard(router) {
  if ((typeof ngDevMode === "undefined" || ngDevMode) && router) {
    throw new RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.`);
  }
  return "guarded";
}
function provideInitialNavigation(config3) {
  return [config3.initialNavigation === "disabled" ? withDisabledInitialNavigation().\u0275providers : [], config3.initialNavigation === "enabledBlocking" ? withEnabledBlockingInitialNavigation().\u0275providers : []];
}
var ROUTER_INITIALIZER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Router Initializer" : "");
function provideRouterInitializer() {
  return [
    // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just
    // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.
    {
      provide: ROUTER_INITIALIZER,
      useFactory: getBootstrapListener
    },
    {
      provide: APP_BOOTSTRAP_LISTENER,
      multi: true,
      useExisting: ROUTER_INITIALIZER
    }
  ];
}
var VERSION5 = new Version("19.0.1");
function getLoadedRoutes(route) {
  return route._loadedRoutes;
}
publishExternalGlobalUtil("\u0275getLoadedRoutes", getLoadedRoutes);

// src/app/common/abstract/base-service.ts
var friendlyHttpStatus = {
  0: "Server side unavailable",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  306: "Unused",
  307: "Temporary Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Required",
  413: "Request Entry Too Large",
  414: "Request-URI Too Long",
  415: "Unsupported Media Type",
  416: "Requested Range Not Satisfiable",
  417: "Expectation Failed",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported"
};
var BaseService = class {
  constructor() {
  }
  handleError(error, errorDto) {
    errorDto.httpStatus = error.status == 0 ? 500 : error.status;
    errorDto.httpStatusMessage = friendlyHttpStatus[errorDto.httpStatus];
    errorDto.errorMessage = error.status == 0 ? "Server site unavailable" : error.error.message;
    console.error(error);
    return throwError(() => error);
  }
  addParamIntoUrl(url, parameter) {
    return url + "/" + parameter;
  }
};

// src/app/service/token-storage.service.ts
var ADMIN_KEY = "auth-admin";
var _TokenStorageService = class _TokenStorageService {
  constructor() {
  }
  signOut() {
    window.sessionStorage.clear();
  }
  saveAdmin(admin) {
    window.sessionStorage.removeItem(ADMIN_KEY);
    window.sessionStorage.setItem(ADMIN_KEY, JSON.stringify(admin));
  }
  getAdmin() {
    try {
      return JSON.parse(sessionStorage.getItem(ADMIN_KEY));
    } catch (e) {
      console.error("Unable to parse user");
      window.sessionStorage.removeItem(ADMIN_KEY);
      return null;
    }
  }
  isExpired() {
    const expiration = this.getExpiration();
    return new Date(expiration) < /* @__PURE__ */ new Date();
  }
  getExpiration() {
    try {
      return this.getAdmin().expiration;
    } catch (exp) {
      return 0;
    }
  }
};
_TokenStorageService.\u0275fac = function TokenStorageService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TokenStorageService)();
};
_TokenStorageService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _TokenStorageService, factory: _TokenStorageService.\u0275fac, providedIn: "root" });
var TokenStorageService = _TokenStorageService;

// src/app/service/auth.service.ts
var _AuthService = class _AuthService extends BaseService {
  constructor(http, tokenStorage) {
    super();
    this.http = http;
    this.tokenStorage = tokenStorage;
    const admin = tokenStorage.isExpired() ? null : tokenStorage.getAdmin();
    this.currentAdminSubject = new BehaviorSubject(admin);
    this.currentAdmin = this.currentAdminSubject.asObservable();
    if (!admin) {
      this.logout();
    }
  }
  get currentAdminValue() {
    return this.currentAdminSubject.value;
  }
  login(credentials, errorDto) {
    return this.http.post(AppConstants.baseUrl + "/authenticate", {
      username: credentials.username,
      password: credentials.password
    }, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(map((resp) => {
      console.log(resp);
      this.tokenStorage.saveAdmin(resp);
      this.currentAdminSubject.next(resp);
      return resp;
    }), catchError((err) => this.handleError(err, errorDto)));
  }
  logout() {
    this.tokenStorage.signOut();
    this.currentAdminSubject.next(null);
  }
};
_AuthService.\u0275fac = function AuthService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AuthService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(TokenStorageService));
};
_AuthService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _AuthService, factory: _AuthService.\u0275fac, providedIn: "root" });
var AuthService = _AuthService;

// node_modules/@fortawesome/fontawesome-svg-core/index.mjs
function _defineProperty(e, r2, t2) {
  return (r2 = _toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r2] = t2, e;
}
function ownKeys(e, r2) {
  var t2 = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e;
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e = t2[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t2, r2 || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey(t2) {
  var i = _toPrimitive(t2, "string");
  return "symbol" == typeof i ? i : i + "";
}
var noop4 = () => {
};
var _WINDOW = {};
var _DOCUMENT = {};
var _MUTATION_OBSERVER = null;
var _PERFORMANCE = {
  mark: noop4,
  measure: noop4
};
try {
  if (typeof window !== "undefined") _WINDOW = window;
  if (typeof document !== "undefined") _DOCUMENT = document;
  if (typeof MutationObserver !== "undefined") _MUTATION_OBSERVER = MutationObserver;
  if (typeof performance !== "undefined") _PERFORMANCE = performance;
} catch (e) {
}
var {
  userAgent = ""
} = _WINDOW.navigator || {};
var WINDOW = _WINDOW;
var DOCUMENT3 = _DOCUMENT;
var MUTATION_OBSERVER = _MUTATION_OBSERVER;
var PERFORMANCE = _PERFORMANCE;
var IS_BROWSER = !!WINDOW.document;
var IS_DOM = !!DOCUMENT3.documentElement && !!DOCUMENT3.head && typeof DOCUMENT3.addEventListener === "function" && typeof DOCUMENT3.createElement === "function";
var IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
var p = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/;
var g = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i;
var S = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  }
};
var A = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var P = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"];
var s = "classic";
var t = "duotone";
var r = "sharp";
var o = "sharp-duotone";
var L = [s, t, r, o];
var G = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
};
var lt = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
};
var pt = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}]]);
var xt = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    brands: "fab"
  },
  duotone: {
    solid: "fad",
    regular: "fadr",
    light: "fadl",
    thin: "fadt"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds",
    regular: "fasdr",
    light: "fasdl",
    thin: "fasdt"
  }
};
var Ft = ["fak", "fa-kit", "fakd", "fa-kit-duotone"];
var St = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
};
var At = ["kit"];
var Ct = {
  kit: {
    "fa-kit": "fak"
  },
  "kit-duotone": {
    "fa-kit-duotone": "fakd"
  }
};
var Lt = ["fak", "fakd"];
var Wt = {
  kit: {
    fak: "fa-kit"
  },
  "kit-duotone": {
    fakd: "fa-kit-duotone"
  }
};
var Et = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
};
var t$1 = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
};
var r$1 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"];
var bt$1 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"];
var Yt = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
};
var po = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  }
};
var I$1 = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
};
var co = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  }
};
var x = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"];
var xo = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...r$1, ...x];
var m$1 = ["solid", "regular", "light", "thin", "duotone", "brands"];
var c$1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var F$1 = c$1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
var Fo = [...Object.keys(I$1), ...m$1, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", t$1.GROUP, t$1.SWAP_OPACITY, t$1.PRIMARY, t$1.SECONDARY].concat(c$1.map((o2) => "".concat(o2, "x"))).concat(F$1.map((o2) => "w-".concat(o2)));
var ko = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
var UNITS_IN_GRID = 16;
var DEFAULT_CSS_PREFIX = "fa";
var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
var DATA_FA_I2SVG = "data-fa-i2svg";
var DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element";
var DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending";
var DATA_PREFIX = "data-prefix";
var DATA_ICON = "data-icon";
var HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg";
var MUTATION_APPROACH_ASYNC = "async";
var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ["HTML", "HEAD", "STYLE", "SCRIPT"];
var PRODUCTION = (() => {
  try {
    return false;
  } catch (e$$1) {
    return false;
  }
})();
function familyProxy(obj) {
  return new Proxy(obj, {
    get(target, prop) {
      return prop in target ? target[prop] : target[s];
    }
  });
}
var _PREFIX_TO_STYLE = _objectSpread2({}, S);
_PREFIX_TO_STYLE[s] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
  "fa-duotone": "duotone"
}), S[s]), St["kit"]), St["kit-duotone"]);
var PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
var _STYLE_TO_PREFIX = _objectSpread2({}, xt);
_STYLE_TO_PREFIX[s] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
  duotone: "fad"
}), _STYLE_TO_PREFIX[s]), Et["kit"]), Et["kit-duotone"]);
var STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
var _PREFIX_TO_LONG_STYLE = _objectSpread2({}, co);
_PREFIX_TO_LONG_STYLE[s] = _objectSpread2(_objectSpread2({}, _PREFIX_TO_LONG_STYLE[s]), Wt["kit"]);
var PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
var _LONG_STYLE_TO_PREFIX = _objectSpread2({}, po);
_LONG_STYLE_TO_PREFIX[s] = _objectSpread2(_objectSpread2({}, _LONG_STYLE_TO_PREFIX[s]), Ct["kit"]);
var LONG_STYLE_TO_PREFIX = familyProxy(_LONG_STYLE_TO_PREFIX);
var ICON_SELECTION_SYNTAX_PATTERN = p;
var LAYERS_TEXT_CLASSNAME = "fa-layers-text";
var FONT_FAMILY_PATTERN = g;
var _FONT_WEIGHT_TO_PREFIX = _objectSpread2({}, G);
var FONT_WEIGHT_TO_PREFIX = familyProxy(_FONT_WEIGHT_TO_PREFIX);
var ATTRIBUTES_WATCHED_FOR_MUTATION = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
var DUOTONE_CLASSES = A;
var RESERVED_CLASSES = [...At, ...Fo];
var initial = WINDOW.FontAwesomeConfig || {};
function getAttrConfig(attr) {
  var element = DOCUMENT3.querySelector("script[" + attr + "]");
  if (element) {
    return element.getAttribute(attr);
  }
}
function coerce(val) {
  if (val === "") return true;
  if (val === "false") return false;
  if (val === "true") return true;
  return val;
}
if (DOCUMENT3 && typeof DOCUMENT3.querySelector === "function") {
  const attrs = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  attrs.forEach((_ref) => {
    let [attr, key] = _ref;
    const val = coerce(getAttrConfig(attr));
    if (val !== void 0 && val !== null) {
      initial[key] = val;
    }
  });
}
var _default = {
  styleDefault: "solid",
  familyDefault: s,
  cssPrefix: DEFAULT_CSS_PREFIX,
  replacementClass: DEFAULT_REPLACEMENT_CLASS,
  autoReplaceSvg: true,
  autoAddCss: true,
  autoA11y: true,
  searchPseudoElements: false,
  observeMutations: true,
  mutateApproach: "async",
  keepOriginalSource: true,
  measurePerformance: false,
  showMissingIcons: true
};
if (initial.familyPrefix) {
  initial.cssPrefix = initial.familyPrefix;
}
var _config = _objectSpread2(_objectSpread2({}, _default), initial);
if (!_config.autoReplaceSvg) _config.observeMutations = false;
var config2 = {};
Object.keys(_default).forEach((key) => {
  Object.defineProperty(config2, key, {
    enumerable: true,
    set: function(val) {
      _config[key] = val;
      _onChangeCb.forEach((cb) => cb(config2));
    },
    get: function() {
      return _config[key];
    }
  });
});
Object.defineProperty(config2, "familyPrefix", {
  enumerable: true,
  set: function(val) {
    _config.cssPrefix = val;
    _onChangeCb.forEach((cb) => cb(config2));
  },
  get: function() {
    return _config.cssPrefix;
  }
});
WINDOW.FontAwesomeConfig = config2;
var _onChangeCb = [];
function onChange(cb) {
  _onChangeCb.push(cb);
  return () => {
    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
  };
}
var d$2 = UNITS_IN_GRID;
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: false,
  flipY: false
};
function insertCss(css2) {
  if (!css2 || !IS_DOM) {
    return;
  }
  const style2 = DOCUMENT3.createElement("style");
  style2.setAttribute("type", "text/css");
  style2.innerHTML = css2;
  const headChildren = DOCUMENT3.head.childNodes;
  let beforeChild = null;
  for (let i = headChildren.length - 1; i > -1; i--) {
    const child = headChildren[i];
    const tagName = (child.tagName || "").toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  DOCUMENT3.head.insertBefore(style2, beforeChild);
  return css2;
}
var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function nextUniqueId() {
  let size2 = 12;
  let id3 = "";
  while (size2-- > 0) {
    id3 += idPool[Math.random() * 62 | 0];
  }
  return id3;
}
function toArray(obj) {
  const array2 = [];
  for (let i = (obj || []).length >>> 0; i--; ) {
    array2[i] = obj[i];
  }
  return array2;
}
function classArray(node) {
  if (node.classList) {
    return toArray(node.classList);
  } else {
    return (node.getAttribute("class") || "").split(" ").filter((i) => i);
  }
}
function htmlEscape(str) {
  return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function joinAttributes(attributes) {
  return Object.keys(attributes || {}).reduce((acc, attributeName) => {
    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
  }, "").trim();
}
function joinStyles(styles2) {
  return Object.keys(styles2 || {}).reduce((acc, styleName) => {
    return acc + "".concat(styleName, ": ").concat(styles2[styleName].trim(), ";");
  }, "");
}
function transformIsMeaningful(transform) {
  return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
}
function transformForSvg(_ref) {
  let {
    transform,
    containerWidth,
    iconWidth
  } = _ref;
  const outer = {
    transform: "translate(".concat(containerWidth / 2, " 256)")
  };
  const innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
  const innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
  const innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
  const inner = {
    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
  };
  const path3 = {
    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
  };
  return {
    outer,
    inner,
    path: path3
  };
}
function transformForCss(_ref2) {
  let {
    transform,
    width = UNITS_IN_GRID,
    height = UNITS_IN_GRID,
    startCentered = false
  } = _ref2;
  let val = "";
  if (startCentered && IS_IE) {
    val += "translate(".concat(transform.x / d$2 - width / 2, "em, ").concat(transform.y / d$2 - height / 2, "em) ");
  } else if (startCentered) {
    val += "translate(calc(-50% + ".concat(transform.x / d$2, "em), calc(-50% + ").concat(transform.y / d$2, "em)) ");
  } else {
    val += "translate(".concat(transform.x / d$2, "em, ").concat(transform.y / d$2, "em) ");
  }
  val += "scale(".concat(transform.size / d$2 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d$2 * (transform.flipY ? -1 : 1), ") ");
  val += "rotate(".concat(transform.rotate, "deg) ");
  return val;
}
var baseStyles = ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";\n  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";\n  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";\n  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-counter-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(-1 * var(--fa-li-width, 2em));\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  animation-name: fa-beat;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  animation-name: fa-bounce;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  animation-name: fa-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  animation-name: fa-beat-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  animation-name: fa-flip;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  animation-name: fa-shake;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  animation-name: fa-spin;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 2s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  animation-name: fa-spin;\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    animation-delay: -1ms;\n    animation-duration: 1ms;\n    animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    transform: scale(1);\n  }\n  45% {\n    transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-shake {\n  0% {\n    transform: rotate(-15deg);\n  }\n  4% {\n    transform: rotate(15deg);\n  }\n  8%, 24% {\n    transform: rotate(-18deg);\n  }\n  12%, 28% {\n    transform: rotate(18deg);\n  }\n  16% {\n    transform: rotate(-22deg);\n  }\n  20% {\n    transform: rotate(22deg);\n  }\n  32% {\n    transform: rotate(-12deg);\n  }\n  36% {\n    transform: rotate(12deg);\n  }\n  40%, 100% {\n    transform: rotate(0deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  transform: rotate(var(--fa-rotate-angle, 0));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}';
function css() {
  const dcp = DEFAULT_CSS_PREFIX;
  const drc = DEFAULT_REPLACEMENT_CLASS;
  const fp = config2.cssPrefix;
  const rc = config2.replacementClass;
  let s2 = baseStyles;
  if (fp !== dcp || rc !== drc) {
    const dPatt = new RegExp("\\.".concat(dcp, "\\-"), "g");
    const customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), "g");
    const rPatt = new RegExp("\\.".concat(drc), "g");
    s2 = s2.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
  }
  return s2;
}
var _cssInserted = false;
function ensureCss() {
  if (config2.autoAddCss && !_cssInserted) {
    insertCss(css());
    _cssInserted = true;
  }
}
var InjectCSS = {
  mixout() {
    return {
      dom: {
        css,
        insertCss: ensureCss
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        ensureCss();
      },
      beforeI2svg() {
        ensureCss();
      }
    };
  }
};
var w = WINDOW || {};
if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
var namespace = w[NAMESPACE_IDENTIFIER];
var functions = [];
var listener = function() {
  DOCUMENT3.removeEventListener("DOMContentLoaded", listener);
  loaded = 1;
  functions.map((fn) => fn());
};
var loaded = false;
if (IS_DOM) {
  loaded = (DOCUMENT3.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT3.readyState);
  if (!loaded) DOCUMENT3.addEventListener("DOMContentLoaded", listener);
}
function domready(fn) {
  if (!IS_DOM) return;
  loaded ? setTimeout(fn, 0) : functions.push(fn);
}
function toHtml(abstractNodes) {
  const {
    tag,
    attributes = {},
    children: children2 = []
  } = abstractNodes;
  if (typeof abstractNodes === "string") {
    return htmlEscape(abstractNodes);
  } else {
    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children2.map(toHtml).join(""), "</").concat(tag, ">");
  }
}
function iconFromMapping(mapping, prefix, iconName) {
  if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
    return {
      prefix,
      iconName,
      icon: mapping[prefix][iconName]
    };
  }
}
var bindInternal4 = function bindInternal42(func, thisContext) {
  return function(a, b, c, d) {
    return func.call(thisContext, a, b, c, d);
  };
};
var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
  var keys = Object.keys(subject), length = keys.length, iterator2 = thisContext !== void 0 ? bindInternal4(fn, thisContext) : fn, i, key, result;
  if (initialValue === void 0) {
    i = 1;
    result = subject[keys[0]];
  } else {
    i = 0;
    result = initialValue;
  }
  for (; i < length; i++) {
    key = keys[i];
    result = iterator2(result, subject[key], key, subject);
  }
  return result;
};
function ucs2decode(string) {
  const output = [];
  let counter2 = 0;
  const length = string.length;
  while (counter2 < length) {
    const value2 = string.charCodeAt(counter2++);
    if (value2 >= 55296 && value2 <= 56319 && counter2 < length) {
      const extra = string.charCodeAt(counter2++);
      if ((extra & 64512) == 56320) {
        output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value2);
        counter2--;
      }
    } else {
      output.push(value2);
    }
  }
  return output;
}
function toHex(unicode) {
  const decoded = ucs2decode(unicode);
  return decoded.length === 1 ? decoded[0].toString(16) : null;
}
function codePointAt(string, index) {
  const size2 = string.length;
  let first2 = string.charCodeAt(index);
  let second2;
  if (first2 >= 55296 && first2 <= 56319 && size2 > index + 1) {
    second2 = string.charCodeAt(index + 1);
    if (second2 >= 56320 && second2 <= 57343) {
      return (first2 - 55296) * 1024 + second2 - 56320 + 65536;
    }
  }
  return first2;
}
function normalizeIcons(icons) {
  return Object.keys(icons).reduce((acc, iconName) => {
    const icon2 = icons[iconName];
    const expanded = !!icon2.icon;
    if (expanded) {
      acc[icon2.iconName] = icon2.icon;
    } else {
      acc[iconName] = icon2;
    }
    return acc;
  }, {});
}
function defineIcons(prefix, icons) {
  let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks = false
  } = params;
  const normalized = normalizeIcons(icons);
  if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
    namespace.hooks.addPack(prefix, normalizeIcons(icons));
  } else {
    namespace.styles[prefix] = _objectSpread2(_objectSpread2({}, namespace.styles[prefix] || {}), normalized);
  }
  if (prefix === "fas") {
    defineIcons("fa", icons);
  }
}
var {
  styles,
  shims
} = namespace;
var FAMILY_NAMES = Object.keys(PREFIX_TO_LONG_STYLE);
var PREFIXES_FOR_FAMILY = FAMILY_NAMES.reduce((acc, familyId) => {
  acc[familyId] = Object.keys(PREFIX_TO_LONG_STYLE[familyId]);
  return acc;
}, {});
var _defaultUsablePrefix = null;
var _byUnicode = {};
var _byLigature = {};
var _byOldName = {};
var _byOldUnicode = {};
var _byAlias = {};
function isReserved(name) {
  return ~RESERVED_CLASSES.indexOf(name);
}
function getIconName(cssPrefix, cls) {
  const parts = cls.split("-");
  const prefix = parts[0];
  const iconName = parts.slice(1).join("-");
  if (prefix === cssPrefix && iconName !== "" && !isReserved(iconName)) {
    return iconName;
  } else {
    return null;
  }
}
var build = () => {
  const lookup = (reducer) => {
    return reduce(styles, (o$$1, style2, prefix) => {
      o$$1[prefix] = reduce(style2, reducer, {});
      return o$$1;
    }, {});
  };
  _byUnicode = lookup((acc, icon2, iconName) => {
    if (icon2[3]) {
      acc[icon2[3]] = iconName;
    }
    if (icon2[2]) {
      const aliases = icon2[2].filter((a$$1) => {
        return typeof a$$1 === "number";
      });
      aliases.forEach((alias) => {
        acc[alias.toString(16)] = iconName;
      });
    }
    return acc;
  });
  _byLigature = lookup((acc, icon2, iconName) => {
    acc[iconName] = iconName;
    if (icon2[2]) {
      const aliases = icon2[2].filter((a$$1) => {
        return typeof a$$1 === "string";
      });
      aliases.forEach((alias) => {
        acc[alias] = iconName;
      });
    }
    return acc;
  });
  _byAlias = lookup((acc, icon2, iconName) => {
    const aliases = icon2[2];
    acc[iconName] = iconName;
    aliases.forEach((alias) => {
      acc[alias] = iconName;
    });
    return acc;
  });
  const hasRegular = "far" in styles || config2.autoFetchSvg;
  const shimLookups = reduce(shims, (acc, shim) => {
    const maybeNameMaybeUnicode = shim[0];
    let prefix = shim[1];
    const iconName = shim[2];
    if (prefix === "far" && !hasRegular) {
      prefix = "fas";
    }
    if (typeof maybeNameMaybeUnicode === "string") {
      acc.names[maybeNameMaybeUnicode] = {
        prefix,
        iconName
      };
    }
    if (typeof maybeNameMaybeUnicode === "number") {
      acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
        prefix,
        iconName
      };
    }
    return acc;
  }, {
    names: {},
    unicodes: {}
  });
  _byOldName = shimLookups.names;
  _byOldUnicode = shimLookups.unicodes;
  _defaultUsablePrefix = getCanonicalPrefix(config2.styleDefault, {
    family: config2.familyDefault
  });
};
onChange((c$$1) => {
  _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
    family: config2.familyDefault
  });
});
build();
function byUnicode(prefix, unicode) {
  return (_byUnicode[prefix] || {})[unicode];
}
function byLigature(prefix, ligature) {
  return (_byLigature[prefix] || {})[ligature];
}
function byAlias(prefix, alias) {
  return (_byAlias[prefix] || {})[alias];
}
function byOldName(name) {
  return _byOldName[name] || {
    prefix: null,
    iconName: null
  };
}
function byOldUnicode(unicode) {
  const oldUnicode = _byOldUnicode[unicode];
  const newUnicode = byUnicode("fas", unicode);
  return oldUnicode || (newUnicode ? {
    prefix: "fas",
    iconName: newUnicode
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function getDefaultUsablePrefix() {
  return _defaultUsablePrefix;
}
var emptyCanonicalIcon = () => {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function getFamilyId(values) {
  let family = s;
  const famProps = FAMILY_NAMES.reduce((acc, familyId) => {
    acc[familyId] = "".concat(config2.cssPrefix, "-").concat(familyId);
    return acc;
  }, {});
  L.forEach((familyId) => {
    if (values.includes(famProps[familyId]) || values.some((v$$1) => PREFIXES_FOR_FAMILY[familyId].includes(v$$1))) {
      family = familyId;
    }
  });
  return family;
}
function getCanonicalPrefix(styleOrPrefix) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family = s
  } = params;
  const style2 = PREFIX_TO_STYLE[family][styleOrPrefix];
  if (family === t && !styleOrPrefix) {
    return "fad";
  }
  const prefix = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style2];
  const defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
  const result = prefix || defined || null;
  return result;
}
function moveNonFaClassesToRest(classNames) {
  let rest = [];
  let iconName = null;
  classNames.forEach((cls) => {
    const result = getIconName(config2.cssPrefix, cls);
    if (result) {
      iconName = result;
    } else if (cls) {
      rest.push(cls);
    }
  });
  return {
    iconName,
    rest
  };
}
function sortedUniqueValues(arr) {
  return arr.sort().filter((value2, index, arr2) => {
    return arr2.indexOf(value2) === index;
  });
}
function getCanonicalIcon(values) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups = false
  } = params;
  let givenPrefix = null;
  const faCombinedClasses = xo.concat(bt$1);
  const faStyleOrFamilyClasses = sortedUniqueValues(values.filter((cls) => faCombinedClasses.includes(cls)));
  const nonStyleOrFamilyClasses = sortedUniqueValues(values.filter((cls) => !xo.includes(cls)));
  const faStyles = faStyleOrFamilyClasses.filter((cls) => {
    givenPrefix = cls;
    return !P.includes(cls);
  });
  const [styleFromValues = null] = faStyles;
  const family = getFamilyId(faStyleOrFamilyClasses);
  const canonical = _objectSpread2(_objectSpread2({}, moveNonFaClassesToRest(nonStyleOrFamilyClasses)), {}, {
    prefix: getCanonicalPrefix(styleFromValues, {
      family
    })
  });
  return _objectSpread2(_objectSpread2(_objectSpread2({}, canonical), getDefaultCanonicalPrefix({
    values,
    family,
    styles,
    config: config2,
    canonical,
    givenPrefix
  })), applyShimAndAlias(skipLookups, givenPrefix, canonical));
}
function applyShimAndAlias(skipLookups, givenPrefix, canonical) {
  let {
    prefix,
    iconName
  } = canonical;
  if (skipLookups || !prefix || !iconName) {
    return {
      prefix,
      iconName
    };
  }
  const shim = givenPrefix === "fa" ? byOldName(iconName) : {};
  const aliasIconName = byAlias(prefix, iconName);
  iconName = shim.iconName || aliasIconName || iconName;
  prefix = shim.prefix || prefix;
  if (prefix === "far" && !styles["far"] && styles["fas"] && !config2.autoFetchSvg) {
    prefix = "fas";
  }
  return {
    prefix,
    iconName
  };
}
var newCanonicalFamilies = L.filter((familyId) => {
  return familyId !== s || familyId !== t;
});
var newCanonicalStyles = Object.keys(co).filter((key) => key !== s).map((key) => Object.keys(co[key])).flat();
function getDefaultCanonicalPrefix(prefixOptions) {
  const {
    values,
    family,
    canonical,
    givenPrefix = "",
    styles: styles2 = {},
    config: config$$1 = {}
  } = prefixOptions;
  const isDuotoneFamily = family === t;
  const valuesHasDuotone = values.includes("fa-duotone") || values.includes("fad");
  const defaultFamilyIsDuotone = config$$1.familyDefault === "duotone";
  const canonicalPrefixIsDuotone = canonical.prefix === "fad" || canonical.prefix === "fa-duotone";
  if (!isDuotoneFamily && (valuesHasDuotone || defaultFamilyIsDuotone || canonicalPrefixIsDuotone)) {
    canonical.prefix = "fad";
  }
  if (values.includes("fa-brands") || values.includes("fab")) {
    canonical.prefix = "fab";
  }
  if (!canonical.prefix && newCanonicalFamilies.includes(family)) {
    const validPrefix = Object.keys(styles2).find((key) => newCanonicalStyles.includes(key));
    if (validPrefix || config$$1.autoFetchSvg) {
      const defaultPrefix = pt.get(family).defaultShortPrefixId;
      canonical.prefix = defaultPrefix;
      canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
    }
  }
  if (canonical.prefix === "fa" || givenPrefix === "fa") {
    canonical.prefix = getDefaultUsablePrefix() || "fas";
  }
  return canonical;
}
var Library = class {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
      definitions[_key] = arguments[_key];
    }
    const additions = definitions.reduce(this._pullDefinitions, {});
    Object.keys(additions).forEach((key) => {
      this.definitions[key] = _objectSpread2(_objectSpread2({}, this.definitions[key] || {}), additions[key]);
      defineIcons(key, additions[key]);
      const longPrefix = PREFIX_TO_LONG_STYLE[s][key];
      if (longPrefix) defineIcons(longPrefix, additions[key]);
      build();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(additions, definition) {
    const normalized = definition.prefix && definition.iconName && definition.icon ? {
      0: definition
    } : definition;
    Object.keys(normalized).map((key) => {
      const {
        prefix,
        iconName,
        icon: icon2
      } = normalized[key];
      const aliases = icon2[2];
      if (!additions[prefix]) additions[prefix] = {};
      if (aliases.length > 0) {
        aliases.forEach((alias) => {
          if (typeof alias === "string") {
            additions[prefix][alias] = icon2;
          }
        });
      }
      additions[prefix][iconName] = icon2;
    });
    return additions;
  }
};
var _plugins = [];
var _hooks = {};
var providers = {};
var defaultProviderKeys = Object.keys(providers);
function registerPlugins(nextPlugins, _ref) {
  let {
    mixoutsTo: obj
  } = _ref;
  _plugins = nextPlugins;
  _hooks = {};
  Object.keys(providers).forEach((k) => {
    if (defaultProviderKeys.indexOf(k) === -1) {
      delete providers[k];
    }
  });
  _plugins.forEach((plugin) => {
    const mixout = plugin.mixout ? plugin.mixout() : {};
    Object.keys(mixout).forEach((tk) => {
      if (typeof mixout[tk] === "function") {
        obj[tk] = mixout[tk];
      }
      if (typeof mixout[tk] === "object") {
        Object.keys(mixout[tk]).forEach((sk) => {
          if (!obj[tk]) {
            obj[tk] = {};
          }
          obj[tk][sk] = mixout[tk][sk];
        });
      }
    });
    if (plugin.hooks) {
      const hooks = plugin.hooks();
      Object.keys(hooks).forEach((hook) => {
        if (!_hooks[hook]) {
          _hooks[hook] = [];
        }
        _hooks[hook].push(hooks[hook]);
      });
    }
    if (plugin.provides) {
      plugin.provides(providers);
    }
  });
  return obj;
}
function chainHooks(hook, accumulator) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach((hookFn) => {
    accumulator = hookFn.apply(null, [accumulator, ...args]);
  });
  return accumulator;
}
function callHooks2(hook) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  const hookFns = _hooks[hook] || [];
  hookFns.forEach((hookFn) => {
    hookFn.apply(null, args);
  });
  return void 0;
}
function callProvided() {
  const hook = arguments[0];
  const args = Array.prototype.slice.call(arguments, 1);
  return providers[hook] ? providers[hook].apply(null, args) : void 0;
}
function findIconDefinition(iconLookup) {
  if (iconLookup.prefix === "fa") {
    iconLookup.prefix = "fas";
  }
  let {
    iconName
  } = iconLookup;
  const prefix = iconLookup.prefix || getDefaultUsablePrefix();
  if (!iconName) return;
  iconName = byAlias(prefix, iconName) || iconName;
  return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
}
var library = new Library();
var noAuto = () => {
  config2.autoReplaceSvg = false;
  config2.observeMutations = false;
  callHooks2("noAuto");
};
var dom = {
  i2svg: function() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (IS_DOM) {
      callHooks2("beforeI2svg", params);
      callProvided("pseudoElements2svg", params);
      return callProvided("i2svg", params);
    } else {
      return Promise.reject(new Error("Operation requires a DOM of some kind."));
    }
  },
  watch: function() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot
    } = params;
    if (config2.autoReplaceSvg === false) {
      config2.autoReplaceSvg = true;
    }
    config2.observeMutations = true;
    domready(() => {
      autoReplace({
        autoReplaceSvgRoot
      });
      callHooks2("watch", params);
    });
  }
};
var parse = {
  icon: (icon2) => {
    if (icon2 === null) {
      return null;
    }
    if (typeof icon2 === "object" && icon2.prefix && icon2.iconName) {
      return {
        prefix: icon2.prefix,
        iconName: byAlias(icon2.prefix, icon2.iconName) || icon2.iconName
      };
    }
    if (Array.isArray(icon2) && icon2.length === 2) {
      const iconName = icon2[1].indexOf("fa-") === 0 ? icon2[1].slice(3) : icon2[1];
      const prefix = getCanonicalPrefix(icon2[0]);
      return {
        prefix,
        iconName: byAlias(prefix, iconName) || iconName
      };
    }
    if (typeof icon2 === "string" && (icon2.indexOf("".concat(config2.cssPrefix, "-")) > -1 || icon2.match(ICON_SELECTION_SYNTAX_PATTERN))) {
      const canonicalIcon = getCanonicalIcon(icon2.split(" "), {
        skipLookups: true
      });
      return {
        prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
        iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
      };
    }
    if (typeof icon2 === "string") {
      const prefix = getDefaultUsablePrefix();
      return {
        prefix,
        iconName: byAlias(prefix, icon2) || icon2
      };
    }
  }
};
var api = {
  noAuto,
  config: config2,
  dom,
  parse,
  library,
  findIconDefinition,
  toHtml
};
var autoReplace = function() {
  let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot = DOCUMENT3
  } = params;
  if ((Object.keys(namespace.styles).length > 0 || config2.autoFetchSvg) && IS_DOM && config2.autoReplaceSvg) api.dom.i2svg({
    node: autoReplaceSvgRoot
  });
};
function domVariants(val, abstractCreator) {
  Object.defineProperty(val, "abstract", {
    get: abstractCreator
  });
  Object.defineProperty(val, "html", {
    get: function() {
      return val.abstract.map((a) => toHtml(a));
    }
  });
  Object.defineProperty(val, "node", {
    get: function() {
      if (!IS_DOM) return;
      const container = DOCUMENT3.createElement("div");
      container.innerHTML = val.html;
      return container.children;
    }
  });
  return val;
}
function asIcon(_ref) {
  let {
    children: children2,
    main,
    mask,
    attributes,
    styles: styles2,
    transform
  } = _ref;
  if (transformIsMeaningful(transform) && main.found && !mask.found) {
    const {
      width,
      height
    } = main;
    const offset2 = {
      x: width / height / 2,
      y: 0.5
    };
    attributes["style"] = joinStyles(_objectSpread2(_objectSpread2({}, styles2), {}, {
      "transform-origin": "".concat(offset2.x + transform.x / 16, "em ").concat(offset2.y + transform.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes,
    children: children2
  }];
}
function asSymbol(_ref) {
  let {
    prefix,
    iconName,
    children: children2,
    attributes,
    symbol
  } = _ref;
  const id3 = symbol === true ? "".concat(prefix, "-").concat(config2.cssPrefix, "-").concat(iconName) : symbol;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: _objectSpread2(_objectSpread2({}, attributes), {}, {
        id: id3
      }),
      children: children2
    }]
  }];
}
function makeInlineSvgAbstract(params) {
  const {
    icons: {
      main,
      mask
    },
    prefix,
    iconName,
    transform,
    symbol,
    title,
    maskId,
    titleId,
    extra,
    watchable = false
  } = params;
  const {
    width,
    height
  } = mask.found ? mask : main;
  const isUploadedIcon = Lt.includes(prefix);
  const attrClass = [config2.replacementClass, iconName ? "".concat(config2.cssPrefix, "-").concat(iconName) : ""].filter((c$$1) => extra.classes.indexOf(c$$1) === -1).filter((c$$1) => c$$1 !== "" || !!c$$1).concat(extra.classes).join(" ");
  let content = {
    children: [],
    attributes: _objectSpread2(_objectSpread2({}, extra.attributes), {}, {
      "data-prefix": prefix,
      "data-icon": iconName,
      "class": attrClass,
      "role": extra.attributes.role || "img",
      "xmlns": "http://www.w3.org/2000/svg",
      "viewBox": "0 0 ".concat(width, " ").concat(height)
    })
  };
  const uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
    width: "".concat(width / height * 16 * 0.0625, "em")
  } : {};
  if (watchable) {
    content.attributes[DATA_FA_I2SVG] = "";
  }
  if (title) {
    content.children.push({
      tag: "title",
      attributes: {
        id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
      },
      children: [title]
    });
    delete content.attributes.title;
  }
  const args = _objectSpread2(_objectSpread2({}, content), {}, {
    prefix,
    iconName,
    main,
    mask,
    maskId,
    transform,
    symbol,
    styles: _objectSpread2(_objectSpread2({}, uploadedIconWidthStyle), extra.styles)
  });
  const {
    children: children2,
    attributes
  } = mask.found && main.found ? callProvided("generateAbstractMask", args) || {
    children: [],
    attributes: {}
  } : callProvided("generateAbstractIcon", args) || {
    children: [],
    attributes: {}
  };
  args.children = children2;
  args.attributes = attributes;
  if (symbol) {
    return asSymbol(args);
  } else {
    return asIcon(args);
  }
}
function makeLayersTextAbstract(params) {
  const {
    content,
    width,
    height,
    transform,
    title,
    extra,
    watchable = false
  } = params;
  const attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
    "title": title
  } : {}), {}, {
    "class": extra.classes.join(" ")
  });
  if (watchable) {
    attributes[DATA_FA_I2SVG] = "";
  }
  const styles2 = _objectSpread2({}, extra.styles);
  if (transformIsMeaningful(transform)) {
    styles2["transform"] = transformForCss({
      transform,
      startCentered: true,
      width,
      height
    });
    styles2["-webkit-transform"] = styles2["transform"];
  }
  const styleString = joinStyles(styles2);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  const val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
function makeLayersCounterAbstract(params) {
  const {
    content,
    title,
    extra
  } = params;
  const attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
    "title": title
  } : {}), {}, {
    "class": extra.classes.join(" ")
  });
  const styleString = joinStyles(extra.styles);
  if (styleString.length > 0) {
    attributes["style"] = styleString;
  }
  const val = [];
  val.push({
    tag: "span",
    attributes,
    children: [content]
  });
  if (title) {
    val.push({
      tag: "span",
      attributes: {
        class: "sr-only"
      },
      children: [title]
    });
  }
  return val;
}
var {
  styles: styles$1
} = namespace;
function asFoundIcon(icon2) {
  const width = icon2[0];
  const height = icon2[1];
  const [vectorData] = icon2.slice(4);
  let element = null;
  if (Array.isArray(vectorData)) {
    element = {
      tag: "g",
      attributes: {
        class: "".concat(config2.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(config2.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
          fill: "currentColor",
          d: vectorData[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(config2.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
          fill: "currentColor",
          d: vectorData[1]
        }
      }]
    };
  } else {
    element = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: vectorData
      }
    };
  }
  return {
    found: true,
    width,
    height,
    icon: element
  };
}
var missingIconResolutionMixin = {
  found: false,
  width: 512,
  height: 512
};
function maybeNotifyMissing(iconName, prefix) {
  if (!PRODUCTION && !config2.showMissingIcons && iconName) {
    console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix, '" is missing.'));
  }
}
function findIcon(iconName, prefix) {
  let givenPrefix = prefix;
  if (prefix === "fa" && config2.styleDefault !== null) {
    prefix = getDefaultUsablePrefix();
  }
  return new Promise((resolve, reject) => {
    if (givenPrefix === "fa") {
      const shim = byOldName(iconName) || {};
      iconName = shim.iconName || iconName;
      prefix = shim.prefix || prefix;
    }
    if (iconName && prefix && styles$1[prefix] && styles$1[prefix][iconName]) {
      const icon2 = styles$1[prefix][iconName];
      return resolve(asFoundIcon(icon2));
    }
    maybeNotifyMissing(iconName, prefix);
    resolve(_objectSpread2(_objectSpread2({}, missingIconResolutionMixin), {}, {
      icon: config2.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
    }));
  });
}
var noop$1 = () => {
};
var p$2 = config2.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
  mark: noop$1,
  measure: noop$1
};
var preamble = 'FA "6.7.1"';
var begin = (name) => {
  p$2.mark("".concat(preamble, " ").concat(name, " begins"));
  return () => end(name);
};
var end = (name) => {
  p$2.mark("".concat(preamble, " ").concat(name, " ends"));
  p$2.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
};
var perf = {
  begin,
  end
};
var noop$2 = () => {
};
function isWatched(node) {
  const i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
  return typeof i2svg === "string";
}
function hasPrefixAndIcon(node) {
  const prefix = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
  const icon2 = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
  return prefix && icon2;
}
function hasBeenReplaced(node) {
  return node && node.classList && node.classList.contains && node.classList.contains(config2.replacementClass);
}
function getMutator() {
  if (config2.autoReplaceSvg === true) {
    return mutators.replace;
  }
  const mutator = mutators[config2.autoReplaceSvg];
  return mutator || mutators.replace;
}
function createElementNS(tag) {
  return DOCUMENT3.createElementNS("http://www.w3.org/2000/svg", tag);
}
function createElement(tag) {
  return DOCUMENT3.createElement(tag);
}
function convertSVG(abstractObj) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn = abstractObj.tag === "svg" ? createElementNS : createElement
  } = params;
  if (typeof abstractObj === "string") {
    return DOCUMENT3.createTextNode(abstractObj);
  }
  const tag = ceFn(abstractObj.tag);
  Object.keys(abstractObj.attributes || []).forEach(function(key) {
    tag.setAttribute(key, abstractObj.attributes[key]);
  });
  const children2 = abstractObj.children || [];
  children2.forEach(function(child) {
    tag.appendChild(convertSVG(child, {
      ceFn
    }));
  });
  return tag;
}
function nodeAsComment(node) {
  let comment = " ".concat(node.outerHTML, " ");
  comment = "".concat(comment, "Font Awesome fontawesome.com ");
  return comment;
}
var mutators = {
  replace: function(mutation) {
    const node = mutation[0];
    if (node.parentNode) {
      mutation[1].forEach((abstract) => {
        node.parentNode.insertBefore(convertSVG(abstract), node);
      });
      if (node.getAttribute(DATA_FA_I2SVG) === null && config2.keepOriginalSource) {
        let comment = DOCUMENT3.createComment(nodeAsComment(node));
        node.parentNode.replaceChild(comment, node);
      } else {
        node.remove();
      }
    }
  },
  nest: function(mutation) {
    const node = mutation[0];
    const abstract = mutation[1];
    if (~classArray(node).indexOf(config2.replacementClass)) {
      return mutators.replace(mutation);
    }
    const forSvg = new RegExp("".concat(config2.cssPrefix, "-.*"));
    delete abstract[0].attributes.id;
    if (abstract[0].attributes.class) {
      const splitClasses = abstract[0].attributes.class.split(" ").reduce((acc, cls) => {
        if (cls === config2.replacementClass || cls.match(forSvg)) {
          acc.toSvg.push(cls);
        } else {
          acc.toNode.push(cls);
        }
        return acc;
      }, {
        toNode: [],
        toSvg: []
      });
      abstract[0].attributes.class = splitClasses.toSvg.join(" ");
      if (splitClasses.toNode.length === 0) {
        node.removeAttribute("class");
      } else {
        node.setAttribute("class", splitClasses.toNode.join(" "));
      }
    }
    const newInnerHTML = abstract.map((a) => toHtml(a)).join("\n");
    node.setAttribute(DATA_FA_I2SVG, "");
    node.innerHTML = newInnerHTML;
  }
};
function performOperationSync(op) {
  op();
}
function perform(mutations, callback) {
  const callbackFunction = typeof callback === "function" ? callback : noop$2;
  if (mutations.length === 0) {
    callbackFunction();
  } else {
    let frame2 = performOperationSync;
    if (config2.mutateApproach === MUTATION_APPROACH_ASYNC) {
      frame2 = WINDOW.requestAnimationFrame || performOperationSync;
    }
    frame2(() => {
      const mutator = getMutator();
      const mark = perf.begin("mutate");
      mutations.map(mutator);
      mark();
      callbackFunction();
    });
  }
}
var disabled = false;
function disableObservation() {
  disabled = true;
}
function enableObservation() {
  disabled = false;
}
var mo$1 = null;
function observe(options) {
  if (!MUTATION_OBSERVER) {
    return;
  }
  if (!config2.observeMutations) {
    return;
  }
  const {
    treeCallback = noop$2,
    nodeCallback = noop$2,
    pseudoElementsCallback = noop$2,
    observeMutationsRoot = DOCUMENT3
  } = options;
  mo$1 = new MUTATION_OBSERVER((objects) => {
    if (disabled) return;
    const defaultPrefix = getDefaultUsablePrefix();
    toArray(objects).forEach((mutationRecord) => {
      if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
        if (config2.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target);
        }
        treeCallback(mutationRecord.target);
      }
      if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config2.searchPseudoElements) {
        pseudoElementsCallback(mutationRecord.target.parentNode);
      }
      if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
        if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
          const {
            prefix,
            iconName
          } = getCanonicalIcon(classArray(mutationRecord.target));
          mutationRecord.target.setAttribute(DATA_PREFIX, prefix || defaultPrefix);
          if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
        } else if (hasBeenReplaced(mutationRecord.target)) {
          nodeCallback(mutationRecord.target);
        }
      }
    });
  });
  if (!IS_DOM) return;
  mo$1.observe(observeMutationsRoot, {
    childList: true,
    attributes: true,
    characterData: true,
    subtree: true
  });
}
function disconnect() {
  if (!mo$1) return;
  mo$1.disconnect();
}
function styleParser(node) {
  const style2 = node.getAttribute("style");
  let val = [];
  if (style2) {
    val = style2.split(";").reduce((acc, style3) => {
      const styles2 = style3.split(":");
      const prop = styles2[0];
      const value2 = styles2.slice(1);
      if (prop && value2.length > 0) {
        acc[prop] = value2.join(":").trim();
      }
      return acc;
    }, {});
  }
  return val;
}
function classParser(node) {
  const existingPrefix = node.getAttribute("data-prefix");
  const existingIconName = node.getAttribute("data-icon");
  const innerText = node.innerText !== void 0 ? node.innerText.trim() : "";
  let val = getCanonicalIcon(classArray(node));
  if (!val.prefix) {
    val.prefix = getDefaultUsablePrefix();
  }
  if (existingPrefix && existingIconName) {
    val.prefix = existingPrefix;
    val.iconName = existingIconName;
  }
  if (val.iconName && val.prefix) {
    return val;
  }
  if (val.prefix && innerText.length > 0) {
    val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
  }
  if (!val.iconName && config2.autoFetchSvg && node.firstChild && node.firstChild.nodeType === Node.TEXT_NODE) {
    val.iconName = node.firstChild.data;
  }
  return val;
}
function attributesParser(node) {
  const extraAttributes = toArray(node.attributes).reduce((acc, attr) => {
    if (acc.name !== "class" && acc.name !== "style") {
      acc[attr.name] = attr.value;
    }
    return acc;
  }, {});
  const title = node.getAttribute("title");
  const titleId = node.getAttribute("data-fa-title-id");
  if (config2.autoA11y) {
    if (title) {
      extraAttributes["aria-labelledby"] = "".concat(config2.replacementClass, "-title-").concat(titleId || nextUniqueId());
    } else {
      extraAttributes["aria-hidden"] = "true";
      extraAttributes["focusable"] = "false";
    }
  }
  return extraAttributes;
}
function blankMeta() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: meaninglessTransform,
    symbol: false,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function parseMeta(node) {
  let parser = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: true
  };
  const {
    iconName,
    prefix,
    rest: extraClasses
  } = classParser(node);
  const extraAttributes = attributesParser(node);
  const pluginMeta = chainHooks("parseNodeAttributes", {}, node);
  let extraStyles = parser.styleParser ? styleParser(node) : [];
  return _objectSpread2({
    iconName,
    title: node.getAttribute("title"),
    titleId: node.getAttribute("data-fa-title-id"),
    prefix,
    transform: meaninglessTransform,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: false,
    extra: {
      classes: extraClasses,
      styles: extraStyles,
      attributes: extraAttributes
    }
  }, pluginMeta);
}
var {
  styles: styles$2
} = namespace;
function generateMutation(node) {
  const nodeMeta = config2.autoReplaceSvg === "nest" ? parseMeta(node, {
    styleParser: false
  }) : parseMeta(node);
  if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
    return callProvided("generateLayersText", node, nodeMeta);
  } else {
    return callProvided("generateSvgReplacementMutation", node, nodeMeta);
  }
}
function getKnownPrefixes() {
  return [...Ft, ...xo];
}
function onTree(root3) {
  let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!IS_DOM) return Promise.resolve();
  const htmlClassList = DOCUMENT3.documentElement.classList;
  const hclAdd = (suffix) => htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const hclRemove = (suffix) => htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
  const prefixes2 = config2.autoFetchSvg ? getKnownPrefixes() : P.concat(Object.keys(styles$2));
  if (!prefixes2.includes("fa")) {
    prefixes2.push("fa");
  }
  const prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes2.map((p$$1) => ".".concat(p$$1, ":not([").concat(DATA_FA_I2SVG, "])"))).join(", ");
  if (prefixesDomQuery.length === 0) {
    return Promise.resolve();
  }
  let candidates = [];
  try {
    candidates = toArray(root3.querySelectorAll(prefixesDomQuery));
  } catch (e$$1) {
  }
  if (candidates.length > 0) {
    hclAdd("pending");
    hclRemove("complete");
  } else {
    return Promise.resolve();
  }
  const mark = perf.begin("onTree");
  const mutations = candidates.reduce((acc, node) => {
    try {
      const mutation = generateMutation(node);
      if (mutation) {
        acc.push(mutation);
      }
    } catch (e$$1) {
      if (!PRODUCTION) {
        if (e$$1.name === "MissingIcon") {
          console.error(e$$1);
        }
      }
    }
    return acc;
  }, []);
  return new Promise((resolve, reject) => {
    Promise.all(mutations).then((resolvedMutations) => {
      perform(resolvedMutations, () => {
        hclAdd("active");
        hclAdd("complete");
        hclRemove("pending");
        if (typeof callback === "function") callback();
        mark();
        resolve();
      });
    }).catch((e$$1) => {
      mark();
      reject(e$$1);
    });
  });
}
function onNode(node) {
  let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  generateMutation(node).then((mutation) => {
    if (mutation) {
      perform([mutation], callback);
    }
  });
}
function resolveIcons(next) {
  return function(maybeIconDefinition) {
    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
    let {
      mask
    } = params;
    if (mask) {
      mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
    }
    return next(iconDefinition, _objectSpread2(_objectSpread2({}, params), {}, {
      mask
    }));
  };
}
var render = function(iconDefinition) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform = meaninglessTransform,
    symbol = false,
    mask = null,
    maskId = null,
    title = null,
    titleId = null,
    classes = [],
    attributes = {},
    styles: styles2 = {}
  } = params;
  if (!iconDefinition) return;
  const {
    prefix,
    iconName,
    icon: icon2
  } = iconDefinition;
  return domVariants(_objectSpread2({
    type: "icon"
  }, iconDefinition), () => {
    callHooks2("beforeDOMElementCreation", {
      iconDefinition,
      params
    });
    if (config2.autoA11y) {
      if (title) {
        attributes["aria-labelledby"] = "".concat(config2.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        attributes["aria-hidden"] = "true";
        attributes["focusable"] = "false";
      }
    }
    return makeInlineSvgAbstract({
      icons: {
        main: asFoundIcon(icon2),
        mask: mask ? asFoundIcon(mask.icon) : {
          found: false,
          width: null,
          height: null,
          icon: {}
        }
      },
      prefix,
      iconName,
      transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
      symbol,
      title,
      maskId,
      titleId,
      extra: {
        attributes,
        styles: styles2,
        classes
      }
    });
  });
};
var ReplaceElements = {
  mixout() {
    return {
      icon: resolveIcons(render)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(accumulator) {
        accumulator.treeCallback = onTree;
        accumulator.nodeCallback = onNode;
        return accumulator;
      }
    };
  },
  provides(providers$$1) {
    providers$$1.i2svg = function(params) {
      const {
        node = DOCUMENT3,
        callback = () => {
        }
      } = params;
      return onTree(node, callback);
    };
    providers$$1.generateSvgReplacementMutation = function(node, nodeMeta) {
      const {
        iconName,
        title,
        titleId,
        prefix,
        transform,
        symbol,
        mask,
        maskId,
        extra
      } = nodeMeta;
      return new Promise((resolve, reject) => {
        Promise.all([findIcon(iconName, prefix), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
          found: false,
          width: 512,
          height: 512,
          icon: {}
        })]).then((_ref) => {
          let [main, mask2] = _ref;
          resolve([node, makeInlineSvgAbstract({
            icons: {
              main,
              mask: mask2
            },
            prefix,
            iconName,
            transform,
            symbol,
            maskId,
            title,
            titleId,
            extra,
            watchable: true
          })]);
        }).catch(reject);
      });
    };
    providers$$1.generateAbstractIcon = function(_ref2) {
      let {
        children: children2,
        attributes,
        main,
        transform,
        styles: styles2
      } = _ref2;
      const styleString = joinStyles(styles2);
      if (styleString.length > 0) {
        attributes["style"] = styleString;
      }
      let nextChild;
      if (transformIsMeaningful(transform)) {
        nextChild = callProvided("generateAbstractTransformGrouping", {
          main,
          transform,
          containerWidth: main.width,
          iconWidth: main.width
        });
      }
      children2.push(nextChild || main.icon);
      return {
        children: children2,
        attributes
      };
    };
  }
};
var Layers = {
  mixout() {
    return {
      layer(assembler) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes = []
        } = params;
        return domVariants({
          type: "layer"
        }, () => {
          callHooks2("beforeDOMElementCreation", {
            assembler,
            params
          });
          let children2 = [];
          assembler((args) => {
            Array.isArray(args) ? args.map((a) => {
              children2 = children2.concat(a.abstract);
            }) : children2 = children2.concat(args.abstract);
          });
          return [{
            tag: "span",
            attributes: {
              class: ["".concat(config2.cssPrefix, "-layers"), ...classes].join(" ")
            },
            children: children2
          }];
        });
      }
    };
  }
};
var LayersCounter = {
  mixout() {
    return {
      counter(content) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title = null,
          classes = [],
          attributes = {},
          styles: styles2 = {}
        } = params;
        return domVariants({
          type: "counter",
          content
        }, () => {
          callHooks2("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersCounterAbstract({
            content: content.toString(),
            title,
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config2.cssPrefix, "-layers-counter"), ...classes]
            }
          });
        });
      }
    };
  }
};
var LayersText = {
  mixout() {
    return {
      text(content) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform = meaninglessTransform,
          title = null,
          classes = [],
          attributes = {},
          styles: styles2 = {}
        } = params;
        return domVariants({
          type: "text",
          content
        }, () => {
          callHooks2("beforeDOMElementCreation", {
            content,
            params
          });
          return makeLayersTextAbstract({
            content,
            transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
            title,
            extra: {
              attributes,
              styles: styles2,
              classes: ["".concat(config2.cssPrefix, "-layers-text"), ...classes]
            }
          });
        });
      }
    };
  },
  provides(providers$$1) {
    providers$$1.generateLayersText = function(node, nodeMeta) {
      const {
        title,
        transform,
        extra
      } = nodeMeta;
      let width = null;
      let height = null;
      if (IS_IE) {
        const computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
        const boundingClientRect = node.getBoundingClientRect();
        width = boundingClientRect.width / computedFontSize;
        height = boundingClientRect.height / computedFontSize;
      }
      if (config2.autoA11y && !title) {
        extra.attributes["aria-hidden"] = "true";
      }
      return Promise.resolve([node, makeLayersTextAbstract({
        content: node.innerHTML,
        width,
        height,
        transform,
        title,
        extra,
        watchable: true
      })]);
    };
  }
};
var CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
var SECONDARY_UNICODE_RANGE = [1105920, 1112319];
var _FONT_FAMILY_WEIGHT_TO_PREFIX = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), lt), ko), Yt);
var FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, key) => {
  acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
  return acc;
}, {});
var FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, fontFamily) => {
  const weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
  acc[fontFamily] = weights[900] || [...Object.entries(weights)][0][1];
  return acc;
}, {});
function hexValueFromContent(content) {
  const cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
  const codePoint = codePointAt(cleaned, 0);
  const isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
  const isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
  return {
    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
    isSecondary: isPrependTen || isDoubled
  };
}
function getPrefix(fontFamily, fontWeight) {
  const fontFamilySanitized = fontFamily.replace(/^['"]|['"]$/g, "").toLowerCase();
  const fontWeightInteger = parseInt(fontWeight);
  const fontWeightSanitized = isNaN(fontWeightInteger) ? "normal" : fontWeightInteger;
  return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
}
function replaceForPosition(node, position) {
  const pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(":", "-"));
  return new Promise((resolve, reject) => {
    if (node.getAttribute(pendingAttribute) !== null) {
      return resolve();
    }
    const children2 = toArray(node.children);
    const alreadyProcessedPseudoElement = children2.filter((c$$1) => c$$1.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position)[0];
    const styles2 = WINDOW.getComputedStyle(node, position);
    const fontFamily = styles2.getPropertyValue("font-family");
    const fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
    const fontWeight = styles2.getPropertyValue("font-weight");
    const content = styles2.getPropertyValue("content");
    if (alreadyProcessedPseudoElement && !fontFamilyMatch) {
      node.removeChild(alreadyProcessedPseudoElement);
      return resolve();
    } else if (fontFamilyMatch && content !== "none" && content !== "") {
      const content2 = styles2.getPropertyValue("content");
      let prefix = getPrefix(fontFamily, fontWeight);
      const {
        value: hexValue,
        isSecondary
      } = hexValueFromContent(content2);
      const isV4 = fontFamilyMatch[0].startsWith("FontAwesome");
      let iconName = byUnicode(prefix, hexValue);
      let iconIdentifier = iconName;
      if (isV4) {
        const iconName4 = byOldUnicode(hexValue);
        if (iconName4.iconName && iconName4.prefix) {
          iconName = iconName4.iconName;
          prefix = iconName4.prefix;
        }
      }
      if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
        node.setAttribute(pendingAttribute, iconIdentifier);
        if (alreadyProcessedPseudoElement) {
          node.removeChild(alreadyProcessedPseudoElement);
        }
        const meta = blankMeta();
        const {
          extra
        } = meta;
        extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
        findIcon(iconName, prefix).then((main) => {
          const abstract = makeInlineSvgAbstract(_objectSpread2(_objectSpread2({}, meta), {}, {
            icons: {
              main,
              mask: emptyCanonicalIcon()
            },
            prefix,
            iconName: iconIdentifier,
            extra,
            watchable: true
          }));
          const element = DOCUMENT3.createElementNS("http://www.w3.org/2000/svg", "svg");
          if (position === "::before") {
            node.insertBefore(element, node.firstChild);
          } else {
            node.appendChild(element);
          }
          element.outerHTML = abstract.map((a$$1) => toHtml(a$$1)).join("\n");
          node.removeAttribute(pendingAttribute);
          resolve();
        }).catch(reject);
      } else {
        resolve();
      }
    } else {
      resolve();
    }
  });
}
function replace(node) {
  return Promise.all([replaceForPosition(node, "::before"), replaceForPosition(node, "::after")]);
}
function processable(node) {
  return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== "svg");
}
function searchPseudoElements(root3) {
  if (!IS_DOM) return;
  return new Promise((resolve, reject) => {
    const operations = toArray(root3.querySelectorAll("*")).filter(processable).map(replace);
    const end2 = perf.begin("searchPseudoElements");
    disableObservation();
    Promise.all(operations).then(() => {
      end2();
      enableObservation();
      resolve();
    }).catch(() => {
      end2();
      enableObservation();
      reject();
    });
  });
}
var PseudoElements = {
  hooks() {
    return {
      mutationObserverCallbacks(accumulator) {
        accumulator.pseudoElementsCallback = searchPseudoElements;
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.pseudoElements2svg = function(params) {
      const {
        node = DOCUMENT3
      } = params;
      if (config2.searchPseudoElements) {
        searchPseudoElements(node);
      }
    };
  }
};
var _unwatched = false;
var MutationObserver$1 = {
  mixout() {
    return {
      dom: {
        unwatch() {
          disableObservation();
          _unwatched = true;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        observe(chainHooks("mutationObserverCallbacks", {}));
      },
      noAuto() {
        disconnect();
      },
      watch(params) {
        const {
          observeMutationsRoot
        } = params;
        if (_unwatched) {
          enableObservation();
        } else {
          observe(chainHooks("mutationObserverCallbacks", {
            observeMutationsRoot
          }));
        }
      }
    };
  }
};
var parseTransformString = (transformString) => {
  let transform = {
    size: 16,
    x: 0,
    y: 0,
    flipX: false,
    flipY: false,
    rotate: 0
  };
  return transformString.toLowerCase().split(" ").reduce((acc, n) => {
    const parts = n.toLowerCase().split("-");
    const first2 = parts[0];
    let rest = parts.slice(1).join("-");
    if (first2 && rest === "h") {
      acc.flipX = true;
      return acc;
    }
    if (first2 && rest === "v") {
      acc.flipY = true;
      return acc;
    }
    rest = parseFloat(rest);
    if (isNaN(rest)) {
      return acc;
    }
    switch (first2) {
      case "grow":
        acc.size = acc.size + rest;
        break;
      case "shrink":
        acc.size = acc.size - rest;
        break;
      case "left":
        acc.x = acc.x - rest;
        break;
      case "right":
        acc.x = acc.x + rest;
        break;
      case "up":
        acc.y = acc.y - rest;
        break;
      case "down":
        acc.y = acc.y + rest;
        break;
      case "rotate":
        acc.rotate = acc.rotate + rest;
        break;
    }
    return acc;
  }, transform);
};
var PowerTransforms = {
  mixout() {
    return {
      parse: {
        transform: (transformString) => {
          return parseTransformString(transformString);
        }
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(accumulator, node) {
        const transformString = node.getAttribute("data-fa-transform");
        if (transformString) {
          accumulator.transform = parseTransformString(transformString);
        }
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.generateAbstractTransformGrouping = function(_ref) {
      let {
        main,
        transform,
        containerWidth,
        iconWidth
      } = _ref;
      const outer = {
        transform: "translate(".concat(containerWidth / 2, " 256)")
      };
      const innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
      const innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
      const innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
      const inner = {
        transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
      };
      const path3 = {
        transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
      };
      const operations = {
        outer,
        inner,
        path: path3
      };
      return {
        tag: "g",
        attributes: _objectSpread2({}, operations.outer),
        children: [{
          tag: "g",
          attributes: _objectSpread2({}, operations.inner),
          children: [{
            tag: main.icon.tag,
            children: main.icon.children,
            attributes: _objectSpread2(_objectSpread2({}, main.icon.attributes), operations.path)
          }]
        }]
      };
    };
  }
};
var ALL_SPACE = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function fillBlack(abstract) {
  let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (abstract.attributes && (abstract.attributes.fill || force)) {
    abstract.attributes.fill = "black";
  }
  return abstract;
}
function deGroup(abstract) {
  if (abstract.tag === "g") {
    return abstract.children;
  } else {
    return [abstract];
  }
}
var Masks = {
  hooks() {
    return {
      parseNodeAttributes(accumulator, node) {
        const maskData = node.getAttribute("data-fa-mask");
        const mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map((i) => i.trim()));
        if (!mask.prefix) {
          mask.prefix = getDefaultUsablePrefix();
        }
        accumulator.mask = mask;
        accumulator.maskId = node.getAttribute("data-fa-mask-id");
        return accumulator;
      }
    };
  },
  provides(providers2) {
    providers2.generateAbstractMask = function(_ref) {
      let {
        children: children2,
        attributes,
        main,
        mask,
        maskId: explicitMaskId,
        transform
      } = _ref;
      const {
        width: mainWidth,
        icon: mainPath
      } = main;
      const {
        width: maskWidth,
        icon: maskPath
      } = mask;
      const trans = transformForSvg({
        transform,
        containerWidth: maskWidth,
        iconWidth: mainWidth
      });
      const maskRect = {
        tag: "rect",
        attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
          fill: "white"
        })
      };
      const maskInnerGroupChildrenMixin = mainPath.children ? {
        children: mainPath.children.map(fillBlack)
      } : {};
      const maskInnerGroup = {
        tag: "g",
        attributes: _objectSpread2({}, trans.inner),
        children: [fillBlack(_objectSpread2({
          tag: mainPath.tag,
          attributes: _objectSpread2(_objectSpread2({}, mainPath.attributes), trans.path)
        }, maskInnerGroupChildrenMixin))]
      };
      const maskOuterGroup = {
        tag: "g",
        attributes: _objectSpread2({}, trans.outer),
        children: [maskInnerGroup]
      };
      const maskId = "mask-".concat(explicitMaskId || nextUniqueId());
      const clipId = "clip-".concat(explicitMaskId || nextUniqueId());
      const maskTag = {
        tag: "mask",
        attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
          id: maskId,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [maskRect, maskOuterGroup]
      };
      const defs = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: clipId
          },
          children: deGroup(maskPath)
        }, maskTag]
      };
      children2.push(defs, {
        tag: "rect",
        attributes: _objectSpread2({
          fill: "currentColor",
          "clip-path": "url(#".concat(clipId, ")"),
          mask: "url(#".concat(maskId, ")")
        }, ALL_SPACE)
      });
      return {
        children: children2,
        attributes
      };
    };
  }
};
var MissingIconIndicator = {
  provides(providers2) {
    let reduceMotion = false;
    if (WINDOW.matchMedia) {
      reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
    }
    providers2.missingIconAbstract = function() {
      const gChildren = [];
      const FILL = {
        fill: "currentColor"
      };
      const ANIMATION_BASE = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      gChildren.push({
        tag: "path",
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      const OPACITY_ANIMATE = _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
        attributeName: "opacity"
      });
      const dot = {
        tag: "circle",
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      if (!reduceMotion) {
        dot.children.push({
          tag: "animate",
          attributes: _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
            attributeName: "r",
            values: "28;14;28;28;14;28;"
          })
        }, {
          tag: "animate",
          attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
            values: "1;0;1;1;0;1;"
          })
        });
      }
      gChildren.push(dot);
      gChildren.push({
        tag: "path",
        attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: reduceMotion ? [] : [{
          tag: "animate",
          attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      });
      if (!reduceMotion) {
        gChildren.push({
          tag: "path",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            opacity: "0",
            d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
          }),
          children: [{
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: "0;0;1;1;0;0;"
            })
          }]
        });
      }
      return {
        tag: "g",
        attributes: {
          "class": "missing"
        },
        children: gChildren
      };
    };
  }
};
var SvgSymbols = {
  hooks() {
    return {
      parseNodeAttributes(accumulator, node) {
        const symbolData = node.getAttribute("data-fa-symbol");
        const symbol = symbolData === null ? false : symbolData === "" ? true : symbolData;
        accumulator["symbol"] = symbol;
        return accumulator;
      }
    };
  }
};
var plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];
registerPlugins(plugins, {
  mixoutsTo: api
});
var noAuto$1 = api.noAuto;
var config$1 = api.config;
var library$1 = api.library;
var dom$1 = api.dom;
var parse$1 = api.parse;
var findIconDefinition$1 = api.findIconDefinition;
var toHtml$1 = api.toHtml;
var icon = api.icon;
var layer = api.layer;
var text = api.text;
var counter = api.counter;

// node_modules/@fortawesome/angular-fontawesome/fesm2022/angular-fontawesome.mjs
var _c02 = ["*"];
var faWarnIfIconDefinitionMissing = (iconSpec) => {
  throw new Error(`Could not find icon with iconName=${iconSpec.iconName} and prefix=${iconSpec.prefix} in the icon library.`);
};
var faWarnIfIconSpecMissing = () => {
  throw new Error("Property `icon` is required for `fa-icon`/`fa-duotone-icon` components.");
};
var isKnownRotateValue = (rotate) => rotate != null && (rotate === 90 || rotate === 180 || rotate === 270 || rotate === "90" || rotate === "180" || rotate === "270");
var faClassList = (props) => {
  const knownRotateValue = isKnownRotateValue(props.rotate);
  const classes = {
    [`fa-${props.animation}`]: props.animation != null && !props.animation.startsWith("spin"),
    "fa-spin": props.animation === "spin" || props.animation === "spin-reverse",
    "fa-spin-pulse": props.animation === "spin-pulse" || props.animation === "spin-pulse-reverse",
    "fa-spin-reverse": props.animation === "spin-reverse" || props.animation === "spin-pulse-reverse",
    // According to https://fontawesome.com/docs/web/style/animate#spin fa-pulse
    // class is deprecated, remove the below line when Font Awesome 5 support
    // is dropped.
    "fa-pulse": props.animation === "spin-pulse" || props.animation === "spin-pulse-reverse",
    "fa-fw": props.fixedWidth,
    "fa-border": props.border,
    "fa-inverse": props.inverse,
    "fa-layers-counter": props.counter,
    "fa-flip-horizontal": props.flip === "horizontal" || props.flip === "both",
    "fa-flip-vertical": props.flip === "vertical" || props.flip === "both",
    [`fa-${props.size}`]: props.size !== null,
    [`fa-rotate-${props.rotate}`]: knownRotateValue,
    "fa-rotate-by": props.rotate != null && !knownRotateValue,
    [`fa-pull-${props.pull}`]: props.pull !== null,
    [`fa-stack-${props.stackItemSize}`]: props.stackItemSize != null
  };
  return Object.keys(classes).map((key) => classes[key] ? key : null).filter((key) => key);
};
var cssInserted = /* @__PURE__ */ new WeakSet();
var autoCssId = "fa-auto-css";
function ensureCss2(document2, config3) {
  if (!config3.autoAddCss) {
    return;
  }
  if (cssInserted.has(document2)) {
    return;
  }
  if (document2.getElementById(autoCssId) != null) {
    config3.autoAddCss = false;
    cssInserted.add(document2);
    return;
  }
  const style2 = document2.createElement("style");
  style2.setAttribute("type", "text/css");
  style2.setAttribute("id", autoCssId);
  style2.innerHTML = dom$1.css();
  const headChildren = document2.head.childNodes;
  let beforeChild = null;
  for (let i = headChildren.length - 1; i > -1; i--) {
    const child = headChildren[i];
    const tagName = child.nodeName.toUpperCase();
    if (["STYLE", "LINK"].indexOf(tagName) > -1) {
      beforeChild = child;
    }
  }
  document2.head.insertBefore(style2, beforeChild);
  config3.autoAddCss = false;
  cssInserted.add(document2);
}
var isIconLookup = (i) => i.prefix !== void 0 && i.iconName !== void 0;
var faNormalizeIconSpec = (iconSpec, defaultPrefix) => {
  if (isIconLookup(iconSpec)) {
    return iconSpec;
  }
  if (Array.isArray(iconSpec) && iconSpec.length === 2) {
    return {
      prefix: iconSpec[0],
      iconName: iconSpec[1]
    };
  }
  return {
    prefix: defaultPrefix,
    iconName: iconSpec
  };
};
var _FaConfig = class _FaConfig {
  constructor() {
    this.defaultPrefix = "fas";
    this.fallbackIcon = null;
    this._autoAddCss = true;
  }
  /**
   * Automatically add Font Awesome styles to the document when icon is rendered.
   *
   * For the majority of the cases the automatically added CSS is sufficient,
   * please refer to the linked guide for more information on when to disable
   * this feature.
   *
   * @see {@link: https://github.com/FortAwesome/angular-fontawesome/blob/main/docs/guide/adding-css.md}
   * @default true
   */
  set autoAddCss(value2) {
    config$1.autoAddCss = value2;
    this._autoAddCss = value2;
  }
  get autoAddCss() {
    return this._autoAddCss;
  }
};
_FaConfig.\u0275fac = function FaConfig_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FaConfig)();
};
_FaConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FaConfig,
  factory: _FaConfig.\u0275fac,
  providedIn: "root"
});
var FaConfig = _FaConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FaConfig, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _FaIconLibrary = class _FaIconLibrary {
  constructor() {
    this.definitions = {};
  }
  addIcons(...icons) {
    for (const icon2 of icons) {
      if (!(icon2.prefix in this.definitions)) {
        this.definitions[icon2.prefix] = {};
      }
      this.definitions[icon2.prefix][icon2.iconName] = icon2;
      for (const alias of icon2.icon[2]) {
        if (typeof alias === "string") {
          this.definitions[icon2.prefix][alias] = icon2;
        }
      }
    }
  }
  addIconPacks(...packs) {
    for (const pack of packs) {
      const icons = Object.keys(pack).map((key) => pack[key]);
      this.addIcons(...icons);
    }
  }
  getIconDefinition(prefix, name) {
    if (prefix in this.definitions && name in this.definitions[prefix]) {
      return this.definitions[prefix][name];
    }
    return null;
  }
};
_FaIconLibrary.\u0275fac = function FaIconLibrary_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FaIconLibrary)();
};
_FaIconLibrary.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _FaIconLibrary,
  factory: _FaIconLibrary.\u0275fac,
  providedIn: "root"
});
var FaIconLibrary = _FaIconLibrary;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FaIconLibrary, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _FaStackItemSizeDirective = class _FaStackItemSizeDirective {
  constructor() {
    this.stackItemSize = "1x";
  }
  ngOnChanges(changes) {
    if ("size" in changes) {
      throw new Error('fa-icon is not allowed to customize size when used inside fa-stack. Set size on the enclosing fa-stack instead: <fa-stack size="4x">...</fa-stack>.');
    }
  }
};
_FaStackItemSizeDirective.\u0275fac = function FaStackItemSizeDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FaStackItemSizeDirective)();
};
_FaStackItemSizeDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _FaStackItemSizeDirective,
  selectors: [["fa-icon", "stackItemSize", ""], ["fa-duotone-icon", "stackItemSize", ""]],
  inputs: {
    stackItemSize: "stackItemSize",
    size: "size"
  },
  features: [\u0275\u0275NgOnChangesFeature]
});
var FaStackItemSizeDirective = _FaStackItemSizeDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FaStackItemSizeDirective, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "fa-icon[stackItemSize],fa-duotone-icon[stackItemSize]"
    }]
  }], null, {
    stackItemSize: [{
      type: Input
    }],
    size: [{
      type: Input
    }]
  });
})();
var _FaStackComponent = class _FaStackComponent {
  constructor(renderer, elementRef) {
    this.renderer = renderer;
    this.elementRef = elementRef;
  }
  ngOnInit() {
    this.renderer.addClass(this.elementRef.nativeElement, "fa-stack");
  }
  ngOnChanges(changes) {
    if ("size" in changes) {
      if (changes.size.currentValue != null) {
        this.renderer.addClass(this.elementRef.nativeElement, `fa-${changes.size.currentValue}`);
      }
      if (changes.size.previousValue != null) {
        this.renderer.removeClass(this.elementRef.nativeElement, `fa-${changes.size.previousValue}`);
      }
    }
  }
};
_FaStackComponent.\u0275fac = function FaStackComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FaStackComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
};
_FaStackComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FaStackComponent,
  selectors: [["fa-stack"]],
  inputs: {
    size: "size"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function FaStackComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var FaStackComponent = _FaStackComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FaStackComponent, [{
    type: Component,
    args: [{
      selector: "fa-stack",
      template: `<ng-content></ng-content>`
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    size: [{
      type: Input
    }]
  });
})();
var _FaIconComponent = class _FaIconComponent {
  constructor(sanitizer, config3, iconLibrary, stackItem, stack) {
    this.sanitizer = sanitizer;
    this.config = config3;
    this.iconLibrary = iconLibrary;
    this.stackItem = stackItem;
    this.document = inject(DOCUMENT2);
    if (stack != null && stackItem == null) {
      console.error('FontAwesome: fa-icon and fa-duotone-icon elements must specify stackItemSize attribute when wrapped into fa-stack. Example: <fa-icon stackItemSize="2x"></fa-icon>.');
    }
  }
  ngOnChanges(changes) {
    if (this.icon == null && this.config.fallbackIcon == null) {
      faWarnIfIconSpecMissing();
      return;
    }
    if (changes) {
      const iconDefinition = this.findIconDefinition(this.icon ?? this.config.fallbackIcon);
      if (iconDefinition != null) {
        const params = this.buildParams();
        ensureCss2(this.document, this.config);
        const renderedIcon = icon(iconDefinition, params);
        this.renderedIconHTML = this.sanitizer.bypassSecurityTrustHtml(renderedIcon.html.join("\n"));
      }
    }
  }
  /**
   * Programmatically trigger rendering of the icon.
   *
   * This method is useful, when creating {@link FaIconComponent} dynamically or
   * changing its inputs programmatically as in these cases icon won't be
   * re-rendered automatically.
   */
  render() {
    this.ngOnChanges({});
  }
  findIconDefinition(i) {
    const lookup = faNormalizeIconSpec(i, this.config.defaultPrefix);
    if ("icon" in lookup) {
      return lookup;
    }
    const definition = this.iconLibrary.getIconDefinition(lookup.prefix, lookup.iconName);
    if (definition != null) {
      return definition;
    }
    faWarnIfIconDefinitionMissing(lookup);
    return null;
  }
  buildParams() {
    const classOpts = {
      flip: this.flip,
      animation: this.animation,
      border: this.border,
      inverse: this.inverse,
      size: this.size || null,
      pull: this.pull || null,
      rotate: this.rotate || null,
      fixedWidth: typeof this.fixedWidth === "boolean" ? this.fixedWidth : this.config.fixedWidth,
      stackItemSize: this.stackItem != null ? this.stackItem.stackItemSize : null
    };
    const parsedTransform = typeof this.transform === "string" ? parse$1.transform(this.transform) : this.transform;
    const styles2 = {};
    if (classOpts.rotate != null && !isKnownRotateValue(classOpts.rotate)) {
      styles2["--fa-rotate-angle"] = `${classOpts.rotate}`;
    }
    return {
      title: this.title,
      transform: parsedTransform,
      classes: faClassList(classOpts),
      mask: this.mask != null ? this.findIconDefinition(this.mask) : null,
      symbol: this.symbol,
      attributes: {
        role: this.a11yRole
      },
      styles: styles2
    };
  }
};
_FaIconComponent.\u0275fac = function FaIconComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FaIconComponent)(\u0275\u0275directiveInject(DomSanitizer), \u0275\u0275directiveInject(FaConfig), \u0275\u0275directiveInject(FaIconLibrary), \u0275\u0275directiveInject(FaStackItemSizeDirective, 8), \u0275\u0275directiveInject(FaStackComponent, 8));
};
_FaIconComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FaIconComponent,
  selectors: [["fa-icon"]],
  hostAttrs: [1, "ng-fa-icon"],
  hostVars: 2,
  hostBindings: function FaIconComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275hostProperty("innerHTML", ctx.renderedIconHTML, \u0275\u0275sanitizeHtml);
      \u0275\u0275attribute("title", ctx.title);
    }
  },
  inputs: {
    icon: "icon",
    title: "title",
    animation: "animation",
    mask: "mask",
    flip: "flip",
    size: "size",
    pull: "pull",
    border: "border",
    inverse: "inverse",
    symbol: "symbol",
    rotate: "rotate",
    fixedWidth: "fixedWidth",
    transform: "transform",
    a11yRole: "a11yRole"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 0,
  vars: 0,
  template: function FaIconComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var FaIconComponent = _FaIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FaIconComponent, [{
    type: Component,
    args: [{
      selector: "fa-icon",
      template: ``,
      host: {
        class: "ng-fa-icon",
        "[attr.title]": "title"
      }
    }]
  }], () => [{
    type: DomSanitizer
  }, {
    type: FaConfig
  }, {
    type: FaIconLibrary
  }, {
    type: FaStackItemSizeDirective,
    decorators: [{
      type: Optional
    }]
  }, {
    type: FaStackComponent,
    decorators: [{
      type: Optional
    }]
  }], {
    icon: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    mask: [{
      type: Input
    }],
    flip: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    pull: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    inverse: [{
      type: Input
    }],
    symbol: [{
      type: Input
    }],
    rotate: [{
      type: Input
    }],
    fixedWidth: [{
      type: Input
    }],
    transform: [{
      type: Input
    }],
    a11yRole: [{
      type: Input
    }],
    renderedIconHTML: [{
      type: HostBinding,
      args: ["innerHTML"]
    }]
  });
})();
var _FaDuotoneIconComponent = class _FaDuotoneIconComponent extends FaIconComponent {
  findIconDefinition(i) {
    const definition = super.findIconDefinition(i);
    if (definition != null && !Array.isArray(definition.icon[4])) {
      throw new Error(`The specified icon does not appear to be a Duotone icon. Check that you specified the correct style: <fa-duotone-icon [icon]="['fad', '${definition.iconName}']"></fa-duotone-icon> or use: <fa-icon icon="${definition.iconName}"></fa-icon> instead.`);
    }
    return definition;
  }
  buildParams() {
    const params = super.buildParams();
    if (this.swapOpacity === true || this.swapOpacity === "true") {
      if (Array.isArray(params.classes)) {
        params.classes.push("fa-swap-opacity");
      } else if (typeof params.classes === "string") {
        params.classes = [params.classes, "fa-swap-opacity"];
      } else {
        params.classes = ["fa-swap-opacity"];
      }
    }
    if (params.styles == null) {
      params.styles = {};
    }
    if (this.primaryOpacity != null) {
      params.styles["--fa-primary-opacity"] = this.primaryOpacity.toString();
    }
    if (this.secondaryOpacity != null) {
      params.styles["--fa-secondary-opacity"] = this.secondaryOpacity.toString();
    }
    if (this.primaryColor != null) {
      params.styles["--fa-primary-color"] = this.primaryColor;
    }
    if (this.secondaryColor != null) {
      params.styles["--fa-secondary-color"] = this.secondaryColor;
    }
    return params;
  }
};
_FaDuotoneIconComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275FaDuotoneIconComponent_BaseFactory;
  return function FaDuotoneIconComponent_Factory(__ngFactoryType__) {
    return (\u0275FaDuotoneIconComponent_BaseFactory || (\u0275FaDuotoneIconComponent_BaseFactory = \u0275\u0275getInheritedFactory(_FaDuotoneIconComponent)))(__ngFactoryType__ || _FaDuotoneIconComponent);
  };
})();
_FaDuotoneIconComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FaDuotoneIconComponent,
  selectors: [["fa-duotone-icon"]],
  inputs: {
    swapOpacity: "swapOpacity",
    primaryOpacity: "primaryOpacity",
    secondaryOpacity: "secondaryOpacity",
    primaryColor: "primaryColor",
    secondaryColor: "secondaryColor"
  },
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function FaDuotoneIconComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var FaDuotoneIconComponent = _FaDuotoneIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FaDuotoneIconComponent, [{
    type: Component,
    args: [{
      selector: "fa-duotone-icon",
      template: ``
    }]
  }], null, {
    swapOpacity: [{
      type: Input
    }],
    primaryOpacity: [{
      type: Input
    }],
    secondaryOpacity: [{
      type: Input
    }],
    primaryColor: [{
      type: Input
    }],
    secondaryColor: [{
      type: Input
    }]
  });
})();
var faWarnIfParentNotExist = (parent, parentName, childName) => {
  if (!parent) {
    throw new Error(`${childName} should be used as child of ${parentName} only.`);
  }
};
var _FaLayersComponent = class _FaLayersComponent {
  constructor(renderer, elementRef, config3) {
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.config = config3;
    this.document = inject(DOCUMENT2);
  }
  ngOnInit() {
    this.renderer.addClass(this.elementRef.nativeElement, "fa-layers");
    ensureCss2(this.document, this.config);
    this.fixedWidth = typeof this.fixedWidth === "boolean" ? this.fixedWidth : this.config.fixedWidth;
  }
  ngOnChanges(changes) {
    if ("size" in changes) {
      if (changes.size.currentValue != null) {
        this.renderer.addClass(this.elementRef.nativeElement, `fa-${changes.size.currentValue}`);
      }
      if (changes.size.previousValue != null) {
        this.renderer.removeClass(this.elementRef.nativeElement, `fa-${changes.size.previousValue}`);
      }
    }
  }
};
_FaLayersComponent.\u0275fac = function FaLayersComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FaLayersComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(FaConfig));
};
_FaLayersComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FaLayersComponent,
  selectors: [["fa-layers"]],
  hostVars: 2,
  hostBindings: function FaLayersComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275classProp("fa-fw", ctx.fixedWidth);
    }
  },
  inputs: {
    size: "size",
    fixedWidth: "fixedWidth"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function FaLayersComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275projection(0);
    }
  },
  encapsulation: 2
});
var FaLayersComponent = _FaLayersComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FaLayersComponent, [{
    type: Component,
    args: [{
      selector: "fa-layers",
      template: `<ng-content></ng-content>`
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: FaConfig
  }], {
    size: [{
      type: Input
    }],
    fixedWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.fa-fw"]
    }]
  });
})();
var _FaLayersCounterComponent = class _FaLayersCounterComponent {
  constructor(parent, sanitizer) {
    this.parent = parent;
    this.sanitizer = sanitizer;
    this.document = inject(DOCUMENT2);
    this.config = inject(FaConfig);
    faWarnIfParentNotExist(this.parent, "FaLayersComponent", this.constructor.name);
  }
  ngOnChanges(changes) {
    if (changes) {
      const params = this.buildParams();
      this.updateContent(params);
    }
  }
  buildParams() {
    return {
      title: this.title,
      classes: this.position != null ? [`fa-layers-${this.position}`] : void 0
    };
  }
  updateContent(params) {
    ensureCss2(this.document, this.config);
    this.renderedHTML = this.sanitizer.bypassSecurityTrustHtml(counter(this.content || "", params).html.join(""));
  }
};
_FaLayersCounterComponent.\u0275fac = function FaLayersCounterComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FaLayersCounterComponent)(\u0275\u0275directiveInject(FaLayersComponent, 8), \u0275\u0275directiveInject(DomSanitizer));
};
_FaLayersCounterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FaLayersCounterComponent,
  selectors: [["fa-layers-counter"]],
  hostAttrs: [1, "ng-fa-layers-counter"],
  hostVars: 1,
  hostBindings: function FaLayersCounterComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275hostProperty("innerHTML", ctx.renderedHTML, \u0275\u0275sanitizeHtml);
    }
  },
  inputs: {
    content: "content",
    title: "title",
    position: "position"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 0,
  vars: 0,
  template: function FaLayersCounterComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var FaLayersCounterComponent = _FaLayersCounterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FaLayersCounterComponent, [{
    type: Component,
    args: [{
      selector: "fa-layers-counter",
      template: "",
      host: {
        class: "ng-fa-layers-counter"
      }
    }]
  }], () => [{
    type: FaLayersComponent,
    decorators: [{
      type: Optional
    }]
  }, {
    type: DomSanitizer
  }], {
    content: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    renderedHTML: [{
      type: HostBinding,
      args: ["innerHTML"]
    }]
  });
})();
var _FaLayersTextComponent = class _FaLayersTextComponent {
  constructor(parent, sanitizer) {
    this.parent = parent;
    this.sanitizer = sanitizer;
    this.document = inject(DOCUMENT2);
    this.config = inject(FaConfig);
    faWarnIfParentNotExist(this.parent, "FaLayersComponent", this.constructor.name);
  }
  ngOnChanges(changes) {
    if (changes) {
      const params = this.buildParams();
      this.updateContent(params);
    }
  }
  /**
   * Updating params by component props.
   */
  buildParams() {
    const classOpts = {
      flip: this.flip,
      border: this.border,
      inverse: this.inverse,
      size: this.size || null,
      pull: this.pull || null,
      rotate: this.rotate || null,
      fixedWidth: this.fixedWidth
    };
    const parsedTransform = typeof this.transform === "string" ? parse$1.transform(this.transform) : this.transform;
    const styles2 = {};
    if (classOpts.rotate != null && !isKnownRotateValue(classOpts.rotate)) {
      styles2["--fa-rotate-angle"] = `${classOpts.rotate}`;
    }
    return {
      transform: parsedTransform,
      classes: faClassList(classOpts),
      title: this.title,
      styles: styles2
    };
  }
  updateContent(params) {
    ensureCss2(this.document, this.config);
    this.renderedHTML = this.sanitizer.bypassSecurityTrustHtml(text(this.content || "", params).html.join("\n"));
  }
};
_FaLayersTextComponent.\u0275fac = function FaLayersTextComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FaLayersTextComponent)(\u0275\u0275directiveInject(FaLayersComponent, 8), \u0275\u0275directiveInject(DomSanitizer));
};
_FaLayersTextComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _FaLayersTextComponent,
  selectors: [["fa-layers-text"]],
  hostAttrs: [1, "ng-fa-layers-text"],
  hostVars: 1,
  hostBindings: function FaLayersTextComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      \u0275\u0275hostProperty("innerHTML", ctx.renderedHTML, \u0275\u0275sanitizeHtml);
    }
  },
  inputs: {
    content: "content",
    title: "title",
    flip: "flip",
    size: "size",
    pull: "pull",
    border: "border",
    inverse: "inverse",
    rotate: "rotate",
    fixedWidth: "fixedWidth",
    transform: "transform"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 0,
  vars: 0,
  template: function FaLayersTextComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var FaLayersTextComponent = _FaLayersTextComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FaLayersTextComponent, [{
    type: Component,
    args: [{
      selector: "fa-layers-text",
      template: "",
      host: {
        class: "ng-fa-layers-text"
      }
    }]
  }], () => [{
    type: FaLayersComponent,
    decorators: [{
      type: Optional
    }]
  }, {
    type: DomSanitizer
  }], {
    content: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    flip: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    pull: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    inverse: [{
      type: Input
    }],
    rotate: [{
      type: Input
    }],
    fixedWidth: [{
      type: Input
    }],
    transform: [{
      type: Input
    }],
    renderedHTML: [{
      type: HostBinding,
      args: ["innerHTML"]
    }]
  });
})();
var _FontAwesomeModule = class _FontAwesomeModule {
};
_FontAwesomeModule.\u0275fac = function FontAwesomeModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _FontAwesomeModule)();
};
_FontAwesomeModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _FontAwesomeModule
});
_FontAwesomeModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var FontAwesomeModule = _FontAwesomeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FontAwesomeModule, [{
    type: NgModule,
    args: [{
      imports: [FaIconComponent, FaDuotoneIconComponent, FaLayersComponent, FaLayersTextComponent, FaLayersCounterComponent, FaStackComponent, FaStackItemSizeDirective],
      exports: [FaIconComponent, FaDuotoneIconComponent, FaLayersComponent, FaLayersTextComponent, FaLayersCounterComponent, FaStackComponent, FaStackItemSizeDirective]
    }]
  }], null, null);
})();

// node_modules/ng-toggle-button/fesm2020/ng-toggle-button.mjs
var _c03 = (a0) => ({
  "ng-toggle-focused": a0
});
function NgToggleComponent_ng_container_4_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 7);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngStyle", ctx_r0.labelLeftStyle);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.labelChecked, " ");
  }
}
function NgToggleComponent_ng_container_4_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngStyle", ctx_r0.labelRightStyle);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.labelUnchecked, " ");
  }
}
function NgToggleComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, NgToggleComponent_ng_container_4_span_1_Template, 2, 2, "span", 5)(2, NgToggleComponent_ng_container_4_span_2_Template, 2, 2, "span", 6);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.toggled);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.toggled);
  }
}
var NgToggleConfig = class {
};
NgToggleConfig.\u0275fac = function NgToggleConfig_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NgToggleConfig)();
};
NgToggleConfig.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: NgToggleConfig,
  factory: NgToggleConfig.\u0275fac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgToggleConfig, [{
    type: Injectable
  }], null, null);
})();
var DEFAULT_COLOR_CHECKED = "#0099CC";
var DEFAULT_COLOR_UNCHECKED = "#e0e0e0";
var DEFAULT_LABEL_CHECKED = "";
var DEFAULT_LABEL_UNCHECKED = "";
var DEFAULT_SWITCH_COLOR = "#fff";
var DISABLED_COLOR = "#dbdbdb";
var DISABLED_BUTTON_COLOR = "silver";
var nextUniqueId2 = 0;
var NgToggleComponent = class {
  constructor(config3, _elementRef) {
    this.config = config3;
    this._elementRef = _elementRef;
    this.value = this.config.value || true;
    this.name = this.config.name || "";
    this.disabled = this.config.disabled || false;
    this.height = this.config.height || 25;
    this.width = this.config.width || 45;
    this.margin = this.config.margin || 2;
    this.fontSize = this.config.fontSize || void 0;
    this.speed = this.config.speed || 300;
    this.color = this.config.color;
    this.switchColor = this.config.switchColor;
    this.labels = this.config.labels || true;
    this.fontColor = this.config.fontColor || void 0;
    this.values = this.config.values || {
      checked: true,
      unchecked: false
    };
    this.textAlign = this.config.textAlign || {
      checked: "left",
      unchecked: "right"
    };
    this.id = "";
    this.ariaLabel = null;
    this.ariaLabelledby = null;
    this.cssColors = false;
    this.change = new EventEmitter();
    this.valueChange = new EventEmitter();
    this.onChange = (_) => {
    };
    this.onTouch = () => {
    };
    this._uniqueId = "ng-toggle-" + ++nextUniqueId2;
    this.id = this.id || this._uniqueId;
    this.ariaLabel = this.ariaLabel || this.name || this.id;
  }
  ngOnInit() {
    this.setToogle();
  }
  onInput(value2) {
    this.value = value2;
    this.onTouch();
    this.onChange(this.value);
  }
  writeValue(value2) {
    this.value = value2;
    this.setToogle();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouch = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  setToogle() {
    const value2 = this.value;
    let index = Object.values(this.values).findIndex((el) => el == value2);
    if (index > -1) this.toggled = Object.keys(this.values)[index] == "checked" ? true : false;
  }
  ngOnChanges(changes) {
    for (const propName in changes) {
      const chng = changes[propName];
      if (propName == "value") this.writeValue(chng.currentValue);
    }
  }
  get coreStyle() {
    return {
      width: px(this.width),
      height: px(this.height),
      transition: `all ${this.speed}ms`,
      backgroundColor: this.cssColors ? null : this.disabled ? this.colorDisabled : this.colorCurrent,
      borderRadius: px(Math.round(this.height / 2))
    };
  }
  get buttonRadius() {
    const radius = this.height - this.margin * 2;
    return radius > 0 ? radius : 0;
  }
  get distance() {
    return px(this.width - this.height + this.margin);
  }
  get buttonStyle() {
    const transition3 = `all ${this.speed}ms`;
    const margin = px(this.margin);
    const transform = this.toggled ? translate(this.distance, margin) : translate(margin, margin);
    let background = this.switchColor ? this.switchColorCurrent : null;
    background = this.disabled ? this.switchColorDisabled : background;
    return {
      width: px(this.buttonRadius),
      height: px(this.buttonRadius),
      transition: transition3,
      transform,
      background
    };
  }
  get labelStyle() {
    return {
      lineHeight: px(this.height),
      fontSize: this.fontSize ? px(this.fontSize) : null,
      color: this.fontColor ? this.fontColorCurrent : null,
      width: px(this.width - this.buttonRadius - this.margin)
    };
  }
  get labelLeftStyle() {
    return __spreadProps(__spreadValues({}, this.labelStyle), {
      textAlign: this.textAlign.checked || this.textAlign
    });
  }
  get labelRightStyle() {
    return __spreadProps(__spreadValues({}, this.labelStyle), {
      textAlign: this.textAlign.unchecked || this.textAlign
    });
  }
  get colorChecked() {
    let {
      color: color2
    } = this;
    if (!isObject(color2)) {
      return color2 || DEFAULT_COLOR_CHECKED;
    }
    return get(color2, "checked", DEFAULT_COLOR_CHECKED);
  }
  get colorUnchecked() {
    return get(this.color, "unchecked", DEFAULT_COLOR_UNCHECKED);
  }
  get colorDisabled() {
    return get(this.color, "disabled", DISABLED_COLOR);
  }
  get colorCurrent() {
    return this.toggled ? this.colorChecked : this.colorUnchecked;
  }
  get labelChecked() {
    return get(this.labels, "checked", DEFAULT_LABEL_CHECKED);
  }
  get labelUnchecked() {
    return get(this.labels, "unchecked", DEFAULT_LABEL_UNCHECKED);
  }
  get switchColorChecked() {
    return get(this.switchColor, "checked", DEFAULT_SWITCH_COLOR);
  }
  get switchColorUnchecked() {
    return get(this.switchColor, "unchecked", DEFAULT_SWITCH_COLOR);
  }
  get switchColorDisabled() {
    return get(this.switchColor, "disabled", DISABLED_BUTTON_COLOR);
  }
  get switchColorCurrent() {
    if (!isObject(this.switchColor)) {
      return this.switchColor || DEFAULT_SWITCH_COLOR;
    }
    return this.toggled ? this.switchColorChecked : this.switchColorUnchecked;
  }
  get fontColorChecked() {
    return get(this.fontColor, "checked", DEFAULT_SWITCH_COLOR);
  }
  get fontColorUnchecked() {
    return get(this.fontColor, "unchecked", DEFAULT_SWITCH_COLOR);
  }
  get fontColorDisabled() {
    return get(this.fontColor, "disabled", DEFAULT_SWITCH_COLOR);
  }
  get fontColorCurrent() {
    if (!isObject(this.fontColor)) {
      return this.fontColor || DEFAULT_SWITCH_COLOR;
    }
    if (this.disabled) {
      return this.fontColorDisabled;
    }
    return this.toggled ? this.fontColorChecked : this.fontColorUnchecked;
  }
  get label() {
    if (this.ariaLabelledby) {
      return this.ariaLabelledby;
    }
    return this.ariaLabel ? null : `${this._uniqueId}-label`;
  }
  toggle(event) {
    const toggled = !this.toggled;
    this.toggled = toggled;
    this.value = this.getValue(toggled);
    this.onTouch();
    this.onChange(this.value);
    this.valueChange.emit(this.value);
  }
  getValue(key) {
    return key === true ? this.values["checked"] : this.values["unchecked"];
  }
  onFocus(event) {
    if (!this.focused && event.relatedTarget) {
      this.focused = true;
    }
  }
  onFocusout(event) {
    if (!this._elementRef.nativeElement.contains(event.relatedTarget)) {
      this.focused = false;
      this.onTouch();
    }
  }
};
NgToggleComponent.\u0275fac = function NgToggleComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NgToggleComponent)(\u0275\u0275directiveInject(NgToggleConfig), \u0275\u0275directiveInject(ElementRef));
};
NgToggleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: NgToggleComponent,
  selectors: [["ng-toggle"]],
  inputs: {
    value: "value",
    name: "name",
    disabled: "disabled",
    height: "height",
    width: "width",
    margin: "margin",
    fontSize: "fontSize",
    speed: "speed",
    color: "color",
    switchColor: "switchColor",
    labels: "labels",
    fontColor: "fontColor",
    values: "values",
    textAlign: "textAlign",
    id: "id",
    ariaLabel: [0, "aria-label", "ariaLabel"],
    ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
    ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"]
  },
  outputs: {
    change: "change",
    valueChange: "valueChange"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NgToggleComponent),
    multi: true
  }]), \u0275\u0275NgOnChangesFeature],
  decls: 5,
  vars: 16,
  consts: [[1, "ng-toggle-switch", 3, "for"], ["type", "checkbox", "role", "checkbox", 1, "ng-toggle-switch-input", 3, "change", "focusin", "focusout", "checked", "disabled"], [1, "ng-toggle-switch-core", 3, "ngClass", "ngStyle"], [1, "ng-toggle-switch-button", 3, "ngStyle"], [4, "ngIf"], ["class", "ng-toggle-switch-label ng-toggle-left", 3, "ngStyle", 4, "ngIf"], ["class", "ng-toggle-switch-label ng-toggle-right", 3, "ngStyle", 4, "ngIf"], [1, "ng-toggle-switch-label", "ng-toggle-left", 3, "ngStyle"], [1, "ng-toggle-switch-label", "ng-toggle-right", 3, "ngStyle"]],
  template: function NgToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "label", 0)(1, "input", 1);
      \u0275\u0275listener("change", function NgToggleComponent_Template_input_change_1_listener($event) {
        return ctx.toggle($event);
      })("focusin", function NgToggleComponent_Template_input_focusin_1_listener($event) {
        return ctx.onFocus($event);
      })("focusout", function NgToggleComponent_Template_input_focusout_1_listener($event) {
        return ctx.onFocusout($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "div", 2);
      \u0275\u0275element(3, "div", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275template(4, NgToggleComponent_ng_container_4_Template, 3, 2, "ng-container", 4);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("for", ctx.id);
      \u0275\u0275attribute("id", ctx.label);
      \u0275\u0275advance();
      \u0275\u0275property("checked", ctx.value)("disabled", ctx.disabled);
      \u0275\u0275attribute("id", ctx.id)("name", ctx.name)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.label)("aria-describedby", ctx.ariaDescribedby)("aria-checked", ctx.toggled);
      \u0275\u0275advance();
      \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(14, _c03, ctx.focused))("ngStyle", ctx.coreStyle);
      \u0275\u0275advance();
      \u0275\u0275property("ngStyle", ctx.buttonStyle);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.labels);
    }
  },
  dependencies: [NgClass, NgIf, NgStyle],
  styles: ["label[_ngcontent-%COMP%]{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}.ng-toggle-switch[_ngcontent-%COMP%]{display:inline-block;position:relative;vertical-align:middle;-webkit-user-select:none;user-select:none;font-size:10px;cursor:pointer}.ng-toggle-switch[_ngcontent-%COMP%]   .ng-toggle-switch-input[_ngcontent-%COMP%]{opacity:0;position:absolute;width:1px;height:1px}.ng-toggle-switch[_ngcontent-%COMP%]   .ng-toggle-switch-label[_ngcontent-%COMP%]{position:absolute;top:0;font-weight:600;color:#fff;z-index:1;padding:0 10px;box-sizing:border-box}.ng-toggle-switch[_ngcontent-%COMP%]   .ng-toggle-switch-label.ng-toggle-left[_ngcontent-%COMP%]{left:0}.ng-toggle-switch[_ngcontent-%COMP%]   .ng-toggle-switch-label.ng-toggle-right[_ngcontent-%COMP%]{right:0}.ng-toggle-switch[_ngcontent-%COMP%]   .ng-toggle-switch-core[_ngcontent-%COMP%]{display:block;position:relative;box-sizing:border-box;outline:0;margin:0;transition:border-color .3s,background-color .3s;-webkit-user-select:none;user-select:none}.ng-toggle-switch[_ngcontent-%COMP%]   .ng-toggle-switch-core[_ngcontent-%COMP%]   .ng-toggle-switch-button[_ngcontent-%COMP%]{display:block;position:absolute;overflow:hidden;top:0;left:0;border-radius:100%;background-color:#fff;z-index:2}.ng-toggle-switch.disabled[_ngcontent-%COMP%]{pointer-events:none;opacity:.6}.ng-toggle-focused[_ngcontent-%COMP%]{box-shadow:0 0 4px 3px #999}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgToggleComponent, [{
    type: Component,
    args: [{
      selector: "ng-toggle",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NgToggleComponent),
        multi: true
      }],
      template: `<label class="ng-toggle-switch" [for]="id" [attr.id]="label">
  <input
    type="checkbox"
    class="ng-toggle-switch-input"
    [checked]="value"
    [disabled]="disabled"
    (change)="toggle($event)"
    (focusin)="onFocus($event)"
    (focusout)="onFocusout($event)"
    [attr.id]="id"
    [attr.name]="name"
    [attr.aria-label]="ariaLabel"
    [attr.aria-labelledby]="label"
    [attr.aria-describedby]="ariaDescribedby"
    [attr.aria-checked]="toggled"
    role="checkbox"
  >
  <div
    class="ng-toggle-switch-core"
    [ngClass]="{'ng-toggle-focused': focused}"
    [ngStyle]="coreStyle"
  >
    <div
      class="ng-toggle-switch-button"
      [ngStyle]="buttonStyle">
    </div>
  </div>
  <ng-container *ngIf="labels">
    <span
      class="ng-toggle-switch-label ng-toggle-left"
      [ngStyle]="labelLeftStyle"
      *ngIf="toggled"
    >
      {{labelChecked}}
    </span>
    <span
      class="ng-toggle-switch-label ng-toggle-right"
      [ngStyle]="labelRightStyle"
      *ngIf="!toggled"
    >
      {{labelUnchecked}}
    </span>
  </ng-container>
</label>`,
      styles: ["label{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}.ng-toggle-switch{display:inline-block;position:relative;vertical-align:middle;-webkit-user-select:none;user-select:none;font-size:10px;cursor:pointer}.ng-toggle-switch .ng-toggle-switch-input{opacity:0;position:absolute;width:1px;height:1px}.ng-toggle-switch .ng-toggle-switch-label{position:absolute;top:0;font-weight:600;color:#fff;z-index:1;padding:0 10px;box-sizing:border-box}.ng-toggle-switch .ng-toggle-switch-label.ng-toggle-left{left:0}.ng-toggle-switch .ng-toggle-switch-label.ng-toggle-right{right:0}.ng-toggle-switch .ng-toggle-switch-core{display:block;position:relative;box-sizing:border-box;outline:0;margin:0;transition:border-color .3s,background-color .3s;-webkit-user-select:none;user-select:none}.ng-toggle-switch .ng-toggle-switch-core .ng-toggle-switch-button{display:block;position:absolute;overflow:hidden;top:0;left:0;border-radius:100%;background-color:#fff;z-index:2}.ng-toggle-switch.disabled{pointer-events:none;opacity:.6}.ng-toggle-focused{box-shadow:0 0 4px 3px #999}\n"]
    }]
  }], function() {
    return [{
      type: NgToggleConfig
    }, {
      type: ElementRef
    }];
  }, {
    value: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    fontSize: [{
      type: Input
    }],
    speed: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    switchColor: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    fontColor: [{
      type: Input
    }],
    values: [{
      type: Input
    }],
    textAlign: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    ariaDescribedby: [{
      type: Input,
      args: ["aria-describedby"]
    }],
    change: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var isObject = (value2) => {
  return typeof value2 === "object";
};
var has = (object, key) => {
  return isObject(object) && object.hasOwnProperty(key);
};
var get = (object, key, defaultValue) => {
  return has(object, key) ? object[key] : defaultValue;
};
var px = (value2) => {
  return `${value2}px`;
};
var translate = (x4, y3) => {
  return `translate(${x4}, ${y3})`;
};
var NgToggleModule = class _NgToggleModule {
  static forRoot(config3 = {}) {
    return {
      ngModule: _NgToggleModule,
      providers: [{
        provide: NgToggleConfig,
        useValue: config3
      }]
    };
  }
};
NgToggleModule.\u0275fac = function NgToggleModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || NgToggleModule)();
};
NgToggleModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: NgToggleModule
});
NgToggleModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [NgToggleConfig],
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgToggleModule, [{
    type: NgModule,
    args: [{
      declarations: [NgToggleComponent],
      imports: [CommonModule],
      exports: [NgToggleComponent],
      providers: [NgToggleConfig]
    }]
  }], null, null);
})();

// src/app/main-menu/main-menu.component.ts
function MainMenuComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 5)(1, "span", 6);
    \u0275\u0275element(2, "i", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Categories");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/categories");
  }
}
function MainMenuComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 5)(1, "span", 6);
    \u0275\u0275element(2, "i", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Variant catalogs");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/variant-catalogs");
  }
}
function MainMenuComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 5)(1, "span", 6);
    \u0275\u0275element(2, "i", 10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Products");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/products");
  }
}
function MainMenuComponent_a_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 5)(1, "span", 6);
    \u0275\u0275element(2, "i", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Accounts");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/accounts");
  }
}
function MainMenuComponent_a_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 12)(1, "span", 6);
    \u0275\u0275element(2, "i", 13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Configuration ");
    \u0275\u0275element(5, "i", 14);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/generic-configs");
  }
}
function MainMenuComponent_a_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 15)(1, "span", 6);
    \u0275\u0275element(2, "i", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Image");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/img");
  }
}
function MainMenuComponent_a_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 15)(1, "span", 6);
    \u0275\u0275element(2, "i", 17);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Qr Code");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/qr-code");
  }
}
function MainMenuComponent_a_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 15)(1, "span", 6);
    \u0275\u0275element(2, "i", 18);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Bank");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/bank");
  }
}
function MainMenuComponent_a_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 15)(1, "span", 6);
    \u0275\u0275element(2, "i", 18);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Advertisement");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/advertisement");
  }
}
function MainMenuComponent_a_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 5)(1, "span", 6);
    \u0275\u0275element(2, "i", 19);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Orders");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/orders");
  }
}
function MainMenuComponent_a_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 5)(1, "span", 6);
    \u0275\u0275element(2, "i", 20);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 8);
    \u0275\u0275text(4, "Graphs");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", "/graph/home");
  }
}
var _MainMenuComponent = class _MainMenuComponent {
  constructor(authService) {
    this.authService = authService;
    this.authService.currentAdmin.subscribe((x4) => this.currentAdmin = x4);
  }
  ngOnInit() {
    this.currentAdmin = this.authService.currentAdminValue;
  }
};
_MainMenuComponent.\u0275fac = function MainMenuComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _MainMenuComponent)(\u0275\u0275directiveInject(AuthService));
};
_MainMenuComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _MainMenuComponent, selectors: [["app-main-menu"]], standalone: false, decls: 13, vars: 11, consts: [[1, "nav", "flex-column"], ["class", "nav-link", "routerLinkActive", "active", 3, "routerLink", 4, "ngIf"], ["class", "nav-link", "routerLinkActive", "active", "data-bs-toggle", "collapse", "data-bs-target", "#submenu", "aria-expanded", "false", "aria-controls", "submenu", 3, "routerLink", 4, "ngIf"], ["id", "submenu", 1, "sub-menu", "collapse"], ["class", "nav-link ms-2", "routerLinkActive", "active", 3, "routerLink", 4, "ngIf"], ["routerLinkActive", "active", 1, "nav-link", 3, "routerLink"], [1, "icon"], [1, "bi", "bi-list-task"], [1, "description", "ms-2"], [1, "bi", "bi-check2-square"], [1, "bi", "bi-box"], [1, "bi", "bi-person"], ["routerLinkActive", "active", "data-bs-toggle", "collapse", "data-bs-target", "#submenu", "aria-expanded", "false", "aria-controls", "submenu", 1, "nav-link", 3, "routerLink"], [1, "bi", "bi-gear-fill"], [1, "bi", "bi-caret-down-fill"], ["routerLinkActive", "active", 1, "nav-link", "ms-2", 3, "routerLink"], [1, "bi", "bi-image"], [1, "bi", "bi-qr-code"], [1, "bi", "bi-bank"], [1, "bi", "bi-basket"], [1, "bi", "bi-graph-down"]], template: function MainMenuComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "nav", 0);
    \u0275\u0275template(1, MainMenuComponent_a_1_Template, 5, 1, "a", 1)(2, MainMenuComponent_a_2_Template, 5, 1, "a", 1)(3, MainMenuComponent_a_3_Template, 5, 1, "a", 1)(4, MainMenuComponent_a_4_Template, 5, 1, "a", 1)(5, MainMenuComponent_a_5_Template, 6, 1, "a", 2);
    \u0275\u0275elementStart(6, "div", 3);
    \u0275\u0275template(7, MainMenuComponent_a_7_Template, 5, 1, "a", 4)(8, MainMenuComponent_a_8_Template, 5, 1, "a", 4)(9, MainMenuComponent_a_9_Template, 5, 1, "a", 4)(10, MainMenuComponent_a_10_Template, 5, 1, "a", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275template(11, MainMenuComponent_a_11_Template, 5, 1, "a", 1)(12, MainMenuComponent_a_12_Template, 5, 1, "a", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
  }
}, dependencies: [NgIf, RouterLink, RouterLinkActive], encapsulation: 2 });
var MainMenuComponent = _MainMenuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(MainMenuComponent, { className: "MainMenuComponent", filePath: "src/app/main-menu/main-menu.component.ts", lineNumber: 11 });
})();

// src/app/app.component.ts
var _c04 = () => ({ unchecked: "blue", checked: "darkorange" });
function AppComponent_li_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 9)(1, "a", 23);
    \u0275\u0275text(2, "Login ");
    \u0275\u0275elementEnd()();
  }
}
function AppComponent_li_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 9)(1, "a", 24);
    \u0275\u0275listener("click", function AppComponent_li_15_Template_a_click_1_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.logout());
    });
    \u0275\u0275text(2, "Logout");
    \u0275\u0275elementEnd()();
  }
}
function AppComponent_li_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 25)(1, "a", 10);
    \u0275\u0275element(2, "fa-icon", 17);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    const popper1Content_r4 = \u0275\u0275reference(19);
    \u0275\u0275property("popper", popper1Content_r4)("popperApplyClass", "popper-content")("popperShowOnStart", false)("popperTrigger", "hover")("popperHideOnClickOutside", true)("popperHideOnScroll", true)("popperPlacement", "bottom");
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx_r2.faUser);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0", ctx_r2.currentAdmin.username, "");
  }
}
function AppComponent_li_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 26)(1, "a", 10);
    \u0275\u0275element(2, "fa-icon", 17);
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "date");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("popperApplyClass", "popper-content")("popper", "Time out")("popperTrigger", ctx_r2.NgxPopperjsTriggers.click)("popperPlacement", "bottom");
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx_r2.faClock);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0", \u0275\u0275pipeBind2(4, 6, ctx_r2.currentAdmin.expiration, "HH:mm"), "");
  }
}
var _AppComponent = class _AppComponent {
  constructor(sharedService, theme, route, authService) {
    this.sharedService = sharedService;
    this.theme = theme;
    this.route = route;
    this.authService = authService;
    this.faUser = AppConstants.iconUser;
    this.faClock = AppConstants.iconClock;
    this.faEmail = AppConstants.iconEmail;
    this.value = true;
    this.destroy$ = new Subject();
    this.NgxPopperjsTriggers = NgxPopperjsTriggers;
    this.authService.currentAdmin.subscribe((x4) => this.currentAdmin = x4);
  }
  ngOnInit() {
    this.resolveThemeMarker();
    this.currentAdmin = this.authService.currentAdminValue;
  }
  logout() {
    this.authService.logout();
    this.route.navigate(["/login"]);
  }
  switchTheme() {
    this.value = !this.value;
    if (this.theme.current === "light") {
      this.theme.current = "dark";
      this.darkTheme = "Dark theme";
      this.sharedService.addLoginImgPath("/assets/images/user-white.png");
    } else {
      this.theme.current = "light";
      this.darkTheme = "Light theme";
      this.sharedService.addLoginImgPath("/assets/images/user-black.png");
    }
  }
  resolveThemeMarker() {
    if (this.theme.current === "light") {
      this.darkTheme = "Light theme";
      this.value = false;
      this.theme.current = "light";
      this.sharedService.addLoginImgPath("/assets/images/user-black.png");
    } else {
      this.value = true;
      this.darkTheme = "Dark theme";
      this.theme.current = "dark";
      this.sharedService.addLoginImgPath("/assets/images/user-white.png");
    }
  }
};
_AppComponent.\u0275fac = function AppComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AppComponent)(\u0275\u0275directiveInject(SharedImgService), \u0275\u0275directiveInject(ThemeService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(AuthService));
};
_AppComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppComponent, selectors: [["app-root"]], standalone: false, decls: 31, vars: 12, consts: [["popper1Content", ""], [1, "container-fluid", "vh-100"], [1, "navbar", "navbar-expand-lg", "navbar-dark", "bg-dark"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#navbarHome", "aria-controls", "navbarHome", "aria-expanded", "false", "aria-label", "Toggle navigation", 1, "navbar-toggler", "mx-3", "mb-3"], [1, "navbar-toggler-icon"], ["id", "navbarHome", 1, "collapse", "navbar-collapse", "mx-3"], ["href", "#", 1, "navbar-brand", "brand"], ["src", "/assets/images/logo.png", "alt", "logo", 1, "img-banner"], [1, "navbar-nav", "me-auto"], [1, "nav-item"], [1, "nav-link"], [1, "me-2"], [3, "valueChange", "value", "color"], ["class", "nav-item", 4, "ngIf"], [1, "navbar-nav", "ms-auto"], ["class", "nav-item", 3, "popper", "popperApplyClass", "popperShowOnStart", "popperTrigger", "popperHideOnClickOutside", "popperHideOnScroll", "popperPlacement", 4, "ngIf"], [1, "mb-2", "d-block"], [3, "icon"], [1, "d-block"], ["class", "nav-item", 3, "popperApplyClass", "popper", "popperTrigger", "popperPlacement", 4, "ngIf"], [1, "row", "h-100"], [1, "col-3", "col-md-2"], [1, "col", "bg-dark", "overflow-auto"], ["routerLinkActive", "active", "routerLink", "login", 1, "nav-link"], [1, "nav-link", 3, "click"], [1, "nav-item", 3, "popper", "popperApplyClass", "popperShowOnStart", "popperTrigger", "popperHideOnClickOutside", "popperHideOnScroll", "popperPlacement"], [1, "nav-item", 3, "popperApplyClass", "popper", "popperTrigger", "popperPlacement"]], template: function AppComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1)(1, "nav", 2)(2, "button", 3);
    \u0275\u0275element(3, "span", 4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 5)(5, "a", 6);
    \u0275\u0275element(6, "img", 7);
    \u0275\u0275text(7, "Admin eshop");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "ul", 8)(9, "li", 9)(10, "span", 10)(11, "span", 11);
    \u0275\u0275text(12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "ng-toggle", 12);
    \u0275\u0275listener("valueChange", function AppComponent_Template_ng_toggle_valueChange_13_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.switchTheme());
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(14, AppComponent_li_14_Template, 3, 0, "li", 13)(15, AppComponent_li_15_Template, 3, 0, "li", 13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "ul", 14);
    \u0275\u0275template(17, AppComponent_li_17_Template, 4, 9, "li", 15);
    \u0275\u0275elementStart(18, "popper-content", null, 0)(20, "span", 16);
    \u0275\u0275element(21, "fa-icon", 17);
    \u0275\u0275text(22);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(23, "span", 18);
    \u0275\u0275element(24, "fa-icon", 17);
    \u0275\u0275text(25);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(26, AppComponent_li_26_Template, 5, 9, "li", 19);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(27, "div", 20);
    \u0275\u0275element(28, "app-main-menu", 21);
    \u0275\u0275elementStart(29, "main", 22);
    \u0275\u0275element(30, "router-outlet");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(12);
    \u0275\u0275textInterpolate(ctx.darkTheme);
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx.value)("color", \u0275\u0275pureFunction0(11, _c04));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.currentAdmin);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.currentAdmin);
    \u0275\u0275advance(4);
    \u0275\u0275property("icon", ctx.faEmail);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0\xA0", ctx.currentAdmin == null ? null : ctx.currentAdmin.email, "");
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faUser);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0\xA0", ctx.currentAdmin == null ? null : ctx.currentAdmin.role, "");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.currentAdmin);
  }
}, dependencies: [NgIf, RouterOutlet, RouterLink, RouterLinkActive, NgxPopperjsContentComponent, NgxPopperjsDirective, FaIconComponent, NgToggleComponent, MainMenuComponent, DatePipe], styles: ["\n\n.bg-dark[_ngcontent-%COMP%] {\n  background-color: var(--color-background-nabvar) !important;\n}\n.navbar-dark[_ngcontent-%COMP%]   .navbar-nav[_ngcontent-%COMP%]   .nav-link[_ngcontent-%COMP%]:active, \n.navbar-dark[_ngcontent-%COMP%]   .navbar-nav[_ngcontent-%COMP%]   .nav-link[_ngcontent-%COMP%]:current {\n  color: var(--color-primary);\n}\n.navbar-dark[_ngcontent-%COMP%]   .navbar-nav[_ngcontent-%COMP%]   .nav-link[_ngcontent-%COMP%] {\n  color: var(--color-dropdown);\n}\n.navbar-dark[_ngcontent-%COMP%]   .navbar-nav[_ngcontent-%COMP%]   .nav-link[_ngcontent-%COMP%]:hover {\n  color: var(--color-primary);\n}\n#navbarHome[_ngcontent-%COMP%]    > ul.navbar-nav.ms-auto[_ngcontent-%COMP%]    > li[_ngcontent-%COMP%]    > a[_ngcontent-%COMP%] {\n  color: var(--color-link);\n  cursor: pointer;\n}\n#navbarHome[_ngcontent-%COMP%]    > ul.navbar-nav.ms-auto[_ngcontent-%COMP%]    > li[_ngcontent-%COMP%]    > a[_ngcontent-%COMP%]:hover {\n  color: var(--color-link-hover);\n}\n#myDropdown[_ngcontent-%COMP%]    > ul.navbar-nav.ms-auto[_ngcontent-%COMP%]    > li[_ngcontent-%COMP%]    > a[_ngcontent-%COMP%] {\n  color: var(--color-link);\n  cursor: pointer;\n}\n#myDropdown[_ngcontent-%COMP%]    > ul.navbar-nav.ms-auto[_ngcontent-%COMP%]    > li[_ngcontent-%COMP%]    > a[_ngcontent-%COMP%]:hover {\n  color: var(--color-link-hover);\n}\n.dropdown-menu[data-bs-popper][_ngcontent-%COMP%] {\n  background: var(--color-background-dropdown) !important;\n  box-shadow: var(--color-box-shadow-primary) !important;\n  color: var(--color-dropdown);\n}\n.dropdown-item[_ngcontent-%COMP%] {\n  color: var(--color-dropdown);\n}\n.dropdown-item[_ngcontent-%COMP%]:hover {\n  color: var(--color-primary);\n  background: var(--color-background-dropdown);\n}\n.dropdown-item.active[_ngcontent-%COMP%] {\n  color: var(--color-primary);\n  background: var(--color-background-dropdown);\n}\n/*# sourceMappingURL=app.component.css.map */"] });
var AppComponent = _AppComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppComponent, { className: "AppComponent", filePath: "src/app/app.component.ts", lineNumber: 17 });
})();

// src/app/model/error/error-dto.ts
var ErrorDto = class {
};

// src/app/model/qr/QrDataRequest.ts
var QrDataRequest = class {
  constructor(data) {
    this.data = data;
  }
};

// src/app/service/qr.service.ts
var _QrService = class _QrService extends BaseService {
  constructor(httpClient) {
    super();
    this.httpClient = httpClient;
    this.qrResponse = AppConstants.baseUrl + "/api/payment/qr-code";
  }
  loadQr(qrRequest, errorDto) {
    const body = JSON.stringify(new QrDataRequest(qrRequest));
    return this.httpClient.post(this.qrResponse, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
};
_QrService.\u0275fac = function QrService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _QrService)(\u0275\u0275inject(HttpClient));
};
_QrService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _QrService, factory: _QrService.\u0275fac, providedIn: "root" });
var QrService = _QrService;

// node_modules/@angular/animations/fesm2022/animations.mjs
var AnimationMetadataType;
(function(AnimationMetadataType2) {
  AnimationMetadataType2[AnimationMetadataType2["State"] = 0] = "State";
  AnimationMetadataType2[AnimationMetadataType2["Transition"] = 1] = "Transition";
  AnimationMetadataType2[AnimationMetadataType2["Sequence"] = 2] = "Sequence";
  AnimationMetadataType2[AnimationMetadataType2["Group"] = 3] = "Group";
  AnimationMetadataType2[AnimationMetadataType2["Animate"] = 4] = "Animate";
  AnimationMetadataType2[AnimationMetadataType2["Keyframes"] = 5] = "Keyframes";
  AnimationMetadataType2[AnimationMetadataType2["Style"] = 6] = "Style";
  AnimationMetadataType2[AnimationMetadataType2["Trigger"] = 7] = "Trigger";
  AnimationMetadataType2[AnimationMetadataType2["Reference"] = 8] = "Reference";
  AnimationMetadataType2[AnimationMetadataType2["AnimateChild"] = 9] = "AnimateChild";
  AnimationMetadataType2[AnimationMetadataType2["AnimateRef"] = 10] = "AnimateRef";
  AnimationMetadataType2[AnimationMetadataType2["Query"] = 11] = "Query";
  AnimationMetadataType2[AnimationMetadataType2["Stagger"] = 12] = "Stagger";
})(AnimationMetadataType || (AnimationMetadataType = {}));
var AUTO_STYLE = "*";
function trigger(name, definitions) {
  return {
    type: AnimationMetadataType.Trigger,
    name,
    definitions,
    options: {}
  };
}
function animate(timings, styles2 = null) {
  return {
    type: AnimationMetadataType.Animate,
    styles: styles2,
    timings
  };
}
function sequence(steps, options = null) {
  return {
    type: AnimationMetadataType.Sequence,
    steps,
    options
  };
}
function style(tokens) {
  return {
    type: AnimationMetadataType.Style,
    styles: tokens,
    offset: null
  };
}
function state(name, styles2, options) {
  return {
    type: AnimationMetadataType.State,
    name,
    styles: styles2,
    options
  };
}
function transition(stateChangeExpr, steps, options = null) {
  return {
    type: AnimationMetadataType.Transition,
    expr: stateChangeExpr,
    animation: steps,
    options
  };
}
var AnimationBuilder = class _AnimationBuilder {
  static \u0275fac = function AnimationBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AnimationBuilder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _AnimationBuilder,
    factory: () => (() => inject(BrowserAnimationBuilder))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnimationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(BrowserAnimationBuilder)
    }]
  }], null, null);
})();
var AnimationFactory = class {
};
var BrowserAnimationBuilder = class _BrowserAnimationBuilder extends AnimationBuilder {
  animationModuleType = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  _nextAnimationId = 0;
  _renderer;
  constructor(rootRenderer, doc) {
    super();
    const typeData = {
      id: "0",
      encapsulation: ViewEncapsulation.None,
      styles: [],
      data: {
        animation: []
      }
    };
    this._renderer = rootRenderer.createRenderer(doc.body, typeData);
    if (this.animationModuleType === null && !isAnimationRenderer(this._renderer)) {
      throw new RuntimeError(3600, (typeof ngDevMode === "undefined" || ngDevMode) && "Angular detected that the `AnimationBuilder` was injected, but animation support was not enabled. Please make sure that you enable animations in your application by calling `provideAnimations()` or `provideAnimationsAsync()` function.");
    }
  }
  build(animation) {
    const id3 = this._nextAnimationId;
    this._nextAnimationId++;
    const entry = Array.isArray(animation) ? sequence(animation) : animation;
    issueAnimationCommand(this._renderer, null, id3, "register", [entry]);
    return new BrowserAnimationFactory(id3, this._renderer);
  }
  static \u0275fac = function BrowserAnimationBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserAnimationBuilder)(\u0275\u0275inject(RendererFactory2), \u0275\u0275inject(DOCUMENT2));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _BrowserAnimationBuilder,
    factory: _BrowserAnimationBuilder.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserAnimationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RendererFactory2
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], null);
})();
var BrowserAnimationFactory = class extends AnimationFactory {
  _id;
  _renderer;
  constructor(_id, _renderer) {
    super();
    this._id = _id;
    this._renderer = _renderer;
  }
  create(element, options) {
    return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
  }
};
var RendererAnimationPlayer = class {
  id;
  element;
  _renderer;
  parentPlayer = null;
  _started = false;
  constructor(id3, element, options, _renderer) {
    this.id = id3;
    this.element = element;
    this._renderer = _renderer;
    this._command("create", options);
  }
  _listen(eventName, callback) {
    return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);
  }
  _command(command, ...args) {
    issueAnimationCommand(this._renderer, this.element, this.id, command, args);
  }
  onDone(fn) {
    this._listen("done", fn);
  }
  onStart(fn) {
    this._listen("start", fn);
  }
  onDestroy(fn) {
    this._listen("destroy", fn);
  }
  init() {
    this._command("init");
  }
  hasStarted() {
    return this._started;
  }
  play() {
    this._command("play");
    this._started = true;
  }
  pause() {
    this._command("pause");
  }
  restart() {
    this._command("restart");
  }
  finish() {
    this._command("finish");
  }
  destroy() {
    this._command("destroy");
  }
  reset() {
    this._command("reset");
    this._started = false;
  }
  setPosition(p2) {
    this._command("setPosition", p2);
  }
  getPosition() {
    return unwrapAnimationRenderer(this._renderer)?.engine?.players[this.id]?.getPosition() ?? 0;
  }
  totalTime = 0;
};
function issueAnimationCommand(renderer, element, id3, command, args) {
  renderer.setProperty(element, `@@${id3}:${command}`, args);
}
function unwrapAnimationRenderer(renderer) {
  const type2 = renderer.\u0275type;
  if (type2 === 0) {
    return renderer;
  } else if (type2 === 1) {
    return renderer.animationRenderer;
  }
  return null;
}
function isAnimationRenderer(renderer) {
  const type2 = renderer.\u0275type;
  return type2 === 0 || type2 === 1;
}
var NoopAnimationPlayer = class {
  _onDoneFns = [];
  _onStartFns = [];
  _onDestroyFns = [];
  _originalOnDoneFns = [];
  _originalOnStartFns = [];
  _started = false;
  _destroyed = false;
  _finished = false;
  _position = 0;
  parentPlayer = null;
  totalTime;
  constructor(duration = 0, delay = 0) {
    this.totalTime = duration + delay;
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach((fn) => fn());
      this._onDoneFns = [];
    }
  }
  onStart(fn) {
    this._originalOnStartFns.push(fn);
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._originalOnDoneFns.push(fn);
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  hasStarted() {
    return this._started;
  }
  init() {
  }
  play() {
    if (!this.hasStarted()) {
      this._onStart();
      this.triggerMicrotask();
    }
    this._started = true;
  }
  /** @internal */
  triggerMicrotask() {
    queueMicrotask(() => this._onFinish());
  }
  _onStart() {
    this._onStartFns.forEach((fn) => fn());
    this._onStartFns = [];
  }
  pause() {
  }
  restart() {
  }
  finish() {
    this._onFinish();
  }
  destroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      if (!this.hasStarted()) {
        this._onStart();
      }
      this.finish();
      this._onDestroyFns.forEach((fn) => fn());
      this._onDestroyFns = [];
    }
  }
  reset() {
    this._started = false;
    this._finished = false;
    this._onStartFns = this._originalOnStartFns;
    this._onDoneFns = this._originalOnDoneFns;
  }
  setPosition(position) {
    this._position = this.totalTime ? position * this.totalTime : 1;
  }
  getPosition() {
    return this.totalTime ? this._position / this.totalTime : 1;
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == "start" ? this._onStartFns : this._onDoneFns;
    methods.forEach((fn) => fn());
    methods.length = 0;
  }
};
var AnimationGroupPlayer = class {
  _onDoneFns = [];
  _onStartFns = [];
  _finished = false;
  _started = false;
  _destroyed = false;
  _onDestroyFns = [];
  parentPlayer = null;
  totalTime = 0;
  players;
  constructor(_players) {
    this.players = _players;
    let doneCount = 0;
    let destroyCount = 0;
    let startCount = 0;
    const total = this.players.length;
    if (total == 0) {
      queueMicrotask(() => this._onFinish());
    } else {
      this.players.forEach((player) => {
        player.onDone(() => {
          if (++doneCount == total) {
            this._onFinish();
          }
        });
        player.onDestroy(() => {
          if (++destroyCount == total) {
            this._onDestroy();
          }
        });
        player.onStart(() => {
          if (++startCount == total) {
            this._onStart();
          }
        });
      });
    }
    this.totalTime = this.players.reduce((time2, player) => Math.max(time2, player.totalTime), 0);
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach((fn) => fn());
      this._onDoneFns = [];
    }
  }
  init() {
    this.players.forEach((player) => player.init());
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  _onStart() {
    if (!this.hasStarted()) {
      this._started = true;
      this._onStartFns.forEach((fn) => fn());
      this._onStartFns = [];
    }
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  hasStarted() {
    return this._started;
  }
  play() {
    if (!this.parentPlayer) {
      this.init();
    }
    this._onStart();
    this.players.forEach((player) => player.play());
  }
  pause() {
    this.players.forEach((player) => player.pause());
  }
  restart() {
    this.players.forEach((player) => player.restart());
  }
  finish() {
    this._onFinish();
    this.players.forEach((player) => player.finish());
  }
  destroy() {
    this._onDestroy();
  }
  _onDestroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      this._onFinish();
      this.players.forEach((player) => player.destroy());
      this._onDestroyFns.forEach((fn) => fn());
      this._onDestroyFns = [];
    }
  }
  reset() {
    this.players.forEach((player) => player.reset());
    this._destroyed = false;
    this._finished = false;
    this._started = false;
  }
  setPosition(p2) {
    const timeAtPosition = p2 * this.totalTime;
    this.players.forEach((player) => {
      const position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
      player.setPosition(position);
    });
  }
  getPosition() {
    const longestPlayer = this.players.reduce((longestSoFar, player) => {
      const newPlayerIsLongest = longestSoFar === null || player.totalTime > longestSoFar.totalTime;
      return newPlayerIsLongest ? player : longestSoFar;
    }, null);
    return longestPlayer != null ? longestPlayer.getPosition() : 0;
  }
  beforeDestroy() {
    this.players.forEach((player) => {
      if (player.beforeDestroy) {
        player.beforeDestroy();
      }
    });
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName == "start" ? this._onStartFns : this._onDoneFns;
    methods.forEach((fn) => fn());
    methods.length = 0;
  }
};
var \u0275PRE_STYLE = "!";

// node_modules/ngx-spinner/fesm2022/ngx-spinner.mjs
var _c05 = ["overlay"];
var _c12 = ["*"];
function NgxSpinnerComponent_div_0_div_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div");
  }
}
function NgxSpinnerComponent_div_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275template(1, NgxSpinnerComponent_div_0_div_2_div_1_Template, 1, 0, "div", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.spinner.class);
    \u0275\u0275styleProp("color", ctx_r0.spinner.color);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r0.spinner.divArray);
  }
}
function NgxSpinnerComponent_div_0_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 7);
    \u0275\u0275pipe(1, "safeHtml");
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("innerHTML", \u0275\u0275pipeBind1(1, 1, ctx_r0.template), \u0275\u0275sanitizeHtml);
  }
}
function NgxSpinnerComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2, 0);
    \u0275\u0275template(2, NgxSpinnerComponent_div_0_div_2_Template, 2, 5, "div", 3)(3, NgxSpinnerComponent_div_0_div_3_Template, 2, 3, "div", 4);
    \u0275\u0275elementStart(4, "div", 5);
    \u0275\u0275projection(5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("background-color", ctx_r0.spinner.bdColor)("z-index", ctx_r0.spinner.zIndex)("position", ctx_r0.spinner.fullScreen ? "fixed" : "absolute");
    \u0275\u0275property("@.disabled", ctx_r0.disableAnimation)("@fadeIn", "in");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !ctx_r0.template);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.template);
    \u0275\u0275advance();
    \u0275\u0275styleProp("z-index", ctx_r0.spinner.zIndex);
  }
}
var LOADERS = {
  "ball-8bits": 16,
  "ball-atom": 4,
  "ball-beat": 3,
  "ball-circus": 5,
  "ball-climbing-dot": 4,
  "ball-clip-rotate": 1,
  "ball-clip-rotate-multiple": 2,
  "ball-clip-rotate-pulse": 2,
  "ball-elastic-dots": 5,
  "ball-fall": 3,
  "ball-fussion": 4,
  "ball-grid-beat": 9,
  "ball-grid-pulse": 9,
  "ball-newton-cradle": 4,
  "ball-pulse": 3,
  "ball-pulse-rise": 5,
  "ball-pulse-sync": 3,
  "ball-rotate": 1,
  "ball-running-dots": 5,
  "ball-scale": 1,
  "ball-scale-multiple": 3,
  "ball-scale-pulse": 2,
  "ball-scale-ripple": 1,
  "ball-scale-ripple-multiple": 3,
  "ball-spin": 8,
  "ball-spin-clockwise": 8,
  "ball-spin-clockwise-fade": 8,
  "ball-spin-clockwise-fade-rotating": 8,
  "ball-spin-fade": 8,
  "ball-spin-fade-rotating": 8,
  "ball-spin-rotate": 2,
  "ball-square-clockwise-spin": 8,
  "ball-square-spin": 8,
  "ball-triangle-path": 3,
  "ball-zig-zag": 2,
  "ball-zig-zag-deflect": 2,
  cog: 1,
  "cube-transition": 2,
  fire: 3,
  "line-scale": 5,
  "line-scale-party": 5,
  "line-scale-pulse-out": 5,
  "line-scale-pulse-out-rapid": 5,
  "line-spin-clockwise-fade": 8,
  "line-spin-clockwise-fade-rotating": 8,
  "line-spin-fade": 8,
  "line-spin-fade-rotating": 8,
  pacman: 6,
  "square-jelly-box": 2,
  "square-loader": 1,
  "square-spin": 1,
  timer: 1,
  "triangle-skew-spin": 1
};
var DEFAULTS = {
  BD_COLOR: "rgba(51,51,51,0.8)",
  SPINNER_COLOR: "#fff",
  Z_INDEX: 99999
};
var PRIMARY_SPINNER = "primary";
var NgxSpinner = class _NgxSpinner {
  constructor(init2) {
    Object.assign(this, init2);
  }
  static create(init2) {
    if (!init2?.template && !init2?.type) {
      console.warn(`[ngx-spinner]: Property "type" is missed. Please, provide animation type to <ngx-spinner> component
        and ensure css is added to angular.json file`);
    }
    return new _NgxSpinner(init2);
  }
};
var _NgxSpinnerService = class _NgxSpinnerService {
  /**
   * Creates an instance of NgxSpinnerService.
   * @memberof NgxSpinnerService
   */
  constructor() {
    this.spinnerObservable = new BehaviorSubject(null);
  }
  /**
   * Get subscription of desired spinner
   * @memberof NgxSpinnerService
   **/
  getSpinner(name) {
    return this.spinnerObservable.asObservable().pipe(filter((x4) => x4 && x4.name === name));
  }
  /**
   * To show spinner
   *
   * @memberof NgxSpinnerService
   */
  show(name = PRIMARY_SPINNER, spinner) {
    return new Promise((resolve, _reject) => {
      setTimeout(() => {
        if (spinner && Object.keys(spinner).length) {
          spinner["name"] = name;
          this.spinnerObservable.next(new NgxSpinner(__spreadProps(__spreadValues({}, spinner), {
            show: true
          })));
          resolve(true);
        } else {
          this.spinnerObservable.next(new NgxSpinner({
            name,
            show: true
          }));
          resolve(true);
        }
      }, 10);
    });
  }
  /**
   * To hide spinner
   *
   * @memberof NgxSpinnerService
   */
  hide(name = PRIMARY_SPINNER, debounce = 10) {
    return new Promise((resolve, _reject) => {
      setTimeout(() => {
        this.spinnerObservable.next(new NgxSpinner({
          name,
          show: false
        }));
        resolve(true);
      }, debounce);
    });
  }
};
_NgxSpinnerService.\u0275fac = function NgxSpinnerService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NgxSpinnerService)();
};
_NgxSpinnerService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _NgxSpinnerService,
  factory: _NgxSpinnerService.\u0275fac,
  providedIn: "root"
});
var NgxSpinnerService = _NgxSpinnerService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxSpinnerService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var NGX_SPINNER_CONFIG = new InjectionToken("NGX_SPINNER_CONFIG");
var _SafeHtmlPipe = class _SafeHtmlPipe {
  constructor(_sanitizer) {
    this._sanitizer = _sanitizer;
  }
  transform(v) {
    if (v) {
      return this._sanitizer.bypassSecurityTrustHtml(v);
    }
  }
};
_SafeHtmlPipe.\u0275fac = function SafeHtmlPipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _SafeHtmlPipe)(\u0275\u0275directiveInject(DomSanitizer, 16));
};
_SafeHtmlPipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
  name: "safeHtml",
  type: _SafeHtmlPipe,
  pure: true
});
var SafeHtmlPipe = _SafeHtmlPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SafeHtmlPipe, [{
    type: Pipe,
    args: [{
      name: "safeHtml",
      standalone: true
    }]
  }], () => [{
    type: DomSanitizer
  }], null);
})();
var _NgxSpinnerComponent = class _NgxSpinnerComponent {
  // TODO: https://github.com/Napster2210/ngx-spinner/issues/259
  // @HostListener("document:keydown", ["$event"])
  // handleKeyboardEvent(event: KeyboardEvent) {
  //   if (this.spinnerDOM && this.spinnerDOM.nativeElement) {
  //     if (
  //       this.fullScreen ||
  //       (!this.fullScreen && this.isSpinnerZone(event.target))
  //     ) {
  //       event.returnValue = false;
  //       event.preventDefault();
  //     }
  //   }
  // }
  /**
   * Creates an instance of NgxSpinnerComponent.
   *
   * @memberof NgxSpinnerComponent
   */
  constructor(spinnerService, changeDetector, elementRef, globalConfig) {
    this.spinnerService = spinnerService;
    this.changeDetector = changeDetector;
    this.elementRef = elementRef;
    this.globalConfig = globalConfig;
    this.disableAnimation = false;
    this.spinner = new NgxSpinner();
    this.ngUnsubscribe = new Subject();
    this.setDefaultOptions = () => {
      const {
        type: type2
      } = this.globalConfig ?? {};
      this.spinner = NgxSpinner.create({
        name: this.name,
        bdColor: this.bdColor,
        size: this.size,
        color: this.color,
        type: this.type ?? type2,
        fullScreen: this.fullScreen,
        divArray: this.divArray,
        divCount: this.divCount,
        show: this.show,
        zIndex: this.zIndex,
        template: this.template,
        showSpinner: this.showSpinner
      });
    };
    this.bdColor = DEFAULTS.BD_COLOR;
    this.zIndex = DEFAULTS.Z_INDEX;
    this.color = DEFAULTS.SPINNER_COLOR;
    this.size = "large";
    this.fullScreen = true;
    this.name = PRIMARY_SPINNER;
    this.template = null;
    this.showSpinner = false;
    this.divArray = [];
    this.divCount = 0;
    this.show = false;
  }
  initObservable() {
    this.spinnerService.getSpinner(this.name).pipe(takeUntil(this.ngUnsubscribe)).subscribe((spinner) => {
      this.setDefaultOptions();
      Object.assign(this.spinner, spinner);
      if (spinner.show) {
        this.onInputChange();
      }
      this.changeDetector.detectChanges();
    });
  }
  /**
   * Initialization method
   *
   * @memberof NgxSpinnerComponent
   */
  ngOnInit() {
    this.setDefaultOptions();
    this.initObservable();
  }
  /**
   * To check event triggers inside the Spinner Zone
   *
   * @param {*} element
   * @returns {boolean}
   * @memberof NgxSpinnerComponent
   */
  isSpinnerZone(element) {
    if (element === this.elementRef.nativeElement.parentElement) {
      return true;
    }
    return element.parentNode && this.isSpinnerZone(element.parentNode);
  }
  /**
   * On changes event for input variables
   *
   * @memberof NgxSpinnerComponent
   */
  ngOnChanges(changes) {
    for (const propName in changes) {
      if (propName) {
        const changedProp = changes[propName];
        if (changedProp.isFirstChange()) {
          return;
        } else if (typeof changedProp.currentValue !== "undefined" && changedProp.currentValue !== changedProp.previousValue) {
          if (changedProp.currentValue !== "") {
            this.spinner[propName] = changedProp.currentValue;
            if (propName === "showSpinner") {
              if (changedProp.currentValue) {
                this.spinnerService.show(this.spinner.name, this.spinner);
              } else {
                this.spinnerService.hide(this.spinner.name);
              }
            }
            if (propName === "name") {
              this.initObservable();
            }
          }
        }
      }
    }
  }
  /**
   * To get class for spinner
   *
   * @memberof NgxSpinnerComponent
   */
  getClass(type2, size2) {
    this.spinner.divCount = LOADERS[type2];
    this.spinner.divArray = Array(this.spinner.divCount).fill(0).map((_, i) => i);
    let sizeClass = "";
    switch (size2.toLowerCase()) {
      case "small":
        sizeClass = "la-sm";
        break;
      case "medium":
        sizeClass = "la-2x";
        break;
      case "large":
        sizeClass = "la-3x";
        break;
      default:
        break;
    }
    return "la-" + type2 + " " + sizeClass;
  }
  /**
   * Check if input variables have changed
   *
   * @memberof NgxSpinnerComponent
   */
  onInputChange() {
    this.spinner.class = this.getClass(this.spinner.type, this.spinner.size);
  }
  /**
   * Component destroy event
   *
   * @memberof NgxSpinnerComponent
   */
  ngOnDestroy() {
    this.ngUnsubscribe.next();
    this.ngUnsubscribe.complete();
  }
};
_NgxSpinnerComponent.\u0275fac = function NgxSpinnerComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NgxSpinnerComponent)(\u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NGX_SPINNER_CONFIG, 8));
};
_NgxSpinnerComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NgxSpinnerComponent,
  selectors: [["ngx-spinner"]],
  viewQuery: function NgxSpinnerComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c05, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.spinnerDOM = _t.first);
    }
  },
  inputs: {
    bdColor: "bdColor",
    size: "size",
    color: "color",
    type: "type",
    fullScreen: "fullScreen",
    name: "name",
    zIndex: "zIndex",
    template: "template",
    showSpinner: "showSpinner",
    disableAnimation: "disableAnimation"
  },
  features: [\u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c12,
  decls: 1,
  vars: 1,
  consts: [["overlay", ""], ["class", "ngx-spinner-overlay", 3, "background-color", "z-index", "position", 4, "ngIf"], [1, "ngx-spinner-overlay"], [3, "class", "color", 4, "ngIf"], [3, "innerHTML", 4, "ngIf"], [1, "loading-text"], [4, "ngFor", "ngForOf"], [3, "innerHTML"]],
  template: function NgxSpinnerComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, NgxSpinnerComponent_div_0_Template, 6, 12, "div", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.spinner.show);
    }
  },
  dependencies: [SafeHtmlPipe, NgIf, NgForOf],
  styles: [".ngx-spinner-overlay[_ngcontent-%COMP%]{position:fixed;top:0;left:0;width:100%;height:100%}.ngx-spinner-overlay[_ngcontent-%COMP%] > div[_ngcontent-%COMP%]:not(.loading-text){top:50%;left:50%;margin:0;position:absolute;transform:translate(-50%,-50%)}.loading-text[_ngcontent-%COMP%]{position:absolute;top:60%;left:50%;transform:translate(-50%,-60%)}"],
  data: {
    animation: [trigger("fadeIn", [state("in", style({
      opacity: 1
    })), transition(":enter", [style({
      opacity: 0
    }), animate(300)]), transition(":leave", animate(200, style({
      opacity: 0
    })))])]
  },
  changeDetection: 0
});
var NgxSpinnerComponent = _NgxSpinnerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxSpinnerComponent, [{
    type: Component,
    args: [{
      imports: [SafeHtmlPipe, NgIf, NgForOf],
      standalone: true,
      selector: "ngx-spinner",
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("fadeIn", [state("in", style({
        opacity: 1
      })), transition(":enter", [style({
        opacity: 0
      }), animate(300)]), transition(":leave", animate(200, style({
        opacity: 0
      })))])],
      template: `<div
  [@.disabled]="disableAnimation"
  [@fadeIn]="'in'"
  *ngIf="spinner.show"
  class="ngx-spinner-overlay"
  [style.background-color]="spinner.bdColor"
  [style.z-index]="spinner.zIndex"
  [style.position]="spinner.fullScreen ? 'fixed' : 'absolute'"
  #overlay
>
  <div *ngIf="!template" [class]="spinner.class" [style.color]="spinner.color">
    <div *ngFor="let index of spinner.divArray"></div>
  </div>
  <div *ngIf="template" [innerHTML]="template | safeHtml"></div>
  <div class="loading-text" [style.z-index]="spinner.zIndex">
    <ng-content></ng-content>
  </div>
</div>
`,
      styles: [".ngx-spinner-overlay{position:fixed;top:0;left:0;width:100%;height:100%}.ngx-spinner-overlay>div:not(.loading-text){top:50%;left:50%;margin:0;position:absolute;transform:translate(-50%,-50%)}.loading-text{position:absolute;top:60%;left:50%;transform:translate(-50%,-60%)}\n"]
    }]
  }], () => [{
    type: NgxSpinnerService
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NGX_SPINNER_CONFIG]
    }]
  }], {
    bdColor: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    fullScreen: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    zIndex: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    showSpinner: [{
      type: Input
    }],
    disableAnimation: [{
      type: Input
    }],
    spinnerDOM: [{
      type: ViewChild,
      args: ["overlay"]
    }]
  });
})();
var _NgxSpinnerModule = class _NgxSpinnerModule {
  static forRoot(config3) {
    return {
      ngModule: _NgxSpinnerModule,
      providers: [{
        provide: NGX_SPINNER_CONFIG,
        useValue: config3
      }]
    };
  }
};
_NgxSpinnerModule.\u0275fac = function NgxSpinnerModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NgxSpinnerModule)();
};
_NgxSpinnerModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NgxSpinnerModule
});
_NgxSpinnerModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var NgxSpinnerModule = _NgxSpinnerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxSpinnerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NgxSpinnerComponent, SafeHtmlPipe],
      exports: [NgxSpinnerComponent]
    }]
  }], null, null);
})();

// node_modules/ngx-toastr/fesm2022/ngx-toastr.mjs
var _c06 = ["toast-component", ""];
function Toast_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 5);
    \u0275\u0275listener("click", function Toast_button_0_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.remove());
    });
    \u0275\u0275elementStart(1, "span", 6);
    \u0275\u0275text(2, "\xD7");
    \u0275\u0275elementEnd()();
  }
}
function Toast_div_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("[", ctx_r1.duplicatesCount + 1, "]");
  }
}
function Toast_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275template(2, Toast_div_1_ng_container_2_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.options.titleClass);
    \u0275\u0275attribute("aria-label", ctx_r1.title);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.title, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.duplicatesCount);
  }
}
function Toast_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 7);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.options.messageClass);
    \u0275\u0275property("innerHTML", ctx_r1.message, \u0275\u0275sanitizeHtml);
  }
}
function Toast_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.options.messageClass);
    \u0275\u0275attribute("aria-label", ctx_r1.message);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.message, " ");
  }
}
function Toast_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275element(1, "div", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275styleProp("width", ctx_r1.width() + "%");
  }
}
function ToastNoAnimation_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 5);
    \u0275\u0275listener("click", function ToastNoAnimation_button_0_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.remove());
    });
    \u0275\u0275elementStart(1, "span", 6);
    \u0275\u0275text(2, "\xD7");
    \u0275\u0275elementEnd()();
  }
}
function ToastNoAnimation_div_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("[", ctx_r1.duplicatesCount + 1, "]");
  }
}
function ToastNoAnimation_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275template(2, ToastNoAnimation_div_1_ng_container_2_Template, 2, 1, "ng-container", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.options.titleClass);
    \u0275\u0275attribute("aria-label", ctx_r1.title);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.title, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.duplicatesCount);
  }
}
function ToastNoAnimation_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 7);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.options.messageClass);
    \u0275\u0275property("innerHTML", ctx_r1.message, \u0275\u0275sanitizeHtml);
  }
}
function ToastNoAnimation_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.options.messageClass);
    \u0275\u0275attribute("aria-label", ctx_r1.message);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.message, " ");
  }
}
function ToastNoAnimation_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275element(1, "div", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275styleProp("width", ctx_r1.width() + "%");
  }
}
var ToastContainerDirective = class _ToastContainerDirective {
  el;
  constructor(el) {
    this.el = el;
  }
  getContainerElement() {
    return this.el.nativeElement;
  }
  static \u0275fac = function ToastContainerDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToastContainerDirective)(\u0275\u0275directiveInject(ElementRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _ToastContainerDirective,
    selectors: [["", "toastContainer", ""]],
    exportAs: ["toastContainer"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToastContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[toastContainer]",
      exportAs: "toastContainer",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], null);
})();
var ComponentPortal = class {
  _attachedHost;
  /** The type of the component that will be instantiated for attachment. */
  component;
  /**
   * [Optional] Where the attached component should live in Angular's *logical* component tree.
   * This is different from where the component *renders*, which is determined by the PortalHost.
   * The origin necessary when the host is outside of the Angular application context.
   */
  viewContainerRef;
  /** Injector used for the instantiation of the component. */
  injector;
  constructor(component, injector) {
    this.component = component;
    this.injector = injector;
  }
  /** Attach this portal to a host. */
  attach(host, newestOnTop) {
    this._attachedHost = host;
    return host.attach(this, newestOnTop);
  }
  /** Detach this portal from its host */
  detach() {
    const host = this._attachedHost;
    if (host) {
      this._attachedHost = void 0;
      return host.detach();
    }
  }
  /** Whether this portal is attached to a host. */
  get isAttached() {
    return this._attachedHost != null;
  }
  /**
   * Sets the PortalHost reference without performing `attach()`. This is used directly by
   * the PortalHost when it is performing an `attach()` or `detach()`.
   */
  setAttachedHost(host) {
    this._attachedHost = host;
  }
};
var BasePortalHost = class {
  /** The portal currently attached to the host. */
  _attachedPortal;
  /** A function that will permanently dispose this host. */
  _disposeFn;
  attach(portal, newestOnTop) {
    this._attachedPortal = portal;
    return this.attachComponentPortal(portal, newestOnTop);
  }
  detach() {
    if (this._attachedPortal) {
      this._attachedPortal.setAttachedHost();
    }
    this._attachedPortal = void 0;
    if (this._disposeFn) {
      this._disposeFn();
      this._disposeFn = void 0;
    }
  }
  setDisposeFn(fn) {
    this._disposeFn = fn;
  }
};
var ToastRef = class {
  _overlayRef;
  /** The instance of component opened into the toast. */
  componentInstance;
  /** Count of duplicates of this toast */
  duplicatesCount = 0;
  /** Subject for notifying the user that the toast has finished closing. */
  _afterClosed = new Subject();
  /** triggered when toast is activated */
  _activate = new Subject();
  /** notifies the toast that it should close before the timeout */
  _manualClose = new Subject();
  /** notifies the toast that it should reset the timeouts */
  _resetTimeout = new Subject();
  /** notifies the toast that it should count a duplicate toast */
  _countDuplicate = new Subject();
  constructor(_overlayRef) {
    this._overlayRef = _overlayRef;
  }
  manualClose() {
    this._manualClose.next();
    this._manualClose.complete();
  }
  manualClosed() {
    return this._manualClose.asObservable();
  }
  timeoutReset() {
    return this._resetTimeout.asObservable();
  }
  countDuplicate() {
    return this._countDuplicate.asObservable();
  }
  /**
   * Close the toast.
   */
  close() {
    this._overlayRef.detach();
    this._afterClosed.next();
    this._manualClose.next();
    this._afterClosed.complete();
    this._manualClose.complete();
    this._activate.complete();
    this._resetTimeout.complete();
    this._countDuplicate.complete();
  }
  /** Gets an observable that is notified when the toast is finished closing. */
  afterClosed() {
    return this._afterClosed.asObservable();
  }
  isInactive() {
    return this._activate.isStopped;
  }
  activate() {
    this._activate.next();
    this._activate.complete();
  }
  /** Gets an observable that is notified when the toast has started opening. */
  afterActivate() {
    return this._activate.asObservable();
  }
  /** Reset the toast timouts and count duplicates */
  onDuplicate(resetTimeout, countDuplicate) {
    if (resetTimeout) {
      this._resetTimeout.next();
    }
    if (countDuplicate) {
      this._countDuplicate.next(++this.duplicatesCount);
    }
  }
};
var ToastPackage = class {
  toastId;
  config;
  message;
  title;
  toastType;
  toastRef;
  _onTap = new Subject();
  _onAction = new Subject();
  constructor(toastId, config3, message, title, toastType, toastRef) {
    this.toastId = toastId;
    this.config = config3;
    this.message = message;
    this.title = title;
    this.toastType = toastType;
    this.toastRef = toastRef;
    this.toastRef.afterClosed().subscribe(() => {
      this._onAction.complete();
      this._onTap.complete();
    });
  }
  /** Fired on click */
  triggerTap() {
    this._onTap.next();
    if (this.config.tapToDismiss) {
      this._onTap.complete();
    }
  }
  onTap() {
    return this._onTap.asObservable();
  }
  /** available for use in custom toast */
  triggerAction(action) {
    this._onAction.next(action);
  }
  onAction() {
    return this._onAction.asObservable();
  }
};
var DefaultNoComponentGlobalConfig = {
  maxOpened: 0,
  autoDismiss: false,
  newestOnTop: true,
  preventDuplicates: false,
  countDuplicates: false,
  resetTimeoutOnDuplicate: false,
  includeTitleDuplicates: false,
  iconClasses: {
    error: "toast-error",
    info: "toast-info",
    success: "toast-success",
    warning: "toast-warning"
  },
  // Individual
  closeButton: false,
  disableTimeOut: false,
  timeOut: 5e3,
  extendedTimeOut: 1e3,
  enableHtml: false,
  progressBar: false,
  toastClass: "ngx-toastr",
  positionClass: "toast-top-right",
  titleClass: "toast-title",
  messageClass: "toast-message",
  easing: "ease-in",
  easeTime: 300,
  tapToDismiss: true,
  onActivateTick: false,
  progressAnimation: "decreasing"
};
var TOAST_CONFIG = new InjectionToken("ToastConfig");
var DomPortalHost = class extends BasePortalHost {
  _hostDomElement;
  _componentFactoryResolver;
  _appRef;
  constructor(_hostDomElement, _componentFactoryResolver, _appRef) {
    super();
    this._hostDomElement = _hostDomElement;
    this._componentFactoryResolver = _componentFactoryResolver;
    this._appRef = _appRef;
  }
  /**
   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
   * @param portal Portal to be attached
   */
  attachComponentPortal(portal, newestOnTop) {
    const componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
    let componentRef;
    componentRef = componentFactory.create(portal.injector);
    this._appRef.attachView(componentRef.hostView);
    this.setDisposeFn(() => {
      this._appRef.detachView(componentRef.hostView);
      componentRef.destroy();
    });
    if (newestOnTop) {
      this._hostDomElement.insertBefore(this._getComponentRootNode(componentRef), this._hostDomElement.firstChild);
    } else {
      this._hostDomElement.appendChild(this._getComponentRootNode(componentRef));
    }
    return componentRef;
  }
  /** Gets the root HTMLElement for an instantiated component. */
  _getComponentRootNode(componentRef) {
    return componentRef.hostView.rootNodes[0];
  }
};
var OverlayContainer = class _OverlayContainer {
  _document = inject(DOCUMENT2);
  _containerElement;
  ngOnDestroy() {
    if (this._containerElement && this._containerElement.parentNode) {
      this._containerElement.parentNode.removeChild(this._containerElement);
    }
  }
  /**
   * This method returns the overlay container element. It will lazily
   * create the element the first time  it is called to facilitate using
   * the container in non-browser environments.
   * @returns the container element
   */
  getContainerElement() {
    if (!this._containerElement) {
      this._createContainer();
    }
    return this._containerElement;
  }
  /**
   * Create the overlay container element, which is simply a div
   * with the 'cdk-overlay-container' class on the document body
   * and 'aria-live="polite"'
   */
  _createContainer() {
    const container = this._document.createElement("div");
    container.classList.add("overlay-container");
    container.setAttribute("aria-live", "polite");
    this._document.body.appendChild(container);
    this._containerElement = container;
  }
  static \u0275fac = function OverlayContainer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OverlayContainer)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _OverlayContainer,
    factory: _OverlayContainer.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var OverlayRef = class {
  _portalHost;
  constructor(_portalHost) {
    this._portalHost = _portalHost;
  }
  attach(portal, newestOnTop = true) {
    return this._portalHost.attach(portal, newestOnTop);
  }
  /**
   * Detaches an overlay from a portal.
   * @returns Resolves when the overlay has been detached.
   */
  detach() {
    return this._portalHost.detach();
  }
};
var Overlay = class _Overlay {
  _overlayContainer = inject(OverlayContainer);
  _componentFactoryResolver = inject(ComponentFactoryResolver$1);
  _appRef = inject(ApplicationRef);
  _document = inject(DOCUMENT2);
  // Namespace panes by overlay container
  _paneElements = /* @__PURE__ */ new Map();
  /**
   * Creates an overlay.
   * @returns A reference to the created overlay.
   */
  create(positionClass, overlayContainer) {
    return this._createOverlayRef(this.getPaneElement(positionClass, overlayContainer));
  }
  getPaneElement(positionClass = "", overlayContainer) {
    if (!this._paneElements.get(overlayContainer)) {
      this._paneElements.set(overlayContainer, {});
    }
    if (!this._paneElements.get(overlayContainer)[positionClass]) {
      this._paneElements.get(overlayContainer)[positionClass] = this._createPaneElement(positionClass, overlayContainer);
    }
    return this._paneElements.get(overlayContainer)[positionClass];
  }
  /**
   * Creates the DOM element for an overlay and appends it to the overlay container.
   * @returns Newly-created pane element
   */
  _createPaneElement(positionClass, overlayContainer) {
    const pane = this._document.createElement("div");
    pane.id = "toast-container";
    pane.classList.add(positionClass);
    pane.classList.add("toast-container");
    if (!overlayContainer) {
      this._overlayContainer.getContainerElement().appendChild(pane);
    } else {
      overlayContainer.getContainerElement().appendChild(pane);
    }
    return pane;
  }
  /**
   * Create a DomPortalHost into which the overlay content can be loaded.
   * @param pane The DOM element to turn into a portal host.
   * @returns A portal host for the given DOM element.
   */
  _createPortalHost(pane) {
    return new DomPortalHost(pane, this._componentFactoryResolver, this._appRef);
  }
  /**
   * Creates an OverlayRef for an overlay in the given DOM element.
   * @param pane DOM element for the overlay
   */
  _createOverlayRef(pane) {
    return new OverlayRef(this._createPortalHost(pane));
  }
  static \u0275fac = function Overlay_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Overlay)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Overlay,
    factory: _Overlay.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Overlay, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ToastrService = class _ToastrService {
  overlay;
  _injector;
  sanitizer;
  ngZone;
  toastrConfig;
  currentlyActive = 0;
  toasts = [];
  overlayContainer;
  previousToastMessage;
  index = 0;
  constructor(token, overlay, _injector, sanitizer, ngZone) {
    this.overlay = overlay;
    this._injector = _injector;
    this.sanitizer = sanitizer;
    this.ngZone = ngZone;
    this.toastrConfig = __spreadValues(__spreadValues({}, token.default), token.config);
    if (token.config.iconClasses) {
      this.toastrConfig.iconClasses = __spreadValues(__spreadValues({}, token.default.iconClasses), token.config.iconClasses);
    }
  }
  /** show toast */
  show(message, title, override = {}, type2 = "") {
    return this._preBuildNotification(type2, message, title, this.applyConfig(override));
  }
  /** show successful toast */
  success(message, title, override = {}) {
    const type2 = this.toastrConfig.iconClasses.success || "";
    return this._preBuildNotification(type2, message, title, this.applyConfig(override));
  }
  /** show error toast */
  error(message, title, override = {}) {
    const type2 = this.toastrConfig.iconClasses.error || "";
    return this._preBuildNotification(type2, message, title, this.applyConfig(override));
  }
  /** show info toast */
  info(message, title, override = {}) {
    const type2 = this.toastrConfig.iconClasses.info || "";
    return this._preBuildNotification(type2, message, title, this.applyConfig(override));
  }
  /** show warning toast */
  warning(message, title, override = {}) {
    const type2 = this.toastrConfig.iconClasses.warning || "";
    return this._preBuildNotification(type2, message, title, this.applyConfig(override));
  }
  /**
   * Remove all or a single toast by id
   */
  clear(toastId) {
    for (const toast of this.toasts) {
      if (toastId !== void 0) {
        if (toast.toastId === toastId) {
          toast.toastRef.manualClose();
          return;
        }
      } else {
        toast.toastRef.manualClose();
      }
    }
  }
  /**
   * Remove and destroy a single toast by id
   */
  remove(toastId) {
    const found = this._findToast(toastId);
    if (!found) {
      return false;
    }
    found.activeToast.toastRef.close();
    this.toasts.splice(found.index, 1);
    this.currentlyActive = this.currentlyActive - 1;
    if (!this.toastrConfig.maxOpened || !this.toasts.length) {
      return false;
    }
    if (this.currentlyActive < this.toastrConfig.maxOpened && this.toasts[this.currentlyActive]) {
      const p2 = this.toasts[this.currentlyActive].toastRef;
      if (!p2.isInactive()) {
        this.currentlyActive = this.currentlyActive + 1;
        p2.activate();
      }
    }
    return true;
  }
  /**
   * Determines if toast message is already shown
   */
  findDuplicate(title = "", message = "", resetOnDuplicate, countDuplicates) {
    const {
      includeTitleDuplicates
    } = this.toastrConfig;
    for (const toast of this.toasts) {
      const hasDuplicateTitle = includeTitleDuplicates && toast.title === title;
      if ((!includeTitleDuplicates || hasDuplicateTitle) && toast.message === message) {
        toast.toastRef.onDuplicate(resetOnDuplicate, countDuplicates);
        return toast;
      }
    }
    return null;
  }
  /** create a clone of global config and apply individual settings */
  applyConfig(override = {}) {
    return __spreadValues(__spreadValues({}, this.toastrConfig), override);
  }
  /**
   * Find toast object by id
   */
  _findToast(toastId) {
    for (let i = 0; i < this.toasts.length; i++) {
      if (this.toasts[i].toastId === toastId) {
        return {
          index: i,
          activeToast: this.toasts[i]
        };
      }
    }
    return null;
  }
  /**
   * Determines the need to run inside angular's zone then builds the toast
   */
  _preBuildNotification(toastType, message, title, config3) {
    if (config3.onActivateTick) {
      return this.ngZone.run(() => this._buildNotification(toastType, message, title, config3));
    }
    return this._buildNotification(toastType, message, title, config3);
  }
  /**
   * Creates and attaches toast data to component
   * returns the active toast, or in case preventDuplicates is enabled the original/non-duplicate active toast.
   */
  _buildNotification(toastType, message, title, config3) {
    if (!config3.toastComponent) {
      throw new Error("toastComponent required");
    }
    const duplicate = this.findDuplicate(title, message, this.toastrConfig.resetTimeoutOnDuplicate && config3.timeOut > 0, this.toastrConfig.countDuplicates);
    if ((this.toastrConfig.includeTitleDuplicates && title || message) && this.toastrConfig.preventDuplicates && duplicate !== null) {
      return duplicate;
    }
    this.previousToastMessage = message;
    let keepInactive = false;
    if (this.toastrConfig.maxOpened && this.currentlyActive >= this.toastrConfig.maxOpened) {
      keepInactive = true;
      if (this.toastrConfig.autoDismiss) {
        this.clear(this.toasts[0].toastId);
      }
    }
    const overlayRef = this.overlay.create(config3.positionClass, this.overlayContainer);
    this.index = this.index + 1;
    let sanitizedMessage = message;
    if (message && config3.enableHtml) {
      sanitizedMessage = this.sanitizer.sanitize(SecurityContext.HTML, message);
    }
    const toastRef = new ToastRef(overlayRef);
    const toastPackage = new ToastPackage(this.index, config3, sanitizedMessage, title, toastType, toastRef);
    const providers2 = [{
      provide: ToastPackage,
      useValue: toastPackage
    }];
    const toastInjector = Injector.create({
      providers: providers2,
      parent: this._injector
    });
    const component = new ComponentPortal(config3.toastComponent, toastInjector);
    const portal = overlayRef.attach(component, config3.newestOnTop);
    toastRef.componentInstance = portal.instance;
    const ins = {
      toastId: this.index,
      title: title || "",
      message: message || "",
      toastRef,
      onShown: toastRef.afterActivate(),
      onHidden: toastRef.afterClosed(),
      onTap: toastPackage.onTap(),
      onAction: toastPackage.onAction(),
      portal
    };
    if (!keepInactive) {
      this.currentlyActive = this.currentlyActive + 1;
      setTimeout(() => {
        ins.toastRef.activate();
      });
    }
    this.toasts.push(ins);
    return ins;
  }
  static \u0275fac = function ToastrService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToastrService)(\u0275\u0275inject(TOAST_CONFIG), \u0275\u0275inject(Overlay), \u0275\u0275inject(Injector), \u0275\u0275inject(DomSanitizer), \u0275\u0275inject(NgZone));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ToastrService,
    factory: _ToastrService.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToastrService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [TOAST_CONFIG]
    }]
  }, {
    type: Overlay
  }, {
    type: Injector
  }, {
    type: DomSanitizer
  }, {
    type: NgZone
  }], null);
})();
var Toast = class _Toast {
  toastrService;
  toastPackage;
  ngZone;
  message;
  title;
  options;
  duplicatesCount;
  originalTimeout;
  /** width of progress bar */
  width = signal(-1);
  /** a combination of toast type and options.toastClass */
  toastClasses = "";
  state;
  /** controls animation */
  get _state() {
    return this.state();
  }
  /** hides component when waiting to be displayed */
  get displayStyle() {
    if (this.state().value === "inactive") {
      return "none";
    }
    return;
  }
  timeout;
  intervalId;
  hideTime;
  sub;
  sub1;
  sub2;
  sub3;
  constructor(toastrService, toastPackage, ngZone) {
    this.toastrService = toastrService;
    this.toastPackage = toastPackage;
    this.ngZone = ngZone;
    this.message = toastPackage.message;
    this.title = toastPackage.title;
    this.options = toastPackage.config;
    this.originalTimeout = toastPackage.config.timeOut;
    this.toastClasses = `${toastPackage.toastType} ${toastPackage.config.toastClass}`;
    this.sub = toastPackage.toastRef.afterActivate().subscribe(() => {
      this.activateToast();
    });
    this.sub1 = toastPackage.toastRef.manualClosed().subscribe(() => {
      this.remove();
    });
    this.sub2 = toastPackage.toastRef.timeoutReset().subscribe(() => {
      this.resetTimeout();
    });
    this.sub3 = toastPackage.toastRef.countDuplicate().subscribe((count3) => {
      this.duplicatesCount = count3;
    });
    this.state = signal({
      value: "inactive",
      params: {
        easeTime: this.toastPackage.config.easeTime,
        easing: "ease-in"
      }
    });
  }
  ngOnDestroy() {
    this.sub.unsubscribe();
    this.sub1.unsubscribe();
    this.sub2.unsubscribe();
    this.sub3.unsubscribe();
    clearInterval(this.intervalId);
    clearTimeout(this.timeout);
  }
  /**
   * activates toast and sets timeout
   */
  activateToast() {
    this.state.update((state2) => __spreadProps(__spreadValues({}, state2), {
      value: "active"
    }));
    if (!(this.options.disableTimeOut === true || this.options.disableTimeOut === "timeOut") && this.options.timeOut) {
      this.outsideTimeout(() => this.remove(), this.options.timeOut);
      this.hideTime = (/* @__PURE__ */ new Date()).getTime() + this.options.timeOut;
      if (this.options.progressBar) {
        this.outsideInterval(() => this.updateProgress(), 10);
      }
    }
  }
  /**
   * updates progress bar width
   */
  updateProgress() {
    if (this.width() === 0 || this.width() === 100 || !this.options.timeOut) {
      return;
    }
    const now2 = (/* @__PURE__ */ new Date()).getTime();
    const remaining = this.hideTime - now2;
    this.width.set(remaining / this.options.timeOut * 100);
    if (this.options.progressAnimation === "increasing") {
      this.width.update((width) => 100 - width);
    }
    if (this.width() <= 0) {
      this.width.set(0);
    }
    if (this.width() >= 100) {
      this.width.set(100);
    }
  }
  resetTimeout() {
    clearTimeout(this.timeout);
    clearInterval(this.intervalId);
    this.state.update((state2) => __spreadProps(__spreadValues({}, state2), {
      value: "active"
    }));
    this.outsideTimeout(() => this.remove(), this.originalTimeout);
    this.options.timeOut = this.originalTimeout;
    this.hideTime = (/* @__PURE__ */ new Date()).getTime() + (this.options.timeOut || 0);
    this.width.set(-1);
    if (this.options.progressBar) {
      this.outsideInterval(() => this.updateProgress(), 10);
    }
  }
  /**
   * tells toastrService to remove this toast after animation time
   */
  remove() {
    if (this.state().value === "removed") {
      return;
    }
    clearTimeout(this.timeout);
    this.state.update((state2) => __spreadProps(__spreadValues({}, state2), {
      value: "removed"
    }));
    this.outsideTimeout(() => this.toastrService.remove(this.toastPackage.toastId), +this.toastPackage.config.easeTime);
  }
  tapToast() {
    if (this.state().value === "removed") {
      return;
    }
    this.toastPackage.triggerTap();
    if (this.options.tapToDismiss) {
      this.remove();
    }
  }
  stickAround() {
    if (this.state().value === "removed") {
      return;
    }
    if (this.options.disableTimeOut !== "extendedTimeOut") {
      clearTimeout(this.timeout);
      this.options.timeOut = 0;
      this.hideTime = 0;
      clearInterval(this.intervalId);
      this.width.set(0);
    }
  }
  delayedHideToast() {
    if (this.options.disableTimeOut === true || this.options.disableTimeOut === "extendedTimeOut" || this.options.extendedTimeOut === 0 || this.state().value === "removed") {
      return;
    }
    this.outsideTimeout(() => this.remove(), this.options.extendedTimeOut);
    this.options.timeOut = this.options.extendedTimeOut;
    this.hideTime = (/* @__PURE__ */ new Date()).getTime() + (this.options.timeOut || 0);
    this.width.set(-1);
    if (this.options.progressBar) {
      this.outsideInterval(() => this.updateProgress(), 10);
    }
  }
  outsideTimeout(func, timeout2) {
    if (this.ngZone) {
      this.ngZone.runOutsideAngular(() => this.timeout = setTimeout(() => this.runInsideAngular(func), timeout2));
    } else {
      this.timeout = setTimeout(() => func(), timeout2);
    }
  }
  outsideInterval(func, timeout2) {
    if (this.ngZone) {
      this.ngZone.runOutsideAngular(() => this.intervalId = setInterval(() => this.runInsideAngular(func), timeout2));
    } else {
      this.intervalId = setInterval(() => func(), timeout2);
    }
  }
  runInsideAngular(func) {
    if (this.ngZone) {
      this.ngZone.run(() => func());
    } else {
      func();
    }
  }
  static \u0275fac = function Toast_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Toast)(\u0275\u0275directiveInject(ToastrService), \u0275\u0275directiveInject(ToastPackage), \u0275\u0275directiveInject(NgZone));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _Toast,
    selectors: [["", "toast-component", ""]],
    hostVars: 5,
    hostBindings: function Toast_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("click", function Toast_click_HostBindingHandler() {
          return ctx.tapToast();
        })("mouseenter", function Toast_mouseenter_HostBindingHandler() {
          return ctx.stickAround();
        })("mouseleave", function Toast_mouseleave_HostBindingHandler() {
          return ctx.delayedHideToast();
        });
      }
      if (rf & 2) {
        \u0275\u0275syntheticHostProperty("@flyInOut", ctx._state);
        \u0275\u0275classMap(ctx.toastClasses);
        \u0275\u0275styleProp("display", ctx.displayStyle);
      }
    },
    attrs: _c06,
    decls: 5,
    vars: 5,
    consts: [["type", "button", "class", "toast-close-button", "aria-label", "Close", 3, "click", 4, "ngIf"], [3, "class", 4, "ngIf"], ["role", "alert", 3, "class", "innerHTML", 4, "ngIf"], ["role", "alert", 3, "class", 4, "ngIf"], [4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "toast-close-button", 3, "click"], ["aria-hidden", "true"], ["role", "alert", 3, "innerHTML"], ["role", "alert"], [1, "toast-progress"]],
    template: function Toast_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275template(0, Toast_button_0_Template, 3, 0, "button", 0)(1, Toast_div_1_Template, 3, 5, "div", 1)(2, Toast_div_2_Template, 1, 3, "div", 2)(3, Toast_div_3_Template, 2, 4, "div", 3)(4, Toast_div_4_Template, 2, 2, "div", 4);
      }
      if (rf & 2) {
        \u0275\u0275property("ngIf", ctx.options.closeButton);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.title);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.message && ctx.options.enableHtml);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.message && !ctx.options.enableHtml);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.options.progressBar);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2,
    data: {
      animation: [trigger("flyInOut", [state("inactive", style({
        opacity: 0
      })), state("active", style({
        opacity: 1
      })), state("removed", style({
        opacity: 0
      })), transition("inactive => active", animate("{{ easeTime }}ms {{ easing }}")), transition("active => removed", animate("{{ easeTime }}ms {{ easing }}"))])]
    },
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Toast, [{
    type: Component,
    args: [{
      selector: "[toast-component]",
      template: `
  <button *ngIf="options.closeButton" (click)="remove()" type="button" class="toast-close-button" aria-label="Close">
    <span aria-hidden="true">&times;</span>
  </button>
  <div *ngIf="title" [class]="options.titleClass" [attr.aria-label]="title">
    {{ title }} <ng-container *ngIf="duplicatesCount">[{{ duplicatesCount + 1 }}]</ng-container>
  </div>
  <div *ngIf="message && options.enableHtml" role="alert"
    [class]="options.messageClass" [innerHTML]="message">
  </div>
  <div *ngIf="message && !options.enableHtml" role="alert"
    [class]="options.messageClass" [attr.aria-label]="message">
    {{ message }}
  </div>
  <div *ngIf="options.progressBar">
    <div class="toast-progress" [style.width]="width() + '%'"></div>
  </div>
  `,
      animations: [trigger("flyInOut", [state("inactive", style({
        opacity: 0
      })), state("active", style({
        opacity: 1
      })), state("removed", style({
        opacity: 0
      })), transition("inactive => active", animate("{{ easeTime }}ms {{ easing }}")), transition("active => removed", animate("{{ easeTime }}ms {{ easing }}"))])],
      preserveWhitespaces: false,
      standalone: true,
      imports: [NgIf],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ToastrService
  }, {
    type: ToastPackage
  }, {
    type: NgZone
  }], {
    toastClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    _state: [{
      type: HostBinding,
      args: ["@flyInOut"]
    }],
    displayStyle: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    tapToast: [{
      type: HostListener,
      args: ["click"]
    }],
    stickAround: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    delayedHideToast: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var DefaultGlobalConfig = __spreadProps(__spreadValues({}, DefaultNoComponentGlobalConfig), {
  toastComponent: Toast
});
var provideToastr = (config3 = {}) => {
  const providers2 = [{
    provide: TOAST_CONFIG,
    useValue: {
      default: DefaultGlobalConfig,
      config: config3
    }
  }];
  return makeEnvironmentProviders(providers2);
};
var ToastrModule = class _ToastrModule {
  static forRoot(config3 = {}) {
    return {
      ngModule: _ToastrModule,
      providers: [provideToastr(config3)]
    };
  }
  static \u0275fac = function ToastrModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToastrModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ToastrModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToastrModule, [{
    type: NgModule,
    args: [{
      imports: [Toast],
      exports: [Toast]
    }]
  }], null, null);
})();
var ToastrComponentlessModule = class _ToastrComponentlessModule {
  static forRoot(config3 = {}) {
    return {
      ngModule: ToastrModule,
      providers: [{
        provide: TOAST_CONFIG,
        useValue: {
          default: DefaultNoComponentGlobalConfig,
          config: config3
        }
      }]
    };
  }
  static \u0275fac = function ToastrComponentlessModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToastrComponentlessModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ToastrComponentlessModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToastrComponentlessModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var ToastNoAnimation = class _ToastNoAnimation {
  toastrService;
  toastPackage;
  appRef;
  message;
  title;
  options;
  duplicatesCount;
  originalTimeout;
  /** width of progress bar */
  width = signal(-1);
  /** a combination of toast type and options.toastClass */
  toastClasses = "";
  /** hides component when waiting to be displayed */
  get displayStyle() {
    if (this.state() === "inactive") {
      return "none";
    }
    return null;
  }
  /** controls animation */
  state = signal("inactive");
  timeout;
  intervalId;
  hideTime;
  sub;
  sub1;
  sub2;
  sub3;
  constructor(toastrService, toastPackage, appRef) {
    this.toastrService = toastrService;
    this.toastPackage = toastPackage;
    this.appRef = appRef;
    this.message = toastPackage.message;
    this.title = toastPackage.title;
    this.options = toastPackage.config;
    this.originalTimeout = toastPackage.config.timeOut;
    this.toastClasses = `${toastPackage.toastType} ${toastPackage.config.toastClass}`;
    this.sub = toastPackage.toastRef.afterActivate().subscribe(() => {
      this.activateToast();
    });
    this.sub1 = toastPackage.toastRef.manualClosed().subscribe(() => {
      this.remove();
    });
    this.sub2 = toastPackage.toastRef.timeoutReset().subscribe(() => {
      this.resetTimeout();
    });
    this.sub3 = toastPackage.toastRef.countDuplicate().subscribe((count3) => {
      this.duplicatesCount = count3;
    });
  }
  ngOnDestroy() {
    this.sub.unsubscribe();
    this.sub1.unsubscribe();
    this.sub2.unsubscribe();
    this.sub3.unsubscribe();
    clearInterval(this.intervalId);
    clearTimeout(this.timeout);
  }
  /**
   * activates toast and sets timeout
   */
  activateToast() {
    this.state.set("active");
    if (!(this.options.disableTimeOut === true || this.options.disableTimeOut === "timeOut") && this.options.timeOut) {
      this.timeout = setTimeout(() => {
        this.remove();
      }, this.options.timeOut);
      this.hideTime = (/* @__PURE__ */ new Date()).getTime() + this.options.timeOut;
      if (this.options.progressBar) {
        this.intervalId = setInterval(() => this.updateProgress(), 10);
      }
    }
    if (this.options.onActivateTick) {
      this.appRef.tick();
    }
  }
  /**
   * updates progress bar width
   */
  updateProgress() {
    if (this.width() === 0 || this.width() === 100 || !this.options.timeOut) {
      return;
    }
    const now2 = (/* @__PURE__ */ new Date()).getTime();
    const remaining = this.hideTime - now2;
    this.width.set(remaining / this.options.timeOut * 100);
    if (this.options.progressAnimation === "increasing") {
      this.width.update((width) => 100 - width);
    }
    if (this.width() <= 0) {
      this.width.set(0);
    }
    if (this.width() >= 100) {
      this.width.set(100);
    }
  }
  resetTimeout() {
    clearTimeout(this.timeout);
    clearInterval(this.intervalId);
    this.state.set("active");
    this.options.timeOut = this.originalTimeout;
    this.timeout = setTimeout(() => this.remove(), this.originalTimeout);
    this.hideTime = (/* @__PURE__ */ new Date()).getTime() + (this.originalTimeout || 0);
    this.width.set(-1);
    if (this.options.progressBar) {
      this.intervalId = setInterval(() => this.updateProgress(), 10);
    }
  }
  /**
   * tells toastrService to remove this toast after animation time
   */
  remove() {
    if (this.state() === "removed") {
      return;
    }
    clearTimeout(this.timeout);
    this.state.set("removed");
    this.timeout = setTimeout(() => this.toastrService.remove(this.toastPackage.toastId));
  }
  tapToast() {
    if (this.state() === "removed") {
      return;
    }
    this.toastPackage.triggerTap();
    if (this.options.tapToDismiss) {
      this.remove();
    }
  }
  stickAround() {
    if (this.state() === "removed") {
      return;
    }
    clearTimeout(this.timeout);
    this.options.timeOut = 0;
    this.hideTime = 0;
    clearInterval(this.intervalId);
    this.width.set(0);
  }
  delayedHideToast() {
    if (this.options.disableTimeOut === true || this.options.disableTimeOut === "extendedTimeOut" || this.options.extendedTimeOut === 0 || this.state() === "removed") {
      return;
    }
    this.timeout = setTimeout(() => this.remove(), this.options.extendedTimeOut);
    this.options.timeOut = this.options.extendedTimeOut;
    this.hideTime = (/* @__PURE__ */ new Date()).getTime() + (this.options.timeOut || 0);
    this.width.set(-1);
    if (this.options.progressBar) {
      this.intervalId = setInterval(() => this.updateProgress(), 10);
    }
  }
  static \u0275fac = function ToastNoAnimation_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToastNoAnimation)(\u0275\u0275directiveInject(ToastrService), \u0275\u0275directiveInject(ToastPackage), \u0275\u0275directiveInject(ApplicationRef));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _ToastNoAnimation,
    selectors: [["", "toast-component", ""]],
    hostVars: 4,
    hostBindings: function ToastNoAnimation_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("click", function ToastNoAnimation_click_HostBindingHandler() {
          return ctx.tapToast();
        })("mouseenter", function ToastNoAnimation_mouseenter_HostBindingHandler() {
          return ctx.stickAround();
        })("mouseleave", function ToastNoAnimation_mouseleave_HostBindingHandler() {
          return ctx.delayedHideToast();
        });
      }
      if (rf & 2) {
        \u0275\u0275classMap(ctx.toastClasses);
        \u0275\u0275styleProp("display", ctx.displayStyle);
      }
    },
    attrs: _c06,
    decls: 5,
    vars: 5,
    consts: [["type", "button", "class", "toast-close-button", "aria-label", "Close", 3, "click", 4, "ngIf"], [3, "class", 4, "ngIf"], ["role", "alert", 3, "class", "innerHTML", 4, "ngIf"], ["role", "alert", 3, "class", 4, "ngIf"], [4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "toast-close-button", 3, "click"], ["aria-hidden", "true"], ["role", "alert", 3, "innerHTML"], ["role", "alert"], [1, "toast-progress"]],
    template: function ToastNoAnimation_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275template(0, ToastNoAnimation_button_0_Template, 3, 0, "button", 0)(1, ToastNoAnimation_div_1_Template, 3, 5, "div", 1)(2, ToastNoAnimation_div_2_Template, 1, 3, "div", 2)(3, ToastNoAnimation_div_3_Template, 2, 4, "div", 3)(4, ToastNoAnimation_div_4_Template, 2, 2, "div", 4);
      }
      if (rf & 2) {
        \u0275\u0275property("ngIf", ctx.options.closeButton);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.title);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.message && ctx.options.enableHtml);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.message && !ctx.options.enableHtml);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.options.progressBar);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToastNoAnimation, [{
    type: Component,
    args: [{
      selector: "[toast-component]",
      template: `
  <button *ngIf="options.closeButton" (click)="remove()" type="button" class="toast-close-button" aria-label="Close">
    <span aria-hidden="true">&times;</span>
  </button>
  <div *ngIf="title" [class]="options.titleClass" [attr.aria-label]="title">
    {{ title }} <ng-container *ngIf="duplicatesCount">[{{ duplicatesCount + 1 }}]</ng-container>
  </div>
  <div *ngIf="message && options.enableHtml" role="alert"
    [class]="options.messageClass" [innerHTML]="message">
  </div>
  <div *ngIf="message && !options.enableHtml" role="alert"
    [class]="options.messageClass" [attr.aria-label]="message">
    {{ message }}
  </div>
  <div *ngIf="options.progressBar">
    <div class="toast-progress" [style.width]="width() + '%'"></div>
  </div>
  `,
      standalone: true,
      imports: [NgIf],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ToastrService
  }, {
    type: ToastPackage
  }, {
    type: ApplicationRef
  }], {
    toastClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    displayStyle: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    tapToast: [{
      type: HostListener,
      args: ["click"]
    }],
    stickAround: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    delayedHideToast: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var DefaultNoAnimationsGlobalConfig = __spreadProps(__spreadValues({}, DefaultNoComponentGlobalConfig), {
  toastComponent: ToastNoAnimation
});
var ToastNoAnimationModule = class _ToastNoAnimationModule {
  static forRoot(config3 = {}) {
    return {
      ngModule: _ToastNoAnimationModule,
      providers: [{
        provide: TOAST_CONFIG,
        useValue: {
          default: DefaultNoAnimationsGlobalConfig,
          config: config3
        }
      }]
    };
  }
  static \u0275fac = function ToastNoAnimationModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToastNoAnimationModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ToastNoAnimationModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToastNoAnimationModule, [{
    type: NgModule,
    args: [{
      imports: [ToastNoAnimation],
      exports: [ToastNoAnimation]
    }]
  }], null, null);
})();

// src/app/model/category/category-request.ts
var CategoryRequest = class {
  constructor(category) {
    this.data = category;
  }
};

// src/app/service/category.service.ts
var _CategoryService = class _CategoryService extends BaseService {
  constructor(httpClient) {
    super();
    this.httpClient = httpClient;
    this.categoryEndpoint = AppConstants.baseUrl + "/api/categories";
  }
  getCategories(errorDto) {
    return this.httpClient.get(this.categoryEndpoint, { headers: AppConstants.acceptJson }).pipe(retry(1), catchError((err) => this.handleError(err, errorDto)));
  }
  getCategory(categoryUrl, errorDto) {
    const categoryEndpointUrl = this.addParamIntoUrl(this.categoryEndpoint, categoryUrl);
    return this.httpClient.get(categoryEndpointUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  createCategory(category, errorDto) {
    const body = JSON.stringify(new CategoryRequest(category));
    return this.httpClient.post(this.categoryEndpoint, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  updateCategory(category, originalUrl, errorDto) {
    const body = JSON.stringify(new CategoryRequest(category));
    const categoryUrl = this.addParamIntoUrl(this.categoryEndpoint, originalUrl);
    return this.httpClient.put(categoryUrl, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  deleteCategory(category, errorDto) {
    const categoryUrl = this.addParamIntoUrl(this.categoryEndpoint, category.url);
    return this.httpClient.delete(categoryUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
};
_CategoryService.\u0275fac = function CategoryService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CategoryService)(\u0275\u0275inject(HttpClient));
};
_CategoryService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _CategoryService, factory: _CategoryService.\u0275fac, providedIn: "root" });
var CategoryService = _CategoryService;

// src/app/model/admin/admin-response.ts
var AdminResponse = class {
};

// src/app/service/account.service.ts
var _AccountService = class _AccountService extends BaseService {
  constructor(httpClient) {
    super();
    this.httpClient = httpClient;
    this.accountEndpoint = AppConstants.baseUrl + "/api/accounts";
  }
  getAccounts(errorDto) {
    return this.httpClient.get(this.accountEndpoint, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  getAccount(username, errorDto) {
    const accountUrl = this.addParamIntoUrl(this.accountEndpoint, username);
    return this.httpClient.get(accountUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  editAccount(admin, username, errorDto) {
    const adminResponse = new AdminResponse();
    adminResponse.data = admin;
    const body = JSON.stringify(adminResponse);
    const accountEndpoint = this.addParamIntoUrl(this.accountEndpoint, username);
    return this.httpClient.put(accountEndpoint, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  createAccount(admin, errorDto) {
    const adminResponse = new AdminResponse();
    adminResponse.data = admin;
    const body = JSON.stringify(adminResponse);
    return this.httpClient.post(this.accountEndpoint, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  passwordRecovery(email, errorDto) {
    return this.httpClient.post(this.accountEndpoint.concat("/password-recovery"), email, {
      headers: AppConstants.contentTypeAndAcceptJson
    }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  passwordChange(credentials, token, errorDto) {
    return this.httpClient.post(this.accountEndpoint.concat("/password-change"), credentials.password, {
      headers: AppConstants.contentTypeAndAcceptJson,
      params: new HttpParams().append("token", token)
    }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  deleteAccount(username, errorDto) {
    const accountUrl = this.addParamIntoUrl(this.accountEndpoint, username);
    return this.httpClient.delete(accountUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
};
_AccountService.\u0275fac = function AccountService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AccountService)(\u0275\u0275inject(HttpClient));
};
_AccountService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _AccountService, factory: _AccountService.\u0275fac, providedIn: "root" });
var AccountService = _AccountService;

// src/app/model/product/product-request.ts
var ProductRequest = class {
  constructor(product) {
    this.data = product;
  }
};

// src/app/service/product.service.ts
var _ProductService = class _ProductService extends BaseService {
  constructor(httpClient) {
    super();
    this.httpClient = httpClient;
    this.productEndpoint = AppConstants.baseUrl + "/api/products";
    this.productsFilterEndpoint = this.productEndpoint + "/filter";
    this.productImageEndpoint = this.productEndpoint + "/img-upload/";
  }
  listProducts(page, errorDto, name, category) {
    let paramsData = new HttpParams().set("pageNumber", String(page)).set("pageSize", "10").set("sortBy", "NAME");
    if (name != null) {
      paramsData = paramsData.set("name", name);
    }
    if (category != null && category.url != null) {
      paramsData = paramsData.set("category", category.url);
    }
    if (page != null) {
      paramsData = paramsData.set("pageNumber", page);
    }
    return this.httpClient.get(this.productsFilterEndpoint, {
      headers: AppConstants.acceptJson,
      params: paramsData
    }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  createProduct(product, errorDto) {
    const body = JSON.stringify(new ProductRequest(product));
    return this.httpClient.post(this.productEndpoint, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  deleteProduct(product, errorDto) {
    const productUrl = this.addParamIntoUrl(this.productEndpoint, product.url);
    return this.httpClient.delete(productUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  updateProduct(product, productOriginalUrl, errorDto) {
    const body = JSON.stringify(new ProductRequest(product));
    const productUrl = this.addParamIntoUrl(this.productEndpoint, productOriginalUrl);
    return this.httpClient.put(productUrl, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  getProduct(productUrl, errorDto) {
    const productUrlEndpoint = this.addParamIntoUrl(this.productEndpoint, productUrl);
    return this.httpClient.get(productUrlEndpoint, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  getProductImage(productUrl, errorDto) {
    return this.httpClient.get(this.productImageEndpoint + productUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  updateProductImage(file, productUrl, errorDto) {
    const formData = new FormData();
    formData.append("file", file);
    return this.httpClient.post(this.productImageEndpoint + productUrl, formData).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
};
_ProductService.\u0275fac = function ProductService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ProductService)(\u0275\u0275inject(HttpClient));
};
_ProductService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ProductService, factory: _ProductService.\u0275fac, providedIn: "root" });
var ProductService = _ProductService;

// src/app/model/email/email-request.ts
var EmailRequest = class {
  constructor(data) {
    this.data = data;
  }
};

// src/app/service/write-us.service.ts
var _WriteUsService = class _WriteUsService extends BaseService {
  constructor(httpClient) {
    super();
    this.httpClient = httpClient;
    this.writeUsEndpoint = AppConstants.baseUrl + "/api/email";
    this.answerEndpoint = AppConstants.baseUrl + "/api/email/respond";
  }
  responseToEmail(errorDto, email) {
    return this.httpClient.post(this.answerEndpoint, JSON.stringify(new EmailRequest(email)), { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  loadEmailsWriteUs(errorDto, pageNumber, pageSize, email, replied) {
    let paramsData = new HttpParams();
    if (pageNumber != null) {
      paramsData = paramsData.set("pageNumber", pageNumber);
    }
    if (pageSize != null) {
      paramsData = paramsData.set("pageSize", pageSize);
    }
    if (email != null) {
      paramsData = paramsData.set("email", email);
    }
    if (replied != null) {
      paramsData = paramsData.set("replied", replied);
    }
    return this.httpClient.get(this.writeUsEndpoint, {
      headers: AppConstants.acceptJson,
      params: paramsData
    }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
};
_WriteUsService.\u0275fac = function WriteUsService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _WriteUsService)(\u0275\u0275inject(HttpClient));
};
_WriteUsService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _WriteUsService, factory: _WriteUsService.\u0275fac, providedIn: "root" });
var WriteUsService = _WriteUsService;

// src/app/shared/error.component.ts
function ErrorComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275text(1);
    \u0275\u0275element(2, "br");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.errorDto.httpStatusMessage, "");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r0.errorDto.errorMessage, " ");
  }
}
var _ErrorComponent = class _ErrorComponent {
};
_ErrorComponent.\u0275fac = function ErrorComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ErrorComponent)();
};
_ErrorComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ErrorComponent, selectors: [["app-error"]], inputs: { errorDto: "errorDto" }, standalone: false, decls: 2, vars: 1, consts: [[1, "mb-3"], ["class", "alert alert-danger", "role", "alert", 4, "ngIf"], ["role", "alert", 1, "alert", "alert-danger"]], template: function ErrorComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275template(1, ErrorComponent_div_1_Template, 4, 2, "div", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.errorDto.httpStatus);
  }
}, dependencies: [NgIf], encapsulation: 2 });
var ErrorComponent = _ErrorComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ErrorComponent, { className: "ErrorComponent", filePath: "src/app/shared/error.component.ts", lineNumber: 19 });
})();

// src/app/home/home.component.ts
var _c07 = () => ["/accounts"];
var _c13 = () => ["/email/write-us"];
var _c2 = () => ["/categories"];
var _c3 = () => ["/products"];
var _HomeComponent = class _HomeComponent {
  constructor(qrService, spinner, toastr, categoryService, accountService, productService, writeUsService) {
    this.qrService = qrService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.categoryService = categoryService;
    this.accountService = accountService;
    this.productService = productService;
    this.writeUsService = writeUsService;
    this.destroy$ = new Subject();
    this.errorDto = new ErrorDto();
    this.accountsIcon = AppConstants.iconUser;
    this.emailIcon = AppConstants.iconEmail;
    this.infoIcon = AppConstants.iconInfo;
    this.gearIcon = AppConstants.iconGear;
    this.categories = new Array();
    this.products = new Array();
    this.adminList = new Array();
    this.emailsInactive = new Array();
    this.emailsAll = new Array();
    this.errorCategory = new ErrorDto();
    this.errorAdmin = new ErrorDto();
    this.errorProducts = new ErrorDto();
    this.errorConfig = new ErrorDto();
    this.errorEmails = new ErrorDto();
    this.info = AppConstants.iconInfo;
    this.emailPercentage = 0;
  }
  ngOnInit() {
    this.spinner.show().then(() => forkJoin([
      this.loadCategories(),
      this.loadAccounts(),
      this.loadProducts(),
      this.loadEmails(0, false)
    ])).then(() => this.spinner.hide());
  }
  loadProducts() {
    return this.productService.listProducts(0, this.errorProducts).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.products = response.data;
      }
    });
  }
  loadEmails(pageNumber, replied) {
    return this.writeUsService.loadEmailsWriteUs(this.errorEmails, pageNumber, 20, null, replied).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.emailsAll = response.data;
        this.emailsInactive = response.data.filter((res) => res.replied == false);
      }
    });
  }
  loadCategories() {
    return this.categoryService.getCategories(this.errorCategory).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.categories = response.data;
      }
    });
  }
  loadAccounts() {
    return this.accountService.getAccounts(this.errorAdmin).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.adminList = response.data;
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_HomeComponent.\u0275fac = function HomeComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _HomeComponent)(\u0275\u0275directiveInject(QrService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService), \u0275\u0275directiveInject(CategoryService), \u0275\u0275directiveInject(AccountService), \u0275\u0275directiveInject(ProductService), \u0275\u0275directiveInject(WriteUsService));
};
_HomeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _HomeComponent, selectors: [["app-home"]], standalone: false, decls: 66, vars: 25, consts: [[1, "row", "m-3", "pt-3"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "col-12", "col-sm-6", "col-md-4", "col-lg-3"], [1, "card", "card-stats", "m-2"], [1, "card-body"], [1, "row"], [1, "col"], [1, "card-title"], [3, "errorDto"], [1, "mt-2", "text-white"], [1, "col-auto", "my-auto"], [1, "h1", "pointer", 3, "icon"], [1, "small-box-footer"], ["href", "#", 1, "text-darkorange", 3, "routerLink"], [1, "ms-1", 3, "icon"]], template: function HomeComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275element(1, "ngx-spinner", 1);
    \u0275\u0275elementStart(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "div", 5)(6, "div", 6)(7, "h5", 7);
    \u0275\u0275text(8, " \xDA\u010Dty ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(9, "app-error", 8);
    \u0275\u0275elementStart(10, "h2", 9);
    \u0275\u0275text(11);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(12, "div", 10);
    \u0275\u0275element(13, "fa-icon", 11);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(14, "div", 12)(15, "a", 13);
    \u0275\u0275text(16, "V\xEDce informac\xED ");
    \u0275\u0275element(17, "fa-icon", 14);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(18, "div", 2)(19, "div", 3)(20, "div", 4)(21, "div", 5)(22, "div", 6)(23, "h5", 7);
    \u0275\u0275text(24, " Emaily ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(25, "app-error", 8);
    \u0275\u0275elementStart(26, "h2", 9);
    \u0275\u0275text(27);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(28, "div", 10);
    \u0275\u0275element(29, "fa-icon", 11);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(30, "div", 12)(31, "a", 13);
    \u0275\u0275text(32, "V\xEDce informac\xED ");
    \u0275\u0275element(33, "fa-icon", 14);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(34, "div", 2)(35, "div", 3)(36, "div", 4)(37, "div", 5)(38, "div", 6)(39, "h5", 7);
    \u0275\u0275text(40, " Kategorie ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(41, "app-error", 8);
    \u0275\u0275elementStart(42, "h2", 9);
    \u0275\u0275text(43);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(44, "div", 10);
    \u0275\u0275element(45, "fa-icon", 11);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(46, "div", 12)(47, "a", 13);
    \u0275\u0275text(48, "V\xEDce informac\xED ");
    \u0275\u0275element(49, "fa-icon", 14);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(50, "div", 2)(51, "div", 3)(52, "div", 4)(53, "div", 5)(54, "div", 6)(55, "h5", 7);
    \u0275\u0275text(56, " Produkty ");
    \u0275\u0275elementEnd();
    \u0275\u0275element(57, "app-error", 8);
    \u0275\u0275elementStart(58, "h2", 9);
    \u0275\u0275text(59);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(60, "div", 10);
    \u0275\u0275element(61, "fa-icon", 11);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(62, "div", 12)(63, "a", 13);
    \u0275\u0275text(64, "V\xEDce informac\xED ");
    \u0275\u0275element(65, "fa-icon", 14);
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(9);
    \u0275\u0275property("errorDto", ctx.errorAdmin);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx.adminList.length);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.accountsIcon);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(21, _c07));
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.infoIcon);
    \u0275\u0275advance(8);
    \u0275\u0275property("errorDto", ctx.errorEmails);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate2("", ctx.emailsInactive == null ? null : ctx.emailsInactive.length, " / ", ctx.emailsAll == null ? null : ctx.emailsAll.length, "");
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.emailIcon);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(22, _c13));
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.infoIcon);
    \u0275\u0275advance(8);
    \u0275\u0275property("errorDto", ctx.errorCategory);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx.categories.length);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.gearIcon);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(23, _c2));
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.infoIcon);
    \u0275\u0275advance(8);
    \u0275\u0275property("errorDto", ctx.errorProducts);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx.products.length);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.gearIcon);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(24, _c3));
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.infoIcon);
  }
}, dependencies: [RouterLink, NgxSpinnerComponent, FaIconComponent, ErrorComponent], styles: ["\n\n.small-box-footer[_ngcontent-%COMP%] {\n  background-color: rgba(0, 0, 0, 0.04) !important;\n  color: rgba(255, 255, 255, 0.8);\n  display: block;\n  padding: 3px 0;\n  position: relative;\n  text-align: center;\n  text-decoration: none;\n  z-index: 10;\n  border-bottom-left-radius: calc(0.375rem - 1px);\n  border-bottom-right-radius: calc(0.375rem - 1px);\n}\n.small-box-footer[_ngcontent-%COMP%]:hover {\n  background-color: rgba(0, 0, 0, 0.08) !important;\n  color: rgba(255, 255, 255, 0.8);\n  display: block;\n  padding: 3px 0;\n  position: relative;\n  text-align: center;\n  text-decoration: none;\n  z-index: 10;\n  border-bottom-left-radius: calc(0.375rem - 1px);\n  border-bottom-right-radius: calc(0.375rem - 1px);\n}\n.small-box-footer[_ngcontent-%COMP%]    > a[_ngcontent-%COMP%] {\n  color: var(--color-primary);\n}\n/*# sourceMappingURL=home.component.css.map */"] });
var HomeComponent = _HomeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(HomeComponent, { className: "HomeComponent", filePath: "src/app/home/home.component.ts", lineNumber: 24 });
})();

// src/app/login/login.component.ts
var _c08 = () => ["/forgot-password"];
function LoginComponent_div_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275text(1, " Username is required! ");
    \u0275\u0275elementEnd();
  }
}
function LoginComponent_div_21_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Password is required");
    \u0275\u0275elementEnd();
  }
}
function LoginComponent_div_21_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Password must be at least 4 characters");
    \u0275\u0275elementEnd();
  }
}
function LoginComponent_div_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275template(1, LoginComponent_div_21_div_1_Template, 2, 0, "div", 22)(2, LoginComponent_div_21_div_2_Template, 2, 0, "div", 22);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const password_r3 = \u0275\u0275reference(20);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", password_r3.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", password_r3.errors.minlength);
  }
}
var _LoginComponent = class _LoginComponent {
  constructor(sharedService, authService, route, spinner, toastr) {
    this.sharedService = sharedService;
    this.authService = authService;
    this.route = route;
    this.spinner = spinner;
    this.toastr = toastr;
    this.form = {};
    this.errorDto = new ErrorDto();
    this.faUser = AppConstants.iconUser;
    this.faLock = AppConstants.iconLock;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.sharedService.currentImgPath.subscribe((data) => this.imgLoginPath = data);
  }
  login() {
    this.spinner.show().then((r2) => r2);
    this.authService.login(this.form, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide().then(() => {
          this.route.navigate(["/home"]).then(() => this.toastr.success("200 Welcome", "Logged in"));
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " login failed", "Login"));
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_LoginComponent.\u0275fac = function LoginComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _LoginComponent)(\u0275\u0275directiveInject(SharedImgService), \u0275\u0275directiveInject(AuthService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_LoginComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _LoginComponent, selectors: [["app-login"]], standalone: false, decls: 30, vars: 10, consts: [["f", "ngForm"], ["username", "ngModel"], ["password", "ngModel"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-3", "col-md-6", "col-sm-8", "align-self-center"], [1, "box-part", "text-center"], ["name", "form", "novalidate", "", 3, "ngSubmit"], ["alt", "user", "width", "120", "height", "120", "id", "profile-img", 1, "profile-img-card", "mb-4", 3, "src"], [1, "input-group", "input-group-lg", "mb-4"], [1, "input-group-text"], [1, "login-icon", 3, "icon"], ["placeholder", "username", "type", "text", "name", "username", "required", "", 1, "form-control", 3, "ngModelChange", "ngModel"], ["class", "alert alert-danger", "role", "alert", 4, "ngIf"], ["bdColor", "rgba(51,51,51,0.8)", "size", "large", "color", "#fff", "type", "ball-spin-clockwise"], ["placeholder", "password", "type", "password", "name", "password", "required", "", "minlength", "4", 1, "form-control", 3, "ngModelChange", "ngModel"], [1, "col-12"], ["type", "submit", 1, "btn", "btn-primary", "btn-lg", "w-100"], [1, "row"], ["routerLinkActive", "active", 1, "mt-3", 3, "routerLink"], [3, "errorDto"], ["role", "alert", 1, "alert", "alert-danger"], [4, "ngIf"]], template: function LoginComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 3)(1, "div", 4)(2, "div", 5)(3, "div", 6)(4, "h3");
    \u0275\u0275text(5, "ADMIN LOGIN");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "form", 7, 0);
    \u0275\u0275listener("ngSubmit", function LoginComponent_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      const f_r2 = \u0275\u0275reference(7);
      return \u0275\u0275resetView(f_r2.form.valid && ctx.login());
    });
    \u0275\u0275element(8, "img", 8);
    \u0275\u0275elementStart(9, "div", 9)(10, "span", 10);
    \u0275\u0275element(11, "fa-icon", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "input", 12, 1);
    \u0275\u0275twoWayListener("ngModelChange", function LoginComponent_Template_input_ngModelChange_12_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.form.username, $event) || (ctx.form.username = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275template(14, LoginComponent_div_14_Template, 2, 0, "div", 13);
    \u0275\u0275element(15, "ngx-spinner", 14);
    \u0275\u0275elementStart(16, "div", 9)(17, "span", 10);
    \u0275\u0275element(18, "fa-icon", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "input", 15, 2);
    \u0275\u0275twoWayListener("ngModelChange", function LoginComponent_Template_input_ngModelChange_19_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.form.password, $event) || (ctx.form.password = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275template(21, LoginComponent_div_21_Template, 3, 2, "div", 13);
    \u0275\u0275elementStart(22, "div", 4)(23, "div", 16)(24, "button", 17);
    \u0275\u0275text(25, "Sign in");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(26, "div", 18)(27, "a", 19);
    \u0275\u0275text(28, "Forgotten\xA0password");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(29, "app-error", 20);
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    const f_r2 = \u0275\u0275reference(7);
    const username_r4 = \u0275\u0275reference(13);
    const password_r3 = \u0275\u0275reference(20);
    \u0275\u0275advance(8);
    \u0275\u0275propertyInterpolate("src", ctx.imgLoginPath, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx.faUser);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx.form.username);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", f_r2.submitted && username_r4.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275property("icon", ctx.faLock);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx.form.password);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", f_r2.submitted && password_r3.invalid);
    \u0275\u0275advance(6);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(9, _c08));
    \u0275\u0275advance(2);
    \u0275\u0275property("errorDto", ctx.errorDto);
  }
}, dependencies: [NgIf, RouterLink, RouterLinkActive, NgxSpinnerComponent, FaIconComponent, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, NgModel, NgForm, ErrorComponent], encapsulation: 2 });
var LoginComponent = _LoginComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(LoginComponent, { className: "LoginComponent", filePath: "src/app/login/login.component.ts", lineNumber: 17 });
})();

// src/app/auth-guard.ts
var authGuard = (route, state2) => {
  const authService = inject(AuthService);
  const router = inject(Router);
  const tokenStorage = inject(TokenStorageService);
  console.log("Call auth guard");
  if (tokenStorage.isExpired()) {
    authService.logout();
    window.alert("You don't have permission to view this page");
    router.navigate(["/login"]).then((r2) => r2);
    return false;
  }
  return true;
};

// src/app/validator/password-matcher.directive.ts
var _PasswordMatcherDirective = class _PasswordMatcherDirective {
  constructor() {
    this.matchPassword = [];
  }
  validate(formGroup) {
    return this.match(this.matchPassword[0], this.matchPassword[1])(formGroup);
  }
  match(controlName, checkControlName) {
    return (formGroup) => {
      const control = formGroup.controls[controlName];
      const checkControl = formGroup.controls[checkControlName];
      if (control?.value == null && checkControl?.value == null) {
        checkControl?.setErrors(null);
        return null;
      }
      if (checkControl?.errors && !checkControl.errors["matching"]) {
        return null;
      }
      if (control?.value !== checkControl?.value) {
        checkControl?.setErrors({ matching: true });
        console.log("errors set tu true");
        return { matching: true };
      } else {
        console.log("errors set tu false");
        checkControl?.setErrors(null);
        return null;
      }
    };
  }
};
_PasswordMatcherDirective.\u0275fac = function PasswordMatcherDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PasswordMatcherDirective)();
};
_PasswordMatcherDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _PasswordMatcherDirective, selectors: [["", "appMatchPassword", ""]], inputs: { matchPassword: [0, "appMatchPassword", "matchPassword"] }, standalone: false, features: [\u0275\u0275ProvidersFeature([{ provide: NG_VALIDATORS, useExisting: _PasswordMatcherDirective, multi: true }])] });
var PasswordMatcherDirective = _PasswordMatcherDirective;

// src/app/validator/password-pattern.directive.ts
var _PasswordPatternDirective = class _PasswordPatternDirective {
  constructor() {
    this.regex = new RegExp("^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9]).{8,}$");
  }
  validate(control) {
    return this.patternValidator()(control);
  }
  patternValidator() {
    return (control) => {
      if (!control.value) {
        return null;
      }
      const regex = new RegExp("^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9]).{8,}$");
      const valid = regex.test(control.value);
      return valid ? null : { invalidPassword: true };
    };
  }
};
_PasswordPatternDirective.\u0275fac = function PasswordPatternDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PasswordPatternDirective)();
};
_PasswordPatternDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _PasswordPatternDirective, selectors: [["", "appPasswordPattern", ""]], standalone: false, features: [\u0275\u0275ProvidersFeature([{ provide: NG_VALIDATORS, useExisting: _PasswordPatternDirective, multi: true }])] });
var PasswordPatternDirective = _PasswordPatternDirective;

// src/app/password-change/password-change.component.ts
var _c09 = () => ["password", "confirmPassword"];
function PasswordChangeComponent_div_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 20);
    \u0275\u0275text(1, " Password should have minimum 8 characters, at least 1 uppercase letter, 1 lowercase letter and 1 number ");
    \u0275\u0275elementEnd();
  }
}
function PasswordChangeComponent_div_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 20);
    \u0275\u0275text(1, " Confirm Password is required ");
    \u0275\u0275elementEnd();
  }
}
function PasswordChangeComponent_div_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 20);
    \u0275\u0275text(1, " Passwords does not match ");
    \u0275\u0275elementEnd();
  }
}
var _PasswordChangeComponent = class _PasswordChangeComponent {
  constructor(accountService, sharedImgService, route, activatedRoute, spinner, toastr) {
    this.accountService = accountService;
    this.sharedImgService = sharedImgService;
    this.route = route;
    this.activatedRoute = activatedRoute;
    this.spinner = spinner;
    this.toastr = toastr;
    this.form = {};
    this.errorDto = new ErrorDto();
    this.faUser = AppConstants.iconUser;
    this.faLock = AppConstants.iconLock;
    this.token = "";
    this.destroy$ = new Subject();
    this.header = "Create password";
  }
  ngOnInit() {
    this.sharedImgService.currentImgPath.subscribe((data) => this.imgPath = data);
    this.activatedRoute.queryParamMap.subscribe((params) => {
      this.token = params.get("token") || "";
    });
  }
  passwordChange() {
    this.spinner.show("refreshPasswordSpinner").then((r2) => r2);
    this.accountService.passwordChange(this.form, this.token, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide("accountSpinner").then(() => {
          this.toastr.success("Account activated", "Activation");
          this.route.navigate(["/login"]).then((r2) => r2);
        });
      },
      error: () => {
        this.toastr.error(this.errorDto.httpStatus + " password change failed", "Login");
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_PasswordChangeComponent.\u0275fac = function PasswordChangeComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PasswordChangeComponent)(\u0275\u0275directiveInject(AccountService), \u0275\u0275directiveInject(SharedImgService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_PasswordChangeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PasswordChangeComponent, selectors: [["app-forgot-password"]], standalone: false, decls: 28, vars: 12, consts: [["registeredForm", "ngForm"], ["password", "ngModel"], ["confirmPassword", "ngModel"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-4", "col-md-6", "col-sm-8", "align-self-center"], [1, "box-part", "text-center"], ["name", "form", "novalidate", "", 3, "ngSubmit", "appMatchPassword"], ["alt", "user", "width", "120", "height", "120", "id", "profile-img", 1, "profile-img-card", "mb-4", 3, "src"], [1, "input-group", "input-group-lg", "mb-4"], [1, "input-group-text"], [3, "icon"], ["placeholder", "password", "type", "password", "name", "password", "appPasswordPattern", "", "required", "", 1, "form-control", 3, "ngModelChange", "ngModel"], ["class", "alert alert-danger", "role", "alert", 4, "ngIf"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["placeholder", "confirmPassword", "type", "password", "name", "confirmPassword", "required", "", 1, "form-control", 3, "ngModelChange", "ngModel"], [1, "row"], [1, "col"], ["type", "submit", 1, "btn", "btn-primary", "btn-block", "mb-3"], [3, "errorDto"], ["role", "alert", 1, "alert", "alert-danger"]], template: function PasswordChangeComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 3)(1, "div", 4)(2, "div", 5)(3, "div", 6)(4, "h3");
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "form", 7, 0);
    \u0275\u0275listener("ngSubmit", function PasswordChangeComponent_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      const registeredForm_r2 = \u0275\u0275reference(7);
      return \u0275\u0275resetView(registeredForm_r2.form.valid && ctx.passwordChange());
    });
    \u0275\u0275element(8, "img", 8);
    \u0275\u0275elementStart(9, "div", 9)(10, "span", 10);
    \u0275\u0275element(11, "fa-icon", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "input", 12, 1);
    \u0275\u0275twoWayListener("ngModelChange", function PasswordChangeComponent_Template_input_ngModelChange_12_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.form.password, $event) || (ctx.form.password = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275template(14, PasswordChangeComponent_div_14_Template, 2, 0, "div", 13);
    \u0275\u0275element(15, "ngx-spinner", 14);
    \u0275\u0275elementStart(16, "div", 9)(17, "span", 10);
    \u0275\u0275element(18, "fa-icon", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "input", 15, 2);
    \u0275\u0275twoWayListener("ngModelChange", function PasswordChangeComponent_Template_input_ngModelChange_19_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.form.confirmPassword, $event) || (ctx.form.confirmPassword = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275template(21, PasswordChangeComponent_div_21_Template, 2, 0, "div", 13)(22, PasswordChangeComponent_div_22_Template, 2, 0, "div", 13);
    \u0275\u0275elementStart(23, "div", 16)(24, "div", 17)(25, "button", 18);
    \u0275\u0275text(26, "Reset");
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(27, "app-error", 19);
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    const registeredForm_r2 = \u0275\u0275reference(7);
    const password_r3 = \u0275\u0275reference(13);
    const confirmPassword_r4 = \u0275\u0275reference(20);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx.header);
    \u0275\u0275advance();
    \u0275\u0275property("appMatchPassword", \u0275\u0275pureFunction0(11, _c09));
    \u0275\u0275advance(2);
    \u0275\u0275propertyInterpolate("src", ctx.imgPath, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx.faLock);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx.form.password);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", registeredForm_r2.submitted && (password_r3.errors == null ? null : password_r3.errors.invalidPassword));
    \u0275\u0275advance(4);
    \u0275\u0275property("icon", ctx.faLock);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx.form.confirmPassword);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", confirmPassword_r4.errors == null ? null : confirmPassword_r4.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", confirmPassword_r4.errors == null ? null : confirmPassword_r4.errors.matching);
    \u0275\u0275advance(5);
    \u0275\u0275property("errorDto", ctx.errorDto);
  }
}, dependencies: [NgIf, NgxSpinnerComponent, FaIconComponent, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, NgModel, NgForm, ErrorComponent, PasswordMatcherDirective, PasswordPatternDirective], encapsulation: 2 });
var PasswordChangeComponent = _PasswordChangeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PasswordChangeComponent, { className: "PasswordChangeComponent", filePath: "src/app/password-change/password-change.component.ts", lineNumber: 17 });
})();

// src/app/forgot-password/forgot-password.component.ts
function ForgotPasswordComponent_div_14_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Email is required.");
    \u0275\u0275elementEnd();
  }
}
function ForgotPasswordComponent_div_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19);
    \u0275\u0275template(1, ForgotPasswordComponent_div_14_div_1_Template, 2, 0, "div", 20);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const catEmail_r3 = \u0275\u0275reference(13);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", catEmail_r3.errors.required);
  }
}
function ForgotPasswordComponent_div_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275text(1);
    \u0275\u0275element(2, "br");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r3.errorDto.httpStatusMessage, "");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r3.errorDto.errorMessage, " ");
  }
}
var _ForgotPasswordComponent = class _ForgotPasswordComponent {
  constructor(accountService, sharedImgService, route, spinner, toastr) {
    this.accountService = accountService;
    this.sharedImgService = sharedImgService;
    this.route = route;
    this.spinner = spinner;
    this.toastr = toastr;
    this.errorDto = new ErrorDto();
    this.faUser = AppConstants.iconUser;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.sharedImgService.currentImgPath.subscribe((data) => this.currentImgPath = data);
  }
  forgotPassword() {
    this.spinner.show("refreshPasswordSpinner").then((r2) => r2);
    this.accountService.passwordRecovery(this.email, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide("accountSpinner").then(() => {
          this.toastr.success("Email send", "Activation");
          this.route.navigate(["/login"]).then((r2) => r2);
        });
      },
      error: () => {
        this.toastr.error(this.errorDto.httpStatus + " sending email failed", "Login");
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_ForgotPasswordComponent.\u0275fac = function ForgotPasswordComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ForgotPasswordComponent)(\u0275\u0275directiveInject(AccountService), \u0275\u0275directiveInject(SharedImgService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_ForgotPasswordComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ForgotPasswordComponent, selectors: [["app-forgot-password"]], standalone: false, decls: 22, vars: 5, consts: [["forgotPswdForm", "ngForm"], ["catEmail", "ngModel"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-4", "col-md-6", "col-sm-8", "align-self-center"], [1, "box-part", "text-center"], ["name", "form", "novalidate", "", 3, "ngSubmit"], ["alt", "user", "width", "120", "height", "120", "id", "profile-img", 1, "profile-img-card", "mb-4", 3, "src"], [1, "input-group", "input-group-lg", "mb-4"], [1, "input-group-text"], [3, "icon"], ["placeholder", "email", "type", "*email", "name", "email", "required", "", 1, "form-control", 3, "ngModelChange", "ngModel"], ["class", "alert alert-danger", 4, "ngIf"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "row"], [1, "col"], ["type", "submit", 1, "btn", "btn-primary", "btn-block", "mb-3"], [1, "mb-3"], ["class", "alert alert-danger", "role", "alert", 4, "ngIf"], [1, "alert", "alert-danger"], [4, "ngIf"], ["role", "alert", 1, "alert", "alert-danger"]], template: function ForgotPasswordComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2)(1, "div", 3)(2, "div", 4)(3, "div", 5)(4, "h3");
    \u0275\u0275text(5, "Forgotten password");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "form", 6, 0);
    \u0275\u0275listener("ngSubmit", function ForgotPasswordComponent_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      const forgotPswdForm_r2 = \u0275\u0275reference(7);
      return \u0275\u0275resetView(forgotPswdForm_r2.form.valid && ctx.forgotPassword());
    });
    \u0275\u0275element(8, "img", 7);
    \u0275\u0275elementStart(9, "div", 8)(10, "span", 9);
    \u0275\u0275element(11, "fa-icon", 10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "input", 11, 1);
    \u0275\u0275twoWayListener("ngModelChange", function ForgotPasswordComponent_Template_input_ngModelChange_12_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.email, $event) || (ctx.email = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275template(14, ForgotPasswordComponent_div_14_Template, 2, 1, "div", 12);
    \u0275\u0275element(15, "ngx-spinner", 13);
    \u0275\u0275elementStart(16, "div", 14)(17, "div", 15)(18, "button", 16);
    \u0275\u0275text(19, "Send link");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(20, "div", 17);
    \u0275\u0275template(21, ForgotPasswordComponent_div_21_Template, 4, 2, "div", 18);
    \u0275\u0275elementEnd()()()()()();
  }
  if (rf & 2) {
    const forgotPswdForm_r2 = \u0275\u0275reference(7);
    const catEmail_r3 = \u0275\u0275reference(13);
    \u0275\u0275advance(8);
    \u0275\u0275propertyInterpolate("src", ctx.currentImgPath, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx.faUser);
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx.email);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", forgotPswdForm_r2.submitted && catEmail_r3.invalid);
    \u0275\u0275advance(7);
    \u0275\u0275property("ngIf", ctx.errorDto == null ? null : ctx.errorDto.httpStatus);
  }
}, dependencies: [NgIf, NgxSpinnerComponent, FaIconComponent, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, NgModel, NgForm], encapsulation: 2 });
var ForgotPasswordComponent = _ForgotPasswordComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ForgotPasswordComponent, { className: "ForgotPasswordComponent", filePath: "src/app/forgot-password/forgot-password.component.ts", lineNumber: 17 });
})();

// src/app/model/qr/QrRequest.ts
var QrRequest = class {
};

// src/app/model/qr/QrResponse.ts
var QrResponse = class {
};

// src/app/shared/app-info.component.ts
function InfoComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("", ctx_r0.info, " ");
  }
}
var _InfoComponent = class _InfoComponent {
};
_InfoComponent.\u0275fac = function InfoComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _InfoComponent)();
};
_InfoComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _InfoComponent, selectors: [["app-info"]], inputs: { info: "info" }, standalone: false, decls: 2, vars: 1, consts: [[1, "mb-3"], ["class", "alert alert-success", "role", "alert", 4, "ngIf"], ["role", "alert", 1, "alert", "alert-success"]], template: function InfoComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275template(1, InfoComponent_div_1_Template, 2, 1, "div", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.info);
  }
}, dependencies: [NgIf], encapsulation: 2 });
var InfoComponent = _InfoComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(InfoComponent, { className: "InfoComponent", filePath: "src/app/shared/app-info.component.ts", lineNumber: 16 });
})();

// src/app/navigation/navigation.service.ts
var _NavigationService = class _NavigationService {
  constructor(router, location2) {
    this.router = router;
    this.location = location2;
    this.history = [];
    this.router.events.subscribe((event) => {
      if (event instanceof NavigationEnd) {
        this.history.push(event.urlAfterRedirects);
      }
    });
  }
  back() {
    this.history.pop();
    if (this.history.length > 0) {
      this.location.back();
    } else {
      this.router.navigateByUrl("/");
    }
  }
};
_NavigationService.\u0275fac = function NavigationService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NavigationService)(\u0275\u0275inject(Router), \u0275\u0275inject(Location));
};
_NavigationService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _NavigationService, factory: _NavigationService.\u0275fac, providedIn: "root" });
var NavigationService = _NavigationService;

// src/app/navigation/back-button.directive.ts
var _BackButtonDirective = class _BackButtonDirective {
  constructor(navigation) {
    this.navigation = navigation;
  }
  onClick() {
    this.navigation.back();
  }
};
_BackButtonDirective.\u0275fac = function BackButtonDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BackButtonDirective)(\u0275\u0275directiveInject(NavigationService));
};
_BackButtonDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _BackButtonDirective, selectors: [["", "appBackButton", ""]], hostBindings: function BackButtonDirective_HostBindings(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275listener("click", function BackButtonDirective_click_HostBindingHandler() {
      return ctx.onClick();
    });
  }
}, standalone: false });
var BackButtonDirective = _BackButtonDirective;

// src/app/qr/qr.component.ts
function QrComponent_img_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 22);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("src", ctx_r2.existingImage, \u0275\u0275sanitizeUrl);
  }
}
var _QrComponent = class _QrComponent {
  constructor(qrService, spinner, toastr) {
    this.qrService = qrService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.destroy$ = new Subject();
    this.existingImage = null;
    this.errorDto = new ErrorDto();
    this.qrCodeRequest = new QrRequest();
    this.qrCodeResponse = new QrResponse();
    this.info = "";
    this.faArrowLeft = AppConstants.iconArrowLeft;
  }
  ngOnInit() {
    this.qrCodeRequest.currency = "CZK";
    this.qrCodeRequest.amount = 500;
    this.qrCodeRequest.iban = "CZ1203000000000217963916";
    this.qrCodeRequest.variableSymbol = 444;
    this.qrCodeRequest.message = "olala message";
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  loadQr() {
    this.spinner.show().then((r2) => r2);
    this.qrService.loadQr(this.qrCodeRequest, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (qrResponseData) => {
        this.spinner.hide().then(() => {
          this.info = "Oscanujte v mobiln\xED aplikaci a ov\u011B\u0159te, \u017Ee QR code pro bankovn\xED platby funguje.";
          this.qrCodeResponse = qrResponseData.data;
          this.existingImage = "data:image/png;base64," + this.qrCodeResponse.image;
          setTimeout(() => {
            this.info = "";
          }, 6e3);
        });
      },
      error: () => {
        this.spinner.hide().then(() => {
          this.toastr.error(this.errorDto.httpStatus + " loading failed", "QrCode");
        });
      }
    });
  }
};
_QrComponent.\u0275fac = function QrComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _QrComponent)(\u0275\u0275directiveInject(QrService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_QrComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _QrComponent, selectors: [["app-qr"]], standalone: false, decls: 26, vars: 6, consts: [["createQrForm", "ngForm"], ["iban", "ngModel"], ["variableSymbol", "ngModel"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-5", "col-sm-10", "align-self-center"], [1, "box-part", "text-center"], ["novalidate", "", 1, "row", "px-3", 3, "ngSubmit"], [1, "mb-4"], [1, "col-8"], ["type", "text", "id", "variableSymbol", "name", "iban", 1, "form-control", 3, "ngModelChange", "ngModel"], [1, "col-4"], ["type", "text", "id", "account", "placeholder", "VS", "name", "variableSymbol", 1, "form-control", 3, "ngModelChange", "ngModel"], ["bdColor", "rgba(51,51,51,0.8)", "size", "large", "color", "#fff", "type", "ball-spin-clockwise"], [1, "row"], [1, "col", "mb-3"], ["type", "submit", "aria-hidden", "true", 1, "btn", "btn-primary", "ms-2"], ["type", "button", "appBackButton", "", 1, "btn", "btn-danger", "ms-4"], [3, "icon"], [3, "errorDto"], ["readonly", "true", "class", "img-responsive show-image p-3", "alt", "Qr code result", 3, "src", 4, "ngIf"], [3, "info"], ["readonly", "true", "alt", "Qr code result", 1, "img-responsive", "show-image", "p-3", 3, "src"]], template: function QrComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 3)(1, "div", 4)(2, "div", 5)(3, "div", 6)(4, "form", 7, 0);
    \u0275\u0275listener("ngSubmit", function QrComponent_Template_form_ngSubmit_4_listener() {
      \u0275\u0275restoreView(_r1);
      const createQrForm_r2 = \u0275\u0275reference(5);
      return \u0275\u0275resetView(createQrForm_r2.form.valid && ctx.loadQr());
    });
    \u0275\u0275elementStart(6, "h2", 8);
    \u0275\u0275text(7, "Generate qr code");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 9)(9, "input", 10, 1);
    \u0275\u0275twoWayListener("ngModelChange", function QrComponent_Template_input_ngModelChange_9_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.qrCodeRequest.iban, $event) || (ctx.qrCodeRequest.iban = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 11)(12, "input", 12, 2);
    \u0275\u0275twoWayListener("ngModelChange", function QrComponent_Template_input_ngModelChange_12_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.qrCodeRequest.variableSymbol, $event) || (ctx.qrCodeRequest.variableSymbol = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275element(14, "ngx-spinner", 13);
    \u0275\u0275elementStart(15, "div", 14)(16, "div", 15);
    \u0275\u0275element(17, "br");
    \u0275\u0275elementStart(18, "button", 16);
    \u0275\u0275text(19, "Generate QR");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "button", 17);
    \u0275\u0275element(21, "fa-icon", 18);
    \u0275\u0275text(22, "\xA0Back ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(23, "app-error", 19);
    \u0275\u0275elementEnd();
    \u0275\u0275template(24, QrComponent_img_24_Template, 1, 1, "img", 20);
    \u0275\u0275element(25, "app-info", 21);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(9);
    \u0275\u0275twoWayProperty("ngModel", ctx.qrCodeRequest.iban);
    \u0275\u0275advance(3);
    \u0275\u0275twoWayProperty("ngModel", ctx.qrCodeRequest.variableSymbol);
    \u0275\u0275advance(9);
    \u0275\u0275property("icon", ctx.faArrowLeft);
    \u0275\u0275advance(2);
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.existingImage);
    \u0275\u0275advance();
    \u0275\u0275property("info", ctx.info);
  }
}, dependencies: [NgIf, NgxSpinnerComponent, FaIconComponent, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, NgModel, NgForm, ErrorComponent, InfoComponent, BackButtonDirective], encapsulation: 2 });
var QrComponent = _QrComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(QrComponent, { className: "QrComponent", filePath: "src/app/qr/qr.component.ts", lineNumber: 17 });
})();

// src/app/write-us/write-us-list/write-us-list.component.ts
var _c010 = (a0) => ["/email/write-us/", a0];
function WriteUsListComponent_div_33_fa_icon_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "fa-icon", 31);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("icon", ctx_r0.faNo);
  }
}
function WriteUsListComponent_div_33_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 20)(1, "div", 21)(2, "div", 22);
    \u0275\u0275element(3, "span", 23);
    \u0275\u0275elementStart(4, "span", 24);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 25);
    \u0275\u0275element(7, "span", 26);
    \u0275\u0275elementStart(8, "span", 24);
    \u0275\u0275text(9);
    \u0275\u0275pipe(10, "date");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 25);
    \u0275\u0275element(12, "span", 27);
    \u0275\u0275elementStart(13, "span", 24);
    \u0275\u0275template(14, WriteUsListComponent_div_33_fa_icon_14_Template, 1, 1, "fa-icon", 28);
    \u0275\u0275text(15);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(16, "div", 29);
    \u0275\u0275element(17, "span", 30);
    \u0275\u0275elementStart(18, "span", 24);
    \u0275\u0275element(19, "fa-icon", 31);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(20, "div", 32)(21, "button", 33);
    \u0275\u0275element(22, "fa-icon", 31);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(23, "div", 32)(24, "button", 34);
    \u0275\u0275element(25, "fa-icon", 31);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const email_r2 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(email_r2.emailFrom);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(10, 8, email_r2.audit.modifiedAt, "dd.MM.yyy HH:mm"));
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", !email_r2.phoneNumber);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", email_r2.phoneNumber, " ");
    \u0275\u0275advance(4);
    \u0275\u0275property("icon", ctx_r0.resolveIconBasedOnReplied(email_r2.replied));
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(11, _c010, email_r2.emailFrom));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faEdit);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx_r0.faDelete);
  }
}
var _WriteUsListComponent = class _WriteUsListComponent {
  constructor(writeUs, router, spinner, toastr) {
    this.writeUs = writeUs;
    this.router = router;
    this.spinner = spinner;
    this.toastr = toastr;
    this.destroy$ = new Subject();
    this.emailList = new Array();
    this.emailListFiltered = new Array();
    this.faEdit = AppConstants.iconEdit;
    this.faDelete = AppConstants.iconDelete;
    this.faYes = AppConstants.iconYes;
    this.faNo = AppConstants.iconNo;
    this.errorDto = new ErrorDto();
    this.replied = false;
  }
  ngOnInit() {
    this.getEmails();
  }
  getEmails() {
    this.spinner.show().then((r2) => r2);
    this.writeUs.loadEmailsWriteUs(this.errorDto, 0, 20, null, null).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.spinner.hide().then(() => this.toastr.info(response.data.length + " emails reloaded", "Emails"));
        this.emailList = response.data;
        this.emailListFiltered = this.emailList.filter((data) => data.replied == false);
      },
      error: () => {
        this.spinner.hide().then(() => {
          this.toastr.error(this.errorDto.httpStatus + " emails reload failed", "Emails");
        });
      }
    });
  }
  resolveIconBasedOnReplied(replied) {
    return replied ? this.faYes : this.faNo;
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  filter() {
    this.replied = !this.replied;
    if (this.replied == false) {
      this.emailListFiltered = this.emailList.filter((data) => data.replied == false);
    } else {
      this.emailListFiltered = this.emailList;
    }
  }
};
_WriteUsListComponent.\u0275fac = function WriteUsListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _WriteUsListComponent)(\u0275\u0275directiveInject(WriteUsService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_WriteUsListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _WriteUsListComponent, selectors: [["app-write-us-list"]], standalone: false, decls: 35, vars: 5, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-8", "col-12", "align-self-center"], [1, "box-part", "text-center"], [1, "text-orange", "mb-2"], [1, "row", "mb-3", "justify-content-end"], [1, "col-12", "col-sm-5", "col-md-4"], [1, "input-group"], ["type", "checkbox", "id", "repliedId", 3, "click", "checked"], ["aria-describedby", "repliedId", "id", "lblrepliedId", "for", "repliedId", 1, "checkbox-inline", "ms-2"], [1, "row"], [1, "input-group", "d-none", "d-sm-inline-flex", "text-center"], [1, "col-12", "col-sm-4"], [1, "text-darkorange"], [1, "col-12", "col-sm-2"], [1, "col-12", "col-sm-1"], [1, "text-darkorange", 3, "icon"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["class", "row text-center", 4, "ngFor", "ngForOf"], [3, "errorDto"], [1, "row", "text-center"], [1, "input-group", "link"], [1, "col-12", "col-sm-4", "border-bottom"], ["data-label", "Email", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "d-inline-block", "m-2", "text-white"], [1, "col-12", "col-sm-2", "text-white", "border-bottom"], ["data-label", "P\u0159ijato", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], ["data-label", "Telefon", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [3, "icon", 4, "ngIf"], [1, "col-12", "col-sm-2", "border-bottom"], ["data-label", "Odpov\u011Bzeno", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [3, "icon"], [1, "col-12", "col-sm-1", "border-bottom", "text-center"], ["routerLinkActive", "active", 1, "btn", "btn-primary", "btn-sm", "m-2", 3, "routerLink"], [1, "btn", "btn-primary", "btn-sm", "m-2"]], template: function WriteUsListComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h3", 4);
    \u0275\u0275text(5, "Emaily");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 5)(7, "div", 6)(8, "div", 7)(9, "input", 8);
    \u0275\u0275listener("click", function WriteUsListComponent_Template_input_click_9_listener() {
      return ctx.filter();
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "label", 9);
    \u0275\u0275text(11, "Pouze nezodpov\u011Bzen\xE9 emaily");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(12, "div", 10)(13, "div", 11)(14, "div", 12)(15, "span", 13);
    \u0275\u0275text(16, "Email");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 14)(18, "span", 13);
    \u0275\u0275text(19, "P\u0159ijato");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(20, "div", 14)(21, "span", 13);
    \u0275\u0275text(22, "Telefon");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(23, "div", 14)(24, "span", 13);
    \u0275\u0275text(25, "Odpov\u011Bzeno");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(26, "div", 15)(27, "span");
    \u0275\u0275element(28, "fa-icon", 16);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(29, "div", 15)(30, "span");
    \u0275\u0275element(31, "fa-icon", 16);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275element(32, "ngx-spinner", 17);
    \u0275\u0275template(33, WriteUsListComponent_div_33_Template, 26, 13, "div", 18);
    \u0275\u0275element(34, "app-error", 19);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(9);
    \u0275\u0275property("checked", ctx.replied === false);
    \u0275\u0275advance(19);
    \u0275\u0275property("icon", ctx.faEdit);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx.faDelete);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.emailListFiltered);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
  }
}, dependencies: [NgForOf, NgIf, RouterLink, RouterLinkActive, NgxSpinnerComponent, FaIconComponent, ErrorComponent, DatePipe], styles: ["\n\ninput[_ngcontent-%COMP%] {\n  box-shadow: none !important;\n}\n/*# sourceMappingURL=write-us-list.component.css.map */"] });
var WriteUsListComponent = _WriteUsListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(WriteUsListComponent, { className: "WriteUsListComponent", filePath: "src/app/write-us/write-us-list/write-us-list.component.ts", lineNumber: 18 });
})();

// src/app/model/email/email.ts
var Email = class {
  constructor(body, recepient) {
    this.body = body;
    this.recepient = recepient;
  }
};

// node_modules/@kolkov/angular-editor/fesm2020/kolkov-angular-editor.mjs
var _c011 = ["labelButton"];
var _c14 = (a0) => ({
  "ae-expanded": a0
});
var _c22 = (a0, a1) => ({
  "selected": a0,
  "focused": a1
});
function AeSelectComponent_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 9);
    \u0275\u0275listener("click", function AeSelectComponent_button_8_Template_button_click_0_listener($event) {
      const item_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.optionSelect(item_r3, $event));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const i_r5 = ctx.index;
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(2, _c22, item_r3.value === ctx_r3.value, i_r5 === ctx_r3.optionId));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", item_r3.label, " ");
  }
}
function AeSelectComponent_span_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 10);
    \u0275\u0275text(1, "No items for select");
    \u0275\u0275elementEnd();
  }
}
var _c32 = ["fileInput"];
var _c4 = ["*"];
function AngularEditorToolbarComponent_div_0_div_55_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 5)(1, "ae-select", 63);
    \u0275\u0275twoWayListener("ngModelChange", function AngularEditorToolbarComponent_div_0_div_55_Template_ae_select_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r1.customClassId, $event) || (ctx_r1.customClassId = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("change", function AngularEditorToolbarComponent_div_0_div_55_Template_ae_select_change_1_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.setCustomClass(ctx_r1.customClassId));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("options", ctx_r1.customClassList);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.customClassId);
    \u0275\u0275property("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("customClasses"));
  }
}
function AngularEditorToolbarComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 5)(2, "button", 6);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_2_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("undo"));
    });
    \u0275\u0275element(3, "i", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 8);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("redo"));
    });
    \u0275\u0275element(5, "i", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 5)(7, "button", 10);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_7_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("bold"));
    });
    \u0275\u0275element(8, "i", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "button", 12);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_9_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("italic"));
    });
    \u0275\u0275element(10, "i", 13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "button", 14);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_11_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("underline"));
    });
    \u0275\u0275element(12, "i", 15);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "button", 16);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_13_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("strikeThrough"));
    });
    \u0275\u0275element(14, "i", 17);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "button", 18);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_15_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("subscript"));
    });
    \u0275\u0275element(16, "i", 19);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "button", 20);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_17_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("superscript"));
    });
    \u0275\u0275element(18, "i", 21);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(19, "div", 5)(20, "button", 22);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_20_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("justifyLeft"));
    });
    \u0275\u0275element(21, "i", 23);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "button", 24);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_22_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("justifyCenter"));
    });
    \u0275\u0275element(23, "i", 25);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(24, "button", 26);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_24_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("justifyRight"));
    });
    \u0275\u0275element(25, "i", 27);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(26, "button", 28);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_26_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("justifyFull"));
    });
    \u0275\u0275element(27, "i", 29);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(28, "div", 5)(29, "button", 30);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_29_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("indent"));
    });
    \u0275\u0275element(30, "i", 31);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(31, "button", 32);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_31_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("outdent"));
    });
    \u0275\u0275element(32, "i", 33);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(33, "div", 5)(34, "button", 34);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_34_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("insertUnorderedList"));
    });
    \u0275\u0275element(35, "i", 35);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(36, "button", 36);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_36_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("insertOrderedList"));
    });
    \u0275\u0275element(37, "i", 37);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(38, "div", 5)(39, "ae-select", 38);
    \u0275\u0275twoWayListener("ngModelChange", function AngularEditorToolbarComponent_div_0_Template_ae_select_ngModelChange_39_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.block, $event) || (ctx_r1.block = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("change", function AngularEditorToolbarComponent_div_0_Template_ae_select_change_39_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand(ctx_r1.block));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(40, "div", 5)(41, "ae-select", 39);
    \u0275\u0275twoWayListener("ngModelChange", function AngularEditorToolbarComponent_div_0_Template_ae_select_ngModelChange_41_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.fontName, $event) || (ctx_r1.fontName = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("change", function AngularEditorToolbarComponent_div_0_Template_ae_select_change_41_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.setFontName(ctx_r1.fontName));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(42, "div", 5)(43, "ae-select", 40);
    \u0275\u0275twoWayListener("ngModelChange", function AngularEditorToolbarComponent_div_0_Template_ae_select_ngModelChange_43_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.fontSize, $event) || (ctx_r1.fontSize = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("change", function AngularEditorToolbarComponent_div_0_Template_ae_select_change_43_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.setFontSize(ctx_r1.fontSize));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(44, "div", 5)(45, "input", 41, 0);
    \u0275\u0275listener("change", function AngularEditorToolbarComponent_div_0_Template_input_change_45_listener() {
      \u0275\u0275restoreView(_r1);
      const fgInput_r3 = \u0275\u0275reference(46);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.insertColor(fgInput_r3.value, "textColor"));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(47, "button", 42);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_47_listener() {
      \u0275\u0275restoreView(_r1);
      const fgInput_r3 = \u0275\u0275reference(46);
      const ctx_r1 = \u0275\u0275nextContext();
      ctx_r1.focus();
      return \u0275\u0275resetView(fgInput_r3.click());
    });
    \u0275\u0275elementStart(48, "span", 43);
    \u0275\u0275element(49, "i", 44);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(50, "input", 41, 1);
    \u0275\u0275listener("change", function AngularEditorToolbarComponent_div_0_Template_input_change_50_listener() {
      \u0275\u0275restoreView(_r1);
      const bgInput_r4 = \u0275\u0275reference(51);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.insertColor(bgInput_r4.value, "backgroundColor"));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(52, "button", 45);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_52_listener() {
      \u0275\u0275restoreView(_r1);
      const bgInput_r4 = \u0275\u0275reference(51);
      const ctx_r1 = \u0275\u0275nextContext();
      ctx_r1.focus();
      return \u0275\u0275resetView(bgInput_r4.click());
    });
    \u0275\u0275elementStart(53, "span", 46);
    \u0275\u0275element(54, "i", 44);
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(55, AngularEditorToolbarComponent_div_0_div_55_Template, 2, 4, "div", 47);
    \u0275\u0275elementStart(56, "div", 5)(57, "button", 48);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_57_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.insertUrl());
    });
    \u0275\u0275element(58, "i", 49);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(59, "button", 50);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_59_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("unlink"));
    });
    \u0275\u0275element(60, "i", 51);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(61, "input", 52, 2);
    \u0275\u0275listener("change", function AngularEditorToolbarComponent_div_0_Template_input_change_61_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onFileChanged($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(63, "button", 53);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_63_listener() {
      \u0275\u0275restoreView(_r1);
      const fileInput_r6 = \u0275\u0275reference(62);
      const ctx_r1 = \u0275\u0275nextContext();
      ctx_r1.focus();
      return \u0275\u0275resetView(fileInput_r6.click());
    });
    \u0275\u0275element(64, "i", 54);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(65, "button", 55);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_65_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.insertVideo());
    });
    \u0275\u0275element(66, "i", 56);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(67, "button", 57);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_67_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("insertHorizontalRule"));
    });
    \u0275\u0275element(68, "i", 58);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(69, "div", 5)(70, "button", 59);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_70_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("removeFormat"));
    });
    \u0275\u0275element(71, "i", 60);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(72, "div", 5)(73, "button", 61);
    \u0275\u0275listener("click", function AngularEditorToolbarComponent_div_0_Template_button_click_73_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.triggerCommand("toggleEditorMode"));
    });
    \u0275\u0275element(74, "i", 62);
    \u0275\u0275elementEnd()();
    \u0275\u0275projection(75);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("hidden", ctx_r1.isButtonHidden("undo"));
    \u0275\u0275advance(2);
    \u0275\u0275property("hidden", ctx_r1.isButtonHidden("redo"));
    \u0275\u0275advance(3);
    \u0275\u0275property("id", "bold-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("bold"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "italic-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("italic"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "underline-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("underline"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "strikeThrough-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("strikeThrough"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "subscript-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("subscript"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "superscript-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("superscript"));
    \u0275\u0275advance(3);
    \u0275\u0275property("id", "justifyLeft-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("justifyLeft"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "justifyCenter-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("justifyCenter"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "justifyRight-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("justifyRight"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "justifyFull-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("justifyFull"));
    \u0275\u0275advance(3);
    \u0275\u0275property("id", "indent-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("indent"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "outdent-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("outdent"));
    \u0275\u0275advance(3);
    \u0275\u0275property("id", "insertUnorderedList-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("insertUnorderedList"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "insertOrderedList-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("insertOrderedList"));
    \u0275\u0275advance(3);
    \u0275\u0275property("options", ctx_r1.headings);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.block);
    \u0275\u0275property("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("heading"));
    \u0275\u0275advance(2);
    \u0275\u0275property("options", ctx_r1.fonts);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.fontName);
    \u0275\u0275property("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("fontName"));
    \u0275\u0275advance(2);
    \u0275\u0275property("options", ctx_r1.fontSizes);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.fontSize);
    \u0275\u0275property("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("fontSize"));
    \u0275\u0275advance(4);
    \u0275\u0275property("id", "foregroundColorPicker-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("textColor"));
    \u0275\u0275advance(5);
    \u0275\u0275property("id", "backgroundColorPicker-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("backgroundColor"));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx_r1._customClasses);
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "link-" + ctx_r1.id)("disabled", ctx_r1.isLinkButtonDisabled)("hidden", ctx_r1.isButtonHidden("link"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "unlink-" + ctx_r1.id)("disabled", ctx_r1.htmlMode || !ctx_r1.linkSelected)("hidden", ctx_r1.isButtonHidden("unlink"));
    \u0275\u0275advance(4);
    \u0275\u0275property("id", "insertImage-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("insertImage"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "insertVideo-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("insertVideo"));
    \u0275\u0275advance(2);
    \u0275\u0275property("id", "insertHorizontalRule-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("insertHorizontalRule"));
    \u0275\u0275advance(3);
    \u0275\u0275property("id", "clearFormatting-" + ctx_r1.id)("disabled", ctx_r1.htmlMode)("hidden", ctx_r1.isButtonHidden("removeFormat"));
    \u0275\u0275advance(3);
    \u0275\u0275property("id", "toggleEditorMode-" + ctx_r1.id)("hidden", ctx_r1.isButtonHidden("toggleEditorMode"));
  }
}
var _c5 = ["customButtons"];
var _c6 = ["editor"];
var _c7 = ["editorWrapper"];
var _c8 = ["editorToolbar"];
var _c9 = (a0) => ({
  executeCommandFn: a0
});
function AngularEditorComponent_angular_editor_toolbar_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "angular-editor-toolbar", 9, 3);
    \u0275\u0275listener("execute", function AngularEditorComponent_angular_editor_toolbar_2_Template_angular_editor_toolbar_execute_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.executeCommand($event));
    });
    \u0275\u0275elementContainer(2, 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("id", ctx_r2.id)("uploadUrl", ctx_r2.config.uploadUrl)("upload", ctx_r2.config.upload)("showToolbar", ctx_r2.config.showToolbar !== void 0 ? ctx_r2.config.showToolbar : true)("fonts", ctx_r2.getFonts())("customClasses", ctx_r2.config.customClasses)("defaultFontName", ctx_r2.config.defaultFontName)("defaultFontSize", ctx_r2.config.defaultFontSize)("hiddenButtons", ctx_r2.config.toolbarHiddenButtons);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.customButtonsTemplateRef)("ngTemplateOutletContext", \u0275\u0275pureFunction1(11, _c9, ctx_r2.executeCommandFn));
  }
}
function AngularEditorComponent_angular_editor_toolbar_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "angular-editor-toolbar", 9, 3);
    \u0275\u0275listener("execute", function AngularEditorComponent_angular_editor_toolbar_9_Template_angular_editor_toolbar_execute_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.executeCommand($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("id", ctx_r2.id)("uploadUrl", ctx_r2.config.uploadUrl)("upload", ctx_r2.config.upload)("showToolbar", ctx_r2.config.showToolbar !== void 0 ? ctx_r2.config.showToolbar : true)("fonts", ctx_r2.getFonts())("customClasses", ctx_r2.config.customClasses)("defaultFontName", ctx_r2.config.defaultFontName)("defaultFontSize", ctx_r2.config.defaultFontSize)("hiddenButtons", ctx_r2.config.toolbarHiddenButtons);
  }
}
var AngularEditorService = class {
  constructor(http, doc) {
    this.http = http;
    this.doc = doc;
    this.saveSelection = () => {
      if (this.doc.getSelection) {
        const sel = this.doc.getSelection();
        if (sel.getRangeAt && sel.rangeCount) {
          this.savedSelection = sel.getRangeAt(0);
          this.selectedText = sel.toString();
        }
      } else if (this.doc.getSelection && this.doc.createRange) {
        this.savedSelection = document.createRange();
      } else {
        this.savedSelection = null;
      }
    };
  }
  /**
   * Executed command from editor header buttons exclude toggleEditorMode
   * @param command string from triggerCommand
   * @param value
   */
  executeCommand(command, value2) {
    const commands = ["h1", "h2", "h3", "h4", "h5", "h6", "p", "pre"];
    if (commands.includes(command)) {
      this.doc.execCommand("formatBlock", false, command);
      return;
    }
    this.doc.execCommand(command, false, value2);
  }
  /**
   * Create URL link
   * @param url string from UI prompt
   */
  createLink(url) {
    if (!url.includes("http")) {
      this.doc.execCommand("createlink", false, url);
    } else {
      const newUrl = '<a href="' + url + '" target="_blank">' + this.selectedText + "</a>";
      this.insertHtml(newUrl);
    }
  }
  /**
   * insert color either font or background
   *
   * @param color color to be inserted
   * @param where where the color has to be inserted either text/background
   */
  insertColor(color2, where) {
    const restored = this.restoreSelection();
    if (restored) {
      if (where === "textColor") {
        this.doc.execCommand("foreColor", false, color2);
      } else {
        this.doc.execCommand("hiliteColor", false, color2);
      }
    }
  }
  /**
   * Set font name
   * @param fontName string
   */
  setFontName(fontName) {
    this.doc.execCommand("fontName", false, fontName);
  }
  /**
   * Set font size
   * @param fontSize string
   */
  setFontSize(fontSize) {
    this.doc.execCommand("fontSize", false, fontSize);
  }
  /**
   * Create raw HTML
   * @param html HTML string
   */
  insertHtml(html) {
    const isHTMLInserted = this.doc.execCommand("insertHTML", false, html);
    if (!isHTMLInserted) {
      throw new Error("Unable to perform the operation");
    }
  }
  /**
   * restore selection when the editor is focused in
   *
   * saved selection when the editor is focused out
   */
  restoreSelection() {
    if (this.savedSelection) {
      if (this.doc.getSelection) {
        const sel = this.doc.getSelection();
        sel.removeAllRanges();
        sel.addRange(this.savedSelection);
        return true;
      } else if (this.doc.getSelection) {
        return true;
      }
    } else {
      return false;
    }
  }
  /**
   * setTimeout used for execute 'saveSelection' method in next event loop iteration
   */
  executeInNextQueueIteration(callbackFn, timeout2 = 100) {
    setTimeout(callbackFn, timeout2);
  }
  /** check any selection is made or not */
  checkSelection() {
    const selectedText = this.savedSelection.toString();
    if (selectedText.length === 0) {
      throw new Error("No Selection Made");
    }
    return true;
  }
  /**
   * Upload file to uploadUrl
   * @param file The file
   */
  uploadImage(file) {
    const uploadData = new FormData();
    uploadData.append("file", file, file.name);
    return this.http.post(this.uploadUrl, uploadData, {
      reportProgress: true,
      observe: "events",
      withCredentials: this.uploadWithCredentials
    });
  }
  /**
   * Insert image with Url
   * @param imageUrl The imageUrl.
   */
  insertImage(imageUrl) {
    this.doc.execCommand("insertImage", false, imageUrl);
  }
  setDefaultParagraphSeparator(separator) {
    this.doc.execCommand("defaultParagraphSeparator", false, separator);
  }
  createCustomClass(customClass) {
    let newTag = this.selectedText;
    if (customClass) {
      const tagName = customClass.tag ? customClass.tag : "span";
      newTag = "<" + tagName + ' class="' + customClass.class + '">' + this.selectedText + "</" + tagName + ">";
    }
    this.insertHtml(newTag);
  }
  insertVideo(videoUrl) {
    if (videoUrl.match("www.youtube.com")) {
      this.insertYouTubeVideoTag(videoUrl);
    }
    if (videoUrl.match("vimeo.com")) {
      this.insertVimeoVideoTag(videoUrl);
    }
  }
  insertYouTubeVideoTag(videoUrl) {
    const id3 = videoUrl.split("v=")[1];
    const imageUrl = `https://img.youtube.com/vi/${id3}/0.jpg`;
    const thumbnail = `
      <div style='position: relative'>
        <a href='${videoUrl}' target='_blank'>
          <img src="${imageUrl}" alt="click to watch"/>
          <img style='position: absolute; left:200px; top:140px'
          src="https://img.icons8.com/color/96/000000/youtube-play.png"/>
        </a>
      </div>`;
    this.insertHtml(thumbnail);
  }
  insertVimeoVideoTag(videoUrl) {
    const sub = this.http.get(`https://vimeo.com/api/oembed.json?url=${videoUrl}`).subscribe((data) => {
      const imageUrl = data.thumbnail_url_with_play_button;
      const thumbnail = `<div>
        <a href='${videoUrl}' target='_blank'>
          <img src="${imageUrl}" alt="${data.title}"/>
        </a>
      </div>`;
      this.insertHtml(thumbnail);
      sub.unsubscribe();
    });
  }
  nextNode(node) {
    if (node.hasChildNodes()) {
      return node.firstChild;
    } else {
      while (node && !node.nextSibling) {
        node = node.parentNode;
      }
      if (!node) {
        return null;
      }
      return node.nextSibling;
    }
  }
  getRangeSelectedNodes(range2, includePartiallySelectedContainers) {
    let node = range2.startContainer;
    const endNode = range2.endContainer;
    let rangeNodes = [];
    if (node === endNode) {
      rangeNodes = [node];
    } else {
      while (node && node !== endNode) {
        rangeNodes.push(node = this.nextNode(node));
      }
      node = range2.startContainer;
      while (node && node !== range2.commonAncestorContainer) {
        rangeNodes.unshift(node);
        node = node.parentNode;
      }
    }
    if (includePartiallySelectedContainers) {
      node = range2.commonAncestorContainer;
      while (node) {
        rangeNodes.push(node);
        node = node.parentNode;
      }
    }
    return rangeNodes;
  }
  getSelectedNodes() {
    const nodes = [];
    if (this.doc.getSelection) {
      const sel = this.doc.getSelection();
      for (let i = 0, len = sel.rangeCount; i < len; ++i) {
        nodes.push.apply(nodes, this.getRangeSelectedNodes(sel.getRangeAt(i), true));
      }
    }
    return nodes;
  }
  replaceWithOwnChildren(el) {
    const parent = el.parentNode;
    while (el.hasChildNodes()) {
      parent.insertBefore(el.firstChild, el);
    }
    parent.removeChild(el);
  }
  removeSelectedElements(tagNames) {
    const tagNamesArray = tagNames.toLowerCase().split(",");
    this.getSelectedNodes().forEach((node) => {
      if (node.nodeType === 1 && tagNamesArray.indexOf(node.tagName.toLowerCase()) > -1) {
        this.replaceWithOwnChildren(node);
      }
    });
  }
};
AngularEditorService.\u0275fac = function AngularEditorService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AngularEditorService)(\u0275\u0275inject(HttpClient), \u0275\u0275inject(DOCUMENT2));
};
AngularEditorService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: AngularEditorService,
  factory: AngularEditorService.\u0275fac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AngularEditorService, [{
    type: Injectable
  }], function() {
    return [{
      type: HttpClient
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT2]
      }]
    }];
  }, null);
})();
var angularEditorConfig = {
  editable: true,
  spellcheck: true,
  height: "auto",
  minHeight: "0",
  maxHeight: "auto",
  width: "auto",
  minWidth: "0",
  translate: "yes",
  enableToolbar: true,
  showToolbar: true,
  placeholder: "Enter text here...",
  defaultParagraphSeparator: "",
  defaultFontName: "",
  defaultFontSize: "",
  fonts: [{
    class: "arial",
    name: "Arial"
  }, {
    class: "times-new-roman",
    name: "Times New Roman"
  }, {
    class: "calibri",
    name: "Calibri"
  }, {
    class: "comic-sans-ms",
    name: "Comic Sans MS"
  }],
  uploadUrl: "v1/image",
  uploadWithCredentials: false,
  sanitize: true,
  toolbarPosition: "top",
  outline: true
  /*toolbarHiddenButtons: [
    ['bold', 'italic', 'underline', 'strikeThrough', 'superscript', 'subscript'],
    ['heading', 'fontName', 'fontSize', 'color'],
    ['justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull', 'indent', 'outdent'],
    ['cut', 'copy', 'delete', 'removeFormat', 'undo', 'redo'],
    ['paragraph', 'blockquote', 'removeBlockquote', 'horizontalLine', 'orderedList', 'unorderedList'],
    ['link', 'unlink', 'image', 'video']
  ]*/
};
function isDefined(value2) {
  return value2 !== void 0 && value2 !== null;
}
var AeSelectComponent = class {
  constructor(elRef, r2) {
    this.elRef = elRef;
    this.r = r2;
    this.options = [];
    this.disabled = false;
    this.optionId = 0;
    this.opened = false;
    this.hidden = "inline-block";
    this.changeEvent = new EventEmitter();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
  }
  get label() {
    return this.selectedOption && this.selectedOption.hasOwnProperty("label") ? this.selectedOption.label : "Select";
  }
  get value() {
    return this.selectedOption.value;
  }
  ngOnInit() {
    this.selectedOption = this.options[0];
    if (isDefined(this.isHidden) && this.isHidden) {
      this.hide();
    }
  }
  hide() {
    this.hidden = "none";
  }
  optionSelect(option, event) {
    event.stopPropagation();
    this.setValue(option.value);
    this.onChange(this.selectedOption.value);
    this.changeEvent.emit(this.selectedOption.value);
    this.onTouched();
    this.opened = false;
  }
  toggleOpen(event) {
    if (this.disabled) {
      return;
    }
    this.opened = !this.opened;
  }
  onClick($event) {
    if (!this.elRef.nativeElement.contains($event.target)) {
      this.close();
    }
  }
  close() {
    this.opened = false;
  }
  get isOpen() {
    return this.opened;
  }
  writeValue(value2) {
    if (!value2 || typeof value2 !== "string") {
      return;
    }
    this.setValue(value2);
  }
  setValue(value2) {
    let index = 0;
    const selectedEl = this.options.find((el, i) => {
      index = i;
      return el.value === value2;
    });
    if (selectedEl) {
      this.selectedOption = selectedEl;
      this.optionId = index;
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.labelButton.nativeElement.disabled = isDisabled;
    const div = this.labelButton.nativeElement;
    const action = isDisabled ? "addClass" : "removeClass";
    this.r[action](div, "disabled");
    this.disabled = isDisabled;
  }
  handleKeyDown($event) {
    if (!this.opened) {
      return;
    }
    switch ($event.key) {
      case "ArrowDown":
        this._handleArrowDown($event);
        break;
      case "ArrowUp":
        this._handleArrowUp($event);
        break;
      case "Space":
        this._handleSpace($event);
        break;
      case "Enter":
        this._handleEnter($event);
        break;
      case "Tab":
        this._handleTab($event);
        break;
      case "Escape":
        this.close();
        $event.preventDefault();
        break;
      case "Backspace":
        this._handleBackspace();
        break;
    }
  }
  _handleArrowDown($event) {
    if (this.optionId < this.options.length - 1) {
      this.optionId++;
    }
  }
  _handleArrowUp($event) {
    if (this.optionId >= 1) {
      this.optionId--;
    }
  }
  _handleSpace($event) {
  }
  _handleEnter($event) {
    this.optionSelect(this.options[this.optionId], $event);
  }
  _handleTab($event) {
  }
  _handleBackspace() {
  }
};
AeSelectComponent.\u0275fac = function AeSelectComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AeSelectComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
};
AeSelectComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: AeSelectComponent,
  selectors: [["ae-select"]],
  viewQuery: function AeSelectComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c011, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.labelButton = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function AeSelectComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function AeSelectComponent_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      }, false, \u0275\u0275resolveDocument)("keydown", function AeSelectComponent_keydown_HostBindingHandler($event) {
        return ctx.handleKeyDown($event);
      });
    }
    if (rf & 2) {
      \u0275\u0275styleProp("display", ctx.hidden);
    }
  },
  inputs: {
    options: "options",
    isHidden: [0, "hidden", "isHidden"]
  },
  outputs: {
    changeEvent: "change"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AeSelectComponent),
    multi: true
  }])],
  decls: 10,
  vars: 7,
  consts: [["labelButton", ""], [1, "ae-font", "ae-picker", 3, "ngClass"], ["tabindex", "0", "type", "button", "role", "button", 1, "ae-picker-label", 3, "click", "tabIndex"], ["viewBox", "0 0 18 18"], ["points", "7 11 9 13 11 11 7 11", 1, "ae-stroke"], ["points", "7 7 9 5 11 7 7 7", 1, "ae-stroke"], [1, "ae-picker-options"], ["tabindex", "-1", "type", "button", "role", "button", "class", "ae-picker-item", 3, "ngClass", "click", 4, "ngFor", "ngForOf"], ["class", "dropdown-item", 4, "ngIf"], ["tabindex", "-1", "type", "button", "role", "button", 1, "ae-picker-item", 3, "click", "ngClass"], [1, "dropdown-item"]],
  template: function AeSelectComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "span", 1)(1, "button", 2, 0);
      \u0275\u0275listener("click", function AeSelectComponent_Template_button_click_1_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.toggleOpen($event));
      });
      \u0275\u0275text(3);
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(4, "svg", 3);
      \u0275\u0275element(5, "polygon", 4)(6, "polygon", 5);
      \u0275\u0275elementEnd()();
      \u0275\u0275namespaceHTML();
      \u0275\u0275elementStart(7, "span", 6);
      \u0275\u0275template(8, AeSelectComponent_button_8_Template, 2, 5, "button", 7)(9, AeSelectComponent_span_9_Template, 2, 0, "span", 8);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(5, _c14, ctx.isOpen));
      \u0275\u0275advance();
      \u0275\u0275property("tabIndex", -1);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1("", ctx.label, " ");
      \u0275\u0275advance(5);
      \u0275\u0275property("ngForOf", ctx.options);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.options.length);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf],
  styles: ['.ae-font.ae-picker{color:#444;display:inline-block;float:left;width:100%;position:relative;vertical-align:middle}.ae-font .ae-picker-label{cursor:pointer;display:inline-block;height:100%;padding-left:8px;padding-right:10px;position:relative;width:100%;line-height:26px;vertical-align:middle;font-size:85%;text-align:left;background-color:#fff;min-width:2rem;float:left;border:1px solid #ddd;text-overflow:clip;overflow:hidden;white-space:nowrap}.ae-font .ae-picker-label:before{content:"";position:absolute;right:0;top:0;width:20px;height:100%;background:linear-gradient(to right,rgb(255,255,255),#ffffff 100%)}.ae-font .ae-picker-label:focus{outline:none}.ae-font .ae-picker-label:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.ae-font .ae-picker-label:hover:before{background:linear-gradient(to right,#f5f5f5 100%,#ffffff 100%)}.ae-font .ae-picker-label:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.ae-font .ae-picker-label:disabled:before{background:linear-gradient(to right,#f5f5f5 100%,#ffffff 100%)}.ae-font .ae-picker-label svg{position:absolute;margin-top:-9px;right:0;top:50%;width:18px}.ae-font .ae-picker-label svg:not(:root){overflow:hidden}.ae-font .ae-picker-label svg .ae-stroke{fill:none;stroke:#444;stroke-linecap:round;stroke-linejoin:round;stroke-width:2}.ae-font .ae-picker-options{background-color:#fff;display:none;min-width:100%;position:absolute;white-space:nowrap;z-index:3;border:1px solid transparent;box-shadow:#0003 0 2px 8px}.ae-font .ae-picker-options .ae-picker-item{cursor:pointer;display:block;padding-bottom:5px;padding-top:5px;padding-left:5px;z-index:3;text-align:left;background-color:transparent;min-width:2rem;width:100%;border:0 solid #ddd}.ae-font .ae-picker-options .ae-picker-item.selected{color:#06c;background-color:#fff4c2}.ae-font .ae-picker-options .ae-picker-item.focused,.ae-font .ae-picker-options .ae-picker-item:hover{background-color:#fffa98}.ae-font.ae-expanded{display:block;margin-top:-1px;z-index:1}.ae-font.ae-expanded .ae-picker-label{color:#ccc;z-index:2}.ae-font.ae-expanded .ae-picker-label svg{color:#ccc;z-index:2}.ae-font.ae-expanded .ae-picker-label svg .ae-stroke{stroke:#ccc}.ae-font.ae-expanded .ae-picker-options{display:block;margin-top:-1px;top:100%;z-index:3;border-color:#ccc}\n'],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AeSelectComponent, [{
    type: Component,
    args: [{
      selector: "ae-select",
      encapsulation: ViewEncapsulation.None,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => AeSelectComponent),
        multi: true
      }],
      template: `<span class="ae-font ae-picker" [ngClass]="{'ae-expanded':isOpen}">
  <button [tabIndex]="-1" #labelButton tabindex="0" type="button" role="button" class="ae-picker-label" (click)="toggleOpen($event);">{{label}}
    <svg viewBox="0 0 18 18">
     <!-- <use x="0" y="0" xlink:href="../assets/icons.svg#hom"></use>-->
      <polygon class="ae-stroke" points="7 11 9 13 11 11 7 11"></polygon>
      <polygon class="ae-stroke" points="7 7 9 5 11 7 7 7"></polygon>
    </svg>
  </button>
  <span class="ae-picker-options">
    <button tabindex="-1" type="button" role="button" class="ae-picker-item"
          *ngFor="let item of options; let i = index"
          [ngClass]="{'selected': item.value === value, 'focused': i === optionId}"
          (click)="optionSelect(item, $event)">
          {{item.label}}
    </button>
    <span class="dropdown-item" *ngIf="!options.length">No items for select</span>
  </span>
</span>
`,
      styles: ['.ae-font.ae-picker{color:#444;display:inline-block;float:left;width:100%;position:relative;vertical-align:middle}.ae-font .ae-picker-label{cursor:pointer;display:inline-block;height:100%;padding-left:8px;padding-right:10px;position:relative;width:100%;line-height:26px;vertical-align:middle;font-size:85%;text-align:left;background-color:#fff;min-width:2rem;float:left;border:1px solid #ddd;text-overflow:clip;overflow:hidden;white-space:nowrap}.ae-font .ae-picker-label:before{content:"";position:absolute;right:0;top:0;width:20px;height:100%;background:linear-gradient(to right,rgb(255,255,255),#ffffff 100%)}.ae-font .ae-picker-label:focus{outline:none}.ae-font .ae-picker-label:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.ae-font .ae-picker-label:hover:before{background:linear-gradient(to right,#f5f5f5 100%,#ffffff 100%)}.ae-font .ae-picker-label:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.ae-font .ae-picker-label:disabled:before{background:linear-gradient(to right,#f5f5f5 100%,#ffffff 100%)}.ae-font .ae-picker-label svg{position:absolute;margin-top:-9px;right:0;top:50%;width:18px}.ae-font .ae-picker-label svg:not(:root){overflow:hidden}.ae-font .ae-picker-label svg .ae-stroke{fill:none;stroke:#444;stroke-linecap:round;stroke-linejoin:round;stroke-width:2}.ae-font .ae-picker-options{background-color:#fff;display:none;min-width:100%;position:absolute;white-space:nowrap;z-index:3;border:1px solid transparent;box-shadow:#0003 0 2px 8px}.ae-font .ae-picker-options .ae-picker-item{cursor:pointer;display:block;padding-bottom:5px;padding-top:5px;padding-left:5px;z-index:3;text-align:left;background-color:transparent;min-width:2rem;width:100%;border:0 solid #ddd}.ae-font .ae-picker-options .ae-picker-item.selected{color:#06c;background-color:#fff4c2}.ae-font .ae-picker-options .ae-picker-item.focused,.ae-font .ae-picker-options .ae-picker-item:hover{background-color:#fffa98}.ae-font.ae-expanded{display:block;margin-top:-1px;z-index:1}.ae-font.ae-expanded .ae-picker-label{color:#ccc;z-index:2}.ae-font.ae-expanded .ae-picker-label svg{color:#ccc;z-index:2}.ae-font.ae-expanded .ae-picker-label svg .ae-stroke{stroke:#ccc}.ae-font.ae-expanded .ae-picker-options{display:block;margin-top:-1px;top:100%;z-index:3;border-color:#ccc}\n']
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    options: [{
      type: Input
    }],
    isHidden: [{
      type: Input,
      args: ["hidden"]
    }],
    hidden: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    changeEvent: [{
      type: Output,
      args: ["change"]
    }],
    labelButton: [{
      type: ViewChild,
      args: ["labelButton", {
        static: true
      }]
    }],
    onClick: [{
      type: HostListener,
      args: ["document:click", ["$event"]]
    }],
    handleKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var AngularEditorToolbarComponent = class {
  constructor(r2, editorService, er, doc) {
    this.r = r2;
    this.editorService = editorService;
    this.er = er;
    this.doc = doc;
    this.htmlMode = false;
    this.linkSelected = false;
    this.block = "default";
    this.fontName = "Times New Roman";
    this.fontSize = "3";
    this.headings = [{
      label: "Heading 1",
      value: "h1"
    }, {
      label: "Heading 2",
      value: "h2"
    }, {
      label: "Heading 3",
      value: "h3"
    }, {
      label: "Heading 4",
      value: "h4"
    }, {
      label: "Heading 5",
      value: "h5"
    }, {
      label: "Heading 6",
      value: "h6"
    }, {
      label: "Heading 7",
      value: "h7"
    }, {
      label: "Paragraph",
      value: "p"
    }, {
      label: "Predefined",
      value: "pre"
    }, {
      label: "Standard",
      value: "div"
    }, {
      label: "default",
      value: "default"
    }];
    this.fontSizes = [{
      label: "1",
      value: "1"
    }, {
      label: "2",
      value: "2"
    }, {
      label: "3",
      value: "3"
    }, {
      label: "4",
      value: "4"
    }, {
      label: "5",
      value: "5"
    }, {
      label: "6",
      value: "6"
    }, {
      label: "7",
      value: "7"
    }];
    this.customClassId = "-1";
    this.customClassList = [{
      label: "",
      value: ""
    }];
    this.tagMap = {
      BLOCKQUOTE: "indent",
      A: "link"
    };
    this.select = ["H1", "H2", "H3", "H4", "H5", "H6", "P", "PRE", "DIV"];
    this.buttons = ["bold", "italic", "underline", "strikeThrough", "subscript", "superscript", "justifyLeft", "justifyCenter", "justifyRight", "justifyFull", "indent", "outdent", "insertUnorderedList", "insertOrderedList", "link"];
    this.fonts = [{
      label: "",
      value: ""
    }];
    this.execute = new EventEmitter();
  }
  set customClasses(classes) {
    if (classes) {
      this._customClasses = classes;
      this.customClassList = this._customClasses.map((x4, i) => ({
        label: x4.name,
        value: i.toString()
      }));
      this.customClassList.unshift({
        label: "Clear Class",
        value: "-1"
      });
    }
  }
  set defaultFontName(value2) {
    if (value2) {
      this.fontName = value2;
    }
  }
  set defaultFontSize(value2) {
    if (value2) {
      this.fontSize = value2;
    }
  }
  get isLinkButtonDisabled() {
    return this.htmlMode || !Boolean(this.editorService.selectedText);
  }
  /**
   * Trigger command from editor header buttons
   * @param command string from toolbar buttons
   */
  triggerCommand(command) {
    this.execute.emit(command);
  }
  /**
   * highlight editor buttons when cursor moved or positioning
   */
  triggerButtons() {
    if (!this.showToolbar) {
      return;
    }
    this.buttons.forEach((e) => {
      const result = this.doc.queryCommandState(e);
      const elementById = this.doc.getElementById(e + "-" + this.id);
      if (result) {
        this.r.addClass(elementById, "active");
      } else {
        this.r.removeClass(elementById, "active");
      }
    });
  }
  /**
   * trigger highlight editor buttons when cursor moved or positioning in block
   */
  triggerBlocks(nodes) {
    if (!this.showToolbar) {
      return;
    }
    this.linkSelected = nodes.findIndex((x4) => x4.nodeName === "A") > -1;
    let found = false;
    this.select.forEach((y3) => {
      const node = nodes.find((x4) => x4.nodeName === y3);
      if (node !== void 0 && y3 === node.nodeName) {
        if (found === false) {
          this.block = node.nodeName.toLowerCase();
          found = true;
        }
      } else if (found === false) {
        this.block = "default";
      }
    });
    found = false;
    if (this._customClasses) {
      this._customClasses.forEach((y3, index) => {
        const node = nodes.find((x4) => {
          if (x4 instanceof Element) {
            return x4.className === y3.class;
          }
        });
        if (node !== void 0) {
          if (found === false) {
            this.customClassId = index.toString();
            found = true;
          }
        } else if (found === false) {
          this.customClassId = "-1";
        }
      });
    }
    Object.keys(this.tagMap).map((e) => {
      const elementById = this.doc.getElementById(this.tagMap[e] + "-" + this.id);
      const node = nodes.find((x4) => x4.nodeName === e);
      if (node !== void 0 && e === node.nodeName) {
        this.r.addClass(elementById, "active");
      } else {
        this.r.removeClass(elementById, "active");
      }
    });
    this.foreColour = this.doc.queryCommandValue("ForeColor");
    this.fontSize = this.doc.queryCommandValue("FontSize");
    this.fontName = this.doc.queryCommandValue("FontName").replace(/"/g, "");
    this.backColor = this.doc.queryCommandValue("backColor");
  }
  /**
   * insert URL link
   */
  insertUrl() {
    let url = "https://";
    const selection2 = this.editorService.savedSelection;
    if (selection2 && selection2.commonAncestorContainer.parentElement.nodeName === "A") {
      const parent = selection2.commonAncestorContainer.parentElement;
      if (parent.href !== "") {
        url = parent.href;
      }
    }
    url = prompt("Insert URL link", url);
    if (url && url !== "" && url !== "https://") {
      this.editorService.createLink(url);
    }
  }
  /**
   * insert Video link
   */
  insertVideo() {
    this.execute.emit("");
    const url = prompt("Insert Video link", `https://`);
    if (url && url !== "" && url !== `https://`) {
      this.editorService.insertVideo(url);
    }
  }
  /** insert color */
  insertColor(color2, where) {
    this.editorService.insertColor(color2, where);
    this.execute.emit("");
  }
  /**
   * set font Name/family
   * @param foreColor string
   */
  setFontName(foreColor) {
    this.editorService.setFontName(foreColor);
    this.execute.emit("");
  }
  /**
   * set font Size
   * @param fontSize string
   */
  setFontSize(fontSize) {
    this.editorService.setFontSize(fontSize);
    this.execute.emit("");
  }
  /**
   * toggle editor mode (WYSIWYG or SOURCE)
   * @param m boolean
   */
  setEditorMode(m) {
    const toggleEditorModeButton = this.doc.getElementById("toggleEditorMode-" + this.id);
    if (m) {
      this.r.addClass(toggleEditorModeButton, "active");
    } else {
      this.r.removeClass(toggleEditorModeButton, "active");
    }
    this.htmlMode = m;
  }
  /**
   * Upload image when file is selected.
   */
  onFileChanged(event) {
    const file = event.target.files[0];
    if (file.type.includes("image/")) {
      if (this.upload) {
        this.upload(file).subscribe((response) => this.watchUploadImage(response, event));
      } else if (this.uploadUrl) {
        this.editorService.uploadImage(file).subscribe((response) => this.watchUploadImage(response, event));
      } else {
        const reader = new FileReader();
        reader.onload = (e) => {
          const fr = e.currentTarget;
          this.editorService.insertImage(fr.result.toString());
        };
        reader.readAsDataURL(file);
      }
    }
  }
  watchUploadImage(response, event) {
    const {
      imageUrl
    } = response.body;
    this.editorService.insertImage(imageUrl);
    event.srcElement.value = null;
  }
  /**
   * Set custom class
   */
  setCustomClass(classId) {
    if (classId === "-1") {
      this.execute.emit("clear");
    } else {
      this.editorService.createCustomClass(this._customClasses[+classId]);
    }
  }
  isButtonHidden(name) {
    if (!name) {
      return false;
    }
    if (!(this.hiddenButtons instanceof Array)) {
      return false;
    }
    let result;
    for (const arr of this.hiddenButtons) {
      if (arr instanceof Array) {
        result = arr.find((item) => item === name);
      }
      if (result) {
        break;
      }
    }
    return result !== void 0;
  }
  focus() {
    this.execute.emit("focus");
    console.log("focused");
  }
};
AngularEditorToolbarComponent.\u0275fac = function AngularEditorToolbarComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AngularEditorToolbarComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(AngularEditorService), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(DOCUMENT2));
};
AngularEditorToolbarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: AngularEditorToolbarComponent,
  selectors: [["angular-editor-toolbar"]],
  viewQuery: function AngularEditorToolbarComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c32, 7);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.myInputFile = _t.first);
    }
  },
  inputs: {
    id: "id",
    uploadUrl: "uploadUrl",
    upload: "upload",
    showToolbar: "showToolbar",
    fonts: "fonts",
    customClasses: "customClasses",
    defaultFontName: "defaultFontName",
    defaultFontSize: "defaultFontSize",
    hiddenButtons: "hiddenButtons"
  },
  outputs: {
    execute: "execute"
  },
  standalone: false,
  ngContentSelectors: _c4,
  decls: 1,
  vars: 1,
  consts: [["fgInput", ""], ["bgInput", ""], ["fileInput", ""], ["class", "angular-editor-toolbar", 4, "ngIf"], [1, "angular-editor-toolbar"], [1, "angular-editor-toolbar-set"], ["type", "button", "title", "Undo", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "hidden"], [1, "fa", "fa-undo"], ["type", "button", "title", "Redo", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "hidden"], [1, "fa", "fa-repeat"], ["type", "button", "title", "Bold", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-bold"], ["type", "button", "title", "Italic", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-italic"], ["type", "button", "title", "Underline", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-underline"], ["type", "button", "title", "Strikethrough", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-strikethrough"], ["type", "button", "title", "Subscript", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-subscript"], ["type", "button", "title", "Superscript", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-superscript"], ["type", "button", "title", "Justify Left", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-align-left"], ["type", "button", "title", "Justify Center", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-align-center"], ["type", "button", "title", "Justify Right", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-align-right"], ["type", "button", "title", "Justify Full", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-align-justify"], ["type", "button", "title", "Indent", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-indent"], ["type", "button", "title", "Outdent", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-outdent"], ["type", "button", "title", "Unordered List", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-list-ul"], ["type", "button", "title", "Ordered List", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-list-ol"], ["tabindex", "-1", 1, "select-heading", 3, "ngModelChange", "change", "options", "ngModel", "disabled", "hidden"], ["tabindex", "-1", 1, "select-font", 3, "ngModelChange", "change", "options", "ngModel", "disabled", "hidden"], ["tabindex", "-1", 1, "select-font-size", 3, "ngModelChange", "change", "options", "ngModel", "disabled", "hidden"], ["type", "color", 2, "display", "none", 3, "change"], ["type", "button", "title", "Text Color", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "color-label", "foreground"], [1, "fa", "fa-font"], ["type", "button", "title", "Background Color", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "color-label", "background"], ["class", "angular-editor-toolbar-set", 4, "ngIf"], ["type", "button", "title", "Insert Link", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-link"], ["type", "button", "title", "Unlink", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-chain-broken"], ["accept", "image/*", "type", "file", 2, "display", "none", 3, "change"], ["type", "button", "title", "Insert Image", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-image"], ["type", "button", "title", "Insert Video", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-video-camera"], ["type", "button", "title", "Horizontal Line", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-minus"], ["type", "button", "title", "Clear Formatting", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "disabled", "hidden"], [1, "fa", "fa-remove"], ["type", "button", "title", "HTML Code", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "id", "hidden"], [1, "fa", "fa-code"], ["tabindex", "-1", 1, "select-custom-style", 3, "ngModelChange", "change", "options", "ngModel", "disabled", "hidden"]],
  template: function AngularEditorToolbarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275template(0, AngularEditorToolbarComponent_div_0_Template, 76, 83, "div", 3);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.showToolbar);
    }
  },
  dependencies: [NgIf, NgControlStatus, NgModel, AeSelectComponent],
  styles: ['\n\n\n\n@font-face{font-family:FontAwesome;src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?v=4.7.0);src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?#iefix&v=4.7.0) format("embedded-opentype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff2?v=4.7.0) format("woff2"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff?v=4.7.0) format("woff"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.ttf?v=4.7.0) format("truetype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular) format("svg");font-weight:400;font-style:normal}.fa[_ngcontent-%COMP%]{display:inline-block;font: 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg[_ngcontent-%COMP%]{font-size:1.3333333333em;line-height:.75em;vertical-align:-15%}.fa-2x[_ngcontent-%COMP%]{font-size:2em}.fa-3x[_ngcontent-%COMP%]{font-size:3em}.fa-4x[_ngcontent-%COMP%]{font-size:4em}.fa-5x[_ngcontent-%COMP%]{font-size:5em}.fa-fw[_ngcontent-%COMP%]{width:1.2857142857em;text-align:center}.fa-ul[_ngcontent-%COMP%]{padding-left:0;margin-left:2.1428571429em;list-style-type:none}.fa-ul[_ngcontent-%COMP%] > li[_ngcontent-%COMP%]{position:relative}.fa-li[_ngcontent-%COMP%]{position:absolute;left:-2.1428571429em;width:2.1428571429em;top:.1428571429em;text-align:center}.fa-li.fa-lg[_ngcontent-%COMP%]{left:-1.8571428571em}.fa-border[_ngcontent-%COMP%]{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left[_ngcontent-%COMP%]{float:left}.fa-pull-right[_ngcontent-%COMP%]{float:right}.fa.fa-pull-left[_ngcontent-%COMP%]{margin-right:.3em}.fa.fa-pull-right[_ngcontent-%COMP%]{margin-left:.3em}.pull-right[_ngcontent-%COMP%]{float:right}.pull-left[_ngcontent-%COMP%]{float:left}.fa.pull-left[_ngcontent-%COMP%]{margin-right:.3em}.fa.pull-right[_ngcontent-%COMP%]{margin-left:.3em}.fa-spin[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_fa-spin 2s infinite linear}.fa-pulse[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_fa-spin 1s infinite steps(8)}@keyframes _ngcontent-%COMP%_fa-spin{0%{transform:rotate(0)}to{transform:rotate(359deg)}}.fa-rotate-90[_ngcontent-%COMP%]{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";transform:rotate(90deg)}.fa-rotate-180[_ngcontent-%COMP%]{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";transform:rotate(180deg)}.fa-rotate-270[_ngcontent-%COMP%]{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";transform:rotate(270deg)}.fa-flip-horizontal[_ngcontent-%COMP%]{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";transform:scaleX(-1)}.fa-flip-vertical[_ngcontent-%COMP%]{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";transform:scaleY(-1)}[_ngcontent-%COMP%]:root   .fa-rotate-90[_ngcontent-%COMP%], [_ngcontent-%COMP%]:root   .fa-rotate-180[_ngcontent-%COMP%], [_ngcontent-%COMP%]:root   .fa-rotate-270[_ngcontent-%COMP%], [_ngcontent-%COMP%]:root   .fa-flip-horizontal[_ngcontent-%COMP%], [_ngcontent-%COMP%]:root   .fa-flip-vertical[_ngcontent-%COMP%]{filter:none}.fa-stack[_ngcontent-%COMP%]{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x[_ngcontent-%COMP%], .fa-stack-2x[_ngcontent-%COMP%]{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x[_ngcontent-%COMP%]{line-height:inherit}.fa-stack-2x[_ngcontent-%COMP%]{font-size:2em}.fa-inverse[_ngcontent-%COMP%]{color:#fff}.fa-glass[_ngcontent-%COMP%]:before{content:"\\f000"}.fa-music[_ngcontent-%COMP%]:before{content:"\\f001"}.fa-search[_ngcontent-%COMP%]:before{content:"\\f002"}.fa-envelope-o[_ngcontent-%COMP%]:before{content:"\\f003"}.fa-heart[_ngcontent-%COMP%]:before{content:"\\f004"}.fa-star[_ngcontent-%COMP%]:before{content:"\\f005"}.fa-star-o[_ngcontent-%COMP%]:before{content:"\\f006"}.fa-user[_ngcontent-%COMP%]:before{content:"\\f007"}.fa-film[_ngcontent-%COMP%]:before{content:"\\f008"}.fa-th-large[_ngcontent-%COMP%]:before{content:"\\f009"}.fa-th[_ngcontent-%COMP%]:before{content:"\\f00a"}.fa-th-list[_ngcontent-%COMP%]:before{content:"\\f00b"}.fa-check[_ngcontent-%COMP%]:before{content:"\\f00c"}.fa-remove[_ngcontent-%COMP%]:before, .fa-close[_ngcontent-%COMP%]:before, .fa-times[_ngcontent-%COMP%]:before{content:"\\f00d"}.fa-search-plus[_ngcontent-%COMP%]:before{content:"\\f00e"}.fa-search-minus[_ngcontent-%COMP%]:before{content:"\\f010"}.fa-power-off[_ngcontent-%COMP%]:before{content:"\\f011"}.fa-signal[_ngcontent-%COMP%]:before{content:"\\f012"}.fa-gear[_ngcontent-%COMP%]:before, .fa-cog[_ngcontent-%COMP%]:before{content:"\\f013"}.fa-trash-o[_ngcontent-%COMP%]:before{content:"\\f014"}.fa-home[_ngcontent-%COMP%]:before{content:"\\f015"}.fa-file-o[_ngcontent-%COMP%]:before{content:"\\f016"}.fa-clock-o[_ngcontent-%COMP%]:before{content:"\\f017"}.fa-road[_ngcontent-%COMP%]:before{content:"\\f018"}.fa-download[_ngcontent-%COMP%]:before{content:"\\f019"}.fa-arrow-circle-o-down[_ngcontent-%COMP%]:before{content:"\\f01a"}.fa-arrow-circle-o-up[_ngcontent-%COMP%]:before{content:"\\f01b"}.fa-inbox[_ngcontent-%COMP%]:before{content:"\\f01c"}.fa-play-circle-o[_ngcontent-%COMP%]:before{content:"\\f01d"}.fa-rotate-right[_ngcontent-%COMP%]:before, .fa-repeat[_ngcontent-%COMP%]:before{content:"\\f01e"}.fa-refresh[_ngcontent-%COMP%]:before{content:"\\f021"}.fa-list-alt[_ngcontent-%COMP%]:before{content:"\\f022"}.fa-lock[_ngcontent-%COMP%]:before{content:"\\f023"}.fa-flag[_ngcontent-%COMP%]:before{content:"\\f024"}.fa-headphones[_ngcontent-%COMP%]:before{content:"\\f025"}.fa-volume-off[_ngcontent-%COMP%]:before{content:"\\f026"}.fa-volume-down[_ngcontent-%COMP%]:before{content:"\\f027"}.fa-volume-up[_ngcontent-%COMP%]:before{content:"\\f028"}.fa-qrcode[_ngcontent-%COMP%]:before{content:"\\f029"}.fa-barcode[_ngcontent-%COMP%]:before{content:"\\f02a"}.fa-tag[_ngcontent-%COMP%]:before{content:"\\f02b"}.fa-tags[_ngcontent-%COMP%]:before{content:"\\f02c"}.fa-book[_ngcontent-%COMP%]:before{content:"\\f02d"}.fa-bookmark[_ngcontent-%COMP%]:before{content:"\\f02e"}.fa-print[_ngcontent-%COMP%]:before{content:"\\f02f"}.fa-camera[_ngcontent-%COMP%]:before{content:"\\f030"}.fa-font[_ngcontent-%COMP%]:before{content:"\\f031"}.fa-bold[_ngcontent-%COMP%]:before{content:"\\f032"}.fa-italic[_ngcontent-%COMP%]:before{content:"\\f033"}.fa-text-height[_ngcontent-%COMP%]:before{content:"\\f034"}.fa-text-width[_ngcontent-%COMP%]:before{content:"\\f035"}.fa-align-left[_ngcontent-%COMP%]:before{content:"\\f036"}.fa-align-center[_ngcontent-%COMP%]:before{content:"\\f037"}.fa-align-right[_ngcontent-%COMP%]:before{content:"\\f038"}.fa-align-justify[_ngcontent-%COMP%]:before{content:"\\f039"}.fa-list[_ngcontent-%COMP%]:before{content:"\\f03a"}.fa-dedent[_ngcontent-%COMP%]:before, .fa-outdent[_ngcontent-%COMP%]:before{content:"\\f03b"}.fa-indent[_ngcontent-%COMP%]:before{content:"\\f03c"}.fa-video-camera[_ngcontent-%COMP%]:before{content:"\\f03d"}.fa-photo[_ngcontent-%COMP%]:before, .fa-image[_ngcontent-%COMP%]:before, .fa-picture-o[_ngcontent-%COMP%]:before{content:"\\f03e"}.fa-pencil[_ngcontent-%COMP%]:before{content:"\\f040"}.fa-map-marker[_ngcontent-%COMP%]:before{content:"\\f041"}.fa-adjust[_ngcontent-%COMP%]:before{content:"\\f042"}.fa-tint[_ngcontent-%COMP%]:before{content:"\\f043"}.fa-edit[_ngcontent-%COMP%]:before, .fa-pencil-square-o[_ngcontent-%COMP%]:before{content:"\\f044"}.fa-share-square-o[_ngcontent-%COMP%]:before{content:"\\f045"}.fa-check-square-o[_ngcontent-%COMP%]:before{content:"\\f046"}.fa-arrows[_ngcontent-%COMP%]:before{content:"\\f047"}.fa-step-backward[_ngcontent-%COMP%]:before{content:"\\f048"}.fa-fast-backward[_ngcontent-%COMP%]:before{content:"\\f049"}.fa-backward[_ngcontent-%COMP%]:before{content:"\\f04a"}.fa-play[_ngcontent-%COMP%]:before{content:"\\f04b"}.fa-pause[_ngcontent-%COMP%]:before{content:"\\f04c"}.fa-stop[_ngcontent-%COMP%]:before{content:"\\f04d"}.fa-forward[_ngcontent-%COMP%]:before{content:"\\f04e"}.fa-fast-forward[_ngcontent-%COMP%]:before{content:"\\f050"}.fa-step-forward[_ngcontent-%COMP%]:before{content:"\\f051"}.fa-eject[_ngcontent-%COMP%]:before{content:"\\f052"}.fa-chevron-left[_ngcontent-%COMP%]:before{content:"\\f053"}.fa-chevron-right[_ngcontent-%COMP%]:before{content:"\\f054"}.fa-plus-circle[_ngcontent-%COMP%]:before{content:"\\f055"}.fa-minus-circle[_ngcontent-%COMP%]:before{content:"\\f056"}.fa-times-circle[_ngcontent-%COMP%]:before{content:"\\f057"}.fa-check-circle[_ngcontent-%COMP%]:before{content:"\\f058"}.fa-question-circle[_ngcontent-%COMP%]:before{content:"\\f059"}.fa-info-circle[_ngcontent-%COMP%]:before{content:"\\f05a"}.fa-crosshairs[_ngcontent-%COMP%]:before{content:"\\f05b"}.fa-times-circle-o[_ngcontent-%COMP%]:before{content:"\\f05c"}.fa-check-circle-o[_ngcontent-%COMP%]:before{content:"\\f05d"}.fa-ban[_ngcontent-%COMP%]:before{content:"\\f05e"}.fa-arrow-left[_ngcontent-%COMP%]:before{content:"\\f060"}.fa-arrow-right[_ngcontent-%COMP%]:before{content:"\\f061"}.fa-arrow-up[_ngcontent-%COMP%]:before{content:"\\f062"}.fa-arrow-down[_ngcontent-%COMP%]:before{content:"\\f063"}.fa-mail-forward[_ngcontent-%COMP%]:before, .fa-share[_ngcontent-%COMP%]:before{content:"\\f064"}.fa-expand[_ngcontent-%COMP%]:before{content:"\\f065"}.fa-compress[_ngcontent-%COMP%]:before{content:"\\f066"}.fa-plus[_ngcontent-%COMP%]:before{content:"\\f067"}.fa-minus[_ngcontent-%COMP%]:before{content:"\\f068"}.fa-asterisk[_ngcontent-%COMP%]:before{content:"\\f069"}.fa-exclamation-circle[_ngcontent-%COMP%]:before{content:"\\f06a"}.fa-gift[_ngcontent-%COMP%]:before{content:"\\f06b"}.fa-leaf[_ngcontent-%COMP%]:before{content:"\\f06c"}.fa-fire[_ngcontent-%COMP%]:before{content:"\\f06d"}.fa-eye[_ngcontent-%COMP%]:before{content:"\\f06e"}.fa-eye-slash[_ngcontent-%COMP%]:before{content:"\\f070"}.fa-warning[_ngcontent-%COMP%]:before, .fa-exclamation-triangle[_ngcontent-%COMP%]:before{content:"\\f071"}.fa-plane[_ngcontent-%COMP%]:before{content:"\\f072"}.fa-calendar[_ngcontent-%COMP%]:before{content:"\\f073"}.fa-random[_ngcontent-%COMP%]:before{content:"\\f074"}.fa-comment[_ngcontent-%COMP%]:before{content:"\\f075"}.fa-magnet[_ngcontent-%COMP%]:before{content:"\\f076"}.fa-chevron-up[_ngcontent-%COMP%]:before{content:"\\f077"}.fa-chevron-down[_ngcontent-%COMP%]:before{content:"\\f078"}.fa-retweet[_ngcontent-%COMP%]:before{content:"\\f079"}.fa-shopping-cart[_ngcontent-%COMP%]:before{content:"\\f07a"}.fa-folder[_ngcontent-%COMP%]:before{content:"\\f07b"}.fa-folder-open[_ngcontent-%COMP%]:before{content:"\\f07c"}.fa-arrows-v[_ngcontent-%COMP%]:before{content:"\\f07d"}.fa-arrows-h[_ngcontent-%COMP%]:before{content:"\\f07e"}.fa-bar-chart-o[_ngcontent-%COMP%]:before, .fa-bar-chart[_ngcontent-%COMP%]:before{content:"\\f080"}.fa-twitter-square[_ngcontent-%COMP%]:before{content:"\\f081"}.fa-facebook-square[_ngcontent-%COMP%]:before{content:"\\f082"}.fa-camera-retro[_ngcontent-%COMP%]:before{content:"\\f083"}.fa-key[_ngcontent-%COMP%]:before{content:"\\f084"}.fa-gears[_ngcontent-%COMP%]:before, .fa-cogs[_ngcontent-%COMP%]:before{content:"\\f085"}.fa-comments[_ngcontent-%COMP%]:before{content:"\\f086"}.fa-thumbs-o-up[_ngcontent-%COMP%]:before{content:"\\f087"}.fa-thumbs-o-down[_ngcontent-%COMP%]:before{content:"\\f088"}.fa-star-half[_ngcontent-%COMP%]:before{content:"\\f089"}.fa-heart-o[_ngcontent-%COMP%]:before{content:"\\f08a"}.fa-sign-out[_ngcontent-%COMP%]:before{content:"\\f08b"}.fa-linkedin-square[_ngcontent-%COMP%]:before{content:"\\f08c"}.fa-thumb-tack[_ngcontent-%COMP%]:before{content:"\\f08d"}.fa-external-link[_ngcontent-%COMP%]:before{content:"\\f08e"}.fa-sign-in[_ngcontent-%COMP%]:before{content:"\\f090"}.fa-trophy[_ngcontent-%COMP%]:before{content:"\\f091"}.fa-github-square[_ngcontent-%COMP%]:before{content:"\\f092"}.fa-upload[_ngcontent-%COMP%]:before{content:"\\f093"}.fa-lemon-o[_ngcontent-%COMP%]:before{content:"\\f094"}.fa-phone[_ngcontent-%COMP%]:before{content:"\\f095"}.fa-square-o[_ngcontent-%COMP%]:before{content:"\\f096"}.fa-bookmark-o[_ngcontent-%COMP%]:before{content:"\\f097"}.fa-phone-square[_ngcontent-%COMP%]:before{content:"\\f098"}.fa-twitter[_ngcontent-%COMP%]:before{content:"\\f099"}.fa-facebook-f[_ngcontent-%COMP%]:before, .fa-facebook[_ngcontent-%COMP%]:before{content:"\\f09a"}.fa-github[_ngcontent-%COMP%]:before{content:"\\f09b"}.fa-unlock[_ngcontent-%COMP%]:before{content:"\\f09c"}.fa-credit-card[_ngcontent-%COMP%]:before{content:"\\f09d"}.fa-feed[_ngcontent-%COMP%]:before, .fa-rss[_ngcontent-%COMP%]:before{content:"\\f09e"}.fa-hdd-o[_ngcontent-%COMP%]:before{content:"\\f0a0"}.fa-bullhorn[_ngcontent-%COMP%]:before{content:"\\f0a1"}.fa-bell[_ngcontent-%COMP%]:before{content:"\\f0f3"}.fa-certificate[_ngcontent-%COMP%]:before{content:"\\f0a3"}.fa-hand-o-right[_ngcontent-%COMP%]:before{content:"\\f0a4"}.fa-hand-o-left[_ngcontent-%COMP%]:before{content:"\\f0a5"}.fa-hand-o-up[_ngcontent-%COMP%]:before{content:"\\f0a6"}.fa-hand-o-down[_ngcontent-%COMP%]:before{content:"\\f0a7"}.fa-arrow-circle-left[_ngcontent-%COMP%]:before{content:"\\f0a8"}.fa-arrow-circle-right[_ngcontent-%COMP%]:before{content:"\\f0a9"}.fa-arrow-circle-up[_ngcontent-%COMP%]:before{content:"\\f0aa"}.fa-arrow-circle-down[_ngcontent-%COMP%]:before{content:"\\f0ab"}.fa-globe[_ngcontent-%COMP%]:before{content:"\\f0ac"}.fa-wrench[_ngcontent-%COMP%]:before{content:"\\f0ad"}.fa-tasks[_ngcontent-%COMP%]:before{content:"\\f0ae"}.fa-filter[_ngcontent-%COMP%]:before{content:"\\f0b0"}.fa-briefcase[_ngcontent-%COMP%]:before{content:"\\f0b1"}.fa-arrows-alt[_ngcontent-%COMP%]:before{content:"\\f0b2"}.fa-group[_ngcontent-%COMP%]:before, .fa-users[_ngcontent-%COMP%]:before{content:"\\f0c0"}.fa-chain[_ngcontent-%COMP%]:before, .fa-link[_ngcontent-%COMP%]:before{content:"\\f0c1"}.fa-cloud[_ngcontent-%COMP%]:before{content:"\\f0c2"}.fa-flask[_ngcontent-%COMP%]:before{content:"\\f0c3"}.fa-cut[_ngcontent-%COMP%]:before, .fa-scissors[_ngcontent-%COMP%]:before{content:"\\f0c4"}.fa-copy[_ngcontent-%COMP%]:before, .fa-files-o[_ngcontent-%COMP%]:before{content:"\\f0c5"}.fa-paperclip[_ngcontent-%COMP%]:before{content:"\\f0c6"}.fa-save[_ngcontent-%COMP%]:before, .fa-floppy-o[_ngcontent-%COMP%]:before{content:"\\f0c7"}.fa-square[_ngcontent-%COMP%]:before{content:"\\f0c8"}.fa-navicon[_ngcontent-%COMP%]:before, .fa-reorder[_ngcontent-%COMP%]:before, .fa-bars[_ngcontent-%COMP%]:before{content:"\\f0c9"}.fa-list-ul[_ngcontent-%COMP%]:before{content:"\\f0ca"}.fa-list-ol[_ngcontent-%COMP%]:before{content:"\\f0cb"}.fa-strikethrough[_ngcontent-%COMP%]:before{content:"\\f0cc"}.fa-underline[_ngcontent-%COMP%]:before{content:"\\f0cd"}.fa-table[_ngcontent-%COMP%]:before{content:"\\f0ce"}.fa-magic[_ngcontent-%COMP%]:before{content:"\\f0d0"}.fa-truck[_ngcontent-%COMP%]:before{content:"\\f0d1"}.fa-pinterest[_ngcontent-%COMP%]:before{content:"\\f0d2"}.fa-pinterest-square[_ngcontent-%COMP%]:before{content:"\\f0d3"}.fa-google-plus-square[_ngcontent-%COMP%]:before{content:"\\f0d4"}.fa-google-plus[_ngcontent-%COMP%]:before{content:"\\f0d5"}.fa-money[_ngcontent-%COMP%]:before{content:"\\f0d6"}.fa-caret-down[_ngcontent-%COMP%]:before{content:"\\f0d7"}.fa-caret-up[_ngcontent-%COMP%]:before{content:"\\f0d8"}.fa-caret-left[_ngcontent-%COMP%]:before{content:"\\f0d9"}.fa-caret-right[_ngcontent-%COMP%]:before{content:"\\f0da"}.fa-columns[_ngcontent-%COMP%]:before{content:"\\f0db"}.fa-unsorted[_ngcontent-%COMP%]:before, .fa-sort[_ngcontent-%COMP%]:before{content:"\\f0dc"}.fa-sort-down[_ngcontent-%COMP%]:before, .fa-sort-desc[_ngcontent-%COMP%]:before{content:"\\f0dd"}.fa-sort-up[_ngcontent-%COMP%]:before, .fa-sort-asc[_ngcontent-%COMP%]:before{content:"\\f0de"}.fa-envelope[_ngcontent-%COMP%]:before{content:"\\f0e0"}.fa-linkedin[_ngcontent-%COMP%]:before{content:"\\f0e1"}.fa-rotate-left[_ngcontent-%COMP%]:before, .fa-undo[_ngcontent-%COMP%]:before{content:"\\f0e2"}.fa-legal[_ngcontent-%COMP%]:before, .fa-gavel[_ngcontent-%COMP%]:before{content:"\\f0e3"}.fa-dashboard[_ngcontent-%COMP%]:before, .fa-tachometer[_ngcontent-%COMP%]:before{content:"\\f0e4"}.fa-comment-o[_ngcontent-%COMP%]:before{content:"\\f0e5"}.fa-comments-o[_ngcontent-%COMP%]:before{content:"\\f0e6"}.fa-flash[_ngcontent-%COMP%]:before, .fa-bolt[_ngcontent-%COMP%]:before{content:"\\f0e7"}.fa-sitemap[_ngcontent-%COMP%]:before{content:"\\f0e8"}.fa-umbrella[_ngcontent-%COMP%]:before{content:"\\f0e9"}.fa-paste[_ngcontent-%COMP%]:before, .fa-clipboard[_ngcontent-%COMP%]:before{content:"\\f0ea"}.fa-lightbulb-o[_ngcontent-%COMP%]:before{content:"\\f0eb"}.fa-exchange[_ngcontent-%COMP%]:before{content:"\\f0ec"}.fa-cloud-download[_ngcontent-%COMP%]:before{content:"\\f0ed"}.fa-cloud-upload[_ngcontent-%COMP%]:before{content:"\\f0ee"}.fa-user-md[_ngcontent-%COMP%]:before{content:"\\f0f0"}.fa-stethoscope[_ngcontent-%COMP%]:before{content:"\\f0f1"}.fa-suitcase[_ngcontent-%COMP%]:before{content:"\\f0f2"}.fa-bell-o[_ngcontent-%COMP%]:before{content:"\\f0a2"}.fa-coffee[_ngcontent-%COMP%]:before{content:"\\f0f4"}.fa-cutlery[_ngcontent-%COMP%]:before{content:"\\f0f5"}.fa-file-text-o[_ngcontent-%COMP%]:before{content:"\\f0f6"}.fa-building-o[_ngcontent-%COMP%]:before{content:"\\f0f7"}.fa-hospital-o[_ngcontent-%COMP%]:before{content:"\\f0f8"}.fa-ambulance[_ngcontent-%COMP%]:before{content:"\\f0f9"}.fa-medkit[_ngcontent-%COMP%]:before{content:"\\f0fa"}.fa-fighter-jet[_ngcontent-%COMP%]:before{content:"\\f0fb"}.fa-beer[_ngcontent-%COMP%]:before{content:"\\f0fc"}.fa-h-square[_ngcontent-%COMP%]:before{content:"\\f0fd"}.fa-plus-square[_ngcontent-%COMP%]:before{content:"\\f0fe"}.fa-angle-double-left[_ngcontent-%COMP%]:before{content:"\\f100"}.fa-angle-double-right[_ngcontent-%COMP%]:before{content:"\\f101"}.fa-angle-double-up[_ngcontent-%COMP%]:before{content:"\\f102"}.fa-angle-double-down[_ngcontent-%COMP%]:before{content:"\\f103"}.fa-angle-left[_ngcontent-%COMP%]:before{content:"\\f104"}.fa-angle-right[_ngcontent-%COMP%]:before{content:"\\f105"}.fa-angle-up[_ngcontent-%COMP%]:before{content:"\\f106"}.fa-angle-down[_ngcontent-%COMP%]:before{content:"\\f107"}.fa-desktop[_ngcontent-%COMP%]:before{content:"\\f108"}.fa-laptop[_ngcontent-%COMP%]:before{content:"\\f109"}.fa-tablet[_ngcontent-%COMP%]:before{content:"\\f10a"}.fa-mobile-phone[_ngcontent-%COMP%]:before, .fa-mobile[_ngcontent-%COMP%]:before{content:"\\f10b"}.fa-circle-o[_ngcontent-%COMP%]:before{content:"\\f10c"}.fa-quote-left[_ngcontent-%COMP%]:before{content:"\\f10d"}.fa-quote-right[_ngcontent-%COMP%]:before{content:"\\f10e"}.fa-spinner[_ngcontent-%COMP%]:before{content:"\\f110"}.fa-circle[_ngcontent-%COMP%]:before{content:"\\f111"}.fa-mail-reply[_ngcontent-%COMP%]:before, .fa-reply[_ngcontent-%COMP%]:before{content:"\\f112"}.fa-github-alt[_ngcontent-%COMP%]:before{content:"\\f113"}.fa-folder-o[_ngcontent-%COMP%]:before{content:"\\f114"}.fa-folder-open-o[_ngcontent-%COMP%]:before{content:"\\f115"}.fa-smile-o[_ngcontent-%COMP%]:before{content:"\\f118"}.fa-frown-o[_ngcontent-%COMP%]:before{content:"\\f119"}.fa-meh-o[_ngcontent-%COMP%]:before{content:"\\f11a"}.fa-gamepad[_ngcontent-%COMP%]:before{content:"\\f11b"}.fa-keyboard-o[_ngcontent-%COMP%]:before{content:"\\f11c"}.fa-flag-o[_ngcontent-%COMP%]:before{content:"\\f11d"}.fa-flag-checkered[_ngcontent-%COMP%]:before{content:"\\f11e"}.fa-terminal[_ngcontent-%COMP%]:before{content:"\\f120"}.fa-code[_ngcontent-%COMP%]:before{content:"\\f121"}.fa-mail-reply-all[_ngcontent-%COMP%]:before, .fa-reply-all[_ngcontent-%COMP%]:before{content:"\\f122"}.fa-star-half-empty[_ngcontent-%COMP%]:before, .fa-star-half-full[_ngcontent-%COMP%]:before, .fa-star-half-o[_ngcontent-%COMP%]:before{content:"\\f123"}.fa-location-arrow[_ngcontent-%COMP%]:before{content:"\\f124"}.fa-crop[_ngcontent-%COMP%]:before{content:"\\f125"}.fa-code-fork[_ngcontent-%COMP%]:before{content:"\\f126"}.fa-unlink[_ngcontent-%COMP%]:before, .fa-chain-broken[_ngcontent-%COMP%]:before{content:"\\f127"}.fa-question[_ngcontent-%COMP%]:before{content:"\\f128"}.fa-info[_ngcontent-%COMP%]:before{content:"\\f129"}.fa-exclamation[_ngcontent-%COMP%]:before{content:"\\f12a"}.fa-superscript[_ngcontent-%COMP%]:before{content:"\\f12b"}.fa-subscript[_ngcontent-%COMP%]:before{content:"\\f12c"}.fa-eraser[_ngcontent-%COMP%]:before{content:"\\f12d"}.fa-puzzle-piece[_ngcontent-%COMP%]:before{content:"\\f12e"}.fa-microphone[_ngcontent-%COMP%]:before{content:"\\f130"}.fa-microphone-slash[_ngcontent-%COMP%]:before{content:"\\f131"}.fa-shield[_ngcontent-%COMP%]:before{content:"\\f132"}.fa-calendar-o[_ngcontent-%COMP%]:before{content:"\\f133"}.fa-fire-extinguisher[_ngcontent-%COMP%]:before{content:"\\f134"}.fa-rocket[_ngcontent-%COMP%]:before{content:"\\f135"}.fa-maxcdn[_ngcontent-%COMP%]:before{content:"\\f136"}.fa-chevron-circle-left[_ngcontent-%COMP%]:before{content:"\\f137"}.fa-chevron-circle-right[_ngcontent-%COMP%]:before{content:"\\f138"}.fa-chevron-circle-up[_ngcontent-%COMP%]:before{content:"\\f139"}.fa-chevron-circle-down[_ngcontent-%COMP%]:before{content:"\\f13a"}.fa-html5[_ngcontent-%COMP%]:before{content:"\\f13b"}.fa-css3[_ngcontent-%COMP%]:before{content:"\\f13c"}.fa-anchor[_ngcontent-%COMP%]:before{content:"\\f13d"}.fa-unlock-alt[_ngcontent-%COMP%]:before{content:"\\f13e"}.fa-bullseye[_ngcontent-%COMP%]:before{content:"\\f140"}.fa-ellipsis-h[_ngcontent-%COMP%]:before{content:"\\f141"}.fa-ellipsis-v[_ngcontent-%COMP%]:before{content:"\\f142"}.fa-rss-square[_ngcontent-%COMP%]:before{content:"\\f143"}.fa-play-circle[_ngcontent-%COMP%]:before{content:"\\f144"}.fa-ticket[_ngcontent-%COMP%]:before{content:"\\f145"}.fa-minus-square[_ngcontent-%COMP%]:before{content:"\\f146"}.fa-minus-square-o[_ngcontent-%COMP%]:before{content:"\\f147"}.fa-level-up[_ngcontent-%COMP%]:before{content:"\\f148"}.fa-level-down[_ngcontent-%COMP%]:before{content:"\\f149"}.fa-check-square[_ngcontent-%COMP%]:before{content:"\\f14a"}.fa-pencil-square[_ngcontent-%COMP%]:before{content:"\\f14b"}.fa-external-link-square[_ngcontent-%COMP%]:before{content:"\\f14c"}.fa-share-square[_ngcontent-%COMP%]:before{content:"\\f14d"}.fa-compass[_ngcontent-%COMP%]:before{content:"\\f14e"}.fa-toggle-down[_ngcontent-%COMP%]:before, .fa-caret-square-o-down[_ngcontent-%COMP%]:before{content:"\\f150"}.fa-toggle-up[_ngcontent-%COMP%]:before, .fa-caret-square-o-up[_ngcontent-%COMP%]:before{content:"\\f151"}.fa-toggle-right[_ngcontent-%COMP%]:before, .fa-caret-square-o-right[_ngcontent-%COMP%]:before{content:"\\f152"}.fa-euro[_ngcontent-%COMP%]:before, .fa-eur[_ngcontent-%COMP%]:before{content:"\\f153"}.fa-gbp[_ngcontent-%COMP%]:before{content:"\\f154"}.fa-dollar[_ngcontent-%COMP%]:before, .fa-usd[_ngcontent-%COMP%]:before{content:"\\f155"}.fa-rupee[_ngcontent-%COMP%]:before, .fa-inr[_ngcontent-%COMP%]:before{content:"\\f156"}.fa-cny[_ngcontent-%COMP%]:before, .fa-rmb[_ngcontent-%COMP%]:before, .fa-yen[_ngcontent-%COMP%]:before, .fa-jpy[_ngcontent-%COMP%]:before{content:"\\f157"}.fa-ruble[_ngcontent-%COMP%]:before, .fa-rouble[_ngcontent-%COMP%]:before, .fa-rub[_ngcontent-%COMP%]:before{content:"\\f158"}.fa-won[_ngcontent-%COMP%]:before, .fa-krw[_ngcontent-%COMP%]:before{content:"\\f159"}.fa-bitcoin[_ngcontent-%COMP%]:before, .fa-btc[_ngcontent-%COMP%]:before{content:"\\f15a"}.fa-file[_ngcontent-%COMP%]:before{content:"\\f15b"}.fa-file-text[_ngcontent-%COMP%]:before{content:"\\f15c"}.fa-sort-alpha-asc[_ngcontent-%COMP%]:before{content:"\\f15d"}.fa-sort-alpha-desc[_ngcontent-%COMP%]:before{content:"\\f15e"}.fa-sort-amount-asc[_ngcontent-%COMP%]:before{content:"\\f160"}.fa-sort-amount-desc[_ngcontent-%COMP%]:before{content:"\\f161"}.fa-sort-numeric-asc[_ngcontent-%COMP%]:before{content:"\\f162"}.fa-sort-numeric-desc[_ngcontent-%COMP%]:before{content:"\\f163"}.fa-thumbs-up[_ngcontent-%COMP%]:before{content:"\\f164"}.fa-thumbs-down[_ngcontent-%COMP%]:before{content:"\\f165"}.fa-youtube-square[_ngcontent-%COMP%]:before{content:"\\f166"}.fa-youtube[_ngcontent-%COMP%]:before{content:"\\f167"}.fa-xing[_ngcontent-%COMP%]:before{content:"\\f168"}.fa-xing-square[_ngcontent-%COMP%]:before{content:"\\f169"}.fa-youtube-play[_ngcontent-%COMP%]:before{content:"\\f16a"}.fa-dropbox[_ngcontent-%COMP%]:before{content:"\\f16b"}.fa-stack-overflow[_ngcontent-%COMP%]:before{content:"\\f16c"}.fa-instagram[_ngcontent-%COMP%]:before{content:"\\f16d"}.fa-flickr[_ngcontent-%COMP%]:before{content:"\\f16e"}.fa-adn[_ngcontent-%COMP%]:before{content:"\\f170"}.fa-bitbucket[_ngcontent-%COMP%]:before{content:"\\f171"}.fa-bitbucket-square[_ngcontent-%COMP%]:before{content:"\\f172"}.fa-tumblr[_ngcontent-%COMP%]:before{content:"\\f173"}.fa-tumblr-square[_ngcontent-%COMP%]:before{content:"\\f174"}.fa-long-arrow-down[_ngcontent-%COMP%]:before{content:"\\f175"}.fa-long-arrow-up[_ngcontent-%COMP%]:before{content:"\\f176"}.fa-long-arrow-left[_ngcontent-%COMP%]:before{content:"\\f177"}.fa-long-arrow-right[_ngcontent-%COMP%]:before{content:"\\f178"}.fa-apple[_ngcontent-%COMP%]:before{content:"\\f179"}.fa-windows[_ngcontent-%COMP%]:before{content:"\\f17a"}.fa-android[_ngcontent-%COMP%]:before{content:"\\f17b"}.fa-linux[_ngcontent-%COMP%]:before{content:"\\f17c"}.fa-dribbble[_ngcontent-%COMP%]:before{content:"\\f17d"}.fa-skype[_ngcontent-%COMP%]:before{content:"\\f17e"}.fa-foursquare[_ngcontent-%COMP%]:before{content:"\\f180"}.fa-trello[_ngcontent-%COMP%]:before{content:"\\f181"}.fa-female[_ngcontent-%COMP%]:before{content:"\\f182"}.fa-male[_ngcontent-%COMP%]:before{content:"\\f183"}.fa-gittip[_ngcontent-%COMP%]:before, .fa-gratipay[_ngcontent-%COMP%]:before{content:"\\f184"}.fa-sun-o[_ngcontent-%COMP%]:before{content:"\\f185"}.fa-moon-o[_ngcontent-%COMP%]:before{content:"\\f186"}.fa-archive[_ngcontent-%COMP%]:before{content:"\\f187"}.fa-bug[_ngcontent-%COMP%]:before{content:"\\f188"}.fa-vk[_ngcontent-%COMP%]:before{content:"\\f189"}.fa-weibo[_ngcontent-%COMP%]:before{content:"\\f18a"}.fa-renren[_ngcontent-%COMP%]:before{content:"\\f18b"}.fa-pagelines[_ngcontent-%COMP%]:before{content:"\\f18c"}.fa-stack-exchange[_ngcontent-%COMP%]:before{content:"\\f18d"}.fa-arrow-circle-o-right[_ngcontent-%COMP%]:before{content:"\\f18e"}.fa-arrow-circle-o-left[_ngcontent-%COMP%]:before{content:"\\f190"}.fa-toggle-left[_ngcontent-%COMP%]:before, .fa-caret-square-o-left[_ngcontent-%COMP%]:before{content:"\\f191"}.fa-dot-circle-o[_ngcontent-%COMP%]:before{content:"\\f192"}.fa-wheelchair[_ngcontent-%COMP%]:before{content:"\\f193"}.fa-vimeo-square[_ngcontent-%COMP%]:before{content:"\\f194"}.fa-turkish-lira[_ngcontent-%COMP%]:before, .fa-try[_ngcontent-%COMP%]:before{content:"\\f195"}.fa-plus-square-o[_ngcontent-%COMP%]:before{content:"\\f196"}.fa-space-shuttle[_ngcontent-%COMP%]:before{content:"\\f197"}.fa-slack[_ngcontent-%COMP%]:before{content:"\\f198"}.fa-envelope-square[_ngcontent-%COMP%]:before{content:"\\f199"}.fa-wordpress[_ngcontent-%COMP%]:before{content:"\\f19a"}.fa-openid[_ngcontent-%COMP%]:before{content:"\\f19b"}.fa-institution[_ngcontent-%COMP%]:before, .fa-bank[_ngcontent-%COMP%]:before, .fa-university[_ngcontent-%COMP%]:before{content:"\\f19c"}.fa-mortar-board[_ngcontent-%COMP%]:before, .fa-graduation-cap[_ngcontent-%COMP%]:before{content:"\\f19d"}.fa-yahoo[_ngcontent-%COMP%]:before{content:"\\f19e"}.fa-google[_ngcontent-%COMP%]:before{content:"\\f1a0"}.fa-reddit[_ngcontent-%COMP%]:before{content:"\\f1a1"}.fa-reddit-square[_ngcontent-%COMP%]:before{content:"\\f1a2"}.fa-stumbleupon-circle[_ngcontent-%COMP%]:before{content:"\\f1a3"}.fa-stumbleupon[_ngcontent-%COMP%]:before{content:"\\f1a4"}.fa-delicious[_ngcontent-%COMP%]:before{content:"\\f1a5"}.fa-digg[_ngcontent-%COMP%]:before{content:"\\f1a6"}.fa-pied-piper-pp[_ngcontent-%COMP%]:before{content:"\\f1a7"}.fa-pied-piper-alt[_ngcontent-%COMP%]:before{content:"\\f1a8"}.fa-drupal[_ngcontent-%COMP%]:before{content:"\\f1a9"}.fa-joomla[_ngcontent-%COMP%]:before{content:"\\f1aa"}.fa-language[_ngcontent-%COMP%]:before{content:"\\f1ab"}.fa-fax[_ngcontent-%COMP%]:before{content:"\\f1ac"}.fa-building[_ngcontent-%COMP%]:before{content:"\\f1ad"}.fa-child[_ngcontent-%COMP%]:before{content:"\\f1ae"}.fa-paw[_ngcontent-%COMP%]:before{content:"\\f1b0"}.fa-spoon[_ngcontent-%COMP%]:before{content:"\\f1b1"}.fa-cube[_ngcontent-%COMP%]:before{content:"\\f1b2"}.fa-cubes[_ngcontent-%COMP%]:before{content:"\\f1b3"}.fa-behance[_ngcontent-%COMP%]:before{content:"\\f1b4"}.fa-behance-square[_ngcontent-%COMP%]:before{content:"\\f1b5"}.fa-steam[_ngcontent-%COMP%]:before{content:"\\f1b6"}.fa-steam-square[_ngcontent-%COMP%]:before{content:"\\f1b7"}.fa-recycle[_ngcontent-%COMP%]:before{content:"\\f1b8"}.fa-automobile[_ngcontent-%COMP%]:before, .fa-car[_ngcontent-%COMP%]:before{content:"\\f1b9"}.fa-cab[_ngcontent-%COMP%]:before, .fa-taxi[_ngcontent-%COMP%]:before{content:"\\f1ba"}.fa-tree[_ngcontent-%COMP%]:before{content:"\\f1bb"}.fa-spotify[_ngcontent-%COMP%]:before{content:"\\f1bc"}.fa-deviantart[_ngcontent-%COMP%]:before{content:"\\f1bd"}.fa-soundcloud[_ngcontent-%COMP%]:before{content:"\\f1be"}.fa-database[_ngcontent-%COMP%]:before{content:"\\f1c0"}.fa-file-pdf-o[_ngcontent-%COMP%]:before{content:"\\f1c1"}.fa-file-word-o[_ngcontent-%COMP%]:before{content:"\\f1c2"}.fa-file-excel-o[_ngcontent-%COMP%]:before{content:"\\f1c3"}.fa-file-powerpoint-o[_ngcontent-%COMP%]:before{content:"\\f1c4"}.fa-file-photo-o[_ngcontent-%COMP%]:before, .fa-file-picture-o[_ngcontent-%COMP%]:before, .fa-file-image-o[_ngcontent-%COMP%]:before{content:"\\f1c5"}.fa-file-zip-o[_ngcontent-%COMP%]:before, .fa-file-archive-o[_ngcontent-%COMP%]:before{content:"\\f1c6"}.fa-file-sound-o[_ngcontent-%COMP%]:before, .fa-file-audio-o[_ngcontent-%COMP%]:before{content:"\\f1c7"}.fa-file-movie-o[_ngcontent-%COMP%]:before, .fa-file-video-o[_ngcontent-%COMP%]:before{content:"\\f1c8"}.fa-file-code-o[_ngcontent-%COMP%]:before{content:"\\f1c9"}.fa-vine[_ngcontent-%COMP%]:before{content:"\\f1ca"}.fa-codepen[_ngcontent-%COMP%]:before{content:"\\f1cb"}.fa-jsfiddle[_ngcontent-%COMP%]:before{content:"\\f1cc"}.fa-life-bouy[_ngcontent-%COMP%]:before, .fa-life-buoy[_ngcontent-%COMP%]:before, .fa-life-saver[_ngcontent-%COMP%]:before, .fa-support[_ngcontent-%COMP%]:before, .fa-life-ring[_ngcontent-%COMP%]:before{content:"\\f1cd"}.fa-circle-o-notch[_ngcontent-%COMP%]:before{content:"\\f1ce"}.fa-ra[_ngcontent-%COMP%]:before, .fa-resistance[_ngcontent-%COMP%]:before, .fa-rebel[_ngcontent-%COMP%]:before{content:"\\f1d0"}.fa-ge[_ngcontent-%COMP%]:before, .fa-empire[_ngcontent-%COMP%]:before{content:"\\f1d1"}.fa-git-square[_ngcontent-%COMP%]:before{content:"\\f1d2"}.fa-git[_ngcontent-%COMP%]:before{content:"\\f1d3"}.fa-y-combinator-square[_ngcontent-%COMP%]:before, .fa-yc-square[_ngcontent-%COMP%]:before, .fa-hacker-news[_ngcontent-%COMP%]:before{content:"\\f1d4"}.fa-tencent-weibo[_ngcontent-%COMP%]:before{content:"\\f1d5"}.fa-qq[_ngcontent-%COMP%]:before{content:"\\f1d6"}.fa-wechat[_ngcontent-%COMP%]:before, .fa-weixin[_ngcontent-%COMP%]:before{content:"\\f1d7"}.fa-send[_ngcontent-%COMP%]:before, .fa-paper-plane[_ngcontent-%COMP%]:before{content:"\\f1d8"}.fa-send-o[_ngcontent-%COMP%]:before, .fa-paper-plane-o[_ngcontent-%COMP%]:before{content:"\\f1d9"}.fa-history[_ngcontent-%COMP%]:before{content:"\\f1da"}.fa-circle-thin[_ngcontent-%COMP%]:before{content:"\\f1db"}.fa-header[_ngcontent-%COMP%]:before{content:"\\f1dc"}.fa-paragraph[_ngcontent-%COMP%]:before{content:"\\f1dd"}.fa-sliders[_ngcontent-%COMP%]:before{content:"\\f1de"}.fa-share-alt[_ngcontent-%COMP%]:before{content:"\\f1e0"}.fa-share-alt-square[_ngcontent-%COMP%]:before{content:"\\f1e1"}.fa-bomb[_ngcontent-%COMP%]:before{content:"\\f1e2"}.fa-soccer-ball-o[_ngcontent-%COMP%]:before, .fa-futbol-o[_ngcontent-%COMP%]:before{content:"\\f1e3"}.fa-tty[_ngcontent-%COMP%]:before{content:"\\f1e4"}.fa-binoculars[_ngcontent-%COMP%]:before{content:"\\f1e5"}.fa-plug[_ngcontent-%COMP%]:before{content:"\\f1e6"}.fa-slideshare[_ngcontent-%COMP%]:before{content:"\\f1e7"}.fa-twitch[_ngcontent-%COMP%]:before{content:"\\f1e8"}.fa-yelp[_ngcontent-%COMP%]:before{content:"\\f1e9"}.fa-newspaper-o[_ngcontent-%COMP%]:before{content:"\\f1ea"}.fa-wifi[_ngcontent-%COMP%]:before{content:"\\f1eb"}.fa-calculator[_ngcontent-%COMP%]:before{content:"\\f1ec"}.fa-paypal[_ngcontent-%COMP%]:before{content:"\\f1ed"}.fa-google-wallet[_ngcontent-%COMP%]:before{content:"\\f1ee"}.fa-cc-visa[_ngcontent-%COMP%]:before{content:"\\f1f0"}.fa-cc-mastercard[_ngcontent-%COMP%]:before{content:"\\f1f1"}.fa-cc-discover[_ngcontent-%COMP%]:before{content:"\\f1f2"}.fa-cc-amex[_ngcontent-%COMP%]:before{content:"\\f1f3"}.fa-cc-paypal[_ngcontent-%COMP%]:before{content:"\\f1f4"}.fa-cc-stripe[_ngcontent-%COMP%]:before{content:"\\f1f5"}.fa-bell-slash[_ngcontent-%COMP%]:before{content:"\\f1f6"}.fa-bell-slash-o[_ngcontent-%COMP%]:before{content:"\\f1f7"}.fa-trash[_ngcontent-%COMP%]:before{content:"\\f1f8"}.fa-copyright[_ngcontent-%COMP%]:before{content:"\\f1f9"}.fa-at[_ngcontent-%COMP%]:before{content:"\\f1fa"}.fa-eyedropper[_ngcontent-%COMP%]:before{content:"\\f1fb"}.fa-paint-brush[_ngcontent-%COMP%]:before{content:"\\f1fc"}.fa-birthday-cake[_ngcontent-%COMP%]:before{content:"\\f1fd"}.fa-area-chart[_ngcontent-%COMP%]:before{content:"\\f1fe"}.fa-pie-chart[_ngcontent-%COMP%]:before{content:"\\f200"}.fa-line-chart[_ngcontent-%COMP%]:before{content:"\\f201"}.fa-lastfm[_ngcontent-%COMP%]:before{content:"\\f202"}.fa-lastfm-square[_ngcontent-%COMP%]:before{content:"\\f203"}.fa-toggle-off[_ngcontent-%COMP%]:before{content:"\\f204"}.fa-toggle-on[_ngcontent-%COMP%]:before{content:"\\f205"}.fa-bicycle[_ngcontent-%COMP%]:before{content:"\\f206"}.fa-bus[_ngcontent-%COMP%]:before{content:"\\f207"}.fa-ioxhost[_ngcontent-%COMP%]:before{content:"\\f208"}.fa-angellist[_ngcontent-%COMP%]:before{content:"\\f209"}.fa-cc[_ngcontent-%COMP%]:before{content:"\\f20a"}.fa-shekel[_ngcontent-%COMP%]:before, .fa-sheqel[_ngcontent-%COMP%]:before, .fa-ils[_ngcontent-%COMP%]:before{content:"\\f20b"}.fa-meanpath[_ngcontent-%COMP%]:before{content:"\\f20c"}.fa-buysellads[_ngcontent-%COMP%]:before{content:"\\f20d"}.fa-connectdevelop[_ngcontent-%COMP%]:before{content:"\\f20e"}.fa-dashcube[_ngcontent-%COMP%]:before{content:"\\f210"}.fa-forumbee[_ngcontent-%COMP%]:before{content:"\\f211"}.fa-leanpub[_ngcontent-%COMP%]:before{content:"\\f212"}.fa-sellsy[_ngcontent-%COMP%]:before{content:"\\f213"}.fa-shirtsinbulk[_ngcontent-%COMP%]:before{content:"\\f214"}.fa-simplybuilt[_ngcontent-%COMP%]:before{content:"\\f215"}.fa-skyatlas[_ngcontent-%COMP%]:before{content:"\\f216"}.fa-cart-plus[_ngcontent-%COMP%]:before{content:"\\f217"}.fa-cart-arrow-down[_ngcontent-%COMP%]:before{content:"\\f218"}.fa-diamond[_ngcontent-%COMP%]:before{content:"\\f219"}.fa-ship[_ngcontent-%COMP%]:before{content:"\\f21a"}.fa-user-secret[_ngcontent-%COMP%]:before{content:"\\f21b"}.fa-motorcycle[_ngcontent-%COMP%]:before{content:"\\f21c"}.fa-street-view[_ngcontent-%COMP%]:before{content:"\\f21d"}.fa-heartbeat[_ngcontent-%COMP%]:before{content:"\\f21e"}.fa-venus[_ngcontent-%COMP%]:before{content:"\\f221"}.fa-mars[_ngcontent-%COMP%]:before{content:"\\f222"}.fa-mercury[_ngcontent-%COMP%]:before{content:"\\f223"}.fa-intersex[_ngcontent-%COMP%]:before, .fa-transgender[_ngcontent-%COMP%]:before{content:"\\f224"}.fa-transgender-alt[_ngcontent-%COMP%]:before{content:"\\f225"}.fa-venus-double[_ngcontent-%COMP%]:before{content:"\\f226"}.fa-mars-double[_ngcontent-%COMP%]:before{content:"\\f227"}.fa-venus-mars[_ngcontent-%COMP%]:before{content:"\\f228"}.fa-mars-stroke[_ngcontent-%COMP%]:before{content:"\\f229"}.fa-mars-stroke-v[_ngcontent-%COMP%]:before{content:"\\f22a"}.fa-mars-stroke-h[_ngcontent-%COMP%]:before{content:"\\f22b"}.fa-neuter[_ngcontent-%COMP%]:before{content:"\\f22c"}.fa-genderless[_ngcontent-%COMP%]:before{content:"\\f22d"}.fa-facebook-official[_ngcontent-%COMP%]:before{content:"\\f230"}.fa-pinterest-p[_ngcontent-%COMP%]:before{content:"\\f231"}.fa-whatsapp[_ngcontent-%COMP%]:before{content:"\\f232"}.fa-server[_ngcontent-%COMP%]:before{content:"\\f233"}.fa-user-plus[_ngcontent-%COMP%]:before{content:"\\f234"}.fa-user-times[_ngcontent-%COMP%]:before{content:"\\f235"}.fa-hotel[_ngcontent-%COMP%]:before, .fa-bed[_ngcontent-%COMP%]:before{content:"\\f236"}.fa-viacoin[_ngcontent-%COMP%]:before{content:"\\f237"}.fa-train[_ngcontent-%COMP%]:before{content:"\\f238"}.fa-subway[_ngcontent-%COMP%]:before{content:"\\f239"}.fa-medium[_ngcontent-%COMP%]:before{content:"\\f23a"}.fa-yc[_ngcontent-%COMP%]:before, .fa-y-combinator[_ngcontent-%COMP%]:before{content:"\\f23b"}.fa-optin-monster[_ngcontent-%COMP%]:before{content:"\\f23c"}.fa-opencart[_ngcontent-%COMP%]:before{content:"\\f23d"}.fa-expeditedssl[_ngcontent-%COMP%]:before{content:"\\f23e"}.fa-battery-4[_ngcontent-%COMP%]:before, .fa-battery[_ngcontent-%COMP%]:before, .fa-battery-full[_ngcontent-%COMP%]:before{content:"\\f240"}.fa-battery-3[_ngcontent-%COMP%]:before, .fa-battery-three-quarters[_ngcontent-%COMP%]:before{content:"\\f241"}.fa-battery-2[_ngcontent-%COMP%]:before, .fa-battery-half[_ngcontent-%COMP%]:before{content:"\\f242"}.fa-battery-1[_ngcontent-%COMP%]:before, .fa-battery-quarter[_ngcontent-%COMP%]:before{content:"\\f243"}.fa-battery-0[_ngcontent-%COMP%]:before, .fa-battery-empty[_ngcontent-%COMP%]:before{content:"\\f244"}.fa-mouse-pointer[_ngcontent-%COMP%]:before{content:"\\f245"}.fa-i-cursor[_ngcontent-%COMP%]:before{content:"\\f246"}.fa-object-group[_ngcontent-%COMP%]:before{content:"\\f247"}.fa-object-ungroup[_ngcontent-%COMP%]:before{content:"\\f248"}.fa-sticky-note[_ngcontent-%COMP%]:before{content:"\\f249"}.fa-sticky-note-o[_ngcontent-%COMP%]:before{content:"\\f24a"}.fa-cc-jcb[_ngcontent-%COMP%]:before{content:"\\f24b"}.fa-cc-diners-club[_ngcontent-%COMP%]:before{content:"\\f24c"}.fa-clone[_ngcontent-%COMP%]:before{content:"\\f24d"}.fa-balance-scale[_ngcontent-%COMP%]:before{content:"\\f24e"}.fa-hourglass-o[_ngcontent-%COMP%]:before{content:"\\f250"}.fa-hourglass-1[_ngcontent-%COMP%]:before, .fa-hourglass-start[_ngcontent-%COMP%]:before{content:"\\f251"}.fa-hourglass-2[_ngcontent-%COMP%]:before, .fa-hourglass-half[_ngcontent-%COMP%]:before{content:"\\f252"}.fa-hourglass-3[_ngcontent-%COMP%]:before, .fa-hourglass-end[_ngcontent-%COMP%]:before{content:"\\f253"}.fa-hourglass[_ngcontent-%COMP%]:before{content:"\\f254"}.fa-hand-grab-o[_ngcontent-%COMP%]:before, .fa-hand-rock-o[_ngcontent-%COMP%]:before{content:"\\f255"}.fa-hand-stop-o[_ngcontent-%COMP%]:before, .fa-hand-paper-o[_ngcontent-%COMP%]:before{content:"\\f256"}.fa-hand-scissors-o[_ngcontent-%COMP%]:before{content:"\\f257"}.fa-hand-lizard-o[_ngcontent-%COMP%]:before{content:"\\f258"}.fa-hand-spock-o[_ngcontent-%COMP%]:before{content:"\\f259"}.fa-hand-pointer-o[_ngcontent-%COMP%]:before{content:"\\f25a"}.fa-hand-peace-o[_ngcontent-%COMP%]:before{content:"\\f25b"}.fa-trademark[_ngcontent-%COMP%]:before{content:"\\f25c"}.fa-registered[_ngcontent-%COMP%]:before{content:"\\f25d"}.fa-creative-commons[_ngcontent-%COMP%]:before{content:"\\f25e"}.fa-gg[_ngcontent-%COMP%]:before{content:"\\f260"}.fa-gg-circle[_ngcontent-%COMP%]:before{content:"\\f261"}.fa-tripadvisor[_ngcontent-%COMP%]:before{content:"\\f262"}.fa-odnoklassniki[_ngcontent-%COMP%]:before{content:"\\f263"}.fa-odnoklassniki-square[_ngcontent-%COMP%]:before{content:"\\f264"}.fa-get-pocket[_ngcontent-%COMP%]:before{content:"\\f265"}.fa-wikipedia-w[_ngcontent-%COMP%]:before{content:"\\f266"}.fa-safari[_ngcontent-%COMP%]:before{content:"\\f267"}.fa-chrome[_ngcontent-%COMP%]:before{content:"\\f268"}.fa-firefox[_ngcontent-%COMP%]:before{content:"\\f269"}.fa-opera[_ngcontent-%COMP%]:before{content:"\\f26a"}.fa-internet-explorer[_ngcontent-%COMP%]:before{content:"\\f26b"}.fa-tv[_ngcontent-%COMP%]:before, .fa-television[_ngcontent-%COMP%]:before{content:"\\f26c"}.fa-contao[_ngcontent-%COMP%]:before{content:"\\f26d"}.fa-500px[_ngcontent-%COMP%]:before{content:"\\f26e"}.fa-amazon[_ngcontent-%COMP%]:before{content:"\\f270"}.fa-calendar-plus-o[_ngcontent-%COMP%]:before{content:"\\f271"}.fa-calendar-minus-o[_ngcontent-%COMP%]:before{content:"\\f272"}.fa-calendar-times-o[_ngcontent-%COMP%]:before{content:"\\f273"}.fa-calendar-check-o[_ngcontent-%COMP%]:before{content:"\\f274"}.fa-industry[_ngcontent-%COMP%]:before{content:"\\f275"}.fa-map-pin[_ngcontent-%COMP%]:before{content:"\\f276"}.fa-map-signs[_ngcontent-%COMP%]:before{content:"\\f277"}.fa-map-o[_ngcontent-%COMP%]:before{content:"\\f278"}.fa-map[_ngcontent-%COMP%]:before{content:"\\f279"}.fa-commenting[_ngcontent-%COMP%]:before{content:"\\f27a"}.fa-commenting-o[_ngcontent-%COMP%]:before{content:"\\f27b"}.fa-houzz[_ngcontent-%COMP%]:before{content:"\\f27c"}.fa-vimeo[_ngcontent-%COMP%]:before{content:"\\f27d"}.fa-black-tie[_ngcontent-%COMP%]:before{content:"\\f27e"}.fa-fonticons[_ngcontent-%COMP%]:before{content:"\\f280"}.fa-reddit-alien[_ngcontent-%COMP%]:before{content:"\\f281"}.fa-edge[_ngcontent-%COMP%]:before{content:"\\f282"}.fa-credit-card-alt[_ngcontent-%COMP%]:before{content:"\\f283"}.fa-codiepie[_ngcontent-%COMP%]:before{content:"\\f284"}.fa-modx[_ngcontent-%COMP%]:before{content:"\\f285"}.fa-fort-awesome[_ngcontent-%COMP%]:before{content:"\\f286"}.fa-usb[_ngcontent-%COMP%]:before{content:"\\f287"}.fa-product-hunt[_ngcontent-%COMP%]:before{content:"\\f288"}.fa-mixcloud[_ngcontent-%COMP%]:before{content:"\\f289"}.fa-scribd[_ngcontent-%COMP%]:before{content:"\\f28a"}.fa-pause-circle[_ngcontent-%COMP%]:before{content:"\\f28b"}.fa-pause-circle-o[_ngcontent-%COMP%]:before{content:"\\f28c"}.fa-stop-circle[_ngcontent-%COMP%]:before{content:"\\f28d"}.fa-stop-circle-o[_ngcontent-%COMP%]:before{content:"\\f28e"}.fa-shopping-bag[_ngcontent-%COMP%]:before{content:"\\f290"}.fa-shopping-basket[_ngcontent-%COMP%]:before{content:"\\f291"}.fa-hashtag[_ngcontent-%COMP%]:before{content:"\\f292"}.fa-bluetooth[_ngcontent-%COMP%]:before{content:"\\f293"}.fa-bluetooth-b[_ngcontent-%COMP%]:before{content:"\\f294"}.fa-percent[_ngcontent-%COMP%]:before{content:"\\f295"}.fa-gitlab[_ngcontent-%COMP%]:before{content:"\\f296"}.fa-wpbeginner[_ngcontent-%COMP%]:before{content:"\\f297"}.fa-wpforms[_ngcontent-%COMP%]:before{content:"\\f298"}.fa-envira[_ngcontent-%COMP%]:before{content:"\\f299"}.fa-universal-access[_ngcontent-%COMP%]:before{content:"\\f29a"}.fa-wheelchair-alt[_ngcontent-%COMP%]:before{content:"\\f29b"}.fa-question-circle-o[_ngcontent-%COMP%]:before{content:"\\f29c"}.fa-blind[_ngcontent-%COMP%]:before{content:"\\f29d"}.fa-audio-description[_ngcontent-%COMP%]:before{content:"\\f29e"}.fa-volume-control-phone[_ngcontent-%COMP%]:before{content:"\\f2a0"}.fa-braille[_ngcontent-%COMP%]:before{content:"\\f2a1"}.fa-assistive-listening-systems[_ngcontent-%COMP%]:before{content:"\\f2a2"}.fa-asl-interpreting[_ngcontent-%COMP%]:before, .fa-american-sign-language-interpreting[_ngcontent-%COMP%]:before{content:"\\f2a3"}.fa-deafness[_ngcontent-%COMP%]:before, .fa-hard-of-hearing[_ngcontent-%COMP%]:before, .fa-deaf[_ngcontent-%COMP%]:before{content:"\\f2a4"}.fa-glide[_ngcontent-%COMP%]:before{content:"\\f2a5"}.fa-glide-g[_ngcontent-%COMP%]:before{content:"\\f2a6"}.fa-signing[_ngcontent-%COMP%]:before, .fa-sign-language[_ngcontent-%COMP%]:before{content:"\\f2a7"}.fa-low-vision[_ngcontent-%COMP%]:before{content:"\\f2a8"}.fa-viadeo[_ngcontent-%COMP%]:before{content:"\\f2a9"}.fa-viadeo-square[_ngcontent-%COMP%]:before{content:"\\f2aa"}.fa-snapchat[_ngcontent-%COMP%]:before{content:"\\f2ab"}.fa-snapchat-ghost[_ngcontent-%COMP%]:before{content:"\\f2ac"}.fa-snapchat-square[_ngcontent-%COMP%]:before{content:"\\f2ad"}.fa-pied-piper[_ngcontent-%COMP%]:before{content:"\\f2ae"}.fa-first-order[_ngcontent-%COMP%]:before{content:"\\f2b0"}.fa-yoast[_ngcontent-%COMP%]:before{content:"\\f2b1"}.fa-themeisle[_ngcontent-%COMP%]:before{content:"\\f2b2"}.fa-google-plus-circle[_ngcontent-%COMP%]:before, .fa-google-plus-official[_ngcontent-%COMP%]:before{content:"\\f2b3"}.fa-fa[_ngcontent-%COMP%]:before, .fa-font-awesome[_ngcontent-%COMP%]:before{content:"\\f2b4"}.fa-handshake-o[_ngcontent-%COMP%]:before{content:"\\f2b5"}.fa-envelope-open[_ngcontent-%COMP%]:before{content:"\\f2b6"}.fa-envelope-open-o[_ngcontent-%COMP%]:before{content:"\\f2b7"}.fa-linode[_ngcontent-%COMP%]:before{content:"\\f2b8"}.fa-address-book[_ngcontent-%COMP%]:before{content:"\\f2b9"}.fa-address-book-o[_ngcontent-%COMP%]:before{content:"\\f2ba"}.fa-vcard[_ngcontent-%COMP%]:before, .fa-address-card[_ngcontent-%COMP%]:before{content:"\\f2bb"}.fa-vcard-o[_ngcontent-%COMP%]:before, .fa-address-card-o[_ngcontent-%COMP%]:before{content:"\\f2bc"}.fa-user-circle[_ngcontent-%COMP%]:before{content:"\\f2bd"}.fa-user-circle-o[_ngcontent-%COMP%]:before{content:"\\f2be"}.fa-user-o[_ngcontent-%COMP%]:before{content:"\\f2c0"}.fa-id-badge[_ngcontent-%COMP%]:before{content:"\\f2c1"}.fa-drivers-license[_ngcontent-%COMP%]:before, .fa-id-card[_ngcontent-%COMP%]:before{content:"\\f2c2"}.fa-drivers-license-o[_ngcontent-%COMP%]:before, .fa-id-card-o[_ngcontent-%COMP%]:before{content:"\\f2c3"}.fa-quora[_ngcontent-%COMP%]:before{content:"\\f2c4"}.fa-free-code-camp[_ngcontent-%COMP%]:before{content:"\\f2c5"}.fa-telegram[_ngcontent-%COMP%]:before{content:"\\f2c6"}.fa-thermometer-4[_ngcontent-%COMP%]:before, .fa-thermometer[_ngcontent-%COMP%]:before, .fa-thermometer-full[_ngcontent-%COMP%]:before{content:"\\f2c7"}.fa-thermometer-3[_ngcontent-%COMP%]:before, .fa-thermometer-three-quarters[_ngcontent-%COMP%]:before{content:"\\f2c8"}.fa-thermometer-2[_ngcontent-%COMP%]:before, .fa-thermometer-half[_ngcontent-%COMP%]:before{content:"\\f2c9"}.fa-thermometer-1[_ngcontent-%COMP%]:before, .fa-thermometer-quarter[_ngcontent-%COMP%]:before{content:"\\f2ca"}.fa-thermometer-0[_ngcontent-%COMP%]:before, .fa-thermometer-empty[_ngcontent-%COMP%]:before{content:"\\f2cb"}.fa-shower[_ngcontent-%COMP%]:before{content:"\\f2cc"}.fa-bathtub[_ngcontent-%COMP%]:before, .fa-s15[_ngcontent-%COMP%]:before, .fa-bath[_ngcontent-%COMP%]:before{content:"\\f2cd"}.fa-podcast[_ngcontent-%COMP%]:before{content:"\\f2ce"}.fa-window-maximize[_ngcontent-%COMP%]:before{content:"\\f2d0"}.fa-window-minimize[_ngcontent-%COMP%]:before{content:"\\f2d1"}.fa-window-restore[_ngcontent-%COMP%]:before{content:"\\f2d2"}.fa-times-rectangle[_ngcontent-%COMP%]:before, .fa-window-close[_ngcontent-%COMP%]:before{content:"\\f2d3"}.fa-times-rectangle-o[_ngcontent-%COMP%]:before, .fa-window-close-o[_ngcontent-%COMP%]:before{content:"\\f2d4"}.fa-bandcamp[_ngcontent-%COMP%]:before{content:"\\f2d5"}.fa-grav[_ngcontent-%COMP%]:before{content:"\\f2d6"}.fa-etsy[_ngcontent-%COMP%]:before{content:"\\f2d7"}.fa-imdb[_ngcontent-%COMP%]:before{content:"\\f2d8"}.fa-ravelry[_ngcontent-%COMP%]:before{content:"\\f2d9"}.fa-eercast[_ngcontent-%COMP%]:before{content:"\\f2da"}.fa-microchip[_ngcontent-%COMP%]:before{content:"\\f2db"}.fa-snowflake-o[_ngcontent-%COMP%]:before{content:"\\f2dc"}.fa-superpowers[_ngcontent-%COMP%]:before{content:"\\f2dd"}.fa-wpexplorer[_ngcontent-%COMP%]:before{content:"\\f2de"}.fa-meetup[_ngcontent-%COMP%]:before{content:"\\f2e0"}.sr-only[_ngcontent-%COMP%]{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable[_ngcontent-%COMP%]:active, .sr-only-focusable[_ngcontent-%COMP%]:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}a[_ngcontent-%COMP%]{cursor:pointer}.angular-editor-textarea[_ngcontent-%COMP%]{min-height:150px;overflow:auto;margin-top:5px;resize:vertical}.angular-editor-textarea[_ngcontent-%COMP%]:after{content:"";position:absolute;bottom:0;right:0;display:block;width:8px;height:8px;cursor:nwse-resize;background-color:#ffffff80}.angular-editor-toolbar[_ngcontent-%COMP%]{font:100 14px/15px Roboto,Arial,sans-serif;background-color:#f5f5f5;font-size:.8rem;padding:.2rem;border:1px solid #ddd}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]{display:none;margin-right:5px;vertical-align:baseline}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]{background-color:#fff;vertical-align:middle;border:1px solid #ddd;padding:.4rem;min-width:2rem;float:left}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:focus, .angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button.focus[_ngcontent-%COMP%]{outline:0}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:disabled > .color-label[_ngcontent-%COMP%]{pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:disabled > .color-label.foreground[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:after{background:#555555}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:disabled > .color-label.background[_ngcontent-%COMP%]{background:#555555}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button.active[_ngcontent-%COMP%]{background:#fff5b9}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button.active[_ngcontent-%COMP%]:hover{background-color:#fffa98}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]{font-size:11px;width:90px;vertical-align:middle;background-color:transparent;border:.5px solid rgba(255,255,255,0);border-radius:5px;outline:none;padding:.4rem;cursor:pointer}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   optgroup[_ngcontent-%COMP%]{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   option[_ngcontent-%COMP%]{border:1px solid;background-color:#fff}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .default[_ngcontent-%COMP%]{font-size:16px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h1[_ngcontent-%COMP%]{font-size:24px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h2[_ngcontent-%COMP%]{font-size:20px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h3[_ngcontent-%COMP%]{font-size:16px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h4[_ngcontent-%COMP%]{font-size:15px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h5[_ngcontent-%COMP%]{font-size:14px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h6[_ngcontent-%COMP%]{font-size:13px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .div[_ngcontent-%COMP%], .angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .pre[_ngcontent-%COMP%]{font-size:12px}}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font[_ngcontent-%COMP%]{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font[_ngcontent-%COMP%]   optgroup[_ngcontent-%COMP%]{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font[_ngcontent-%COMP%]   option[_ngcontent-%COMP%]{border:1px solid;background-color:#fff}}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font[_ngcontent-%COMP%]:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]{display:inline-block;width:50px}@supports not (-moz-appearance: none){.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   optgroup[_ngcontent-%COMP%]{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   option[_ngcontent-%COMP%]{border:1px solid;background-color:#fff}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size1[_ngcontent-%COMP%]{font-size:10px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size2[_ngcontent-%COMP%]{font-size:12px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size3[_ngcontent-%COMP%]{font-size:14px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size4[_ngcontent-%COMP%]{font-size:16px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size5[_ngcontent-%COMP%]{font-size:18px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size6[_ngcontent-%COMP%]{font-size:20px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size7[_ngcontent-%COMP%]{font-size:22px}}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-custom-style[_ngcontent-%COMP%]{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-custom-style[_ngcontent-%COMP%]   optgroup[_ngcontent-%COMP%]{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-custom-style[_ngcontent-%COMP%]   option[_ngcontent-%COMP%]{border:1px solid;background-color:#fff}}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-custom-style[_ngcontent-%COMP%]:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-custom-style[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .color-label[_ngcontent-%COMP%]{position:relative;cursor:pointer}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .background[_ngcontent-%COMP%]{font-size:smaller;background:#1b1b1b;color:#fff;padding:3px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .foreground[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:after{position:absolute;content:"";left:-1px;top:auto;bottom:-3px;right:auto;width:15px;height:2px;z-index:0;background:#1b1b1b}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]:not([style*="display:none"]):not([style*="display: none"]){display:inline-block}']
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AngularEditorToolbarComponent, [{
    type: Component,
    args: [{
      selector: "angular-editor-toolbar",
      template: `<div class="angular-editor-toolbar" *ngIf="showToolbar">
  <div class="angular-editor-toolbar-set">
    <button type="button" title="Undo" class="angular-editor-button" (click)="triggerCommand('undo')"
            [hidden]="isButtonHidden('undo')" tabindex="-1"><i
      class='fa fa-undo'></i></button>
    <button type="button" title="Redo" class="angular-editor-button" (click)="triggerCommand('redo')"
            [hidden]="isButtonHidden('redo')" tabindex="-1"><i
      class='fa fa-repeat'></i></button>
  </div>
  <div class="angular-editor-toolbar-set">
    <button [id]="'bold-'+id" type="button" title="Bold" class="angular-editor-button" (click)="triggerCommand('bold')"
            [disabled]="htmlMode" [hidden]="isButtonHidden('bold')" tabindex="-1"><i class='fa fa-bold'></i></button>
    <button [id]="'italic-'+id" type="button" title="Italic" class="angular-editor-button"
            (click)="triggerCommand('italic')"
            [disabled]="htmlMode" [hidden]="isButtonHidden('italic')" tabindex="-1"><i class='fa fa-italic'></i>
    </button>
    <button [id]="'underline-'+id" type="button" title="Underline" class="angular-editor-button"
            (click)="triggerCommand('underline')" [disabled]="htmlMode" [hidden]="isButtonHidden('underline')"
            tabindex="-1"><i class='fa fa-underline'></i></button>
    <button [id]="'strikeThrough-'+id" type="button" title="Strikethrough" class="angular-editor-button"
            (click)="triggerCommand('strikeThrough')" [disabled]="htmlMode" [hidden]="isButtonHidden('strikeThrough')"
            tabindex="-1"><i class='fa fa-strikethrough'></i></button>
    <button [id]="'subscript-'+id" type="button" title="Subscript" class="angular-editor-button"
            (click)="triggerCommand('subscript')" [disabled]="htmlMode" [hidden]="isButtonHidden('subscript')"
            tabindex="-1"><i class='fa fa-subscript'></i></button>
    <button [id]="'superscript-'+id" type="button" title="Superscript" class="angular-editor-button"
            (click)="triggerCommand('superscript')" [disabled]="htmlMode" [hidden]="isButtonHidden('superscript')"
            tabindex="-1"><i class='fa fa-superscript'></i></button>
  </div>
  <div class="angular-editor-toolbar-set">
    <button [id]="'justifyLeft-'+id" type="button" title="Justify Left" class="angular-editor-button"
            (click)="triggerCommand('justifyLeft')" [disabled]="htmlMode" [hidden]="isButtonHidden('justifyLeft')"
            tabindex="-1"><i
      class='fa fa-align-left'></i></button>
    <button [id]="'justifyCenter-'+id" type="button" title="Justify Center" class="angular-editor-button"
            (click)="triggerCommand('justifyCenter')" [disabled]="htmlMode" [hidden]="isButtonHidden('justifyCenter')"
            tabindex="-1"><i
      class='fa fa-align-center'></i></button>
    <button [id]="'justifyRight-'+id" type="button" title="Justify Right" class="angular-editor-button"
            (click)="triggerCommand('justifyRight')" [disabled]="htmlMode" [hidden]="isButtonHidden('justifyRight')"
            tabindex="-1">
      <i class='fa fa-align-right'></i></button>
    <button [id]="'justifyFull-'+id" type="button" title="Justify Full" class="angular-editor-button"
            (click)="triggerCommand('justifyFull')" [disabled]="htmlMode" [hidden]="isButtonHidden('justifyFull')"
            tabindex="-1"><i
      class='fa fa-align-justify'></i></button>
  </div>
  <div class="angular-editor-toolbar-set">
    <button [id]="'indent-'+id" type="button" title="Indent" class="angular-editor-button"
            (click)="triggerCommand('indent')"
            [disabled]="htmlMode" [hidden]="isButtonHidden('indent')" tabindex="-1"><i
      class='fa fa-indent'></i></button>
    <button [id]="'outdent-'+id" type="button" title="Outdent" class="angular-editor-button"
            (click)="triggerCommand('outdent')"
            [disabled]="htmlMode" [hidden]="isButtonHidden('outdent')" tabindex="-1"><i
      class='fa fa-outdent'></i></button>
  </div>
  <div class="angular-editor-toolbar-set">
    <button [id]="'insertUnorderedList-'+id" type="button" title="Unordered List" class="angular-editor-button"
            (click)="triggerCommand('insertUnorderedList')" [disabled]="htmlMode"
            [hidden]="isButtonHidden('insertUnorderedList')" tabindex="-1"><i
      class='fa fa-list-ul'></i></button>
    <button [id]="'insertOrderedList-'+id" type="button" title="Ordered List" class="angular-editor-button"
            (click)="triggerCommand('insertOrderedList')" [disabled]="htmlMode"
            [hidden]="isButtonHidden('insertOrderedList')" tabindex="-1"><i
      class='fa fa-list-ol'></i></button>
  </div>
  <div class="angular-editor-toolbar-set">

    <ae-select class="select-heading" [options]="headings"
               [(ngModel)]="block"
               (change)="triggerCommand(block)"
               [disabled]="htmlMode"
               [hidden]="isButtonHidden('heading')"
               tabindex="-1"></ae-select>
  </div>
  <div class="angular-editor-toolbar-set">

    <ae-select class="select-font" [options]="fonts"
               [(ngModel)]="fontName"
               (change)="setFontName(fontName)"
               [disabled]="htmlMode"
               [hidden]="isButtonHidden('fontName')"
               tabindex="-1"></ae-select>
  </div>
  <div class="angular-editor-toolbar-set">

    <ae-select class="select-font-size" [options]="fontSizes"
               [(ngModel)]="fontSize"
               (change)="setFontSize(fontSize)"
               [disabled]="htmlMode"
               [hidden]="isButtonHidden('fontSize')"
               tabindex="-1">
    </ae-select>
  </div>
  <div class="angular-editor-toolbar-set">
    <input
      style="display: none"
      type="color" (change)="insertColor(fgInput.value, 'textColor')"
      #fgInput>
    <button [id]="'foregroundColorPicker-'+id" type="button" class="angular-editor-button" (click)="focus(); ; fgInput.click()"
            title="Text Color"
            [disabled]="htmlMode" [hidden]="isButtonHidden('textColor')" tabindex="-1"><span
      class="color-label foreground"><i class="fa fa-font"></i></span>
    </button>
    <input
      style="display: none"
      type="color" (change)="insertColor(bgInput.value, 'backgroundColor')"
      #bgInput>
    <button [id]="'backgroundColorPicker-'+id" type="button" class="angular-editor-button" (click)="focus(); ; bgInput.click()"
            title="Background Color"
            [disabled]="htmlMode" [hidden]="isButtonHidden('backgroundColor')" tabindex="-1"><span
      class="color-label background"><i class="fa fa-font"></i></span>
    </button>
  </div>
  <div *ngIf="_customClasses" class="angular-editor-toolbar-set">
    <ae-select class="select-custom-style" [options]="customClassList"
               [(ngModel)]="customClassId"
               (change)="setCustomClass(customClassId)"
               [disabled]="htmlMode"
               [hidden]="isButtonHidden('customClasses')"
               tabindex="-1"></ae-select>
  </div>
  <div class="angular-editor-toolbar-set">
    <button [id]="'link-'+id" type="button" class="angular-editor-button" (click)="insertUrl()"
            title="Insert Link" [disabled]="isLinkButtonDisabled" [hidden]="isButtonHidden('link')" tabindex="-1">
      <i class="fa fa-link"></i>
    </button>
    <button [id]="'unlink-'+id" type="button" class="angular-editor-button" (click)="triggerCommand('unlink')"
            title="Unlink" [disabled]="htmlMode || !linkSelected" [hidden]="isButtonHidden('unlink')" tabindex="-1">
      <i class="fa fa-chain-broken"></i>
    </button>
    <input
      style="display: none"
      accept="image/*"
      type="file" (change)="onFileChanged($event)"
      #fileInput>
    <button [id]="'insertImage-'+id" type="button" class="angular-editor-button" (click)="focus(); fileInput.click()"
            title="Insert Image"
            [disabled]="htmlMode" [hidden]="isButtonHidden('insertImage')" tabindex="-1"><i class="fa fa-image"></i>
    </button>
    <button [id]="'insertVideo-'+id" type="button" class="angular-editor-button"
            (click)="insertVideo()" title="Insert Video" [disabled]="htmlMode" [hidden]="isButtonHidden('insertVideo')"
            tabindex="-1"><i
      class="fa fa-video-camera"></i></button>
    <button [id]="'insertHorizontalRule-'+id" type="button" title="Horizontal Line" class="angular-editor-button"
            (click)="triggerCommand('insertHorizontalRule')" [disabled]="htmlMode"
            [hidden]="isButtonHidden('insertHorizontalRule')" tabindex="-1"><i
      class="fa fa-minus"></i></button>
  </div>
  <div class="angular-editor-toolbar-set">
    <button [id]="'clearFormatting-'+id" type="button" title="Clear Formatting" class="angular-editor-button"
            (click)="triggerCommand('removeFormat')" [disabled]="htmlMode" [hidden]="isButtonHidden('removeFormat')"
            tabindex="-1"><i class='fa fa-remove'></i>
    </button>
  </div>
  <div class="angular-editor-toolbar-set">
    <button [id]="'toggleEditorMode-'+id" type="button" title="HTML Code" class="angular-editor-button"
            (click)="triggerCommand('toggleEditorMode')" [hidden]="isButtonHidden('toggleEditorMode')" tabindex="-1"><i
      class='fa fa-code'></i></button>
  </div>
  <ng-content></ng-content>
</div>
`,
      styles: ['/*!\n *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome\n *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)\n */@font-face{font-family:FontAwesome;src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?v=4.7.0);src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?#iefix&v=4.7.0) format("embedded-opentype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff2?v=4.7.0) format("woff2"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff?v=4.7.0) format("woff"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.ttf?v=4.7.0) format("truetype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular) format("svg");font-weight:400;font-style:normal}.fa{display:inline-block;font: 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.3333333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.2857142857em;text-align:center}.fa-ul{padding-left:0;margin-left:2.1428571429em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.1428571429em;width:2.1428571429em;top:.1428571429em;text-align:center}.fa-li.fa-lg{left:-1.8571428571em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{animation:fa-spin 2s infinite linear}.fa-pulse{animation:fa-spin 1s infinite steps(8)}@keyframes fa-spin{0%{transform:rotate(0)}to{transform:rotate(359deg)}}.fa-rotate-90{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";transform:rotate(90deg)}.fa-rotate-180{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";transform:rotate(180deg)}.fa-rotate-270{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";transform:rotate(270deg)}.fa-flip-horizontal{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";transform:scaleX(-1)}.fa-flip-vertical{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";transform:scaleY(-1)}:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-flip-horizontal,:root .fa-flip-vertical{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:"\\f000"}.fa-music:before{content:"\\f001"}.fa-search:before{content:"\\f002"}.fa-envelope-o:before{content:"\\f003"}.fa-heart:before{content:"\\f004"}.fa-star:before{content:"\\f005"}.fa-star-o:before{content:"\\f006"}.fa-user:before{content:"\\f007"}.fa-film:before{content:"\\f008"}.fa-th-large:before{content:"\\f009"}.fa-th:before{content:"\\f00a"}.fa-th-list:before{content:"\\f00b"}.fa-check:before{content:"\\f00c"}.fa-remove:before,.fa-close:before,.fa-times:before{content:"\\f00d"}.fa-search-plus:before{content:"\\f00e"}.fa-search-minus:before{content:"\\f010"}.fa-power-off:before{content:"\\f011"}.fa-signal:before{content:"\\f012"}.fa-gear:before,.fa-cog:before{content:"\\f013"}.fa-trash-o:before{content:"\\f014"}.fa-home:before{content:"\\f015"}.fa-file-o:before{content:"\\f016"}.fa-clock-o:before{content:"\\f017"}.fa-road:before{content:"\\f018"}.fa-download:before{content:"\\f019"}.fa-arrow-circle-o-down:before{content:"\\f01a"}.fa-arrow-circle-o-up:before{content:"\\f01b"}.fa-inbox:before{content:"\\f01c"}.fa-play-circle-o:before{content:"\\f01d"}.fa-rotate-right:before,.fa-repeat:before{content:"\\f01e"}.fa-refresh:before{content:"\\f021"}.fa-list-alt:before{content:"\\f022"}.fa-lock:before{content:"\\f023"}.fa-flag:before{content:"\\f024"}.fa-headphones:before{content:"\\f025"}.fa-volume-off:before{content:"\\f026"}.fa-volume-down:before{content:"\\f027"}.fa-volume-up:before{content:"\\f028"}.fa-qrcode:before{content:"\\f029"}.fa-barcode:before{content:"\\f02a"}.fa-tag:before{content:"\\f02b"}.fa-tags:before{content:"\\f02c"}.fa-book:before{content:"\\f02d"}.fa-bookmark:before{content:"\\f02e"}.fa-print:before{content:"\\f02f"}.fa-camera:before{content:"\\f030"}.fa-font:before{content:"\\f031"}.fa-bold:before{content:"\\f032"}.fa-italic:before{content:"\\f033"}.fa-text-height:before{content:"\\f034"}.fa-text-width:before{content:"\\f035"}.fa-align-left:before{content:"\\f036"}.fa-align-center:before{content:"\\f037"}.fa-align-right:before{content:"\\f038"}.fa-align-justify:before{content:"\\f039"}.fa-list:before{content:"\\f03a"}.fa-dedent:before,.fa-outdent:before{content:"\\f03b"}.fa-indent:before{content:"\\f03c"}.fa-video-camera:before{content:"\\f03d"}.fa-photo:before,.fa-image:before,.fa-picture-o:before{content:"\\f03e"}.fa-pencil:before{content:"\\f040"}.fa-map-marker:before{content:"\\f041"}.fa-adjust:before{content:"\\f042"}.fa-tint:before{content:"\\f043"}.fa-edit:before,.fa-pencil-square-o:before{content:"\\f044"}.fa-share-square-o:before{content:"\\f045"}.fa-check-square-o:before{content:"\\f046"}.fa-arrows:before{content:"\\f047"}.fa-step-backward:before{content:"\\f048"}.fa-fast-backward:before{content:"\\f049"}.fa-backward:before{content:"\\f04a"}.fa-play:before{content:"\\f04b"}.fa-pause:before{content:"\\f04c"}.fa-stop:before{content:"\\f04d"}.fa-forward:before{content:"\\f04e"}.fa-fast-forward:before{content:"\\f050"}.fa-step-forward:before{content:"\\f051"}.fa-eject:before{content:"\\f052"}.fa-chevron-left:before{content:"\\f053"}.fa-chevron-right:before{content:"\\f054"}.fa-plus-circle:before{content:"\\f055"}.fa-minus-circle:before{content:"\\f056"}.fa-times-circle:before{content:"\\f057"}.fa-check-circle:before{content:"\\f058"}.fa-question-circle:before{content:"\\f059"}.fa-info-circle:before{content:"\\f05a"}.fa-crosshairs:before{content:"\\f05b"}.fa-times-circle-o:before{content:"\\f05c"}.fa-check-circle-o:before{content:"\\f05d"}.fa-ban:before{content:"\\f05e"}.fa-arrow-left:before{content:"\\f060"}.fa-arrow-right:before{content:"\\f061"}.fa-arrow-up:before{content:"\\f062"}.fa-arrow-down:before{content:"\\f063"}.fa-mail-forward:before,.fa-share:before{content:"\\f064"}.fa-expand:before{content:"\\f065"}.fa-compress:before{content:"\\f066"}.fa-plus:before{content:"\\f067"}.fa-minus:before{content:"\\f068"}.fa-asterisk:before{content:"\\f069"}.fa-exclamation-circle:before{content:"\\f06a"}.fa-gift:before{content:"\\f06b"}.fa-leaf:before{content:"\\f06c"}.fa-fire:before{content:"\\f06d"}.fa-eye:before{content:"\\f06e"}.fa-eye-slash:before{content:"\\f070"}.fa-warning:before,.fa-exclamation-triangle:before{content:"\\f071"}.fa-plane:before{content:"\\f072"}.fa-calendar:before{content:"\\f073"}.fa-random:before{content:"\\f074"}.fa-comment:before{content:"\\f075"}.fa-magnet:before{content:"\\f076"}.fa-chevron-up:before{content:"\\f077"}.fa-chevron-down:before{content:"\\f078"}.fa-retweet:before{content:"\\f079"}.fa-shopping-cart:before{content:"\\f07a"}.fa-folder:before{content:"\\f07b"}.fa-folder-open:before{content:"\\f07c"}.fa-arrows-v:before{content:"\\f07d"}.fa-arrows-h:before{content:"\\f07e"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:"\\f080"}.fa-twitter-square:before{content:"\\f081"}.fa-facebook-square:before{content:"\\f082"}.fa-camera-retro:before{content:"\\f083"}.fa-key:before{content:"\\f084"}.fa-gears:before,.fa-cogs:before{content:"\\f085"}.fa-comments:before{content:"\\f086"}.fa-thumbs-o-up:before{content:"\\f087"}.fa-thumbs-o-down:before{content:"\\f088"}.fa-star-half:before{content:"\\f089"}.fa-heart-o:before{content:"\\f08a"}.fa-sign-out:before{content:"\\f08b"}.fa-linkedin-square:before{content:"\\f08c"}.fa-thumb-tack:before{content:"\\f08d"}.fa-external-link:before{content:"\\f08e"}.fa-sign-in:before{content:"\\f090"}.fa-trophy:before{content:"\\f091"}.fa-github-square:before{content:"\\f092"}.fa-upload:before{content:"\\f093"}.fa-lemon-o:before{content:"\\f094"}.fa-phone:before{content:"\\f095"}.fa-square-o:before{content:"\\f096"}.fa-bookmark-o:before{content:"\\f097"}.fa-phone-square:before{content:"\\f098"}.fa-twitter:before{content:"\\f099"}.fa-facebook-f:before,.fa-facebook:before{content:"\\f09a"}.fa-github:before{content:"\\f09b"}.fa-unlock:before{content:"\\f09c"}.fa-credit-card:before{content:"\\f09d"}.fa-feed:before,.fa-rss:before{content:"\\f09e"}.fa-hdd-o:before{content:"\\f0a0"}.fa-bullhorn:before{content:"\\f0a1"}.fa-bell:before{content:"\\f0f3"}.fa-certificate:before{content:"\\f0a3"}.fa-hand-o-right:before{content:"\\f0a4"}.fa-hand-o-left:before{content:"\\f0a5"}.fa-hand-o-up:before{content:"\\f0a6"}.fa-hand-o-down:before{content:"\\f0a7"}.fa-arrow-circle-left:before{content:"\\f0a8"}.fa-arrow-circle-right:before{content:"\\f0a9"}.fa-arrow-circle-up:before{content:"\\f0aa"}.fa-arrow-circle-down:before{content:"\\f0ab"}.fa-globe:before{content:"\\f0ac"}.fa-wrench:before{content:"\\f0ad"}.fa-tasks:before{content:"\\f0ae"}.fa-filter:before{content:"\\f0b0"}.fa-briefcase:before{content:"\\f0b1"}.fa-arrows-alt:before{content:"\\f0b2"}.fa-group:before,.fa-users:before{content:"\\f0c0"}.fa-chain:before,.fa-link:before{content:"\\f0c1"}.fa-cloud:before{content:"\\f0c2"}.fa-flask:before{content:"\\f0c3"}.fa-cut:before,.fa-scissors:before{content:"\\f0c4"}.fa-copy:before,.fa-files-o:before{content:"\\f0c5"}.fa-paperclip:before{content:"\\f0c6"}.fa-save:before,.fa-floppy-o:before{content:"\\f0c7"}.fa-square:before{content:"\\f0c8"}.fa-navicon:before,.fa-reorder:before,.fa-bars:before{content:"\\f0c9"}.fa-list-ul:before{content:"\\f0ca"}.fa-list-ol:before{content:"\\f0cb"}.fa-strikethrough:before{content:"\\f0cc"}.fa-underline:before{content:"\\f0cd"}.fa-table:before{content:"\\f0ce"}.fa-magic:before{content:"\\f0d0"}.fa-truck:before{content:"\\f0d1"}.fa-pinterest:before{content:"\\f0d2"}.fa-pinterest-square:before{content:"\\f0d3"}.fa-google-plus-square:before{content:"\\f0d4"}.fa-google-plus:before{content:"\\f0d5"}.fa-money:before{content:"\\f0d6"}.fa-caret-down:before{content:"\\f0d7"}.fa-caret-up:before{content:"\\f0d8"}.fa-caret-left:before{content:"\\f0d9"}.fa-caret-right:before{content:"\\f0da"}.fa-columns:before{content:"\\f0db"}.fa-unsorted:before,.fa-sort:before{content:"\\f0dc"}.fa-sort-down:before,.fa-sort-desc:before{content:"\\f0dd"}.fa-sort-up:before,.fa-sort-asc:before{content:"\\f0de"}.fa-envelope:before{content:"\\f0e0"}.fa-linkedin:before{content:"\\f0e1"}.fa-rotate-left:before,.fa-undo:before{content:"\\f0e2"}.fa-legal:before,.fa-gavel:before{content:"\\f0e3"}.fa-dashboard:before,.fa-tachometer:before{content:"\\f0e4"}.fa-comment-o:before{content:"\\f0e5"}.fa-comments-o:before{content:"\\f0e6"}.fa-flash:before,.fa-bolt:before{content:"\\f0e7"}.fa-sitemap:before{content:"\\f0e8"}.fa-umbrella:before{content:"\\f0e9"}.fa-paste:before,.fa-clipboard:before{content:"\\f0ea"}.fa-lightbulb-o:before{content:"\\f0eb"}.fa-exchange:before{content:"\\f0ec"}.fa-cloud-download:before{content:"\\f0ed"}.fa-cloud-upload:before{content:"\\f0ee"}.fa-user-md:before{content:"\\f0f0"}.fa-stethoscope:before{content:"\\f0f1"}.fa-suitcase:before{content:"\\f0f2"}.fa-bell-o:before{content:"\\f0a2"}.fa-coffee:before{content:"\\f0f4"}.fa-cutlery:before{content:"\\f0f5"}.fa-file-text-o:before{content:"\\f0f6"}.fa-building-o:before{content:"\\f0f7"}.fa-hospital-o:before{content:"\\f0f8"}.fa-ambulance:before{content:"\\f0f9"}.fa-medkit:before{content:"\\f0fa"}.fa-fighter-jet:before{content:"\\f0fb"}.fa-beer:before{content:"\\f0fc"}.fa-h-square:before{content:"\\f0fd"}.fa-plus-square:before{content:"\\f0fe"}.fa-angle-double-left:before{content:"\\f100"}.fa-angle-double-right:before{content:"\\f101"}.fa-angle-double-up:before{content:"\\f102"}.fa-angle-double-down:before{content:"\\f103"}.fa-angle-left:before{content:"\\f104"}.fa-angle-right:before{content:"\\f105"}.fa-angle-up:before{content:"\\f106"}.fa-angle-down:before{content:"\\f107"}.fa-desktop:before{content:"\\f108"}.fa-laptop:before{content:"\\f109"}.fa-tablet:before{content:"\\f10a"}.fa-mobile-phone:before,.fa-mobile:before{content:"\\f10b"}.fa-circle-o:before{content:"\\f10c"}.fa-quote-left:before{content:"\\f10d"}.fa-quote-right:before{content:"\\f10e"}.fa-spinner:before{content:"\\f110"}.fa-circle:before{content:"\\f111"}.fa-mail-reply:before,.fa-reply:before{content:"\\f112"}.fa-github-alt:before{content:"\\f113"}.fa-folder-o:before{content:"\\f114"}.fa-folder-open-o:before{content:"\\f115"}.fa-smile-o:before{content:"\\f118"}.fa-frown-o:before{content:"\\f119"}.fa-meh-o:before{content:"\\f11a"}.fa-gamepad:before{content:"\\f11b"}.fa-keyboard-o:before{content:"\\f11c"}.fa-flag-o:before{content:"\\f11d"}.fa-flag-checkered:before{content:"\\f11e"}.fa-terminal:before{content:"\\f120"}.fa-code:before{content:"\\f121"}.fa-mail-reply-all:before,.fa-reply-all:before{content:"\\f122"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:"\\f123"}.fa-location-arrow:before{content:"\\f124"}.fa-crop:before{content:"\\f125"}.fa-code-fork:before{content:"\\f126"}.fa-unlink:before,.fa-chain-broken:before{content:"\\f127"}.fa-question:before{content:"\\f128"}.fa-info:before{content:"\\f129"}.fa-exclamation:before{content:"\\f12a"}.fa-superscript:before{content:"\\f12b"}.fa-subscript:before{content:"\\f12c"}.fa-eraser:before{content:"\\f12d"}.fa-puzzle-piece:before{content:"\\f12e"}.fa-microphone:before{content:"\\f130"}.fa-microphone-slash:before{content:"\\f131"}.fa-shield:before{content:"\\f132"}.fa-calendar-o:before{content:"\\f133"}.fa-fire-extinguisher:before{content:"\\f134"}.fa-rocket:before{content:"\\f135"}.fa-maxcdn:before{content:"\\f136"}.fa-chevron-circle-left:before{content:"\\f137"}.fa-chevron-circle-right:before{content:"\\f138"}.fa-chevron-circle-up:before{content:"\\f139"}.fa-chevron-circle-down:before{content:"\\f13a"}.fa-html5:before{content:"\\f13b"}.fa-css3:before{content:"\\f13c"}.fa-anchor:before{content:"\\f13d"}.fa-unlock-alt:before{content:"\\f13e"}.fa-bullseye:before{content:"\\f140"}.fa-ellipsis-h:before{content:"\\f141"}.fa-ellipsis-v:before{content:"\\f142"}.fa-rss-square:before{content:"\\f143"}.fa-play-circle:before{content:"\\f144"}.fa-ticket:before{content:"\\f145"}.fa-minus-square:before{content:"\\f146"}.fa-minus-square-o:before{content:"\\f147"}.fa-level-up:before{content:"\\f148"}.fa-level-down:before{content:"\\f149"}.fa-check-square:before{content:"\\f14a"}.fa-pencil-square:before{content:"\\f14b"}.fa-external-link-square:before{content:"\\f14c"}.fa-share-square:before{content:"\\f14d"}.fa-compass:before{content:"\\f14e"}.fa-toggle-down:before,.fa-caret-square-o-down:before{content:"\\f150"}.fa-toggle-up:before,.fa-caret-square-o-up:before{content:"\\f151"}.fa-toggle-right:before,.fa-caret-square-o-right:before{content:"\\f152"}.fa-euro:before,.fa-eur:before{content:"\\f153"}.fa-gbp:before{content:"\\f154"}.fa-dollar:before,.fa-usd:before{content:"\\f155"}.fa-rupee:before,.fa-inr:before{content:"\\f156"}.fa-cny:before,.fa-rmb:before,.fa-yen:before,.fa-jpy:before{content:"\\f157"}.fa-ruble:before,.fa-rouble:before,.fa-rub:before{content:"\\f158"}.fa-won:before,.fa-krw:before{content:"\\f159"}.fa-bitcoin:before,.fa-btc:before{content:"\\f15a"}.fa-file:before{content:"\\f15b"}.fa-file-text:before{content:"\\f15c"}.fa-sort-alpha-asc:before{content:"\\f15d"}.fa-sort-alpha-desc:before{content:"\\f15e"}.fa-sort-amount-asc:before{content:"\\f160"}.fa-sort-amount-desc:before{content:"\\f161"}.fa-sort-numeric-asc:before{content:"\\f162"}.fa-sort-numeric-desc:before{content:"\\f163"}.fa-thumbs-up:before{content:"\\f164"}.fa-thumbs-down:before{content:"\\f165"}.fa-youtube-square:before{content:"\\f166"}.fa-youtube:before{content:"\\f167"}.fa-xing:before{content:"\\f168"}.fa-xing-square:before{content:"\\f169"}.fa-youtube-play:before{content:"\\f16a"}.fa-dropbox:before{content:"\\f16b"}.fa-stack-overflow:before{content:"\\f16c"}.fa-instagram:before{content:"\\f16d"}.fa-flickr:before{content:"\\f16e"}.fa-adn:before{content:"\\f170"}.fa-bitbucket:before{content:"\\f171"}.fa-bitbucket-square:before{content:"\\f172"}.fa-tumblr:before{content:"\\f173"}.fa-tumblr-square:before{content:"\\f174"}.fa-long-arrow-down:before{content:"\\f175"}.fa-long-arrow-up:before{content:"\\f176"}.fa-long-arrow-left:before{content:"\\f177"}.fa-long-arrow-right:before{content:"\\f178"}.fa-apple:before{content:"\\f179"}.fa-windows:before{content:"\\f17a"}.fa-android:before{content:"\\f17b"}.fa-linux:before{content:"\\f17c"}.fa-dribbble:before{content:"\\f17d"}.fa-skype:before{content:"\\f17e"}.fa-foursquare:before{content:"\\f180"}.fa-trello:before{content:"\\f181"}.fa-female:before{content:"\\f182"}.fa-male:before{content:"\\f183"}.fa-gittip:before,.fa-gratipay:before{content:"\\f184"}.fa-sun-o:before{content:"\\f185"}.fa-moon-o:before{content:"\\f186"}.fa-archive:before{content:"\\f187"}.fa-bug:before{content:"\\f188"}.fa-vk:before{content:"\\f189"}.fa-weibo:before{content:"\\f18a"}.fa-renren:before{content:"\\f18b"}.fa-pagelines:before{content:"\\f18c"}.fa-stack-exchange:before{content:"\\f18d"}.fa-arrow-circle-o-right:before{content:"\\f18e"}.fa-arrow-circle-o-left:before{content:"\\f190"}.fa-toggle-left:before,.fa-caret-square-o-left:before{content:"\\f191"}.fa-dot-circle-o:before{content:"\\f192"}.fa-wheelchair:before{content:"\\f193"}.fa-vimeo-square:before{content:"\\f194"}.fa-turkish-lira:before,.fa-try:before{content:"\\f195"}.fa-plus-square-o:before{content:"\\f196"}.fa-space-shuttle:before{content:"\\f197"}.fa-slack:before{content:"\\f198"}.fa-envelope-square:before{content:"\\f199"}.fa-wordpress:before{content:"\\f19a"}.fa-openid:before{content:"\\f19b"}.fa-institution:before,.fa-bank:before,.fa-university:before{content:"\\f19c"}.fa-mortar-board:before,.fa-graduation-cap:before{content:"\\f19d"}.fa-yahoo:before{content:"\\f19e"}.fa-google:before{content:"\\f1a0"}.fa-reddit:before{content:"\\f1a1"}.fa-reddit-square:before{content:"\\f1a2"}.fa-stumbleupon-circle:before{content:"\\f1a3"}.fa-stumbleupon:before{content:"\\f1a4"}.fa-delicious:before{content:"\\f1a5"}.fa-digg:before{content:"\\f1a6"}.fa-pied-piper-pp:before{content:"\\f1a7"}.fa-pied-piper-alt:before{content:"\\f1a8"}.fa-drupal:before{content:"\\f1a9"}.fa-joomla:before{content:"\\f1aa"}.fa-language:before{content:"\\f1ab"}.fa-fax:before{content:"\\f1ac"}.fa-building:before{content:"\\f1ad"}.fa-child:before{content:"\\f1ae"}.fa-paw:before{content:"\\f1b0"}.fa-spoon:before{content:"\\f1b1"}.fa-cube:before{content:"\\f1b2"}.fa-cubes:before{content:"\\f1b3"}.fa-behance:before{content:"\\f1b4"}.fa-behance-square:before{content:"\\f1b5"}.fa-steam:before{content:"\\f1b6"}.fa-steam-square:before{content:"\\f1b7"}.fa-recycle:before{content:"\\f1b8"}.fa-automobile:before,.fa-car:before{content:"\\f1b9"}.fa-cab:before,.fa-taxi:before{content:"\\f1ba"}.fa-tree:before{content:"\\f1bb"}.fa-spotify:before{content:"\\f1bc"}.fa-deviantart:before{content:"\\f1bd"}.fa-soundcloud:before{content:"\\f1be"}.fa-database:before{content:"\\f1c0"}.fa-file-pdf-o:before{content:"\\f1c1"}.fa-file-word-o:before{content:"\\f1c2"}.fa-file-excel-o:before{content:"\\f1c3"}.fa-file-powerpoint-o:before{content:"\\f1c4"}.fa-file-photo-o:before,.fa-file-picture-o:before,.fa-file-image-o:before{content:"\\f1c5"}.fa-file-zip-o:before,.fa-file-archive-o:before{content:"\\f1c6"}.fa-file-sound-o:before,.fa-file-audio-o:before{content:"\\f1c7"}.fa-file-movie-o:before,.fa-file-video-o:before{content:"\\f1c8"}.fa-file-code-o:before{content:"\\f1c9"}.fa-vine:before{content:"\\f1ca"}.fa-codepen:before{content:"\\f1cb"}.fa-jsfiddle:before{content:"\\f1cc"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-saver:before,.fa-support:before,.fa-life-ring:before{content:"\\f1cd"}.fa-circle-o-notch:before{content:"\\f1ce"}.fa-ra:before,.fa-resistance:before,.fa-rebel:before{content:"\\f1d0"}.fa-ge:before,.fa-empire:before{content:"\\f1d1"}.fa-git-square:before{content:"\\f1d2"}.fa-git:before{content:"\\f1d3"}.fa-y-combinator-square:before,.fa-yc-square:before,.fa-hacker-news:before{content:"\\f1d4"}.fa-tencent-weibo:before{content:"\\f1d5"}.fa-qq:before{content:"\\f1d6"}.fa-wechat:before,.fa-weixin:before{content:"\\f1d7"}.fa-send:before,.fa-paper-plane:before{content:"\\f1d8"}.fa-send-o:before,.fa-paper-plane-o:before{content:"\\f1d9"}.fa-history:before{content:"\\f1da"}.fa-circle-thin:before{content:"\\f1db"}.fa-header:before{content:"\\f1dc"}.fa-paragraph:before{content:"\\f1dd"}.fa-sliders:before{content:"\\f1de"}.fa-share-alt:before{content:"\\f1e0"}.fa-share-alt-square:before{content:"\\f1e1"}.fa-bomb:before{content:"\\f1e2"}.fa-soccer-ball-o:before,.fa-futbol-o:before{content:"\\f1e3"}.fa-tty:before{content:"\\f1e4"}.fa-binoculars:before{content:"\\f1e5"}.fa-plug:before{content:"\\f1e6"}.fa-slideshare:before{content:"\\f1e7"}.fa-twitch:before{content:"\\f1e8"}.fa-yelp:before{content:"\\f1e9"}.fa-newspaper-o:before{content:"\\f1ea"}.fa-wifi:before{content:"\\f1eb"}.fa-calculator:before{content:"\\f1ec"}.fa-paypal:before{content:"\\f1ed"}.fa-google-wallet:before{content:"\\f1ee"}.fa-cc-visa:before{content:"\\f1f0"}.fa-cc-mastercard:before{content:"\\f1f1"}.fa-cc-discover:before{content:"\\f1f2"}.fa-cc-amex:before{content:"\\f1f3"}.fa-cc-paypal:before{content:"\\f1f4"}.fa-cc-stripe:before{content:"\\f1f5"}.fa-bell-slash:before{content:"\\f1f6"}.fa-bell-slash-o:before{content:"\\f1f7"}.fa-trash:before{content:"\\f1f8"}.fa-copyright:before{content:"\\f1f9"}.fa-at:before{content:"\\f1fa"}.fa-eyedropper:before{content:"\\f1fb"}.fa-paint-brush:before{content:"\\f1fc"}.fa-birthday-cake:before{content:"\\f1fd"}.fa-area-chart:before{content:"\\f1fe"}.fa-pie-chart:before{content:"\\f200"}.fa-line-chart:before{content:"\\f201"}.fa-lastfm:before{content:"\\f202"}.fa-lastfm-square:before{content:"\\f203"}.fa-toggle-off:before{content:"\\f204"}.fa-toggle-on:before{content:"\\f205"}.fa-bicycle:before{content:"\\f206"}.fa-bus:before{content:"\\f207"}.fa-ioxhost:before{content:"\\f208"}.fa-angellist:before{content:"\\f209"}.fa-cc:before{content:"\\f20a"}.fa-shekel:before,.fa-sheqel:before,.fa-ils:before{content:"\\f20b"}.fa-meanpath:before{content:"\\f20c"}.fa-buysellads:before{content:"\\f20d"}.fa-connectdevelop:before{content:"\\f20e"}.fa-dashcube:before{content:"\\f210"}.fa-forumbee:before{content:"\\f211"}.fa-leanpub:before{content:"\\f212"}.fa-sellsy:before{content:"\\f213"}.fa-shirtsinbulk:before{content:"\\f214"}.fa-simplybuilt:before{content:"\\f215"}.fa-skyatlas:before{content:"\\f216"}.fa-cart-plus:before{content:"\\f217"}.fa-cart-arrow-down:before{content:"\\f218"}.fa-diamond:before{content:"\\f219"}.fa-ship:before{content:"\\f21a"}.fa-user-secret:before{content:"\\f21b"}.fa-motorcycle:before{content:"\\f21c"}.fa-street-view:before{content:"\\f21d"}.fa-heartbeat:before{content:"\\f21e"}.fa-venus:before{content:"\\f221"}.fa-mars:before{content:"\\f222"}.fa-mercury:before{content:"\\f223"}.fa-intersex:before,.fa-transgender:before{content:"\\f224"}.fa-transgender-alt:before{content:"\\f225"}.fa-venus-double:before{content:"\\f226"}.fa-mars-double:before{content:"\\f227"}.fa-venus-mars:before{content:"\\f228"}.fa-mars-stroke:before{content:"\\f229"}.fa-mars-stroke-v:before{content:"\\f22a"}.fa-mars-stroke-h:before{content:"\\f22b"}.fa-neuter:before{content:"\\f22c"}.fa-genderless:before{content:"\\f22d"}.fa-facebook-official:before{content:"\\f230"}.fa-pinterest-p:before{content:"\\f231"}.fa-whatsapp:before{content:"\\f232"}.fa-server:before{content:"\\f233"}.fa-user-plus:before{content:"\\f234"}.fa-user-times:before{content:"\\f235"}.fa-hotel:before,.fa-bed:before{content:"\\f236"}.fa-viacoin:before{content:"\\f237"}.fa-train:before{content:"\\f238"}.fa-subway:before{content:"\\f239"}.fa-medium:before{content:"\\f23a"}.fa-yc:before,.fa-y-combinator:before{content:"\\f23b"}.fa-optin-monster:before{content:"\\f23c"}.fa-opencart:before{content:"\\f23d"}.fa-expeditedssl:before{content:"\\f23e"}.fa-battery-4:before,.fa-battery:before,.fa-battery-full:before{content:"\\f240"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:"\\f241"}.fa-battery-2:before,.fa-battery-half:before{content:"\\f242"}.fa-battery-1:before,.fa-battery-quarter:before{content:"\\f243"}.fa-battery-0:before,.fa-battery-empty:before{content:"\\f244"}.fa-mouse-pointer:before{content:"\\f245"}.fa-i-cursor:before{content:"\\f246"}.fa-object-group:before{content:"\\f247"}.fa-object-ungroup:before{content:"\\f248"}.fa-sticky-note:before{content:"\\f249"}.fa-sticky-note-o:before{content:"\\f24a"}.fa-cc-jcb:before{content:"\\f24b"}.fa-cc-diners-club:before{content:"\\f24c"}.fa-clone:before{content:"\\f24d"}.fa-balance-scale:before{content:"\\f24e"}.fa-hourglass-o:before{content:"\\f250"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:"\\f251"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:"\\f252"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:"\\f253"}.fa-hourglass:before{content:"\\f254"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:"\\f255"}.fa-hand-stop-o:before,.fa-hand-paper-o:before{content:"\\f256"}.fa-hand-scissors-o:before{content:"\\f257"}.fa-hand-lizard-o:before{content:"\\f258"}.fa-hand-spock-o:before{content:"\\f259"}.fa-hand-pointer-o:before{content:"\\f25a"}.fa-hand-peace-o:before{content:"\\f25b"}.fa-trademark:before{content:"\\f25c"}.fa-registered:before{content:"\\f25d"}.fa-creative-commons:before{content:"\\f25e"}.fa-gg:before{content:"\\f260"}.fa-gg-circle:before{content:"\\f261"}.fa-tripadvisor:before{content:"\\f262"}.fa-odnoklassniki:before{content:"\\f263"}.fa-odnoklassniki-square:before{content:"\\f264"}.fa-get-pocket:before{content:"\\f265"}.fa-wikipedia-w:before{content:"\\f266"}.fa-safari:before{content:"\\f267"}.fa-chrome:before{content:"\\f268"}.fa-firefox:before{content:"\\f269"}.fa-opera:before{content:"\\f26a"}.fa-internet-explorer:before{content:"\\f26b"}.fa-tv:before,.fa-television:before{content:"\\f26c"}.fa-contao:before{content:"\\f26d"}.fa-500px:before{content:"\\f26e"}.fa-amazon:before{content:"\\f270"}.fa-calendar-plus-o:before{content:"\\f271"}.fa-calendar-minus-o:before{content:"\\f272"}.fa-calendar-times-o:before{content:"\\f273"}.fa-calendar-check-o:before{content:"\\f274"}.fa-industry:before{content:"\\f275"}.fa-map-pin:before{content:"\\f276"}.fa-map-signs:before{content:"\\f277"}.fa-map-o:before{content:"\\f278"}.fa-map:before{content:"\\f279"}.fa-commenting:before{content:"\\f27a"}.fa-commenting-o:before{content:"\\f27b"}.fa-houzz:before{content:"\\f27c"}.fa-vimeo:before{content:"\\f27d"}.fa-black-tie:before{content:"\\f27e"}.fa-fonticons:before{content:"\\f280"}.fa-reddit-alien:before{content:"\\f281"}.fa-edge:before{content:"\\f282"}.fa-credit-card-alt:before{content:"\\f283"}.fa-codiepie:before{content:"\\f284"}.fa-modx:before{content:"\\f285"}.fa-fort-awesome:before{content:"\\f286"}.fa-usb:before{content:"\\f287"}.fa-product-hunt:before{content:"\\f288"}.fa-mixcloud:before{content:"\\f289"}.fa-scribd:before{content:"\\f28a"}.fa-pause-circle:before{content:"\\f28b"}.fa-pause-circle-o:before{content:"\\f28c"}.fa-stop-circle:before{content:"\\f28d"}.fa-stop-circle-o:before{content:"\\f28e"}.fa-shopping-bag:before{content:"\\f290"}.fa-shopping-basket:before{content:"\\f291"}.fa-hashtag:before{content:"\\f292"}.fa-bluetooth:before{content:"\\f293"}.fa-bluetooth-b:before{content:"\\f294"}.fa-percent:before{content:"\\f295"}.fa-gitlab:before{content:"\\f296"}.fa-wpbeginner:before{content:"\\f297"}.fa-wpforms:before{content:"\\f298"}.fa-envira:before{content:"\\f299"}.fa-universal-access:before{content:"\\f29a"}.fa-wheelchair-alt:before{content:"\\f29b"}.fa-question-circle-o:before{content:"\\f29c"}.fa-blind:before{content:"\\f29d"}.fa-audio-description:before{content:"\\f29e"}.fa-volume-control-phone:before{content:"\\f2a0"}.fa-braille:before{content:"\\f2a1"}.fa-assistive-listening-systems:before{content:"\\f2a2"}.fa-asl-interpreting:before,.fa-american-sign-language-interpreting:before{content:"\\f2a3"}.fa-deafness:before,.fa-hard-of-hearing:before,.fa-deaf:before{content:"\\f2a4"}.fa-glide:before{content:"\\f2a5"}.fa-glide-g:before{content:"\\f2a6"}.fa-signing:before,.fa-sign-language:before{content:"\\f2a7"}.fa-low-vision:before{content:"\\f2a8"}.fa-viadeo:before{content:"\\f2a9"}.fa-viadeo-square:before{content:"\\f2aa"}.fa-snapchat:before{content:"\\f2ab"}.fa-snapchat-ghost:before{content:"\\f2ac"}.fa-snapchat-square:before{content:"\\f2ad"}.fa-pied-piper:before{content:"\\f2ae"}.fa-first-order:before{content:"\\f2b0"}.fa-yoast:before{content:"\\f2b1"}.fa-themeisle:before{content:"\\f2b2"}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:"\\f2b3"}.fa-fa:before,.fa-font-awesome:before{content:"\\f2b4"}.fa-handshake-o:before{content:"\\f2b5"}.fa-envelope-open:before{content:"\\f2b6"}.fa-envelope-open-o:before{content:"\\f2b7"}.fa-linode:before{content:"\\f2b8"}.fa-address-book:before{content:"\\f2b9"}.fa-address-book-o:before{content:"\\f2ba"}.fa-vcard:before,.fa-address-card:before{content:"\\f2bb"}.fa-vcard-o:before,.fa-address-card-o:before{content:"\\f2bc"}.fa-user-circle:before{content:"\\f2bd"}.fa-user-circle-o:before{content:"\\f2be"}.fa-user-o:before{content:"\\f2c0"}.fa-id-badge:before{content:"\\f2c1"}.fa-drivers-license:before,.fa-id-card:before{content:"\\f2c2"}.fa-drivers-license-o:before,.fa-id-card-o:before{content:"\\f2c3"}.fa-quora:before{content:"\\f2c4"}.fa-free-code-camp:before{content:"\\f2c5"}.fa-telegram:before{content:"\\f2c6"}.fa-thermometer-4:before,.fa-thermometer:before,.fa-thermometer-full:before{content:"\\f2c7"}.fa-thermometer-3:before,.fa-thermometer-three-quarters:before{content:"\\f2c8"}.fa-thermometer-2:before,.fa-thermometer-half:before{content:"\\f2c9"}.fa-thermometer-1:before,.fa-thermometer-quarter:before{content:"\\f2ca"}.fa-thermometer-0:before,.fa-thermometer-empty:before{content:"\\f2cb"}.fa-shower:before{content:"\\f2cc"}.fa-bathtub:before,.fa-s15:before,.fa-bath:before{content:"\\f2cd"}.fa-podcast:before{content:"\\f2ce"}.fa-window-maximize:before{content:"\\f2d0"}.fa-window-minimize:before{content:"\\f2d1"}.fa-window-restore:before{content:"\\f2d2"}.fa-times-rectangle:before,.fa-window-close:before{content:"\\f2d3"}.fa-times-rectangle-o:before,.fa-window-close-o:before{content:"\\f2d4"}.fa-bandcamp:before{content:"\\f2d5"}.fa-grav:before{content:"\\f2d6"}.fa-etsy:before{content:"\\f2d7"}.fa-imdb:before{content:"\\f2d8"}.fa-ravelry:before{content:"\\f2d9"}.fa-eercast:before{content:"\\f2da"}.fa-microchip:before{content:"\\f2db"}.fa-snowflake-o:before{content:"\\f2dc"}.fa-superpowers:before{content:"\\f2dd"}.fa-wpexplorer:before{content:"\\f2de"}.fa-meetup:before{content:"\\f2e0"}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}a{cursor:pointer}.angular-editor-textarea{min-height:150px;overflow:auto;margin-top:5px;resize:vertical}.angular-editor-textarea:after{content:"";position:absolute;bottom:0;right:0;display:block;width:8px;height:8px;cursor:nwse-resize;background-color:#ffffff80}.angular-editor-toolbar{font:100 14px/15px Roboto,Arial,sans-serif;background-color:#f5f5f5;font-size:.8rem;padding:.2rem;border:1px solid #ddd}.angular-editor-toolbar .angular-editor-toolbar-set{display:none;margin-right:5px;vertical-align:baseline}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button{background-color:#fff;vertical-align:middle;border:1px solid #ddd;padding:.4rem;min-width:2rem;float:left}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:focus,.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.focus{outline:0}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label{pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label.foreground :after{background:#555555}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label.background{background:#555555}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.active{background:#fff5b9}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.active:hover{background-color:#fffa98}.angular-editor-toolbar .angular-editor-toolbar-set select{font-size:11px;width:90px;vertical-align:middle;background-color:transparent;border:.5px solid rgba(255,255,255,0);border-radius:5px;outline:none;padding:.4rem;cursor:pointer}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-heading optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading option{border:1px solid;background-color:#fff}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .default{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h1{font-size:24px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h2{font-size:20px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h3{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h4{font-size:15px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h5{font-size:14px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h6{font-size:13px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .div,.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .pre{font-size:12px}}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-font{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-font optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font option{border:1px solid;background-color:#fff}}.angular-editor-toolbar .angular-editor-toolbar-set .select-font:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-font:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size{display:inline-block;width:50px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size option{border:1px solid;background-color:#fff}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size1{font-size:10px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size2{font-size:12px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size3{font-size:14px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size4{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size5{font-size:18px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size6{font-size:20px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size7{font-size:22px}}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style option{border:1px solid;background-color:#fff}}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .color-label{position:relative;cursor:pointer}.angular-editor-toolbar .angular-editor-toolbar-set .background{font-size:smaller;background:#1b1b1b;color:#fff;padding:3px}.angular-editor-toolbar .angular-editor-toolbar-set .foreground :after{position:absolute;content:"";left:-1px;top:auto;bottom:-3px;right:auto;width:15px;height:2px;z-index:0;background:#1b1b1b}.angular-editor-toolbar .angular-editor-toolbar-set:not([style*="display:none"]):not([style*="display: none"]){display:inline-block}\n']
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: AngularEditorService
    }, {
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT2]
      }]
    }];
  }, {
    id: [{
      type: Input
    }],
    uploadUrl: [{
      type: Input
    }],
    upload: [{
      type: Input
    }],
    showToolbar: [{
      type: Input
    }],
    fonts: [{
      type: Input
    }],
    customClasses: [{
      type: Input
    }],
    defaultFontName: [{
      type: Input
    }],
    defaultFontSize: [{
      type: Input
    }],
    hiddenButtons: [{
      type: Input
    }],
    execute: [{
      type: Output
    }],
    myInputFile: [{
      type: ViewChild,
      args: ["fileInput", {
        static: true
      }]
    }]
  });
})();
var AngularEditorComponent = class {
  constructor(r2, editorService, doc, sanitizer, cdRef, defaultTabIndex, autoFocus) {
    this.r = r2;
    this.editorService = editorService;
    this.doc = doc;
    this.sanitizer = sanitizer;
    this.cdRef = cdRef;
    this.autoFocus = autoFocus;
    this.modeVisual = true;
    this.showPlaceholder = false;
    this.disabled = false;
    this.focused = false;
    this.touched = false;
    this.changed = false;
    this.id = "";
    this.config = angularEditorConfig;
    this.placeholder = "";
    this.executeCommandFn = this.executeCommand.bind(this);
    this.viewMode = new EventEmitter();
    this.blurEvent = new EventEmitter();
    this.focusEvent = new EventEmitter();
    this.tabindex = -1;
    const parsedTabIndex = Number(defaultTabIndex);
    this.tabIndex = parsedTabIndex || parsedTabIndex === 0 ? parsedTabIndex : null;
  }
  onFocus() {
    this.focus();
  }
  ngOnInit() {
    this.config.toolbarPosition = this.config.toolbarPosition ? this.config.toolbarPosition : angularEditorConfig.toolbarPosition;
  }
  ngAfterViewInit() {
    if (isDefined(this.autoFocus)) {
      this.focus();
    }
  }
  onPaste(event) {
    if (this.config.rawPaste) {
      event.preventDefault();
      const text2 = event.clipboardData.getData("text/plain");
      document.execCommand("insertHTML", false, text2);
      return text2;
    }
  }
  /**
   * Executed command from editor header buttons
   * @param command string from triggerCommand
   * @param value
   */
  executeCommand(command, value2) {
    this.focus();
    if (command === "focus") {
      return;
    }
    if (command === "toggleEditorMode") {
      this.toggleEditorMode(this.modeVisual);
    } else if (command !== "") {
      if (command === "clear") {
        this.editorService.removeSelectedElements(this.getCustomTags());
        this.onContentChange(this.textArea.nativeElement);
      } else if (command === "default") {
        this.editorService.removeSelectedElements("h1,h2,h3,h4,h5,h6,p,pre");
        this.onContentChange(this.textArea.nativeElement);
      } else {
        this.editorService.executeCommand(command, value2);
      }
      this.exec();
    }
  }
  /**
   * focus event
   */
  onTextAreaFocus(event) {
    if (this.focused) {
      event.stopPropagation();
      return;
    }
    this.focused = true;
    this.focusEvent.emit(event);
    if (!this.touched || !this.changed) {
      this.editorService.executeInNextQueueIteration(() => {
        this.configure();
        this.touched = true;
      });
    }
  }
  /**
   * @description fires when cursor leaves textarea
   */
  onTextAreaMouseOut(event) {
    this.editorService.saveSelection();
  }
  /**
   * blur event
   */
  onTextAreaBlur(event) {
    this.editorService.executeInNextQueueIteration(this.editorService.saveSelection);
    if (typeof this.onTouched === "function") {
      this.onTouched();
    }
    if (event.relatedTarget !== null) {
      const parent = event.relatedTarget.parentElement;
      if (!parent.classList.contains("angular-editor-toolbar-set") && !parent.classList.contains("ae-picker")) {
        this.blurEvent.emit(event);
        this.focused = false;
      }
    }
  }
  /**
   *  focus the text area when the editor is focused
   */
  focus() {
    if (this.modeVisual) {
      this.textArea.nativeElement.focus();
    } else {
      const sourceText = this.doc.getElementById("sourceText" + this.id);
      sourceText.focus();
      this.focused = true;
    }
  }
  /**
   * Executed from the contenteditable section while the input property changes
   * @param element html element from contenteditable
   */
  onContentChange(element) {
    let html = "";
    if (this.modeVisual) {
      html = element.innerHTML;
    } else {
      html = element.innerText;
    }
    if (!html || html === "<br>") {
      html = "";
    }
    if (typeof this.onChange === "function") {
      this.onChange(this.config.sanitize || this.config.sanitize === void 0 ? this.sanitizer.sanitize(SecurityContext.HTML, html) : html);
      if (!html !== this.showPlaceholder) {
        this.togglePlaceholder(this.showPlaceholder);
      }
    }
    this.changed = true;
  }
  /**
   * Set the function to be called
   * when the control receives a change event.
   *
   * @param fn a function
   */
  registerOnChange(fn) {
    this.onChange = (e) => e === "<br>" ? fn("") : fn(e);
  }
  /**
   * Set the function to be called
   * when the control receives a touch event.
   *
   * @param fn a function
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Write a new value to the element.
   *
   * @param value value to be executed when there is a change in contenteditable
   */
  writeValue(value2) {
    if ((!value2 || value2 === "<br>" || value2 === "") !== this.showPlaceholder) {
      this.togglePlaceholder(this.showPlaceholder);
    }
    if (value2 === void 0 || value2 === "" || value2 === "<br>") {
      value2 = null;
    }
    this.refreshView(value2);
  }
  /**
   * refresh view/HTML of the editor
   *
   * @param value html string from the editor
   */
  refreshView(value2) {
    const normalizedValue = value2 === null ? "" : value2;
    this.r.setProperty(this.textArea.nativeElement, "innerHTML", normalizedValue);
    return;
  }
  /**
   * toggles placeholder based on input string
   *
   * @param value A HTML string from the editor
   */
  togglePlaceholder(value2) {
    if (!value2) {
      this.r.addClass(this.editorWrapper.nativeElement, "show-placeholder");
      this.showPlaceholder = true;
    } else {
      this.r.removeClass(this.editorWrapper.nativeElement, "show-placeholder");
      this.showPlaceholder = false;
    }
  }
  /**
   * Implements disabled state for this element
   *
   * @param isDisabled Disabled flag
   */
  setDisabledState(isDisabled) {
    const div = this.textArea.nativeElement;
    const action = isDisabled ? "addClass" : "removeClass";
    this.r[action](div, "disabled");
    this.disabled = isDisabled;
  }
  /**
   * toggles editor mode based on bToSource bool
   *
   * @param bToSource A boolean value from the editor
   */
  toggleEditorMode(bToSource) {
    let oContent;
    const editableElement = this.textArea.nativeElement;
    if (bToSource) {
      oContent = this.r.createText(editableElement.innerHTML);
      this.r.setProperty(editableElement, "innerHTML", "");
      this.r.setProperty(editableElement, "contentEditable", false);
      const oPre = this.r.createElement("pre");
      this.r.setStyle(oPre, "margin", "0");
      this.r.setStyle(oPre, "outline", "none");
      const oCode = this.r.createElement("code");
      this.r.setProperty(oCode, "id", "sourceText" + this.id);
      this.r.setStyle(oCode, "display", "block");
      this.r.setStyle(oCode, "white-space", "pre-wrap");
      this.r.setStyle(oCode, "word-break", "keep-all");
      this.r.setStyle(oCode, "outline", "none");
      this.r.setStyle(oCode, "margin", "0");
      this.r.setStyle(oCode, "background-color", "#fff5b9");
      this.r.setProperty(oCode, "contentEditable", true);
      this.r.appendChild(oCode, oContent);
      this.focusInstance = this.r.listen(oCode, "focus", (event) => this.onTextAreaFocus(event));
      this.blurInstance = this.r.listen(oCode, "blur", (event) => this.onTextAreaBlur(event));
      this.r.appendChild(oPre, oCode);
      this.r.appendChild(editableElement, oPre);
      this.doc.execCommand("defaultParagraphSeparator", false, "div");
      this.modeVisual = false;
      this.viewMode.emit(false);
      oCode.focus();
    } else {
      if (this.doc.querySelectorAll) {
        this.r.setProperty(editableElement, "innerHTML", editableElement.innerText);
      } else {
        oContent = this.doc.createRange();
        oContent.selectNodeContents(editableElement.firstChild);
        this.r.setProperty(editableElement, "innerHTML", oContent.toString());
      }
      this.r.setProperty(editableElement, "contentEditable", true);
      this.modeVisual = true;
      this.viewMode.emit(true);
      this.onContentChange(editableElement);
      editableElement.focus();
    }
    this.editorToolbar.setEditorMode(!this.modeVisual);
  }
  /**
   * toggles editor buttons when cursor moved or positioning
   *
   * Send a node array from the contentEditable of the editor
   */
  exec() {
    this.editorToolbar.triggerButtons();
    let userSelection;
    if (this.doc.getSelection) {
      userSelection = this.doc.getSelection();
      this.editorService.executeInNextQueueIteration(this.editorService.saveSelection);
    }
    let a = userSelection.focusNode;
    const els = [];
    while (a && a.id !== "editor") {
      els.unshift(a);
      a = a.parentNode;
    }
    this.editorToolbar.triggerBlocks(els);
  }
  configure() {
    this.editorService.uploadUrl = this.config.uploadUrl;
    this.editorService.uploadWithCredentials = this.config.uploadWithCredentials;
    if (this.config.defaultParagraphSeparator) {
      this.editorService.setDefaultParagraphSeparator(this.config.defaultParagraphSeparator);
    }
    if (this.config.defaultFontName) {
      this.editorService.setFontName(this.config.defaultFontName);
    }
    if (this.config.defaultFontSize) {
      this.editorService.setFontSize(this.config.defaultFontSize);
    }
  }
  getFonts() {
    const fonts = this.config.fonts ? this.config.fonts : angularEditorConfig.fonts;
    return fonts.map((x4) => {
      return {
        label: x4.name,
        value: x4.name
      };
    });
  }
  getCustomTags() {
    const tags = ["span"];
    this.config.customClasses.forEach((x4) => {
      if (x4.tag !== void 0) {
        if (!tags.includes(x4.tag)) {
          tags.push(x4.tag);
        }
      }
    });
    return tags.join(",");
  }
  ngOnDestroy() {
    if (this.blurInstance) {
      this.blurInstance();
    }
    if (this.focusInstance) {
      this.focusInstance();
    }
  }
  filterStyles(html) {
    html = html.replace("position: fixed;", "");
    return html;
  }
};
AngularEditorComponent.\u0275fac = function AngularEditorComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AngularEditorComponent)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(AngularEditorService), \u0275\u0275directiveInject(DOCUMENT2), \u0275\u0275directiveInject(DomSanitizer), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275injectAttribute("tabindex"), \u0275\u0275injectAttribute("autofocus"));
};
AngularEditorComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: AngularEditorComponent,
  selectors: [["angular-editor"]],
  contentQueries: function AngularEditorComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c5, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.customButtonsTemplateRef = _t.first);
    }
  },
  viewQuery: function AngularEditorComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c6, 7);
      \u0275\u0275viewQuery(_c7, 7);
      \u0275\u0275viewQuery(_c8, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.textArea = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.editorWrapper = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.editorToolbar = _t.first);
    }
  },
  hostVars: 1,
  hostBindings: function AngularEditorComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("focus", function AngularEditorComponent_focus_HostBindingHandler() {
        return ctx.onFocus();
      });
    }
    if (rf & 2) {
      \u0275\u0275attribute("tabindex", ctx.tabindex);
    }
  },
  inputs: {
    id: "id",
    config: "config",
    placeholder: "placeholder",
    tabIndex: "tabIndex"
  },
  outputs: {
    html: "html",
    viewMode: "viewMode",
    blurEvent: "blur",
    focusEvent: "focus"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AngularEditorComponent),
    multi: true
  }, AngularEditorService])],
  decls: 10,
  vars: 19,
  consts: [["angularEditor", ""], ["editorWrapper", ""], ["editor", ""], ["editorToolbar", ""], [1, "angular-editor"], [3, "id", "uploadUrl", "upload", "showToolbar", "fonts", "customClasses", "defaultFontName", "defaultFontSize", "hiddenButtons", "execute", 4, "ngIf"], [1, "angular-editor-wrapper"], [1, "angular-editor-textarea", 3, "input", "focus", "blur", "click", "keyup", "mouseout", "paste"], [1, "angular-editor-placeholder"], [3, "execute", "id", "uploadUrl", "upload", "showToolbar", "fonts", "customClasses", "defaultFontName", "defaultFontSize", "hiddenButtons"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function AngularEditorComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "div", 4, 0);
      \u0275\u0275template(2, AngularEditorComponent_angular_editor_toolbar_2_Template, 3, 13, "angular-editor-toolbar", 5);
      \u0275\u0275elementStart(3, "div", 6, 1)(5, "div", 7, 2);
      \u0275\u0275listener("input", function AngularEditorComponent_Template_div_input_5_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onContentChange($event.target));
      })("focus", function AngularEditorComponent_Template_div_focus_5_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onTextAreaFocus($event));
      })("blur", function AngularEditorComponent_Template_div_blur_5_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onTextAreaBlur($event));
      })("click", function AngularEditorComponent_Template_div_click_5_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.exec());
      })("keyup", function AngularEditorComponent_Template_div_keyup_5_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.exec());
      })("mouseout", function AngularEditorComponent_Template_div_mouseout_5_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onTextAreaMouseOut($event));
      })("paste", function AngularEditorComponent_Template_div_paste_5_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onPaste($event));
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(7, "span", 8);
      \u0275\u0275text(8);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(9, AngularEditorComponent_angular_editor_toolbar_9_Template, 2, 9, "angular-editor-toolbar", 5);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx.config.width)("min-width", ctx.config.minWidth);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.config.toolbarPosition === "top");
      \u0275\u0275advance(3);
      \u0275\u0275styleProp("height", ctx.config.height)("min-height", ctx.config.minHeight)("max-height", ctx.config.maxHeight)("outline", ctx.config.outline === false ? "none" : void 0);
      \u0275\u0275attribute("contenteditable", ctx.config.editable)("tabindex", ctx.disabled ? -1 : ctx.tabIndex)("translate", ctx.config.translate)("spellcheck", ctx.config.spellcheck);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.placeholder || ctx.config["placeholder"]);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.config.toolbarPosition === "bottom");
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, AngularEditorToolbarComponent],
  styles: ['\n\n\n\n@font-face{font-family:FontAwesome;src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?v=4.7.0);src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?#iefix&v=4.7.0) format("embedded-opentype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff2?v=4.7.0) format("woff2"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff?v=4.7.0) format("woff"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.ttf?v=4.7.0) format("truetype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular) format("svg");font-weight:400;font-style:normal}.fa[_ngcontent-%COMP%]{display:inline-block;font: 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg[_ngcontent-%COMP%]{font-size:1.3333333333em;line-height:.75em;vertical-align:-15%}.fa-2x[_ngcontent-%COMP%]{font-size:2em}.fa-3x[_ngcontent-%COMP%]{font-size:3em}.fa-4x[_ngcontent-%COMP%]{font-size:4em}.fa-5x[_ngcontent-%COMP%]{font-size:5em}.fa-fw[_ngcontent-%COMP%]{width:1.2857142857em;text-align:center}.fa-ul[_ngcontent-%COMP%]{padding-left:0;margin-left:2.1428571429em;list-style-type:none}.fa-ul[_ngcontent-%COMP%] > li[_ngcontent-%COMP%]{position:relative}.fa-li[_ngcontent-%COMP%]{position:absolute;left:-2.1428571429em;width:2.1428571429em;top:.1428571429em;text-align:center}.fa-li.fa-lg[_ngcontent-%COMP%]{left:-1.8571428571em}.fa-border[_ngcontent-%COMP%]{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left[_ngcontent-%COMP%]{float:left}.fa-pull-right[_ngcontent-%COMP%]{float:right}.fa.fa-pull-left[_ngcontent-%COMP%]{margin-right:.3em}.fa.fa-pull-right[_ngcontent-%COMP%]{margin-left:.3em}.pull-right[_ngcontent-%COMP%]{float:right}.pull-left[_ngcontent-%COMP%]{float:left}.fa.pull-left[_ngcontent-%COMP%]{margin-right:.3em}.fa.pull-right[_ngcontent-%COMP%]{margin-left:.3em}.fa-spin[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_fa-spin 2s infinite linear}.fa-pulse[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_fa-spin 1s infinite steps(8)}@keyframes _ngcontent-%COMP%_fa-spin{0%{transform:rotate(0)}to{transform:rotate(359deg)}}.fa-rotate-90[_ngcontent-%COMP%]{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";transform:rotate(90deg)}.fa-rotate-180[_ngcontent-%COMP%]{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";transform:rotate(180deg)}.fa-rotate-270[_ngcontent-%COMP%]{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";transform:rotate(270deg)}.fa-flip-horizontal[_ngcontent-%COMP%]{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";transform:scaleX(-1)}.fa-flip-vertical[_ngcontent-%COMP%]{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";transform:scaleY(-1)}[_ngcontent-%COMP%]:root   .fa-rotate-90[_ngcontent-%COMP%], [_ngcontent-%COMP%]:root   .fa-rotate-180[_ngcontent-%COMP%], [_ngcontent-%COMP%]:root   .fa-rotate-270[_ngcontent-%COMP%], [_ngcontent-%COMP%]:root   .fa-flip-horizontal[_ngcontent-%COMP%], [_ngcontent-%COMP%]:root   .fa-flip-vertical[_ngcontent-%COMP%]{filter:none}.fa-stack[_ngcontent-%COMP%]{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x[_ngcontent-%COMP%], .fa-stack-2x[_ngcontent-%COMP%]{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x[_ngcontent-%COMP%]{line-height:inherit}.fa-stack-2x[_ngcontent-%COMP%]{font-size:2em}.fa-inverse[_ngcontent-%COMP%]{color:#fff}.fa-glass[_ngcontent-%COMP%]:before{content:"\\f000"}.fa-music[_ngcontent-%COMP%]:before{content:"\\f001"}.fa-search[_ngcontent-%COMP%]:before{content:"\\f002"}.fa-envelope-o[_ngcontent-%COMP%]:before{content:"\\f003"}.fa-heart[_ngcontent-%COMP%]:before{content:"\\f004"}.fa-star[_ngcontent-%COMP%]:before{content:"\\f005"}.fa-star-o[_ngcontent-%COMP%]:before{content:"\\f006"}.fa-user[_ngcontent-%COMP%]:before{content:"\\f007"}.fa-film[_ngcontent-%COMP%]:before{content:"\\f008"}.fa-th-large[_ngcontent-%COMP%]:before{content:"\\f009"}.fa-th[_ngcontent-%COMP%]:before{content:"\\f00a"}.fa-th-list[_ngcontent-%COMP%]:before{content:"\\f00b"}.fa-check[_ngcontent-%COMP%]:before{content:"\\f00c"}.fa-remove[_ngcontent-%COMP%]:before, .fa-close[_ngcontent-%COMP%]:before, .fa-times[_ngcontent-%COMP%]:before{content:"\\f00d"}.fa-search-plus[_ngcontent-%COMP%]:before{content:"\\f00e"}.fa-search-minus[_ngcontent-%COMP%]:before{content:"\\f010"}.fa-power-off[_ngcontent-%COMP%]:before{content:"\\f011"}.fa-signal[_ngcontent-%COMP%]:before{content:"\\f012"}.fa-gear[_ngcontent-%COMP%]:before, .fa-cog[_ngcontent-%COMP%]:before{content:"\\f013"}.fa-trash-o[_ngcontent-%COMP%]:before{content:"\\f014"}.fa-home[_ngcontent-%COMP%]:before{content:"\\f015"}.fa-file-o[_ngcontent-%COMP%]:before{content:"\\f016"}.fa-clock-o[_ngcontent-%COMP%]:before{content:"\\f017"}.fa-road[_ngcontent-%COMP%]:before{content:"\\f018"}.fa-download[_ngcontent-%COMP%]:before{content:"\\f019"}.fa-arrow-circle-o-down[_ngcontent-%COMP%]:before{content:"\\f01a"}.fa-arrow-circle-o-up[_ngcontent-%COMP%]:before{content:"\\f01b"}.fa-inbox[_ngcontent-%COMP%]:before{content:"\\f01c"}.fa-play-circle-o[_ngcontent-%COMP%]:before{content:"\\f01d"}.fa-rotate-right[_ngcontent-%COMP%]:before, .fa-repeat[_ngcontent-%COMP%]:before{content:"\\f01e"}.fa-refresh[_ngcontent-%COMP%]:before{content:"\\f021"}.fa-list-alt[_ngcontent-%COMP%]:before{content:"\\f022"}.fa-lock[_ngcontent-%COMP%]:before{content:"\\f023"}.fa-flag[_ngcontent-%COMP%]:before{content:"\\f024"}.fa-headphones[_ngcontent-%COMP%]:before{content:"\\f025"}.fa-volume-off[_ngcontent-%COMP%]:before{content:"\\f026"}.fa-volume-down[_ngcontent-%COMP%]:before{content:"\\f027"}.fa-volume-up[_ngcontent-%COMP%]:before{content:"\\f028"}.fa-qrcode[_ngcontent-%COMP%]:before{content:"\\f029"}.fa-barcode[_ngcontent-%COMP%]:before{content:"\\f02a"}.fa-tag[_ngcontent-%COMP%]:before{content:"\\f02b"}.fa-tags[_ngcontent-%COMP%]:before{content:"\\f02c"}.fa-book[_ngcontent-%COMP%]:before{content:"\\f02d"}.fa-bookmark[_ngcontent-%COMP%]:before{content:"\\f02e"}.fa-print[_ngcontent-%COMP%]:before{content:"\\f02f"}.fa-camera[_ngcontent-%COMP%]:before{content:"\\f030"}.fa-font[_ngcontent-%COMP%]:before{content:"\\f031"}.fa-bold[_ngcontent-%COMP%]:before{content:"\\f032"}.fa-italic[_ngcontent-%COMP%]:before{content:"\\f033"}.fa-text-height[_ngcontent-%COMP%]:before{content:"\\f034"}.fa-text-width[_ngcontent-%COMP%]:before{content:"\\f035"}.fa-align-left[_ngcontent-%COMP%]:before{content:"\\f036"}.fa-align-center[_ngcontent-%COMP%]:before{content:"\\f037"}.fa-align-right[_ngcontent-%COMP%]:before{content:"\\f038"}.fa-align-justify[_ngcontent-%COMP%]:before{content:"\\f039"}.fa-list[_ngcontent-%COMP%]:before{content:"\\f03a"}.fa-dedent[_ngcontent-%COMP%]:before, .fa-outdent[_ngcontent-%COMP%]:before{content:"\\f03b"}.fa-indent[_ngcontent-%COMP%]:before{content:"\\f03c"}.fa-video-camera[_ngcontent-%COMP%]:before{content:"\\f03d"}.fa-photo[_ngcontent-%COMP%]:before, .fa-image[_ngcontent-%COMP%]:before, .fa-picture-o[_ngcontent-%COMP%]:before{content:"\\f03e"}.fa-pencil[_ngcontent-%COMP%]:before{content:"\\f040"}.fa-map-marker[_ngcontent-%COMP%]:before{content:"\\f041"}.fa-adjust[_ngcontent-%COMP%]:before{content:"\\f042"}.fa-tint[_ngcontent-%COMP%]:before{content:"\\f043"}.fa-edit[_ngcontent-%COMP%]:before, .fa-pencil-square-o[_ngcontent-%COMP%]:before{content:"\\f044"}.fa-share-square-o[_ngcontent-%COMP%]:before{content:"\\f045"}.fa-check-square-o[_ngcontent-%COMP%]:before{content:"\\f046"}.fa-arrows[_ngcontent-%COMP%]:before{content:"\\f047"}.fa-step-backward[_ngcontent-%COMP%]:before{content:"\\f048"}.fa-fast-backward[_ngcontent-%COMP%]:before{content:"\\f049"}.fa-backward[_ngcontent-%COMP%]:before{content:"\\f04a"}.fa-play[_ngcontent-%COMP%]:before{content:"\\f04b"}.fa-pause[_ngcontent-%COMP%]:before{content:"\\f04c"}.fa-stop[_ngcontent-%COMP%]:before{content:"\\f04d"}.fa-forward[_ngcontent-%COMP%]:before{content:"\\f04e"}.fa-fast-forward[_ngcontent-%COMP%]:before{content:"\\f050"}.fa-step-forward[_ngcontent-%COMP%]:before{content:"\\f051"}.fa-eject[_ngcontent-%COMP%]:before{content:"\\f052"}.fa-chevron-left[_ngcontent-%COMP%]:before{content:"\\f053"}.fa-chevron-right[_ngcontent-%COMP%]:before{content:"\\f054"}.fa-plus-circle[_ngcontent-%COMP%]:before{content:"\\f055"}.fa-minus-circle[_ngcontent-%COMP%]:before{content:"\\f056"}.fa-times-circle[_ngcontent-%COMP%]:before{content:"\\f057"}.fa-check-circle[_ngcontent-%COMP%]:before{content:"\\f058"}.fa-question-circle[_ngcontent-%COMP%]:before{content:"\\f059"}.fa-info-circle[_ngcontent-%COMP%]:before{content:"\\f05a"}.fa-crosshairs[_ngcontent-%COMP%]:before{content:"\\f05b"}.fa-times-circle-o[_ngcontent-%COMP%]:before{content:"\\f05c"}.fa-check-circle-o[_ngcontent-%COMP%]:before{content:"\\f05d"}.fa-ban[_ngcontent-%COMP%]:before{content:"\\f05e"}.fa-arrow-left[_ngcontent-%COMP%]:before{content:"\\f060"}.fa-arrow-right[_ngcontent-%COMP%]:before{content:"\\f061"}.fa-arrow-up[_ngcontent-%COMP%]:before{content:"\\f062"}.fa-arrow-down[_ngcontent-%COMP%]:before{content:"\\f063"}.fa-mail-forward[_ngcontent-%COMP%]:before, .fa-share[_ngcontent-%COMP%]:before{content:"\\f064"}.fa-expand[_ngcontent-%COMP%]:before{content:"\\f065"}.fa-compress[_ngcontent-%COMP%]:before{content:"\\f066"}.fa-plus[_ngcontent-%COMP%]:before{content:"\\f067"}.fa-minus[_ngcontent-%COMP%]:before{content:"\\f068"}.fa-asterisk[_ngcontent-%COMP%]:before{content:"\\f069"}.fa-exclamation-circle[_ngcontent-%COMP%]:before{content:"\\f06a"}.fa-gift[_ngcontent-%COMP%]:before{content:"\\f06b"}.fa-leaf[_ngcontent-%COMP%]:before{content:"\\f06c"}.fa-fire[_ngcontent-%COMP%]:before{content:"\\f06d"}.fa-eye[_ngcontent-%COMP%]:before{content:"\\f06e"}.fa-eye-slash[_ngcontent-%COMP%]:before{content:"\\f070"}.fa-warning[_ngcontent-%COMP%]:before, .fa-exclamation-triangle[_ngcontent-%COMP%]:before{content:"\\f071"}.fa-plane[_ngcontent-%COMP%]:before{content:"\\f072"}.fa-calendar[_ngcontent-%COMP%]:before{content:"\\f073"}.fa-random[_ngcontent-%COMP%]:before{content:"\\f074"}.fa-comment[_ngcontent-%COMP%]:before{content:"\\f075"}.fa-magnet[_ngcontent-%COMP%]:before{content:"\\f076"}.fa-chevron-up[_ngcontent-%COMP%]:before{content:"\\f077"}.fa-chevron-down[_ngcontent-%COMP%]:before{content:"\\f078"}.fa-retweet[_ngcontent-%COMP%]:before{content:"\\f079"}.fa-shopping-cart[_ngcontent-%COMP%]:before{content:"\\f07a"}.fa-folder[_ngcontent-%COMP%]:before{content:"\\f07b"}.fa-folder-open[_ngcontent-%COMP%]:before{content:"\\f07c"}.fa-arrows-v[_ngcontent-%COMP%]:before{content:"\\f07d"}.fa-arrows-h[_ngcontent-%COMP%]:before{content:"\\f07e"}.fa-bar-chart-o[_ngcontent-%COMP%]:before, .fa-bar-chart[_ngcontent-%COMP%]:before{content:"\\f080"}.fa-twitter-square[_ngcontent-%COMP%]:before{content:"\\f081"}.fa-facebook-square[_ngcontent-%COMP%]:before{content:"\\f082"}.fa-camera-retro[_ngcontent-%COMP%]:before{content:"\\f083"}.fa-key[_ngcontent-%COMP%]:before{content:"\\f084"}.fa-gears[_ngcontent-%COMP%]:before, .fa-cogs[_ngcontent-%COMP%]:before{content:"\\f085"}.fa-comments[_ngcontent-%COMP%]:before{content:"\\f086"}.fa-thumbs-o-up[_ngcontent-%COMP%]:before{content:"\\f087"}.fa-thumbs-o-down[_ngcontent-%COMP%]:before{content:"\\f088"}.fa-star-half[_ngcontent-%COMP%]:before{content:"\\f089"}.fa-heart-o[_ngcontent-%COMP%]:before{content:"\\f08a"}.fa-sign-out[_ngcontent-%COMP%]:before{content:"\\f08b"}.fa-linkedin-square[_ngcontent-%COMP%]:before{content:"\\f08c"}.fa-thumb-tack[_ngcontent-%COMP%]:before{content:"\\f08d"}.fa-external-link[_ngcontent-%COMP%]:before{content:"\\f08e"}.fa-sign-in[_ngcontent-%COMP%]:before{content:"\\f090"}.fa-trophy[_ngcontent-%COMP%]:before{content:"\\f091"}.fa-github-square[_ngcontent-%COMP%]:before{content:"\\f092"}.fa-upload[_ngcontent-%COMP%]:before{content:"\\f093"}.fa-lemon-o[_ngcontent-%COMP%]:before{content:"\\f094"}.fa-phone[_ngcontent-%COMP%]:before{content:"\\f095"}.fa-square-o[_ngcontent-%COMP%]:before{content:"\\f096"}.fa-bookmark-o[_ngcontent-%COMP%]:before{content:"\\f097"}.fa-phone-square[_ngcontent-%COMP%]:before{content:"\\f098"}.fa-twitter[_ngcontent-%COMP%]:before{content:"\\f099"}.fa-facebook-f[_ngcontent-%COMP%]:before, .fa-facebook[_ngcontent-%COMP%]:before{content:"\\f09a"}.fa-github[_ngcontent-%COMP%]:before{content:"\\f09b"}.fa-unlock[_ngcontent-%COMP%]:before{content:"\\f09c"}.fa-credit-card[_ngcontent-%COMP%]:before{content:"\\f09d"}.fa-feed[_ngcontent-%COMP%]:before, .fa-rss[_ngcontent-%COMP%]:before{content:"\\f09e"}.fa-hdd-o[_ngcontent-%COMP%]:before{content:"\\f0a0"}.fa-bullhorn[_ngcontent-%COMP%]:before{content:"\\f0a1"}.fa-bell[_ngcontent-%COMP%]:before{content:"\\f0f3"}.fa-certificate[_ngcontent-%COMP%]:before{content:"\\f0a3"}.fa-hand-o-right[_ngcontent-%COMP%]:before{content:"\\f0a4"}.fa-hand-o-left[_ngcontent-%COMP%]:before{content:"\\f0a5"}.fa-hand-o-up[_ngcontent-%COMP%]:before{content:"\\f0a6"}.fa-hand-o-down[_ngcontent-%COMP%]:before{content:"\\f0a7"}.fa-arrow-circle-left[_ngcontent-%COMP%]:before{content:"\\f0a8"}.fa-arrow-circle-right[_ngcontent-%COMP%]:before{content:"\\f0a9"}.fa-arrow-circle-up[_ngcontent-%COMP%]:before{content:"\\f0aa"}.fa-arrow-circle-down[_ngcontent-%COMP%]:before{content:"\\f0ab"}.fa-globe[_ngcontent-%COMP%]:before{content:"\\f0ac"}.fa-wrench[_ngcontent-%COMP%]:before{content:"\\f0ad"}.fa-tasks[_ngcontent-%COMP%]:before{content:"\\f0ae"}.fa-filter[_ngcontent-%COMP%]:before{content:"\\f0b0"}.fa-briefcase[_ngcontent-%COMP%]:before{content:"\\f0b1"}.fa-arrows-alt[_ngcontent-%COMP%]:before{content:"\\f0b2"}.fa-group[_ngcontent-%COMP%]:before, .fa-users[_ngcontent-%COMP%]:before{content:"\\f0c0"}.fa-chain[_ngcontent-%COMP%]:before, .fa-link[_ngcontent-%COMP%]:before{content:"\\f0c1"}.fa-cloud[_ngcontent-%COMP%]:before{content:"\\f0c2"}.fa-flask[_ngcontent-%COMP%]:before{content:"\\f0c3"}.fa-cut[_ngcontent-%COMP%]:before, .fa-scissors[_ngcontent-%COMP%]:before{content:"\\f0c4"}.fa-copy[_ngcontent-%COMP%]:before, .fa-files-o[_ngcontent-%COMP%]:before{content:"\\f0c5"}.fa-paperclip[_ngcontent-%COMP%]:before{content:"\\f0c6"}.fa-save[_ngcontent-%COMP%]:before, .fa-floppy-o[_ngcontent-%COMP%]:before{content:"\\f0c7"}.fa-square[_ngcontent-%COMP%]:before{content:"\\f0c8"}.fa-navicon[_ngcontent-%COMP%]:before, .fa-reorder[_ngcontent-%COMP%]:before, .fa-bars[_ngcontent-%COMP%]:before{content:"\\f0c9"}.fa-list-ul[_ngcontent-%COMP%]:before{content:"\\f0ca"}.fa-list-ol[_ngcontent-%COMP%]:before{content:"\\f0cb"}.fa-strikethrough[_ngcontent-%COMP%]:before{content:"\\f0cc"}.fa-underline[_ngcontent-%COMP%]:before{content:"\\f0cd"}.fa-table[_ngcontent-%COMP%]:before{content:"\\f0ce"}.fa-magic[_ngcontent-%COMP%]:before{content:"\\f0d0"}.fa-truck[_ngcontent-%COMP%]:before{content:"\\f0d1"}.fa-pinterest[_ngcontent-%COMP%]:before{content:"\\f0d2"}.fa-pinterest-square[_ngcontent-%COMP%]:before{content:"\\f0d3"}.fa-google-plus-square[_ngcontent-%COMP%]:before{content:"\\f0d4"}.fa-google-plus[_ngcontent-%COMP%]:before{content:"\\f0d5"}.fa-money[_ngcontent-%COMP%]:before{content:"\\f0d6"}.fa-caret-down[_ngcontent-%COMP%]:before{content:"\\f0d7"}.fa-caret-up[_ngcontent-%COMP%]:before{content:"\\f0d8"}.fa-caret-left[_ngcontent-%COMP%]:before{content:"\\f0d9"}.fa-caret-right[_ngcontent-%COMP%]:before{content:"\\f0da"}.fa-columns[_ngcontent-%COMP%]:before{content:"\\f0db"}.fa-unsorted[_ngcontent-%COMP%]:before, .fa-sort[_ngcontent-%COMP%]:before{content:"\\f0dc"}.fa-sort-down[_ngcontent-%COMP%]:before, .fa-sort-desc[_ngcontent-%COMP%]:before{content:"\\f0dd"}.fa-sort-up[_ngcontent-%COMP%]:before, .fa-sort-asc[_ngcontent-%COMP%]:before{content:"\\f0de"}.fa-envelope[_ngcontent-%COMP%]:before{content:"\\f0e0"}.fa-linkedin[_ngcontent-%COMP%]:before{content:"\\f0e1"}.fa-rotate-left[_ngcontent-%COMP%]:before, .fa-undo[_ngcontent-%COMP%]:before{content:"\\f0e2"}.fa-legal[_ngcontent-%COMP%]:before, .fa-gavel[_ngcontent-%COMP%]:before{content:"\\f0e3"}.fa-dashboard[_ngcontent-%COMP%]:before, .fa-tachometer[_ngcontent-%COMP%]:before{content:"\\f0e4"}.fa-comment-o[_ngcontent-%COMP%]:before{content:"\\f0e5"}.fa-comments-o[_ngcontent-%COMP%]:before{content:"\\f0e6"}.fa-flash[_ngcontent-%COMP%]:before, .fa-bolt[_ngcontent-%COMP%]:before{content:"\\f0e7"}.fa-sitemap[_ngcontent-%COMP%]:before{content:"\\f0e8"}.fa-umbrella[_ngcontent-%COMP%]:before{content:"\\f0e9"}.fa-paste[_ngcontent-%COMP%]:before, .fa-clipboard[_ngcontent-%COMP%]:before{content:"\\f0ea"}.fa-lightbulb-o[_ngcontent-%COMP%]:before{content:"\\f0eb"}.fa-exchange[_ngcontent-%COMP%]:before{content:"\\f0ec"}.fa-cloud-download[_ngcontent-%COMP%]:before{content:"\\f0ed"}.fa-cloud-upload[_ngcontent-%COMP%]:before{content:"\\f0ee"}.fa-user-md[_ngcontent-%COMP%]:before{content:"\\f0f0"}.fa-stethoscope[_ngcontent-%COMP%]:before{content:"\\f0f1"}.fa-suitcase[_ngcontent-%COMP%]:before{content:"\\f0f2"}.fa-bell-o[_ngcontent-%COMP%]:before{content:"\\f0a2"}.fa-coffee[_ngcontent-%COMP%]:before{content:"\\f0f4"}.fa-cutlery[_ngcontent-%COMP%]:before{content:"\\f0f5"}.fa-file-text-o[_ngcontent-%COMP%]:before{content:"\\f0f6"}.fa-building-o[_ngcontent-%COMP%]:before{content:"\\f0f7"}.fa-hospital-o[_ngcontent-%COMP%]:before{content:"\\f0f8"}.fa-ambulance[_ngcontent-%COMP%]:before{content:"\\f0f9"}.fa-medkit[_ngcontent-%COMP%]:before{content:"\\f0fa"}.fa-fighter-jet[_ngcontent-%COMP%]:before{content:"\\f0fb"}.fa-beer[_ngcontent-%COMP%]:before{content:"\\f0fc"}.fa-h-square[_ngcontent-%COMP%]:before{content:"\\f0fd"}.fa-plus-square[_ngcontent-%COMP%]:before{content:"\\f0fe"}.fa-angle-double-left[_ngcontent-%COMP%]:before{content:"\\f100"}.fa-angle-double-right[_ngcontent-%COMP%]:before{content:"\\f101"}.fa-angle-double-up[_ngcontent-%COMP%]:before{content:"\\f102"}.fa-angle-double-down[_ngcontent-%COMP%]:before{content:"\\f103"}.fa-angle-left[_ngcontent-%COMP%]:before{content:"\\f104"}.fa-angle-right[_ngcontent-%COMP%]:before{content:"\\f105"}.fa-angle-up[_ngcontent-%COMP%]:before{content:"\\f106"}.fa-angle-down[_ngcontent-%COMP%]:before{content:"\\f107"}.fa-desktop[_ngcontent-%COMP%]:before{content:"\\f108"}.fa-laptop[_ngcontent-%COMP%]:before{content:"\\f109"}.fa-tablet[_ngcontent-%COMP%]:before{content:"\\f10a"}.fa-mobile-phone[_ngcontent-%COMP%]:before, .fa-mobile[_ngcontent-%COMP%]:before{content:"\\f10b"}.fa-circle-o[_ngcontent-%COMP%]:before{content:"\\f10c"}.fa-quote-left[_ngcontent-%COMP%]:before{content:"\\f10d"}.fa-quote-right[_ngcontent-%COMP%]:before{content:"\\f10e"}.fa-spinner[_ngcontent-%COMP%]:before{content:"\\f110"}.fa-circle[_ngcontent-%COMP%]:before{content:"\\f111"}.fa-mail-reply[_ngcontent-%COMP%]:before, .fa-reply[_ngcontent-%COMP%]:before{content:"\\f112"}.fa-github-alt[_ngcontent-%COMP%]:before{content:"\\f113"}.fa-folder-o[_ngcontent-%COMP%]:before{content:"\\f114"}.fa-folder-open-o[_ngcontent-%COMP%]:before{content:"\\f115"}.fa-smile-o[_ngcontent-%COMP%]:before{content:"\\f118"}.fa-frown-o[_ngcontent-%COMP%]:before{content:"\\f119"}.fa-meh-o[_ngcontent-%COMP%]:before{content:"\\f11a"}.fa-gamepad[_ngcontent-%COMP%]:before{content:"\\f11b"}.fa-keyboard-o[_ngcontent-%COMP%]:before{content:"\\f11c"}.fa-flag-o[_ngcontent-%COMP%]:before{content:"\\f11d"}.fa-flag-checkered[_ngcontent-%COMP%]:before{content:"\\f11e"}.fa-terminal[_ngcontent-%COMP%]:before{content:"\\f120"}.fa-code[_ngcontent-%COMP%]:before{content:"\\f121"}.fa-mail-reply-all[_ngcontent-%COMP%]:before, .fa-reply-all[_ngcontent-%COMP%]:before{content:"\\f122"}.fa-star-half-empty[_ngcontent-%COMP%]:before, .fa-star-half-full[_ngcontent-%COMP%]:before, .fa-star-half-o[_ngcontent-%COMP%]:before{content:"\\f123"}.fa-location-arrow[_ngcontent-%COMP%]:before{content:"\\f124"}.fa-crop[_ngcontent-%COMP%]:before{content:"\\f125"}.fa-code-fork[_ngcontent-%COMP%]:before{content:"\\f126"}.fa-unlink[_ngcontent-%COMP%]:before, .fa-chain-broken[_ngcontent-%COMP%]:before{content:"\\f127"}.fa-question[_ngcontent-%COMP%]:before{content:"\\f128"}.fa-info[_ngcontent-%COMP%]:before{content:"\\f129"}.fa-exclamation[_ngcontent-%COMP%]:before{content:"\\f12a"}.fa-superscript[_ngcontent-%COMP%]:before{content:"\\f12b"}.fa-subscript[_ngcontent-%COMP%]:before{content:"\\f12c"}.fa-eraser[_ngcontent-%COMP%]:before{content:"\\f12d"}.fa-puzzle-piece[_ngcontent-%COMP%]:before{content:"\\f12e"}.fa-microphone[_ngcontent-%COMP%]:before{content:"\\f130"}.fa-microphone-slash[_ngcontent-%COMP%]:before{content:"\\f131"}.fa-shield[_ngcontent-%COMP%]:before{content:"\\f132"}.fa-calendar-o[_ngcontent-%COMP%]:before{content:"\\f133"}.fa-fire-extinguisher[_ngcontent-%COMP%]:before{content:"\\f134"}.fa-rocket[_ngcontent-%COMP%]:before{content:"\\f135"}.fa-maxcdn[_ngcontent-%COMP%]:before{content:"\\f136"}.fa-chevron-circle-left[_ngcontent-%COMP%]:before{content:"\\f137"}.fa-chevron-circle-right[_ngcontent-%COMP%]:before{content:"\\f138"}.fa-chevron-circle-up[_ngcontent-%COMP%]:before{content:"\\f139"}.fa-chevron-circle-down[_ngcontent-%COMP%]:before{content:"\\f13a"}.fa-html5[_ngcontent-%COMP%]:before{content:"\\f13b"}.fa-css3[_ngcontent-%COMP%]:before{content:"\\f13c"}.fa-anchor[_ngcontent-%COMP%]:before{content:"\\f13d"}.fa-unlock-alt[_ngcontent-%COMP%]:before{content:"\\f13e"}.fa-bullseye[_ngcontent-%COMP%]:before{content:"\\f140"}.fa-ellipsis-h[_ngcontent-%COMP%]:before{content:"\\f141"}.fa-ellipsis-v[_ngcontent-%COMP%]:before{content:"\\f142"}.fa-rss-square[_ngcontent-%COMP%]:before{content:"\\f143"}.fa-play-circle[_ngcontent-%COMP%]:before{content:"\\f144"}.fa-ticket[_ngcontent-%COMP%]:before{content:"\\f145"}.fa-minus-square[_ngcontent-%COMP%]:before{content:"\\f146"}.fa-minus-square-o[_ngcontent-%COMP%]:before{content:"\\f147"}.fa-level-up[_ngcontent-%COMP%]:before{content:"\\f148"}.fa-level-down[_ngcontent-%COMP%]:before{content:"\\f149"}.fa-check-square[_ngcontent-%COMP%]:before{content:"\\f14a"}.fa-pencil-square[_ngcontent-%COMP%]:before{content:"\\f14b"}.fa-external-link-square[_ngcontent-%COMP%]:before{content:"\\f14c"}.fa-share-square[_ngcontent-%COMP%]:before{content:"\\f14d"}.fa-compass[_ngcontent-%COMP%]:before{content:"\\f14e"}.fa-toggle-down[_ngcontent-%COMP%]:before, .fa-caret-square-o-down[_ngcontent-%COMP%]:before{content:"\\f150"}.fa-toggle-up[_ngcontent-%COMP%]:before, .fa-caret-square-o-up[_ngcontent-%COMP%]:before{content:"\\f151"}.fa-toggle-right[_ngcontent-%COMP%]:before, .fa-caret-square-o-right[_ngcontent-%COMP%]:before{content:"\\f152"}.fa-euro[_ngcontent-%COMP%]:before, .fa-eur[_ngcontent-%COMP%]:before{content:"\\f153"}.fa-gbp[_ngcontent-%COMP%]:before{content:"\\f154"}.fa-dollar[_ngcontent-%COMP%]:before, .fa-usd[_ngcontent-%COMP%]:before{content:"\\f155"}.fa-rupee[_ngcontent-%COMP%]:before, .fa-inr[_ngcontent-%COMP%]:before{content:"\\f156"}.fa-cny[_ngcontent-%COMP%]:before, .fa-rmb[_ngcontent-%COMP%]:before, .fa-yen[_ngcontent-%COMP%]:before, .fa-jpy[_ngcontent-%COMP%]:before{content:"\\f157"}.fa-ruble[_ngcontent-%COMP%]:before, .fa-rouble[_ngcontent-%COMP%]:before, .fa-rub[_ngcontent-%COMP%]:before{content:"\\f158"}.fa-won[_ngcontent-%COMP%]:before, .fa-krw[_ngcontent-%COMP%]:before{content:"\\f159"}.fa-bitcoin[_ngcontent-%COMP%]:before, .fa-btc[_ngcontent-%COMP%]:before{content:"\\f15a"}.fa-file[_ngcontent-%COMP%]:before{content:"\\f15b"}.fa-file-text[_ngcontent-%COMP%]:before{content:"\\f15c"}.fa-sort-alpha-asc[_ngcontent-%COMP%]:before{content:"\\f15d"}.fa-sort-alpha-desc[_ngcontent-%COMP%]:before{content:"\\f15e"}.fa-sort-amount-asc[_ngcontent-%COMP%]:before{content:"\\f160"}.fa-sort-amount-desc[_ngcontent-%COMP%]:before{content:"\\f161"}.fa-sort-numeric-asc[_ngcontent-%COMP%]:before{content:"\\f162"}.fa-sort-numeric-desc[_ngcontent-%COMP%]:before{content:"\\f163"}.fa-thumbs-up[_ngcontent-%COMP%]:before{content:"\\f164"}.fa-thumbs-down[_ngcontent-%COMP%]:before{content:"\\f165"}.fa-youtube-square[_ngcontent-%COMP%]:before{content:"\\f166"}.fa-youtube[_ngcontent-%COMP%]:before{content:"\\f167"}.fa-xing[_ngcontent-%COMP%]:before{content:"\\f168"}.fa-xing-square[_ngcontent-%COMP%]:before{content:"\\f169"}.fa-youtube-play[_ngcontent-%COMP%]:before{content:"\\f16a"}.fa-dropbox[_ngcontent-%COMP%]:before{content:"\\f16b"}.fa-stack-overflow[_ngcontent-%COMP%]:before{content:"\\f16c"}.fa-instagram[_ngcontent-%COMP%]:before{content:"\\f16d"}.fa-flickr[_ngcontent-%COMP%]:before{content:"\\f16e"}.fa-adn[_ngcontent-%COMP%]:before{content:"\\f170"}.fa-bitbucket[_ngcontent-%COMP%]:before{content:"\\f171"}.fa-bitbucket-square[_ngcontent-%COMP%]:before{content:"\\f172"}.fa-tumblr[_ngcontent-%COMP%]:before{content:"\\f173"}.fa-tumblr-square[_ngcontent-%COMP%]:before{content:"\\f174"}.fa-long-arrow-down[_ngcontent-%COMP%]:before{content:"\\f175"}.fa-long-arrow-up[_ngcontent-%COMP%]:before{content:"\\f176"}.fa-long-arrow-left[_ngcontent-%COMP%]:before{content:"\\f177"}.fa-long-arrow-right[_ngcontent-%COMP%]:before{content:"\\f178"}.fa-apple[_ngcontent-%COMP%]:before{content:"\\f179"}.fa-windows[_ngcontent-%COMP%]:before{content:"\\f17a"}.fa-android[_ngcontent-%COMP%]:before{content:"\\f17b"}.fa-linux[_ngcontent-%COMP%]:before{content:"\\f17c"}.fa-dribbble[_ngcontent-%COMP%]:before{content:"\\f17d"}.fa-skype[_ngcontent-%COMP%]:before{content:"\\f17e"}.fa-foursquare[_ngcontent-%COMP%]:before{content:"\\f180"}.fa-trello[_ngcontent-%COMP%]:before{content:"\\f181"}.fa-female[_ngcontent-%COMP%]:before{content:"\\f182"}.fa-male[_ngcontent-%COMP%]:before{content:"\\f183"}.fa-gittip[_ngcontent-%COMP%]:before, .fa-gratipay[_ngcontent-%COMP%]:before{content:"\\f184"}.fa-sun-o[_ngcontent-%COMP%]:before{content:"\\f185"}.fa-moon-o[_ngcontent-%COMP%]:before{content:"\\f186"}.fa-archive[_ngcontent-%COMP%]:before{content:"\\f187"}.fa-bug[_ngcontent-%COMP%]:before{content:"\\f188"}.fa-vk[_ngcontent-%COMP%]:before{content:"\\f189"}.fa-weibo[_ngcontent-%COMP%]:before{content:"\\f18a"}.fa-renren[_ngcontent-%COMP%]:before{content:"\\f18b"}.fa-pagelines[_ngcontent-%COMP%]:before{content:"\\f18c"}.fa-stack-exchange[_ngcontent-%COMP%]:before{content:"\\f18d"}.fa-arrow-circle-o-right[_ngcontent-%COMP%]:before{content:"\\f18e"}.fa-arrow-circle-o-left[_ngcontent-%COMP%]:before{content:"\\f190"}.fa-toggle-left[_ngcontent-%COMP%]:before, .fa-caret-square-o-left[_ngcontent-%COMP%]:before{content:"\\f191"}.fa-dot-circle-o[_ngcontent-%COMP%]:before{content:"\\f192"}.fa-wheelchair[_ngcontent-%COMP%]:before{content:"\\f193"}.fa-vimeo-square[_ngcontent-%COMP%]:before{content:"\\f194"}.fa-turkish-lira[_ngcontent-%COMP%]:before, .fa-try[_ngcontent-%COMP%]:before{content:"\\f195"}.fa-plus-square-o[_ngcontent-%COMP%]:before{content:"\\f196"}.fa-space-shuttle[_ngcontent-%COMP%]:before{content:"\\f197"}.fa-slack[_ngcontent-%COMP%]:before{content:"\\f198"}.fa-envelope-square[_ngcontent-%COMP%]:before{content:"\\f199"}.fa-wordpress[_ngcontent-%COMP%]:before{content:"\\f19a"}.fa-openid[_ngcontent-%COMP%]:before{content:"\\f19b"}.fa-institution[_ngcontent-%COMP%]:before, .fa-bank[_ngcontent-%COMP%]:before, .fa-university[_ngcontent-%COMP%]:before{content:"\\f19c"}.fa-mortar-board[_ngcontent-%COMP%]:before, .fa-graduation-cap[_ngcontent-%COMP%]:before{content:"\\f19d"}.fa-yahoo[_ngcontent-%COMP%]:before{content:"\\f19e"}.fa-google[_ngcontent-%COMP%]:before{content:"\\f1a0"}.fa-reddit[_ngcontent-%COMP%]:before{content:"\\f1a1"}.fa-reddit-square[_ngcontent-%COMP%]:before{content:"\\f1a2"}.fa-stumbleupon-circle[_ngcontent-%COMP%]:before{content:"\\f1a3"}.fa-stumbleupon[_ngcontent-%COMP%]:before{content:"\\f1a4"}.fa-delicious[_ngcontent-%COMP%]:before{content:"\\f1a5"}.fa-digg[_ngcontent-%COMP%]:before{content:"\\f1a6"}.fa-pied-piper-pp[_ngcontent-%COMP%]:before{content:"\\f1a7"}.fa-pied-piper-alt[_ngcontent-%COMP%]:before{content:"\\f1a8"}.fa-drupal[_ngcontent-%COMP%]:before{content:"\\f1a9"}.fa-joomla[_ngcontent-%COMP%]:before{content:"\\f1aa"}.fa-language[_ngcontent-%COMP%]:before{content:"\\f1ab"}.fa-fax[_ngcontent-%COMP%]:before{content:"\\f1ac"}.fa-building[_ngcontent-%COMP%]:before{content:"\\f1ad"}.fa-child[_ngcontent-%COMP%]:before{content:"\\f1ae"}.fa-paw[_ngcontent-%COMP%]:before{content:"\\f1b0"}.fa-spoon[_ngcontent-%COMP%]:before{content:"\\f1b1"}.fa-cube[_ngcontent-%COMP%]:before{content:"\\f1b2"}.fa-cubes[_ngcontent-%COMP%]:before{content:"\\f1b3"}.fa-behance[_ngcontent-%COMP%]:before{content:"\\f1b4"}.fa-behance-square[_ngcontent-%COMP%]:before{content:"\\f1b5"}.fa-steam[_ngcontent-%COMP%]:before{content:"\\f1b6"}.fa-steam-square[_ngcontent-%COMP%]:before{content:"\\f1b7"}.fa-recycle[_ngcontent-%COMP%]:before{content:"\\f1b8"}.fa-automobile[_ngcontent-%COMP%]:before, .fa-car[_ngcontent-%COMP%]:before{content:"\\f1b9"}.fa-cab[_ngcontent-%COMP%]:before, .fa-taxi[_ngcontent-%COMP%]:before{content:"\\f1ba"}.fa-tree[_ngcontent-%COMP%]:before{content:"\\f1bb"}.fa-spotify[_ngcontent-%COMP%]:before{content:"\\f1bc"}.fa-deviantart[_ngcontent-%COMP%]:before{content:"\\f1bd"}.fa-soundcloud[_ngcontent-%COMP%]:before{content:"\\f1be"}.fa-database[_ngcontent-%COMP%]:before{content:"\\f1c0"}.fa-file-pdf-o[_ngcontent-%COMP%]:before{content:"\\f1c1"}.fa-file-word-o[_ngcontent-%COMP%]:before{content:"\\f1c2"}.fa-file-excel-o[_ngcontent-%COMP%]:before{content:"\\f1c3"}.fa-file-powerpoint-o[_ngcontent-%COMP%]:before{content:"\\f1c4"}.fa-file-photo-o[_ngcontent-%COMP%]:before, .fa-file-picture-o[_ngcontent-%COMP%]:before, .fa-file-image-o[_ngcontent-%COMP%]:before{content:"\\f1c5"}.fa-file-zip-o[_ngcontent-%COMP%]:before, .fa-file-archive-o[_ngcontent-%COMP%]:before{content:"\\f1c6"}.fa-file-sound-o[_ngcontent-%COMP%]:before, .fa-file-audio-o[_ngcontent-%COMP%]:before{content:"\\f1c7"}.fa-file-movie-o[_ngcontent-%COMP%]:before, .fa-file-video-o[_ngcontent-%COMP%]:before{content:"\\f1c8"}.fa-file-code-o[_ngcontent-%COMP%]:before{content:"\\f1c9"}.fa-vine[_ngcontent-%COMP%]:before{content:"\\f1ca"}.fa-codepen[_ngcontent-%COMP%]:before{content:"\\f1cb"}.fa-jsfiddle[_ngcontent-%COMP%]:before{content:"\\f1cc"}.fa-life-bouy[_ngcontent-%COMP%]:before, .fa-life-buoy[_ngcontent-%COMP%]:before, .fa-life-saver[_ngcontent-%COMP%]:before, .fa-support[_ngcontent-%COMP%]:before, .fa-life-ring[_ngcontent-%COMP%]:before{content:"\\f1cd"}.fa-circle-o-notch[_ngcontent-%COMP%]:before{content:"\\f1ce"}.fa-ra[_ngcontent-%COMP%]:before, .fa-resistance[_ngcontent-%COMP%]:before, .fa-rebel[_ngcontent-%COMP%]:before{content:"\\f1d0"}.fa-ge[_ngcontent-%COMP%]:before, .fa-empire[_ngcontent-%COMP%]:before{content:"\\f1d1"}.fa-git-square[_ngcontent-%COMP%]:before{content:"\\f1d2"}.fa-git[_ngcontent-%COMP%]:before{content:"\\f1d3"}.fa-y-combinator-square[_ngcontent-%COMP%]:before, .fa-yc-square[_ngcontent-%COMP%]:before, .fa-hacker-news[_ngcontent-%COMP%]:before{content:"\\f1d4"}.fa-tencent-weibo[_ngcontent-%COMP%]:before{content:"\\f1d5"}.fa-qq[_ngcontent-%COMP%]:before{content:"\\f1d6"}.fa-wechat[_ngcontent-%COMP%]:before, .fa-weixin[_ngcontent-%COMP%]:before{content:"\\f1d7"}.fa-send[_ngcontent-%COMP%]:before, .fa-paper-plane[_ngcontent-%COMP%]:before{content:"\\f1d8"}.fa-send-o[_ngcontent-%COMP%]:before, .fa-paper-plane-o[_ngcontent-%COMP%]:before{content:"\\f1d9"}.fa-history[_ngcontent-%COMP%]:before{content:"\\f1da"}.fa-circle-thin[_ngcontent-%COMP%]:before{content:"\\f1db"}.fa-header[_ngcontent-%COMP%]:before{content:"\\f1dc"}.fa-paragraph[_ngcontent-%COMP%]:before{content:"\\f1dd"}.fa-sliders[_ngcontent-%COMP%]:before{content:"\\f1de"}.fa-share-alt[_ngcontent-%COMP%]:before{content:"\\f1e0"}.fa-share-alt-square[_ngcontent-%COMP%]:before{content:"\\f1e1"}.fa-bomb[_ngcontent-%COMP%]:before{content:"\\f1e2"}.fa-soccer-ball-o[_ngcontent-%COMP%]:before, .fa-futbol-o[_ngcontent-%COMP%]:before{content:"\\f1e3"}.fa-tty[_ngcontent-%COMP%]:before{content:"\\f1e4"}.fa-binoculars[_ngcontent-%COMP%]:before{content:"\\f1e5"}.fa-plug[_ngcontent-%COMP%]:before{content:"\\f1e6"}.fa-slideshare[_ngcontent-%COMP%]:before{content:"\\f1e7"}.fa-twitch[_ngcontent-%COMP%]:before{content:"\\f1e8"}.fa-yelp[_ngcontent-%COMP%]:before{content:"\\f1e9"}.fa-newspaper-o[_ngcontent-%COMP%]:before{content:"\\f1ea"}.fa-wifi[_ngcontent-%COMP%]:before{content:"\\f1eb"}.fa-calculator[_ngcontent-%COMP%]:before{content:"\\f1ec"}.fa-paypal[_ngcontent-%COMP%]:before{content:"\\f1ed"}.fa-google-wallet[_ngcontent-%COMP%]:before{content:"\\f1ee"}.fa-cc-visa[_ngcontent-%COMP%]:before{content:"\\f1f0"}.fa-cc-mastercard[_ngcontent-%COMP%]:before{content:"\\f1f1"}.fa-cc-discover[_ngcontent-%COMP%]:before{content:"\\f1f2"}.fa-cc-amex[_ngcontent-%COMP%]:before{content:"\\f1f3"}.fa-cc-paypal[_ngcontent-%COMP%]:before{content:"\\f1f4"}.fa-cc-stripe[_ngcontent-%COMP%]:before{content:"\\f1f5"}.fa-bell-slash[_ngcontent-%COMP%]:before{content:"\\f1f6"}.fa-bell-slash-o[_ngcontent-%COMP%]:before{content:"\\f1f7"}.fa-trash[_ngcontent-%COMP%]:before{content:"\\f1f8"}.fa-copyright[_ngcontent-%COMP%]:before{content:"\\f1f9"}.fa-at[_ngcontent-%COMP%]:before{content:"\\f1fa"}.fa-eyedropper[_ngcontent-%COMP%]:before{content:"\\f1fb"}.fa-paint-brush[_ngcontent-%COMP%]:before{content:"\\f1fc"}.fa-birthday-cake[_ngcontent-%COMP%]:before{content:"\\f1fd"}.fa-area-chart[_ngcontent-%COMP%]:before{content:"\\f1fe"}.fa-pie-chart[_ngcontent-%COMP%]:before{content:"\\f200"}.fa-line-chart[_ngcontent-%COMP%]:before{content:"\\f201"}.fa-lastfm[_ngcontent-%COMP%]:before{content:"\\f202"}.fa-lastfm-square[_ngcontent-%COMP%]:before{content:"\\f203"}.fa-toggle-off[_ngcontent-%COMP%]:before{content:"\\f204"}.fa-toggle-on[_ngcontent-%COMP%]:before{content:"\\f205"}.fa-bicycle[_ngcontent-%COMP%]:before{content:"\\f206"}.fa-bus[_ngcontent-%COMP%]:before{content:"\\f207"}.fa-ioxhost[_ngcontent-%COMP%]:before{content:"\\f208"}.fa-angellist[_ngcontent-%COMP%]:before{content:"\\f209"}.fa-cc[_ngcontent-%COMP%]:before{content:"\\f20a"}.fa-shekel[_ngcontent-%COMP%]:before, .fa-sheqel[_ngcontent-%COMP%]:before, .fa-ils[_ngcontent-%COMP%]:before{content:"\\f20b"}.fa-meanpath[_ngcontent-%COMP%]:before{content:"\\f20c"}.fa-buysellads[_ngcontent-%COMP%]:before{content:"\\f20d"}.fa-connectdevelop[_ngcontent-%COMP%]:before{content:"\\f20e"}.fa-dashcube[_ngcontent-%COMP%]:before{content:"\\f210"}.fa-forumbee[_ngcontent-%COMP%]:before{content:"\\f211"}.fa-leanpub[_ngcontent-%COMP%]:before{content:"\\f212"}.fa-sellsy[_ngcontent-%COMP%]:before{content:"\\f213"}.fa-shirtsinbulk[_ngcontent-%COMP%]:before{content:"\\f214"}.fa-simplybuilt[_ngcontent-%COMP%]:before{content:"\\f215"}.fa-skyatlas[_ngcontent-%COMP%]:before{content:"\\f216"}.fa-cart-plus[_ngcontent-%COMP%]:before{content:"\\f217"}.fa-cart-arrow-down[_ngcontent-%COMP%]:before{content:"\\f218"}.fa-diamond[_ngcontent-%COMP%]:before{content:"\\f219"}.fa-ship[_ngcontent-%COMP%]:before{content:"\\f21a"}.fa-user-secret[_ngcontent-%COMP%]:before{content:"\\f21b"}.fa-motorcycle[_ngcontent-%COMP%]:before{content:"\\f21c"}.fa-street-view[_ngcontent-%COMP%]:before{content:"\\f21d"}.fa-heartbeat[_ngcontent-%COMP%]:before{content:"\\f21e"}.fa-venus[_ngcontent-%COMP%]:before{content:"\\f221"}.fa-mars[_ngcontent-%COMP%]:before{content:"\\f222"}.fa-mercury[_ngcontent-%COMP%]:before{content:"\\f223"}.fa-intersex[_ngcontent-%COMP%]:before, .fa-transgender[_ngcontent-%COMP%]:before{content:"\\f224"}.fa-transgender-alt[_ngcontent-%COMP%]:before{content:"\\f225"}.fa-venus-double[_ngcontent-%COMP%]:before{content:"\\f226"}.fa-mars-double[_ngcontent-%COMP%]:before{content:"\\f227"}.fa-venus-mars[_ngcontent-%COMP%]:before{content:"\\f228"}.fa-mars-stroke[_ngcontent-%COMP%]:before{content:"\\f229"}.fa-mars-stroke-v[_ngcontent-%COMP%]:before{content:"\\f22a"}.fa-mars-stroke-h[_ngcontent-%COMP%]:before{content:"\\f22b"}.fa-neuter[_ngcontent-%COMP%]:before{content:"\\f22c"}.fa-genderless[_ngcontent-%COMP%]:before{content:"\\f22d"}.fa-facebook-official[_ngcontent-%COMP%]:before{content:"\\f230"}.fa-pinterest-p[_ngcontent-%COMP%]:before{content:"\\f231"}.fa-whatsapp[_ngcontent-%COMP%]:before{content:"\\f232"}.fa-server[_ngcontent-%COMP%]:before{content:"\\f233"}.fa-user-plus[_ngcontent-%COMP%]:before{content:"\\f234"}.fa-user-times[_ngcontent-%COMP%]:before{content:"\\f235"}.fa-hotel[_ngcontent-%COMP%]:before, .fa-bed[_ngcontent-%COMP%]:before{content:"\\f236"}.fa-viacoin[_ngcontent-%COMP%]:before{content:"\\f237"}.fa-train[_ngcontent-%COMP%]:before{content:"\\f238"}.fa-subway[_ngcontent-%COMP%]:before{content:"\\f239"}.fa-medium[_ngcontent-%COMP%]:before{content:"\\f23a"}.fa-yc[_ngcontent-%COMP%]:before, .fa-y-combinator[_ngcontent-%COMP%]:before{content:"\\f23b"}.fa-optin-monster[_ngcontent-%COMP%]:before{content:"\\f23c"}.fa-opencart[_ngcontent-%COMP%]:before{content:"\\f23d"}.fa-expeditedssl[_ngcontent-%COMP%]:before{content:"\\f23e"}.fa-battery-4[_ngcontent-%COMP%]:before, .fa-battery[_ngcontent-%COMP%]:before, .fa-battery-full[_ngcontent-%COMP%]:before{content:"\\f240"}.fa-battery-3[_ngcontent-%COMP%]:before, .fa-battery-three-quarters[_ngcontent-%COMP%]:before{content:"\\f241"}.fa-battery-2[_ngcontent-%COMP%]:before, .fa-battery-half[_ngcontent-%COMP%]:before{content:"\\f242"}.fa-battery-1[_ngcontent-%COMP%]:before, .fa-battery-quarter[_ngcontent-%COMP%]:before{content:"\\f243"}.fa-battery-0[_ngcontent-%COMP%]:before, .fa-battery-empty[_ngcontent-%COMP%]:before{content:"\\f244"}.fa-mouse-pointer[_ngcontent-%COMP%]:before{content:"\\f245"}.fa-i-cursor[_ngcontent-%COMP%]:before{content:"\\f246"}.fa-object-group[_ngcontent-%COMP%]:before{content:"\\f247"}.fa-object-ungroup[_ngcontent-%COMP%]:before{content:"\\f248"}.fa-sticky-note[_ngcontent-%COMP%]:before{content:"\\f249"}.fa-sticky-note-o[_ngcontent-%COMP%]:before{content:"\\f24a"}.fa-cc-jcb[_ngcontent-%COMP%]:before{content:"\\f24b"}.fa-cc-diners-club[_ngcontent-%COMP%]:before{content:"\\f24c"}.fa-clone[_ngcontent-%COMP%]:before{content:"\\f24d"}.fa-balance-scale[_ngcontent-%COMP%]:before{content:"\\f24e"}.fa-hourglass-o[_ngcontent-%COMP%]:before{content:"\\f250"}.fa-hourglass-1[_ngcontent-%COMP%]:before, .fa-hourglass-start[_ngcontent-%COMP%]:before{content:"\\f251"}.fa-hourglass-2[_ngcontent-%COMP%]:before, .fa-hourglass-half[_ngcontent-%COMP%]:before{content:"\\f252"}.fa-hourglass-3[_ngcontent-%COMP%]:before, .fa-hourglass-end[_ngcontent-%COMP%]:before{content:"\\f253"}.fa-hourglass[_ngcontent-%COMP%]:before{content:"\\f254"}.fa-hand-grab-o[_ngcontent-%COMP%]:before, .fa-hand-rock-o[_ngcontent-%COMP%]:before{content:"\\f255"}.fa-hand-stop-o[_ngcontent-%COMP%]:before, .fa-hand-paper-o[_ngcontent-%COMP%]:before{content:"\\f256"}.fa-hand-scissors-o[_ngcontent-%COMP%]:before{content:"\\f257"}.fa-hand-lizard-o[_ngcontent-%COMP%]:before{content:"\\f258"}.fa-hand-spock-o[_ngcontent-%COMP%]:before{content:"\\f259"}.fa-hand-pointer-o[_ngcontent-%COMP%]:before{content:"\\f25a"}.fa-hand-peace-o[_ngcontent-%COMP%]:before{content:"\\f25b"}.fa-trademark[_ngcontent-%COMP%]:before{content:"\\f25c"}.fa-registered[_ngcontent-%COMP%]:before{content:"\\f25d"}.fa-creative-commons[_ngcontent-%COMP%]:before{content:"\\f25e"}.fa-gg[_ngcontent-%COMP%]:before{content:"\\f260"}.fa-gg-circle[_ngcontent-%COMP%]:before{content:"\\f261"}.fa-tripadvisor[_ngcontent-%COMP%]:before{content:"\\f262"}.fa-odnoklassniki[_ngcontent-%COMP%]:before{content:"\\f263"}.fa-odnoklassniki-square[_ngcontent-%COMP%]:before{content:"\\f264"}.fa-get-pocket[_ngcontent-%COMP%]:before{content:"\\f265"}.fa-wikipedia-w[_ngcontent-%COMP%]:before{content:"\\f266"}.fa-safari[_ngcontent-%COMP%]:before{content:"\\f267"}.fa-chrome[_ngcontent-%COMP%]:before{content:"\\f268"}.fa-firefox[_ngcontent-%COMP%]:before{content:"\\f269"}.fa-opera[_ngcontent-%COMP%]:before{content:"\\f26a"}.fa-internet-explorer[_ngcontent-%COMP%]:before{content:"\\f26b"}.fa-tv[_ngcontent-%COMP%]:before, .fa-television[_ngcontent-%COMP%]:before{content:"\\f26c"}.fa-contao[_ngcontent-%COMP%]:before{content:"\\f26d"}.fa-500px[_ngcontent-%COMP%]:before{content:"\\f26e"}.fa-amazon[_ngcontent-%COMP%]:before{content:"\\f270"}.fa-calendar-plus-o[_ngcontent-%COMP%]:before{content:"\\f271"}.fa-calendar-minus-o[_ngcontent-%COMP%]:before{content:"\\f272"}.fa-calendar-times-o[_ngcontent-%COMP%]:before{content:"\\f273"}.fa-calendar-check-o[_ngcontent-%COMP%]:before{content:"\\f274"}.fa-industry[_ngcontent-%COMP%]:before{content:"\\f275"}.fa-map-pin[_ngcontent-%COMP%]:before{content:"\\f276"}.fa-map-signs[_ngcontent-%COMP%]:before{content:"\\f277"}.fa-map-o[_ngcontent-%COMP%]:before{content:"\\f278"}.fa-map[_ngcontent-%COMP%]:before{content:"\\f279"}.fa-commenting[_ngcontent-%COMP%]:before{content:"\\f27a"}.fa-commenting-o[_ngcontent-%COMP%]:before{content:"\\f27b"}.fa-houzz[_ngcontent-%COMP%]:before{content:"\\f27c"}.fa-vimeo[_ngcontent-%COMP%]:before{content:"\\f27d"}.fa-black-tie[_ngcontent-%COMP%]:before{content:"\\f27e"}.fa-fonticons[_ngcontent-%COMP%]:before{content:"\\f280"}.fa-reddit-alien[_ngcontent-%COMP%]:before{content:"\\f281"}.fa-edge[_ngcontent-%COMP%]:before{content:"\\f282"}.fa-credit-card-alt[_ngcontent-%COMP%]:before{content:"\\f283"}.fa-codiepie[_ngcontent-%COMP%]:before{content:"\\f284"}.fa-modx[_ngcontent-%COMP%]:before{content:"\\f285"}.fa-fort-awesome[_ngcontent-%COMP%]:before{content:"\\f286"}.fa-usb[_ngcontent-%COMP%]:before{content:"\\f287"}.fa-product-hunt[_ngcontent-%COMP%]:before{content:"\\f288"}.fa-mixcloud[_ngcontent-%COMP%]:before{content:"\\f289"}.fa-scribd[_ngcontent-%COMP%]:before{content:"\\f28a"}.fa-pause-circle[_ngcontent-%COMP%]:before{content:"\\f28b"}.fa-pause-circle-o[_ngcontent-%COMP%]:before{content:"\\f28c"}.fa-stop-circle[_ngcontent-%COMP%]:before{content:"\\f28d"}.fa-stop-circle-o[_ngcontent-%COMP%]:before{content:"\\f28e"}.fa-shopping-bag[_ngcontent-%COMP%]:before{content:"\\f290"}.fa-shopping-basket[_ngcontent-%COMP%]:before{content:"\\f291"}.fa-hashtag[_ngcontent-%COMP%]:before{content:"\\f292"}.fa-bluetooth[_ngcontent-%COMP%]:before{content:"\\f293"}.fa-bluetooth-b[_ngcontent-%COMP%]:before{content:"\\f294"}.fa-percent[_ngcontent-%COMP%]:before{content:"\\f295"}.fa-gitlab[_ngcontent-%COMP%]:before{content:"\\f296"}.fa-wpbeginner[_ngcontent-%COMP%]:before{content:"\\f297"}.fa-wpforms[_ngcontent-%COMP%]:before{content:"\\f298"}.fa-envira[_ngcontent-%COMP%]:before{content:"\\f299"}.fa-universal-access[_ngcontent-%COMP%]:before{content:"\\f29a"}.fa-wheelchair-alt[_ngcontent-%COMP%]:before{content:"\\f29b"}.fa-question-circle-o[_ngcontent-%COMP%]:before{content:"\\f29c"}.fa-blind[_ngcontent-%COMP%]:before{content:"\\f29d"}.fa-audio-description[_ngcontent-%COMP%]:before{content:"\\f29e"}.fa-volume-control-phone[_ngcontent-%COMP%]:before{content:"\\f2a0"}.fa-braille[_ngcontent-%COMP%]:before{content:"\\f2a1"}.fa-assistive-listening-systems[_ngcontent-%COMP%]:before{content:"\\f2a2"}.fa-asl-interpreting[_ngcontent-%COMP%]:before, .fa-american-sign-language-interpreting[_ngcontent-%COMP%]:before{content:"\\f2a3"}.fa-deafness[_ngcontent-%COMP%]:before, .fa-hard-of-hearing[_ngcontent-%COMP%]:before, .fa-deaf[_ngcontent-%COMP%]:before{content:"\\f2a4"}.fa-glide[_ngcontent-%COMP%]:before{content:"\\f2a5"}.fa-glide-g[_ngcontent-%COMP%]:before{content:"\\f2a6"}.fa-signing[_ngcontent-%COMP%]:before, .fa-sign-language[_ngcontent-%COMP%]:before{content:"\\f2a7"}.fa-low-vision[_ngcontent-%COMP%]:before{content:"\\f2a8"}.fa-viadeo[_ngcontent-%COMP%]:before{content:"\\f2a9"}.fa-viadeo-square[_ngcontent-%COMP%]:before{content:"\\f2aa"}.fa-snapchat[_ngcontent-%COMP%]:before{content:"\\f2ab"}.fa-snapchat-ghost[_ngcontent-%COMP%]:before{content:"\\f2ac"}.fa-snapchat-square[_ngcontent-%COMP%]:before{content:"\\f2ad"}.fa-pied-piper[_ngcontent-%COMP%]:before{content:"\\f2ae"}.fa-first-order[_ngcontent-%COMP%]:before{content:"\\f2b0"}.fa-yoast[_ngcontent-%COMP%]:before{content:"\\f2b1"}.fa-themeisle[_ngcontent-%COMP%]:before{content:"\\f2b2"}.fa-google-plus-circle[_ngcontent-%COMP%]:before, .fa-google-plus-official[_ngcontent-%COMP%]:before{content:"\\f2b3"}.fa-fa[_ngcontent-%COMP%]:before, .fa-font-awesome[_ngcontent-%COMP%]:before{content:"\\f2b4"}.fa-handshake-o[_ngcontent-%COMP%]:before{content:"\\f2b5"}.fa-envelope-open[_ngcontent-%COMP%]:before{content:"\\f2b6"}.fa-envelope-open-o[_ngcontent-%COMP%]:before{content:"\\f2b7"}.fa-linode[_ngcontent-%COMP%]:before{content:"\\f2b8"}.fa-address-book[_ngcontent-%COMP%]:before{content:"\\f2b9"}.fa-address-book-o[_ngcontent-%COMP%]:before{content:"\\f2ba"}.fa-vcard[_ngcontent-%COMP%]:before, .fa-address-card[_ngcontent-%COMP%]:before{content:"\\f2bb"}.fa-vcard-o[_ngcontent-%COMP%]:before, .fa-address-card-o[_ngcontent-%COMP%]:before{content:"\\f2bc"}.fa-user-circle[_ngcontent-%COMP%]:before{content:"\\f2bd"}.fa-user-circle-o[_ngcontent-%COMP%]:before{content:"\\f2be"}.fa-user-o[_ngcontent-%COMP%]:before{content:"\\f2c0"}.fa-id-badge[_ngcontent-%COMP%]:before{content:"\\f2c1"}.fa-drivers-license[_ngcontent-%COMP%]:before, .fa-id-card[_ngcontent-%COMP%]:before{content:"\\f2c2"}.fa-drivers-license-o[_ngcontent-%COMP%]:before, .fa-id-card-o[_ngcontent-%COMP%]:before{content:"\\f2c3"}.fa-quora[_ngcontent-%COMP%]:before{content:"\\f2c4"}.fa-free-code-camp[_ngcontent-%COMP%]:before{content:"\\f2c5"}.fa-telegram[_ngcontent-%COMP%]:before{content:"\\f2c6"}.fa-thermometer-4[_ngcontent-%COMP%]:before, .fa-thermometer[_ngcontent-%COMP%]:before, .fa-thermometer-full[_ngcontent-%COMP%]:before{content:"\\f2c7"}.fa-thermometer-3[_ngcontent-%COMP%]:before, .fa-thermometer-three-quarters[_ngcontent-%COMP%]:before{content:"\\f2c8"}.fa-thermometer-2[_ngcontent-%COMP%]:before, .fa-thermometer-half[_ngcontent-%COMP%]:before{content:"\\f2c9"}.fa-thermometer-1[_ngcontent-%COMP%]:before, .fa-thermometer-quarter[_ngcontent-%COMP%]:before{content:"\\f2ca"}.fa-thermometer-0[_ngcontent-%COMP%]:before, .fa-thermometer-empty[_ngcontent-%COMP%]:before{content:"\\f2cb"}.fa-shower[_ngcontent-%COMP%]:before{content:"\\f2cc"}.fa-bathtub[_ngcontent-%COMP%]:before, .fa-s15[_ngcontent-%COMP%]:before, .fa-bath[_ngcontent-%COMP%]:before{content:"\\f2cd"}.fa-podcast[_ngcontent-%COMP%]:before{content:"\\f2ce"}.fa-window-maximize[_ngcontent-%COMP%]:before{content:"\\f2d0"}.fa-window-minimize[_ngcontent-%COMP%]:before{content:"\\f2d1"}.fa-window-restore[_ngcontent-%COMP%]:before{content:"\\f2d2"}.fa-times-rectangle[_ngcontent-%COMP%]:before, .fa-window-close[_ngcontent-%COMP%]:before{content:"\\f2d3"}.fa-times-rectangle-o[_ngcontent-%COMP%]:before, .fa-window-close-o[_ngcontent-%COMP%]:before{content:"\\f2d4"}.fa-bandcamp[_ngcontent-%COMP%]:before{content:"\\f2d5"}.fa-grav[_ngcontent-%COMP%]:before{content:"\\f2d6"}.fa-etsy[_ngcontent-%COMP%]:before{content:"\\f2d7"}.fa-imdb[_ngcontent-%COMP%]:before{content:"\\f2d8"}.fa-ravelry[_ngcontent-%COMP%]:before{content:"\\f2d9"}.fa-eercast[_ngcontent-%COMP%]:before{content:"\\f2da"}.fa-microchip[_ngcontent-%COMP%]:before{content:"\\f2db"}.fa-snowflake-o[_ngcontent-%COMP%]:before{content:"\\f2dc"}.fa-superpowers[_ngcontent-%COMP%]:before{content:"\\f2dd"}.fa-wpexplorer[_ngcontent-%COMP%]:before{content:"\\f2de"}.fa-meetup[_ngcontent-%COMP%]:before{content:"\\f2e0"}.sr-only[_ngcontent-%COMP%]{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable[_ngcontent-%COMP%]:active, .sr-only-focusable[_ngcontent-%COMP%]:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}a[_ngcontent-%COMP%]{cursor:pointer}.angular-editor-textarea[_ngcontent-%COMP%]{min-height:150px;overflow:auto;margin-top:5px;resize:vertical}.angular-editor-textarea[_ngcontent-%COMP%]:after{content:"";position:absolute;bottom:0;right:0;display:block;width:8px;height:8px;cursor:nwse-resize;background-color:#ffffff80}.angular-editor-toolbar[_ngcontent-%COMP%]{font:100 14px/15px Roboto,Arial,sans-serif;background-color:#f5f5f5;font-size:.8rem;padding:.2rem;border:1px solid #ddd}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]{display:none;margin-right:5px;vertical-align:baseline}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]{background-color:#fff;vertical-align:middle;border:1px solid #ddd;padding:.4rem;min-width:2rem;float:left}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:focus, .angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button.focus[_ngcontent-%COMP%]{outline:0}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:disabled > .color-label[_ngcontent-%COMP%]{pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:disabled > .color-label.foreground[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:after{background:#555555}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button[_ngcontent-%COMP%]:disabled > .color-label.background[_ngcontent-%COMP%]{background:#555555}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button.active[_ngcontent-%COMP%]{background:#fff5b9}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .angular-editor-button.active[_ngcontent-%COMP%]:hover{background-color:#fffa98}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]{font-size:11px;width:90px;vertical-align:middle;background-color:transparent;border:.5px solid rgba(255,255,255,0);border-radius:5px;outline:none;padding:.4rem;cursor:pointer}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   optgroup[_ngcontent-%COMP%]{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   option[_ngcontent-%COMP%]{border:1px solid;background-color:#fff}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .default[_ngcontent-%COMP%]{font-size:16px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h1[_ngcontent-%COMP%]{font-size:24px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h2[_ngcontent-%COMP%]{font-size:20px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h3[_ngcontent-%COMP%]{font-size:16px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h4[_ngcontent-%COMP%]{font-size:15px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h5[_ngcontent-%COMP%]{font-size:14px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .h6[_ngcontent-%COMP%]{font-size:13px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .div[_ngcontent-%COMP%], .angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]   .pre[_ngcontent-%COMP%]{font-size:12px}}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-heading[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font[_ngcontent-%COMP%]{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font[_ngcontent-%COMP%]   optgroup[_ngcontent-%COMP%]{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font[_ngcontent-%COMP%]   option[_ngcontent-%COMP%]{border:1px solid;background-color:#fff}}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font[_ngcontent-%COMP%]:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]{display:inline-block;width:50px}@supports not (-moz-appearance: none){.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   optgroup[_ngcontent-%COMP%]{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   option[_ngcontent-%COMP%]{border:1px solid;background-color:#fff}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size1[_ngcontent-%COMP%]{font-size:10px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size2[_ngcontent-%COMP%]{font-size:12px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size3[_ngcontent-%COMP%]{font-size:14px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size4[_ngcontent-%COMP%]{font-size:16px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size5[_ngcontent-%COMP%]{font-size:18px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size6[_ngcontent-%COMP%]{font-size:20px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]   .size7[_ngcontent-%COMP%]{font-size:22px}}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-font-size[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-custom-style[_ngcontent-%COMP%]{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-custom-style[_ngcontent-%COMP%]   optgroup[_ngcontent-%COMP%]{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-custom-style[_ngcontent-%COMP%]   option[_ngcontent-%COMP%]{border:1px solid;background-color:#fff}}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-custom-style[_ngcontent-%COMP%]:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .select-custom-style[_ngcontent-%COMP%]:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .color-label[_ngcontent-%COMP%]{position:relative;cursor:pointer}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .background[_ngcontent-%COMP%]{font-size:smaller;background:#1b1b1b;color:#fff;padding:3px}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]   .foreground[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:after{position:absolute;content:"";left:-1px;top:auto;bottom:-3px;right:auto;width:15px;height:2px;z-index:0;background:#1b1b1b}.angular-editor-toolbar[_ngcontent-%COMP%]   .angular-editor-toolbar-set[_ngcontent-%COMP%]:not([style*="display:none"]):not([style*="display: none"]){display:inline-block}.angular-editor[_ngcontent-%COMP%]{position:relative}.angular-editor[_ngcontent-%COMP%]     [contenteditable=true]:empty:before{content:attr(placeholder);color:#868e96;opacity:1}.angular-editor[_ngcontent-%COMP%]   .angular-editor-wrapper[_ngcontent-%COMP%]{position:relative}.angular-editor[_ngcontent-%COMP%]   .angular-editor-wrapper[_ngcontent-%COMP%]   .angular-editor-textarea[_ngcontent-%COMP%]{min-height:5rem;padding:.5rem .8rem 1rem;border:1px solid #ddd;background-color:transparent;overflow-x:hidden;overflow-y:auto;position:relative}.angular-editor[_ngcontent-%COMP%]   .angular-editor-wrapper[_ngcontent-%COMP%]   .angular-editor-textarea[_ngcontent-%COMP%]     blockquote{margin-left:1rem;border-left:.2em solid #dfe2e5;padding-left:.5rem}.angular-editor[_ngcontent-%COMP%]   .angular-editor-wrapper[_ngcontent-%COMP%]     p{margin-bottom:0}.angular-editor[_ngcontent-%COMP%]   .angular-editor-wrapper[_ngcontent-%COMP%]   .angular-editor-placeholder[_ngcontent-%COMP%]{display:none;position:absolute;top:0;padding:.5rem .8rem 1rem .9rem;color:#6c757d;opacity:.75}.angular-editor[_ngcontent-%COMP%]   .angular-editor-wrapper.show-placeholder[_ngcontent-%COMP%]   .angular-editor-placeholder[_ngcontent-%COMP%]{display:block}.angular-editor[_ngcontent-%COMP%]   .angular-editor-wrapper.disabled[_ngcontent-%COMP%]{cursor:not-allowed;opacity:.5;pointer-events:none}']
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AngularEditorComponent, [{
    type: Component,
    args: [{
      selector: "angular-editor",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => AngularEditorComponent),
        multi: true
      }, AngularEditorService],
      template: `<div
     class="angular-editor"
     #angularEditor
     [style.width]="config.width"
     [style.minWidth]="config.minWidth"
>
     <angular-editor-toolbar
          *ngIf="config.toolbarPosition === 'top'"
          #editorToolbar
          [id]="id"
          [uploadUrl]="config.uploadUrl"
          [upload]="config.upload"
          [showToolbar]="config.showToolbar !== undefined ? config.showToolbar : true"
          [fonts]="getFonts()"
          [customClasses]="config.customClasses"
          [defaultFontName]="config.defaultFontName"
          [defaultFontSize]="config.defaultFontSize"
          [hiddenButtons]="config.toolbarHiddenButtons"
          (execute)="executeCommand($event)"
     >
       <ng-container
         [ngTemplateOutlet]="customButtonsTemplateRef"
         [ngTemplateOutletContext]="{ executeCommandFn: this.executeCommandFn}"
       >
       </ng-container>
     </angular-editor-toolbar>

     <div
          class="angular-editor-wrapper"
          #editorWrapper
     >
          <div
               #editor
               class="angular-editor-textarea"
               [attr.contenteditable]="config.editable"
               [attr.tabindex]="disabled ? -1 : tabIndex"
               [attr.translate]="config.translate"
               [attr.spellcheck]="config.spellcheck"
               [style.height]="config.height"
               [style.minHeight]="config.minHeight"
               [style.maxHeight]="config.maxHeight"
               [style.outline]="config.outline === false ? 'none': undefined"
               (input)="onContentChange($event.target)"
               (focus)="onTextAreaFocus($event)"
               (blur)="onTextAreaBlur($event)"
               (click)="exec()"
               (keyup)="exec()"
               (mouseout)="onTextAreaMouseOut($event)"
               (paste)="onPaste($event)"
          >
          </div>
          <span class="angular-editor-placeholder">{{ placeholder || config['placeholder'] }}</span>
     </div>
     <angular-editor-toolbar
          *ngIf="config.toolbarPosition === 'bottom'"
          #editorToolbar
          [id]="id"
          [uploadUrl]="config.uploadUrl"
          [upload]="config.upload"
          [showToolbar]="config.showToolbar !== undefined ? config.showToolbar : true"
          [fonts]="getFonts()"
          [customClasses]="config.customClasses"
          [defaultFontName]="config.defaultFontName"
          [defaultFontSize]="config.defaultFontSize"
          [hiddenButtons]="config.toolbarHiddenButtons"
          (execute)="executeCommand($event)"
     ></angular-editor-toolbar>
</div>
`,
      styles: ['/*!\n *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome\n *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)\n */@font-face{font-family:FontAwesome;src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?v=4.7.0);src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?#iefix&v=4.7.0) format("embedded-opentype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff2?v=4.7.0) format("woff2"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff?v=4.7.0) format("woff"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.ttf?v=4.7.0) format("truetype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular) format("svg");font-weight:400;font-style:normal}.fa{display:inline-block;font: 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.3333333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.2857142857em;text-align:center}.fa-ul{padding-left:0;margin-left:2.1428571429em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.1428571429em;width:2.1428571429em;top:.1428571429em;text-align:center}.fa-li.fa-lg{left:-1.8571428571em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{animation:fa-spin 2s infinite linear}.fa-pulse{animation:fa-spin 1s infinite steps(8)}@keyframes fa-spin{0%{transform:rotate(0)}to{transform:rotate(359deg)}}.fa-rotate-90{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";transform:rotate(90deg)}.fa-rotate-180{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";transform:rotate(180deg)}.fa-rotate-270{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";transform:rotate(270deg)}.fa-flip-horizontal{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";transform:scaleX(-1)}.fa-flip-vertical{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";transform:scaleY(-1)}:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-flip-horizontal,:root .fa-flip-vertical{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:"\\f000"}.fa-music:before{content:"\\f001"}.fa-search:before{content:"\\f002"}.fa-envelope-o:before{content:"\\f003"}.fa-heart:before{content:"\\f004"}.fa-star:before{content:"\\f005"}.fa-star-o:before{content:"\\f006"}.fa-user:before{content:"\\f007"}.fa-film:before{content:"\\f008"}.fa-th-large:before{content:"\\f009"}.fa-th:before{content:"\\f00a"}.fa-th-list:before{content:"\\f00b"}.fa-check:before{content:"\\f00c"}.fa-remove:before,.fa-close:before,.fa-times:before{content:"\\f00d"}.fa-search-plus:before{content:"\\f00e"}.fa-search-minus:before{content:"\\f010"}.fa-power-off:before{content:"\\f011"}.fa-signal:before{content:"\\f012"}.fa-gear:before,.fa-cog:before{content:"\\f013"}.fa-trash-o:before{content:"\\f014"}.fa-home:before{content:"\\f015"}.fa-file-o:before{content:"\\f016"}.fa-clock-o:before{content:"\\f017"}.fa-road:before{content:"\\f018"}.fa-download:before{content:"\\f019"}.fa-arrow-circle-o-down:before{content:"\\f01a"}.fa-arrow-circle-o-up:before{content:"\\f01b"}.fa-inbox:before{content:"\\f01c"}.fa-play-circle-o:before{content:"\\f01d"}.fa-rotate-right:before,.fa-repeat:before{content:"\\f01e"}.fa-refresh:before{content:"\\f021"}.fa-list-alt:before{content:"\\f022"}.fa-lock:before{content:"\\f023"}.fa-flag:before{content:"\\f024"}.fa-headphones:before{content:"\\f025"}.fa-volume-off:before{content:"\\f026"}.fa-volume-down:before{content:"\\f027"}.fa-volume-up:before{content:"\\f028"}.fa-qrcode:before{content:"\\f029"}.fa-barcode:before{content:"\\f02a"}.fa-tag:before{content:"\\f02b"}.fa-tags:before{content:"\\f02c"}.fa-book:before{content:"\\f02d"}.fa-bookmark:before{content:"\\f02e"}.fa-print:before{content:"\\f02f"}.fa-camera:before{content:"\\f030"}.fa-font:before{content:"\\f031"}.fa-bold:before{content:"\\f032"}.fa-italic:before{content:"\\f033"}.fa-text-height:before{content:"\\f034"}.fa-text-width:before{content:"\\f035"}.fa-align-left:before{content:"\\f036"}.fa-align-center:before{content:"\\f037"}.fa-align-right:before{content:"\\f038"}.fa-align-justify:before{content:"\\f039"}.fa-list:before{content:"\\f03a"}.fa-dedent:before,.fa-outdent:before{content:"\\f03b"}.fa-indent:before{content:"\\f03c"}.fa-video-camera:before{content:"\\f03d"}.fa-photo:before,.fa-image:before,.fa-picture-o:before{content:"\\f03e"}.fa-pencil:before{content:"\\f040"}.fa-map-marker:before{content:"\\f041"}.fa-adjust:before{content:"\\f042"}.fa-tint:before{content:"\\f043"}.fa-edit:before,.fa-pencil-square-o:before{content:"\\f044"}.fa-share-square-o:before{content:"\\f045"}.fa-check-square-o:before{content:"\\f046"}.fa-arrows:before{content:"\\f047"}.fa-step-backward:before{content:"\\f048"}.fa-fast-backward:before{content:"\\f049"}.fa-backward:before{content:"\\f04a"}.fa-play:before{content:"\\f04b"}.fa-pause:before{content:"\\f04c"}.fa-stop:before{content:"\\f04d"}.fa-forward:before{content:"\\f04e"}.fa-fast-forward:before{content:"\\f050"}.fa-step-forward:before{content:"\\f051"}.fa-eject:before{content:"\\f052"}.fa-chevron-left:before{content:"\\f053"}.fa-chevron-right:before{content:"\\f054"}.fa-plus-circle:before{content:"\\f055"}.fa-minus-circle:before{content:"\\f056"}.fa-times-circle:before{content:"\\f057"}.fa-check-circle:before{content:"\\f058"}.fa-question-circle:before{content:"\\f059"}.fa-info-circle:before{content:"\\f05a"}.fa-crosshairs:before{content:"\\f05b"}.fa-times-circle-o:before{content:"\\f05c"}.fa-check-circle-o:before{content:"\\f05d"}.fa-ban:before{content:"\\f05e"}.fa-arrow-left:before{content:"\\f060"}.fa-arrow-right:before{content:"\\f061"}.fa-arrow-up:before{content:"\\f062"}.fa-arrow-down:before{content:"\\f063"}.fa-mail-forward:before,.fa-share:before{content:"\\f064"}.fa-expand:before{content:"\\f065"}.fa-compress:before{content:"\\f066"}.fa-plus:before{content:"\\f067"}.fa-minus:before{content:"\\f068"}.fa-asterisk:before{content:"\\f069"}.fa-exclamation-circle:before{content:"\\f06a"}.fa-gift:before{content:"\\f06b"}.fa-leaf:before{content:"\\f06c"}.fa-fire:before{content:"\\f06d"}.fa-eye:before{content:"\\f06e"}.fa-eye-slash:before{content:"\\f070"}.fa-warning:before,.fa-exclamation-triangle:before{content:"\\f071"}.fa-plane:before{content:"\\f072"}.fa-calendar:before{content:"\\f073"}.fa-random:before{content:"\\f074"}.fa-comment:before{content:"\\f075"}.fa-magnet:before{content:"\\f076"}.fa-chevron-up:before{content:"\\f077"}.fa-chevron-down:before{content:"\\f078"}.fa-retweet:before{content:"\\f079"}.fa-shopping-cart:before{content:"\\f07a"}.fa-folder:before{content:"\\f07b"}.fa-folder-open:before{content:"\\f07c"}.fa-arrows-v:before{content:"\\f07d"}.fa-arrows-h:before{content:"\\f07e"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:"\\f080"}.fa-twitter-square:before{content:"\\f081"}.fa-facebook-square:before{content:"\\f082"}.fa-camera-retro:before{content:"\\f083"}.fa-key:before{content:"\\f084"}.fa-gears:before,.fa-cogs:before{content:"\\f085"}.fa-comments:before{content:"\\f086"}.fa-thumbs-o-up:before{content:"\\f087"}.fa-thumbs-o-down:before{content:"\\f088"}.fa-star-half:before{content:"\\f089"}.fa-heart-o:before{content:"\\f08a"}.fa-sign-out:before{content:"\\f08b"}.fa-linkedin-square:before{content:"\\f08c"}.fa-thumb-tack:before{content:"\\f08d"}.fa-external-link:before{content:"\\f08e"}.fa-sign-in:before{content:"\\f090"}.fa-trophy:before{content:"\\f091"}.fa-github-square:before{content:"\\f092"}.fa-upload:before{content:"\\f093"}.fa-lemon-o:before{content:"\\f094"}.fa-phone:before{content:"\\f095"}.fa-square-o:before{content:"\\f096"}.fa-bookmark-o:before{content:"\\f097"}.fa-phone-square:before{content:"\\f098"}.fa-twitter:before{content:"\\f099"}.fa-facebook-f:before,.fa-facebook:before{content:"\\f09a"}.fa-github:before{content:"\\f09b"}.fa-unlock:before{content:"\\f09c"}.fa-credit-card:before{content:"\\f09d"}.fa-feed:before,.fa-rss:before{content:"\\f09e"}.fa-hdd-o:before{content:"\\f0a0"}.fa-bullhorn:before{content:"\\f0a1"}.fa-bell:before{content:"\\f0f3"}.fa-certificate:before{content:"\\f0a3"}.fa-hand-o-right:before{content:"\\f0a4"}.fa-hand-o-left:before{content:"\\f0a5"}.fa-hand-o-up:before{content:"\\f0a6"}.fa-hand-o-down:before{content:"\\f0a7"}.fa-arrow-circle-left:before{content:"\\f0a8"}.fa-arrow-circle-right:before{content:"\\f0a9"}.fa-arrow-circle-up:before{content:"\\f0aa"}.fa-arrow-circle-down:before{content:"\\f0ab"}.fa-globe:before{content:"\\f0ac"}.fa-wrench:before{content:"\\f0ad"}.fa-tasks:before{content:"\\f0ae"}.fa-filter:before{content:"\\f0b0"}.fa-briefcase:before{content:"\\f0b1"}.fa-arrows-alt:before{content:"\\f0b2"}.fa-group:before,.fa-users:before{content:"\\f0c0"}.fa-chain:before,.fa-link:before{content:"\\f0c1"}.fa-cloud:before{content:"\\f0c2"}.fa-flask:before{content:"\\f0c3"}.fa-cut:before,.fa-scissors:before{content:"\\f0c4"}.fa-copy:before,.fa-files-o:before{content:"\\f0c5"}.fa-paperclip:before{content:"\\f0c6"}.fa-save:before,.fa-floppy-o:before{content:"\\f0c7"}.fa-square:before{content:"\\f0c8"}.fa-navicon:before,.fa-reorder:before,.fa-bars:before{content:"\\f0c9"}.fa-list-ul:before{content:"\\f0ca"}.fa-list-ol:before{content:"\\f0cb"}.fa-strikethrough:before{content:"\\f0cc"}.fa-underline:before{content:"\\f0cd"}.fa-table:before{content:"\\f0ce"}.fa-magic:before{content:"\\f0d0"}.fa-truck:before{content:"\\f0d1"}.fa-pinterest:before{content:"\\f0d2"}.fa-pinterest-square:before{content:"\\f0d3"}.fa-google-plus-square:before{content:"\\f0d4"}.fa-google-plus:before{content:"\\f0d5"}.fa-money:before{content:"\\f0d6"}.fa-caret-down:before{content:"\\f0d7"}.fa-caret-up:before{content:"\\f0d8"}.fa-caret-left:before{content:"\\f0d9"}.fa-caret-right:before{content:"\\f0da"}.fa-columns:before{content:"\\f0db"}.fa-unsorted:before,.fa-sort:before{content:"\\f0dc"}.fa-sort-down:before,.fa-sort-desc:before{content:"\\f0dd"}.fa-sort-up:before,.fa-sort-asc:before{content:"\\f0de"}.fa-envelope:before{content:"\\f0e0"}.fa-linkedin:before{content:"\\f0e1"}.fa-rotate-left:before,.fa-undo:before{content:"\\f0e2"}.fa-legal:before,.fa-gavel:before{content:"\\f0e3"}.fa-dashboard:before,.fa-tachometer:before{content:"\\f0e4"}.fa-comment-o:before{content:"\\f0e5"}.fa-comments-o:before{content:"\\f0e6"}.fa-flash:before,.fa-bolt:before{content:"\\f0e7"}.fa-sitemap:before{content:"\\f0e8"}.fa-umbrella:before{content:"\\f0e9"}.fa-paste:before,.fa-clipboard:before{content:"\\f0ea"}.fa-lightbulb-o:before{content:"\\f0eb"}.fa-exchange:before{content:"\\f0ec"}.fa-cloud-download:before{content:"\\f0ed"}.fa-cloud-upload:before{content:"\\f0ee"}.fa-user-md:before{content:"\\f0f0"}.fa-stethoscope:before{content:"\\f0f1"}.fa-suitcase:before{content:"\\f0f2"}.fa-bell-o:before{content:"\\f0a2"}.fa-coffee:before{content:"\\f0f4"}.fa-cutlery:before{content:"\\f0f5"}.fa-file-text-o:before{content:"\\f0f6"}.fa-building-o:before{content:"\\f0f7"}.fa-hospital-o:before{content:"\\f0f8"}.fa-ambulance:before{content:"\\f0f9"}.fa-medkit:before{content:"\\f0fa"}.fa-fighter-jet:before{content:"\\f0fb"}.fa-beer:before{content:"\\f0fc"}.fa-h-square:before{content:"\\f0fd"}.fa-plus-square:before{content:"\\f0fe"}.fa-angle-double-left:before{content:"\\f100"}.fa-angle-double-right:before{content:"\\f101"}.fa-angle-double-up:before{content:"\\f102"}.fa-angle-double-down:before{content:"\\f103"}.fa-angle-left:before{content:"\\f104"}.fa-angle-right:before{content:"\\f105"}.fa-angle-up:before{content:"\\f106"}.fa-angle-down:before{content:"\\f107"}.fa-desktop:before{content:"\\f108"}.fa-laptop:before{content:"\\f109"}.fa-tablet:before{content:"\\f10a"}.fa-mobile-phone:before,.fa-mobile:before{content:"\\f10b"}.fa-circle-o:before{content:"\\f10c"}.fa-quote-left:before{content:"\\f10d"}.fa-quote-right:before{content:"\\f10e"}.fa-spinner:before{content:"\\f110"}.fa-circle:before{content:"\\f111"}.fa-mail-reply:before,.fa-reply:before{content:"\\f112"}.fa-github-alt:before{content:"\\f113"}.fa-folder-o:before{content:"\\f114"}.fa-folder-open-o:before{content:"\\f115"}.fa-smile-o:before{content:"\\f118"}.fa-frown-o:before{content:"\\f119"}.fa-meh-o:before{content:"\\f11a"}.fa-gamepad:before{content:"\\f11b"}.fa-keyboard-o:before{content:"\\f11c"}.fa-flag-o:before{content:"\\f11d"}.fa-flag-checkered:before{content:"\\f11e"}.fa-terminal:before{content:"\\f120"}.fa-code:before{content:"\\f121"}.fa-mail-reply-all:before,.fa-reply-all:before{content:"\\f122"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:"\\f123"}.fa-location-arrow:before{content:"\\f124"}.fa-crop:before{content:"\\f125"}.fa-code-fork:before{content:"\\f126"}.fa-unlink:before,.fa-chain-broken:before{content:"\\f127"}.fa-question:before{content:"\\f128"}.fa-info:before{content:"\\f129"}.fa-exclamation:before{content:"\\f12a"}.fa-superscript:before{content:"\\f12b"}.fa-subscript:before{content:"\\f12c"}.fa-eraser:before{content:"\\f12d"}.fa-puzzle-piece:before{content:"\\f12e"}.fa-microphone:before{content:"\\f130"}.fa-microphone-slash:before{content:"\\f131"}.fa-shield:before{content:"\\f132"}.fa-calendar-o:before{content:"\\f133"}.fa-fire-extinguisher:before{content:"\\f134"}.fa-rocket:before{content:"\\f135"}.fa-maxcdn:before{content:"\\f136"}.fa-chevron-circle-left:before{content:"\\f137"}.fa-chevron-circle-right:before{content:"\\f138"}.fa-chevron-circle-up:before{content:"\\f139"}.fa-chevron-circle-down:before{content:"\\f13a"}.fa-html5:before{content:"\\f13b"}.fa-css3:before{content:"\\f13c"}.fa-anchor:before{content:"\\f13d"}.fa-unlock-alt:before{content:"\\f13e"}.fa-bullseye:before{content:"\\f140"}.fa-ellipsis-h:before{content:"\\f141"}.fa-ellipsis-v:before{content:"\\f142"}.fa-rss-square:before{content:"\\f143"}.fa-play-circle:before{content:"\\f144"}.fa-ticket:before{content:"\\f145"}.fa-minus-square:before{content:"\\f146"}.fa-minus-square-o:before{content:"\\f147"}.fa-level-up:before{content:"\\f148"}.fa-level-down:before{content:"\\f149"}.fa-check-square:before{content:"\\f14a"}.fa-pencil-square:before{content:"\\f14b"}.fa-external-link-square:before{content:"\\f14c"}.fa-share-square:before{content:"\\f14d"}.fa-compass:before{content:"\\f14e"}.fa-toggle-down:before,.fa-caret-square-o-down:before{content:"\\f150"}.fa-toggle-up:before,.fa-caret-square-o-up:before{content:"\\f151"}.fa-toggle-right:before,.fa-caret-square-o-right:before{content:"\\f152"}.fa-euro:before,.fa-eur:before{content:"\\f153"}.fa-gbp:before{content:"\\f154"}.fa-dollar:before,.fa-usd:before{content:"\\f155"}.fa-rupee:before,.fa-inr:before{content:"\\f156"}.fa-cny:before,.fa-rmb:before,.fa-yen:before,.fa-jpy:before{content:"\\f157"}.fa-ruble:before,.fa-rouble:before,.fa-rub:before{content:"\\f158"}.fa-won:before,.fa-krw:before{content:"\\f159"}.fa-bitcoin:before,.fa-btc:before{content:"\\f15a"}.fa-file:before{content:"\\f15b"}.fa-file-text:before{content:"\\f15c"}.fa-sort-alpha-asc:before{content:"\\f15d"}.fa-sort-alpha-desc:before{content:"\\f15e"}.fa-sort-amount-asc:before{content:"\\f160"}.fa-sort-amount-desc:before{content:"\\f161"}.fa-sort-numeric-asc:before{content:"\\f162"}.fa-sort-numeric-desc:before{content:"\\f163"}.fa-thumbs-up:before{content:"\\f164"}.fa-thumbs-down:before{content:"\\f165"}.fa-youtube-square:before{content:"\\f166"}.fa-youtube:before{content:"\\f167"}.fa-xing:before{content:"\\f168"}.fa-xing-square:before{content:"\\f169"}.fa-youtube-play:before{content:"\\f16a"}.fa-dropbox:before{content:"\\f16b"}.fa-stack-overflow:before{content:"\\f16c"}.fa-instagram:before{content:"\\f16d"}.fa-flickr:before{content:"\\f16e"}.fa-adn:before{content:"\\f170"}.fa-bitbucket:before{content:"\\f171"}.fa-bitbucket-square:before{content:"\\f172"}.fa-tumblr:before{content:"\\f173"}.fa-tumblr-square:before{content:"\\f174"}.fa-long-arrow-down:before{content:"\\f175"}.fa-long-arrow-up:before{content:"\\f176"}.fa-long-arrow-left:before{content:"\\f177"}.fa-long-arrow-right:before{content:"\\f178"}.fa-apple:before{content:"\\f179"}.fa-windows:before{content:"\\f17a"}.fa-android:before{content:"\\f17b"}.fa-linux:before{content:"\\f17c"}.fa-dribbble:before{content:"\\f17d"}.fa-skype:before{content:"\\f17e"}.fa-foursquare:before{content:"\\f180"}.fa-trello:before{content:"\\f181"}.fa-female:before{content:"\\f182"}.fa-male:before{content:"\\f183"}.fa-gittip:before,.fa-gratipay:before{content:"\\f184"}.fa-sun-o:before{content:"\\f185"}.fa-moon-o:before{content:"\\f186"}.fa-archive:before{content:"\\f187"}.fa-bug:before{content:"\\f188"}.fa-vk:before{content:"\\f189"}.fa-weibo:before{content:"\\f18a"}.fa-renren:before{content:"\\f18b"}.fa-pagelines:before{content:"\\f18c"}.fa-stack-exchange:before{content:"\\f18d"}.fa-arrow-circle-o-right:before{content:"\\f18e"}.fa-arrow-circle-o-left:before{content:"\\f190"}.fa-toggle-left:before,.fa-caret-square-o-left:before{content:"\\f191"}.fa-dot-circle-o:before{content:"\\f192"}.fa-wheelchair:before{content:"\\f193"}.fa-vimeo-square:before{content:"\\f194"}.fa-turkish-lira:before,.fa-try:before{content:"\\f195"}.fa-plus-square-o:before{content:"\\f196"}.fa-space-shuttle:before{content:"\\f197"}.fa-slack:before{content:"\\f198"}.fa-envelope-square:before{content:"\\f199"}.fa-wordpress:before{content:"\\f19a"}.fa-openid:before{content:"\\f19b"}.fa-institution:before,.fa-bank:before,.fa-university:before{content:"\\f19c"}.fa-mortar-board:before,.fa-graduation-cap:before{content:"\\f19d"}.fa-yahoo:before{content:"\\f19e"}.fa-google:before{content:"\\f1a0"}.fa-reddit:before{content:"\\f1a1"}.fa-reddit-square:before{content:"\\f1a2"}.fa-stumbleupon-circle:before{content:"\\f1a3"}.fa-stumbleupon:before{content:"\\f1a4"}.fa-delicious:before{content:"\\f1a5"}.fa-digg:before{content:"\\f1a6"}.fa-pied-piper-pp:before{content:"\\f1a7"}.fa-pied-piper-alt:before{content:"\\f1a8"}.fa-drupal:before{content:"\\f1a9"}.fa-joomla:before{content:"\\f1aa"}.fa-language:before{content:"\\f1ab"}.fa-fax:before{content:"\\f1ac"}.fa-building:before{content:"\\f1ad"}.fa-child:before{content:"\\f1ae"}.fa-paw:before{content:"\\f1b0"}.fa-spoon:before{content:"\\f1b1"}.fa-cube:before{content:"\\f1b2"}.fa-cubes:before{content:"\\f1b3"}.fa-behance:before{content:"\\f1b4"}.fa-behance-square:before{content:"\\f1b5"}.fa-steam:before{content:"\\f1b6"}.fa-steam-square:before{content:"\\f1b7"}.fa-recycle:before{content:"\\f1b8"}.fa-automobile:before,.fa-car:before{content:"\\f1b9"}.fa-cab:before,.fa-taxi:before{content:"\\f1ba"}.fa-tree:before{content:"\\f1bb"}.fa-spotify:before{content:"\\f1bc"}.fa-deviantart:before{content:"\\f1bd"}.fa-soundcloud:before{content:"\\f1be"}.fa-database:before{content:"\\f1c0"}.fa-file-pdf-o:before{content:"\\f1c1"}.fa-file-word-o:before{content:"\\f1c2"}.fa-file-excel-o:before{content:"\\f1c3"}.fa-file-powerpoint-o:before{content:"\\f1c4"}.fa-file-photo-o:before,.fa-file-picture-o:before,.fa-file-image-o:before{content:"\\f1c5"}.fa-file-zip-o:before,.fa-file-archive-o:before{content:"\\f1c6"}.fa-file-sound-o:before,.fa-file-audio-o:before{content:"\\f1c7"}.fa-file-movie-o:before,.fa-file-video-o:before{content:"\\f1c8"}.fa-file-code-o:before{content:"\\f1c9"}.fa-vine:before{content:"\\f1ca"}.fa-codepen:before{content:"\\f1cb"}.fa-jsfiddle:before{content:"\\f1cc"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-saver:before,.fa-support:before,.fa-life-ring:before{content:"\\f1cd"}.fa-circle-o-notch:before{content:"\\f1ce"}.fa-ra:before,.fa-resistance:before,.fa-rebel:before{content:"\\f1d0"}.fa-ge:before,.fa-empire:before{content:"\\f1d1"}.fa-git-square:before{content:"\\f1d2"}.fa-git:before{content:"\\f1d3"}.fa-y-combinator-square:before,.fa-yc-square:before,.fa-hacker-news:before{content:"\\f1d4"}.fa-tencent-weibo:before{content:"\\f1d5"}.fa-qq:before{content:"\\f1d6"}.fa-wechat:before,.fa-weixin:before{content:"\\f1d7"}.fa-send:before,.fa-paper-plane:before{content:"\\f1d8"}.fa-send-o:before,.fa-paper-plane-o:before{content:"\\f1d9"}.fa-history:before{content:"\\f1da"}.fa-circle-thin:before{content:"\\f1db"}.fa-header:before{content:"\\f1dc"}.fa-paragraph:before{content:"\\f1dd"}.fa-sliders:before{content:"\\f1de"}.fa-share-alt:before{content:"\\f1e0"}.fa-share-alt-square:before{content:"\\f1e1"}.fa-bomb:before{content:"\\f1e2"}.fa-soccer-ball-o:before,.fa-futbol-o:before{content:"\\f1e3"}.fa-tty:before{content:"\\f1e4"}.fa-binoculars:before{content:"\\f1e5"}.fa-plug:before{content:"\\f1e6"}.fa-slideshare:before{content:"\\f1e7"}.fa-twitch:before{content:"\\f1e8"}.fa-yelp:before{content:"\\f1e9"}.fa-newspaper-o:before{content:"\\f1ea"}.fa-wifi:before{content:"\\f1eb"}.fa-calculator:before{content:"\\f1ec"}.fa-paypal:before{content:"\\f1ed"}.fa-google-wallet:before{content:"\\f1ee"}.fa-cc-visa:before{content:"\\f1f0"}.fa-cc-mastercard:before{content:"\\f1f1"}.fa-cc-discover:before{content:"\\f1f2"}.fa-cc-amex:before{content:"\\f1f3"}.fa-cc-paypal:before{content:"\\f1f4"}.fa-cc-stripe:before{content:"\\f1f5"}.fa-bell-slash:before{content:"\\f1f6"}.fa-bell-slash-o:before{content:"\\f1f7"}.fa-trash:before{content:"\\f1f8"}.fa-copyright:before{content:"\\f1f9"}.fa-at:before{content:"\\f1fa"}.fa-eyedropper:before{content:"\\f1fb"}.fa-paint-brush:before{content:"\\f1fc"}.fa-birthday-cake:before{content:"\\f1fd"}.fa-area-chart:before{content:"\\f1fe"}.fa-pie-chart:before{content:"\\f200"}.fa-line-chart:before{content:"\\f201"}.fa-lastfm:before{content:"\\f202"}.fa-lastfm-square:before{content:"\\f203"}.fa-toggle-off:before{content:"\\f204"}.fa-toggle-on:before{content:"\\f205"}.fa-bicycle:before{content:"\\f206"}.fa-bus:before{content:"\\f207"}.fa-ioxhost:before{content:"\\f208"}.fa-angellist:before{content:"\\f209"}.fa-cc:before{content:"\\f20a"}.fa-shekel:before,.fa-sheqel:before,.fa-ils:before{content:"\\f20b"}.fa-meanpath:before{content:"\\f20c"}.fa-buysellads:before{content:"\\f20d"}.fa-connectdevelop:before{content:"\\f20e"}.fa-dashcube:before{content:"\\f210"}.fa-forumbee:before{content:"\\f211"}.fa-leanpub:before{content:"\\f212"}.fa-sellsy:before{content:"\\f213"}.fa-shirtsinbulk:before{content:"\\f214"}.fa-simplybuilt:before{content:"\\f215"}.fa-skyatlas:before{content:"\\f216"}.fa-cart-plus:before{content:"\\f217"}.fa-cart-arrow-down:before{content:"\\f218"}.fa-diamond:before{content:"\\f219"}.fa-ship:before{content:"\\f21a"}.fa-user-secret:before{content:"\\f21b"}.fa-motorcycle:before{content:"\\f21c"}.fa-street-view:before{content:"\\f21d"}.fa-heartbeat:before{content:"\\f21e"}.fa-venus:before{content:"\\f221"}.fa-mars:before{content:"\\f222"}.fa-mercury:before{content:"\\f223"}.fa-intersex:before,.fa-transgender:before{content:"\\f224"}.fa-transgender-alt:before{content:"\\f225"}.fa-venus-double:before{content:"\\f226"}.fa-mars-double:before{content:"\\f227"}.fa-venus-mars:before{content:"\\f228"}.fa-mars-stroke:before{content:"\\f229"}.fa-mars-stroke-v:before{content:"\\f22a"}.fa-mars-stroke-h:before{content:"\\f22b"}.fa-neuter:before{content:"\\f22c"}.fa-genderless:before{content:"\\f22d"}.fa-facebook-official:before{content:"\\f230"}.fa-pinterest-p:before{content:"\\f231"}.fa-whatsapp:before{content:"\\f232"}.fa-server:before{content:"\\f233"}.fa-user-plus:before{content:"\\f234"}.fa-user-times:before{content:"\\f235"}.fa-hotel:before,.fa-bed:before{content:"\\f236"}.fa-viacoin:before{content:"\\f237"}.fa-train:before{content:"\\f238"}.fa-subway:before{content:"\\f239"}.fa-medium:before{content:"\\f23a"}.fa-yc:before,.fa-y-combinator:before{content:"\\f23b"}.fa-optin-monster:before{content:"\\f23c"}.fa-opencart:before{content:"\\f23d"}.fa-expeditedssl:before{content:"\\f23e"}.fa-battery-4:before,.fa-battery:before,.fa-battery-full:before{content:"\\f240"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:"\\f241"}.fa-battery-2:before,.fa-battery-half:before{content:"\\f242"}.fa-battery-1:before,.fa-battery-quarter:before{content:"\\f243"}.fa-battery-0:before,.fa-battery-empty:before{content:"\\f244"}.fa-mouse-pointer:before{content:"\\f245"}.fa-i-cursor:before{content:"\\f246"}.fa-object-group:before{content:"\\f247"}.fa-object-ungroup:before{content:"\\f248"}.fa-sticky-note:before{content:"\\f249"}.fa-sticky-note-o:before{content:"\\f24a"}.fa-cc-jcb:before{content:"\\f24b"}.fa-cc-diners-club:before{content:"\\f24c"}.fa-clone:before{content:"\\f24d"}.fa-balance-scale:before{content:"\\f24e"}.fa-hourglass-o:before{content:"\\f250"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:"\\f251"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:"\\f252"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:"\\f253"}.fa-hourglass:before{content:"\\f254"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:"\\f255"}.fa-hand-stop-o:before,.fa-hand-paper-o:before{content:"\\f256"}.fa-hand-scissors-o:before{content:"\\f257"}.fa-hand-lizard-o:before{content:"\\f258"}.fa-hand-spock-o:before{content:"\\f259"}.fa-hand-pointer-o:before{content:"\\f25a"}.fa-hand-peace-o:before{content:"\\f25b"}.fa-trademark:before{content:"\\f25c"}.fa-registered:before{content:"\\f25d"}.fa-creative-commons:before{content:"\\f25e"}.fa-gg:before{content:"\\f260"}.fa-gg-circle:before{content:"\\f261"}.fa-tripadvisor:before{content:"\\f262"}.fa-odnoklassniki:before{content:"\\f263"}.fa-odnoklassniki-square:before{content:"\\f264"}.fa-get-pocket:before{content:"\\f265"}.fa-wikipedia-w:before{content:"\\f266"}.fa-safari:before{content:"\\f267"}.fa-chrome:before{content:"\\f268"}.fa-firefox:before{content:"\\f269"}.fa-opera:before{content:"\\f26a"}.fa-internet-explorer:before{content:"\\f26b"}.fa-tv:before,.fa-television:before{content:"\\f26c"}.fa-contao:before{content:"\\f26d"}.fa-500px:before{content:"\\f26e"}.fa-amazon:before{content:"\\f270"}.fa-calendar-plus-o:before{content:"\\f271"}.fa-calendar-minus-o:before{content:"\\f272"}.fa-calendar-times-o:before{content:"\\f273"}.fa-calendar-check-o:before{content:"\\f274"}.fa-industry:before{content:"\\f275"}.fa-map-pin:before{content:"\\f276"}.fa-map-signs:before{content:"\\f277"}.fa-map-o:before{content:"\\f278"}.fa-map:before{content:"\\f279"}.fa-commenting:before{content:"\\f27a"}.fa-commenting-o:before{content:"\\f27b"}.fa-houzz:before{content:"\\f27c"}.fa-vimeo:before{content:"\\f27d"}.fa-black-tie:before{content:"\\f27e"}.fa-fonticons:before{content:"\\f280"}.fa-reddit-alien:before{content:"\\f281"}.fa-edge:before{content:"\\f282"}.fa-credit-card-alt:before{content:"\\f283"}.fa-codiepie:before{content:"\\f284"}.fa-modx:before{content:"\\f285"}.fa-fort-awesome:before{content:"\\f286"}.fa-usb:before{content:"\\f287"}.fa-product-hunt:before{content:"\\f288"}.fa-mixcloud:before{content:"\\f289"}.fa-scribd:before{content:"\\f28a"}.fa-pause-circle:before{content:"\\f28b"}.fa-pause-circle-o:before{content:"\\f28c"}.fa-stop-circle:before{content:"\\f28d"}.fa-stop-circle-o:before{content:"\\f28e"}.fa-shopping-bag:before{content:"\\f290"}.fa-shopping-basket:before{content:"\\f291"}.fa-hashtag:before{content:"\\f292"}.fa-bluetooth:before{content:"\\f293"}.fa-bluetooth-b:before{content:"\\f294"}.fa-percent:before{content:"\\f295"}.fa-gitlab:before{content:"\\f296"}.fa-wpbeginner:before{content:"\\f297"}.fa-wpforms:before{content:"\\f298"}.fa-envira:before{content:"\\f299"}.fa-universal-access:before{content:"\\f29a"}.fa-wheelchair-alt:before{content:"\\f29b"}.fa-question-circle-o:before{content:"\\f29c"}.fa-blind:before{content:"\\f29d"}.fa-audio-description:before{content:"\\f29e"}.fa-volume-control-phone:before{content:"\\f2a0"}.fa-braille:before{content:"\\f2a1"}.fa-assistive-listening-systems:before{content:"\\f2a2"}.fa-asl-interpreting:before,.fa-american-sign-language-interpreting:before{content:"\\f2a3"}.fa-deafness:before,.fa-hard-of-hearing:before,.fa-deaf:before{content:"\\f2a4"}.fa-glide:before{content:"\\f2a5"}.fa-glide-g:before{content:"\\f2a6"}.fa-signing:before,.fa-sign-language:before{content:"\\f2a7"}.fa-low-vision:before{content:"\\f2a8"}.fa-viadeo:before{content:"\\f2a9"}.fa-viadeo-square:before{content:"\\f2aa"}.fa-snapchat:before{content:"\\f2ab"}.fa-snapchat-ghost:before{content:"\\f2ac"}.fa-snapchat-square:before{content:"\\f2ad"}.fa-pied-piper:before{content:"\\f2ae"}.fa-first-order:before{content:"\\f2b0"}.fa-yoast:before{content:"\\f2b1"}.fa-themeisle:before{content:"\\f2b2"}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:"\\f2b3"}.fa-fa:before,.fa-font-awesome:before{content:"\\f2b4"}.fa-handshake-o:before{content:"\\f2b5"}.fa-envelope-open:before{content:"\\f2b6"}.fa-envelope-open-o:before{content:"\\f2b7"}.fa-linode:before{content:"\\f2b8"}.fa-address-book:before{content:"\\f2b9"}.fa-address-book-o:before{content:"\\f2ba"}.fa-vcard:before,.fa-address-card:before{content:"\\f2bb"}.fa-vcard-o:before,.fa-address-card-o:before{content:"\\f2bc"}.fa-user-circle:before{content:"\\f2bd"}.fa-user-circle-o:before{content:"\\f2be"}.fa-user-o:before{content:"\\f2c0"}.fa-id-badge:before{content:"\\f2c1"}.fa-drivers-license:before,.fa-id-card:before{content:"\\f2c2"}.fa-drivers-license-o:before,.fa-id-card-o:before{content:"\\f2c3"}.fa-quora:before{content:"\\f2c4"}.fa-free-code-camp:before{content:"\\f2c5"}.fa-telegram:before{content:"\\f2c6"}.fa-thermometer-4:before,.fa-thermometer:before,.fa-thermometer-full:before{content:"\\f2c7"}.fa-thermometer-3:before,.fa-thermometer-three-quarters:before{content:"\\f2c8"}.fa-thermometer-2:before,.fa-thermometer-half:before{content:"\\f2c9"}.fa-thermometer-1:before,.fa-thermometer-quarter:before{content:"\\f2ca"}.fa-thermometer-0:before,.fa-thermometer-empty:before{content:"\\f2cb"}.fa-shower:before{content:"\\f2cc"}.fa-bathtub:before,.fa-s15:before,.fa-bath:before{content:"\\f2cd"}.fa-podcast:before{content:"\\f2ce"}.fa-window-maximize:before{content:"\\f2d0"}.fa-window-minimize:before{content:"\\f2d1"}.fa-window-restore:before{content:"\\f2d2"}.fa-times-rectangle:before,.fa-window-close:before{content:"\\f2d3"}.fa-times-rectangle-o:before,.fa-window-close-o:before{content:"\\f2d4"}.fa-bandcamp:before{content:"\\f2d5"}.fa-grav:before{content:"\\f2d6"}.fa-etsy:before{content:"\\f2d7"}.fa-imdb:before{content:"\\f2d8"}.fa-ravelry:before{content:"\\f2d9"}.fa-eercast:before{content:"\\f2da"}.fa-microchip:before{content:"\\f2db"}.fa-snowflake-o:before{content:"\\f2dc"}.fa-superpowers:before{content:"\\f2dd"}.fa-wpexplorer:before{content:"\\f2de"}.fa-meetup:before{content:"\\f2e0"}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}a{cursor:pointer}.angular-editor-textarea{min-height:150px;overflow:auto;margin-top:5px;resize:vertical}.angular-editor-textarea:after{content:"";position:absolute;bottom:0;right:0;display:block;width:8px;height:8px;cursor:nwse-resize;background-color:#ffffff80}.angular-editor-toolbar{font:100 14px/15px Roboto,Arial,sans-serif;background-color:#f5f5f5;font-size:.8rem;padding:.2rem;border:1px solid #ddd}.angular-editor-toolbar .angular-editor-toolbar-set{display:none;margin-right:5px;vertical-align:baseline}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button{background-color:#fff;vertical-align:middle;border:1px solid #ddd;padding:.4rem;min-width:2rem;float:left}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:focus,.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.focus{outline:0}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label{pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label.foreground :after{background:#555555}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label.background{background:#555555}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.active{background:#fff5b9}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.active:hover{background-color:#fffa98}.angular-editor-toolbar .angular-editor-toolbar-set select{font-size:11px;width:90px;vertical-align:middle;background-color:transparent;border:.5px solid rgba(255,255,255,0);border-radius:5px;outline:none;padding:.4rem;cursor:pointer}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-heading optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading option{border:1px solid;background-color:#fff}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .default{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h1{font-size:24px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h2{font-size:20px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h3{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h4{font-size:15px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h5{font-size:14px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h6{font-size:13px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .div,.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .pre{font-size:12px}}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-font{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-font optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font option{border:1px solid;background-color:#fff}}.angular-editor-toolbar .angular-editor-toolbar-set .select-font:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-font:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size{display:inline-block;width:50px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size option{border:1px solid;background-color:#fff}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size1{font-size:10px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size2{font-size:12px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size3{font-size:14px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size4{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size5{font-size:18px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size6{font-size:20px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size7{font-size:22px}}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style option{border:1px solid;background-color:#fff}}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .color-label{position:relative;cursor:pointer}.angular-editor-toolbar .angular-editor-toolbar-set .background{font-size:smaller;background:#1b1b1b;color:#fff;padding:3px}.angular-editor-toolbar .angular-editor-toolbar-set .foreground :after{position:absolute;content:"";left:-1px;top:auto;bottom:-3px;right:auto;width:15px;height:2px;z-index:0;background:#1b1b1b}.angular-editor-toolbar .angular-editor-toolbar-set:not([style*="display:none"]):not([style*="display: none"]){display:inline-block}.angular-editor{position:relative}.angular-editor ::ng-deep [contenteditable=true]:empty:before{content:attr(placeholder);color:#868e96;opacity:1}.angular-editor .angular-editor-wrapper{position:relative}.angular-editor .angular-editor-wrapper .angular-editor-textarea{min-height:5rem;padding:.5rem .8rem 1rem;border:1px solid #ddd;background-color:transparent;overflow-x:hidden;overflow-y:auto;position:relative}.angular-editor .angular-editor-wrapper .angular-editor-textarea ::ng-deep blockquote{margin-left:1rem;border-left:.2em solid #dfe2e5;padding-left:.5rem}.angular-editor .angular-editor-wrapper ::ng-deep p{margin-bottom:0}.angular-editor .angular-editor-wrapper .angular-editor-placeholder{display:none;position:absolute;top:0;padding:.5rem .8rem 1rem .9rem;color:#6c757d;opacity:.75}.angular-editor .angular-editor-wrapper.show-placeholder .angular-editor-placeholder{display:block}.angular-editor .angular-editor-wrapper.disabled{cursor:not-allowed;opacity:.5;pointer-events:none}\n']
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: AngularEditorService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT2]
      }]
    }, {
      type: DomSanitizer
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["tabindex"]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["autofocus"]
      }]
    }];
  }, {
    id: [{
      type: Input
    }],
    config: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    html: [{
      type: Output
    }],
    textArea: [{
      type: ViewChild,
      args: ["editor", {
        static: true
      }]
    }],
    editorWrapper: [{
      type: ViewChild,
      args: ["editorWrapper", {
        static: true
      }]
    }],
    editorToolbar: [{
      type: ViewChild,
      args: ["editorToolbar"]
    }],
    customButtonsTemplateRef: [{
      type: ContentChild,
      args: ["customButtons"]
    }],
    viewMode: [{
      type: Output
    }],
    blurEvent: [{
      type: Output,
      args: ["blur"]
    }],
    focusEvent: [{
      type: Output,
      args: ["focus"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    onFocus: [{
      type: HostListener,
      args: ["focus"]
    }]
  });
})();
var AeButtonComponent = class {
  constructor() {
    this.iconClass = "";
    this.title = "";
    this.buttonClick = new EventEmitter();
  }
};
AeButtonComponent.\u0275fac = function AeButtonComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AeButtonComponent)();
};
AeButtonComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: AeButtonComponent,
  selectors: [["ae-button"]],
  inputs: {
    iconClass: "iconClass",
    title: "title"
  },
  outputs: {
    buttonClick: "buttonClick"
  },
  standalone: false,
  decls: 2,
  vars: 3,
  consts: [["type", "button", "tabindex", "-1", 1, "angular-editor-button", 3, "click", "title"]],
  template: function AeButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "button", 0);
      \u0275\u0275listener("click", function AeButtonComponent_Template_button_click_0_listener() {
        return ctx.buttonClick.emit();
      });
      \u0275\u0275element(1, "i");
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("title", ctx.title);
      \u0275\u0275advance();
      \u0275\u0275classMap(ctx.iconClass);
    }
  },
  styles: ['/*!\n *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome\n *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)\n */@font-face{font-family:FontAwesome;src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?v=4.7.0);src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?#iefix&v=4.7.0) format("embedded-opentype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff2?v=4.7.0) format("woff2"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff?v=4.7.0) format("woff"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.ttf?v=4.7.0) format("truetype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular) format("svg");font-weight:400;font-style:normal}.fa{display:inline-block;font: 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.3333333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.2857142857em;text-align:center}.fa-ul{padding-left:0;margin-left:2.1428571429em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.1428571429em;width:2.1428571429em;top:.1428571429em;text-align:center}.fa-li.fa-lg{left:-1.8571428571em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{animation:fa-spin 2s infinite linear}.fa-pulse{animation:fa-spin 1s infinite steps(8)}@keyframes fa-spin{0%{transform:rotate(0)}to{transform:rotate(359deg)}}.fa-rotate-90{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";transform:rotate(90deg)}.fa-rotate-180{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";transform:rotate(180deg)}.fa-rotate-270{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";transform:rotate(270deg)}.fa-flip-horizontal{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";transform:scaleX(-1)}.fa-flip-vertical{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";transform:scaleY(-1)}:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-flip-horizontal,:root .fa-flip-vertical{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:"\\f000"}.fa-music:before{content:"\\f001"}.fa-search:before{content:"\\f002"}.fa-envelope-o:before{content:"\\f003"}.fa-heart:before{content:"\\f004"}.fa-star:before{content:"\\f005"}.fa-star-o:before{content:"\\f006"}.fa-user:before{content:"\\f007"}.fa-film:before{content:"\\f008"}.fa-th-large:before{content:"\\f009"}.fa-th:before{content:"\\f00a"}.fa-th-list:before{content:"\\f00b"}.fa-check:before{content:"\\f00c"}.fa-remove:before,.fa-close:before,.fa-times:before{content:"\\f00d"}.fa-search-plus:before{content:"\\f00e"}.fa-search-minus:before{content:"\\f010"}.fa-power-off:before{content:"\\f011"}.fa-signal:before{content:"\\f012"}.fa-gear:before,.fa-cog:before{content:"\\f013"}.fa-trash-o:before{content:"\\f014"}.fa-home:before{content:"\\f015"}.fa-file-o:before{content:"\\f016"}.fa-clock-o:before{content:"\\f017"}.fa-road:before{content:"\\f018"}.fa-download:before{content:"\\f019"}.fa-arrow-circle-o-down:before{content:"\\f01a"}.fa-arrow-circle-o-up:before{content:"\\f01b"}.fa-inbox:before{content:"\\f01c"}.fa-play-circle-o:before{content:"\\f01d"}.fa-rotate-right:before,.fa-repeat:before{content:"\\f01e"}.fa-refresh:before{content:"\\f021"}.fa-list-alt:before{content:"\\f022"}.fa-lock:before{content:"\\f023"}.fa-flag:before{content:"\\f024"}.fa-headphones:before{content:"\\f025"}.fa-volume-off:before{content:"\\f026"}.fa-volume-down:before{content:"\\f027"}.fa-volume-up:before{content:"\\f028"}.fa-qrcode:before{content:"\\f029"}.fa-barcode:before{content:"\\f02a"}.fa-tag:before{content:"\\f02b"}.fa-tags:before{content:"\\f02c"}.fa-book:before{content:"\\f02d"}.fa-bookmark:before{content:"\\f02e"}.fa-print:before{content:"\\f02f"}.fa-camera:before{content:"\\f030"}.fa-font:before{content:"\\f031"}.fa-bold:before{content:"\\f032"}.fa-italic:before{content:"\\f033"}.fa-text-height:before{content:"\\f034"}.fa-text-width:before{content:"\\f035"}.fa-align-left:before{content:"\\f036"}.fa-align-center:before{content:"\\f037"}.fa-align-right:before{content:"\\f038"}.fa-align-justify:before{content:"\\f039"}.fa-list:before{content:"\\f03a"}.fa-dedent:before,.fa-outdent:before{content:"\\f03b"}.fa-indent:before{content:"\\f03c"}.fa-video-camera:before{content:"\\f03d"}.fa-photo:before,.fa-image:before,.fa-picture-o:before{content:"\\f03e"}.fa-pencil:before{content:"\\f040"}.fa-map-marker:before{content:"\\f041"}.fa-adjust:before{content:"\\f042"}.fa-tint:before{content:"\\f043"}.fa-edit:before,.fa-pencil-square-o:before{content:"\\f044"}.fa-share-square-o:before{content:"\\f045"}.fa-check-square-o:before{content:"\\f046"}.fa-arrows:before{content:"\\f047"}.fa-step-backward:before{content:"\\f048"}.fa-fast-backward:before{content:"\\f049"}.fa-backward:before{content:"\\f04a"}.fa-play:before{content:"\\f04b"}.fa-pause:before{content:"\\f04c"}.fa-stop:before{content:"\\f04d"}.fa-forward:before{content:"\\f04e"}.fa-fast-forward:before{content:"\\f050"}.fa-step-forward:before{content:"\\f051"}.fa-eject:before{content:"\\f052"}.fa-chevron-left:before{content:"\\f053"}.fa-chevron-right:before{content:"\\f054"}.fa-plus-circle:before{content:"\\f055"}.fa-minus-circle:before{content:"\\f056"}.fa-times-circle:before{content:"\\f057"}.fa-check-circle:before{content:"\\f058"}.fa-question-circle:before{content:"\\f059"}.fa-info-circle:before{content:"\\f05a"}.fa-crosshairs:before{content:"\\f05b"}.fa-times-circle-o:before{content:"\\f05c"}.fa-check-circle-o:before{content:"\\f05d"}.fa-ban:before{content:"\\f05e"}.fa-arrow-left:before{content:"\\f060"}.fa-arrow-right:before{content:"\\f061"}.fa-arrow-up:before{content:"\\f062"}.fa-arrow-down:before{content:"\\f063"}.fa-mail-forward:before,.fa-share:before{content:"\\f064"}.fa-expand:before{content:"\\f065"}.fa-compress:before{content:"\\f066"}.fa-plus:before{content:"\\f067"}.fa-minus:before{content:"\\f068"}.fa-asterisk:before{content:"\\f069"}.fa-exclamation-circle:before{content:"\\f06a"}.fa-gift:before{content:"\\f06b"}.fa-leaf:before{content:"\\f06c"}.fa-fire:before{content:"\\f06d"}.fa-eye:before{content:"\\f06e"}.fa-eye-slash:before{content:"\\f070"}.fa-warning:before,.fa-exclamation-triangle:before{content:"\\f071"}.fa-plane:before{content:"\\f072"}.fa-calendar:before{content:"\\f073"}.fa-random:before{content:"\\f074"}.fa-comment:before{content:"\\f075"}.fa-magnet:before{content:"\\f076"}.fa-chevron-up:before{content:"\\f077"}.fa-chevron-down:before{content:"\\f078"}.fa-retweet:before{content:"\\f079"}.fa-shopping-cart:before{content:"\\f07a"}.fa-folder:before{content:"\\f07b"}.fa-folder-open:before{content:"\\f07c"}.fa-arrows-v:before{content:"\\f07d"}.fa-arrows-h:before{content:"\\f07e"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:"\\f080"}.fa-twitter-square:before{content:"\\f081"}.fa-facebook-square:before{content:"\\f082"}.fa-camera-retro:before{content:"\\f083"}.fa-key:before{content:"\\f084"}.fa-gears:before,.fa-cogs:before{content:"\\f085"}.fa-comments:before{content:"\\f086"}.fa-thumbs-o-up:before{content:"\\f087"}.fa-thumbs-o-down:before{content:"\\f088"}.fa-star-half:before{content:"\\f089"}.fa-heart-o:before{content:"\\f08a"}.fa-sign-out:before{content:"\\f08b"}.fa-linkedin-square:before{content:"\\f08c"}.fa-thumb-tack:before{content:"\\f08d"}.fa-external-link:before{content:"\\f08e"}.fa-sign-in:before{content:"\\f090"}.fa-trophy:before{content:"\\f091"}.fa-github-square:before{content:"\\f092"}.fa-upload:before{content:"\\f093"}.fa-lemon-o:before{content:"\\f094"}.fa-phone:before{content:"\\f095"}.fa-square-o:before{content:"\\f096"}.fa-bookmark-o:before{content:"\\f097"}.fa-phone-square:before{content:"\\f098"}.fa-twitter:before{content:"\\f099"}.fa-facebook-f:before,.fa-facebook:before{content:"\\f09a"}.fa-github:before{content:"\\f09b"}.fa-unlock:before{content:"\\f09c"}.fa-credit-card:before{content:"\\f09d"}.fa-feed:before,.fa-rss:before{content:"\\f09e"}.fa-hdd-o:before{content:"\\f0a0"}.fa-bullhorn:before{content:"\\f0a1"}.fa-bell:before{content:"\\f0f3"}.fa-certificate:before{content:"\\f0a3"}.fa-hand-o-right:before{content:"\\f0a4"}.fa-hand-o-left:before{content:"\\f0a5"}.fa-hand-o-up:before{content:"\\f0a6"}.fa-hand-o-down:before{content:"\\f0a7"}.fa-arrow-circle-left:before{content:"\\f0a8"}.fa-arrow-circle-right:before{content:"\\f0a9"}.fa-arrow-circle-up:before{content:"\\f0aa"}.fa-arrow-circle-down:before{content:"\\f0ab"}.fa-globe:before{content:"\\f0ac"}.fa-wrench:before{content:"\\f0ad"}.fa-tasks:before{content:"\\f0ae"}.fa-filter:before{content:"\\f0b0"}.fa-briefcase:before{content:"\\f0b1"}.fa-arrows-alt:before{content:"\\f0b2"}.fa-group:before,.fa-users:before{content:"\\f0c0"}.fa-chain:before,.fa-link:before{content:"\\f0c1"}.fa-cloud:before{content:"\\f0c2"}.fa-flask:before{content:"\\f0c3"}.fa-cut:before,.fa-scissors:before{content:"\\f0c4"}.fa-copy:before,.fa-files-o:before{content:"\\f0c5"}.fa-paperclip:before{content:"\\f0c6"}.fa-save:before,.fa-floppy-o:before{content:"\\f0c7"}.fa-square:before{content:"\\f0c8"}.fa-navicon:before,.fa-reorder:before,.fa-bars:before{content:"\\f0c9"}.fa-list-ul:before{content:"\\f0ca"}.fa-list-ol:before{content:"\\f0cb"}.fa-strikethrough:before{content:"\\f0cc"}.fa-underline:before{content:"\\f0cd"}.fa-table:before{content:"\\f0ce"}.fa-magic:before{content:"\\f0d0"}.fa-truck:before{content:"\\f0d1"}.fa-pinterest:before{content:"\\f0d2"}.fa-pinterest-square:before{content:"\\f0d3"}.fa-google-plus-square:before{content:"\\f0d4"}.fa-google-plus:before{content:"\\f0d5"}.fa-money:before{content:"\\f0d6"}.fa-caret-down:before{content:"\\f0d7"}.fa-caret-up:before{content:"\\f0d8"}.fa-caret-left:before{content:"\\f0d9"}.fa-caret-right:before{content:"\\f0da"}.fa-columns:before{content:"\\f0db"}.fa-unsorted:before,.fa-sort:before{content:"\\f0dc"}.fa-sort-down:before,.fa-sort-desc:before{content:"\\f0dd"}.fa-sort-up:before,.fa-sort-asc:before{content:"\\f0de"}.fa-envelope:before{content:"\\f0e0"}.fa-linkedin:before{content:"\\f0e1"}.fa-rotate-left:before,.fa-undo:before{content:"\\f0e2"}.fa-legal:before,.fa-gavel:before{content:"\\f0e3"}.fa-dashboard:before,.fa-tachometer:before{content:"\\f0e4"}.fa-comment-o:before{content:"\\f0e5"}.fa-comments-o:before{content:"\\f0e6"}.fa-flash:before,.fa-bolt:before{content:"\\f0e7"}.fa-sitemap:before{content:"\\f0e8"}.fa-umbrella:before{content:"\\f0e9"}.fa-paste:before,.fa-clipboard:before{content:"\\f0ea"}.fa-lightbulb-o:before{content:"\\f0eb"}.fa-exchange:before{content:"\\f0ec"}.fa-cloud-download:before{content:"\\f0ed"}.fa-cloud-upload:before{content:"\\f0ee"}.fa-user-md:before{content:"\\f0f0"}.fa-stethoscope:before{content:"\\f0f1"}.fa-suitcase:before{content:"\\f0f2"}.fa-bell-o:before{content:"\\f0a2"}.fa-coffee:before{content:"\\f0f4"}.fa-cutlery:before{content:"\\f0f5"}.fa-file-text-o:before{content:"\\f0f6"}.fa-building-o:before{content:"\\f0f7"}.fa-hospital-o:before{content:"\\f0f8"}.fa-ambulance:before{content:"\\f0f9"}.fa-medkit:before{content:"\\f0fa"}.fa-fighter-jet:before{content:"\\f0fb"}.fa-beer:before{content:"\\f0fc"}.fa-h-square:before{content:"\\f0fd"}.fa-plus-square:before{content:"\\f0fe"}.fa-angle-double-left:before{content:"\\f100"}.fa-angle-double-right:before{content:"\\f101"}.fa-angle-double-up:before{content:"\\f102"}.fa-angle-double-down:before{content:"\\f103"}.fa-angle-left:before{content:"\\f104"}.fa-angle-right:before{content:"\\f105"}.fa-angle-up:before{content:"\\f106"}.fa-angle-down:before{content:"\\f107"}.fa-desktop:before{content:"\\f108"}.fa-laptop:before{content:"\\f109"}.fa-tablet:before{content:"\\f10a"}.fa-mobile-phone:before,.fa-mobile:before{content:"\\f10b"}.fa-circle-o:before{content:"\\f10c"}.fa-quote-left:before{content:"\\f10d"}.fa-quote-right:before{content:"\\f10e"}.fa-spinner:before{content:"\\f110"}.fa-circle:before{content:"\\f111"}.fa-mail-reply:before,.fa-reply:before{content:"\\f112"}.fa-github-alt:before{content:"\\f113"}.fa-folder-o:before{content:"\\f114"}.fa-folder-open-o:before{content:"\\f115"}.fa-smile-o:before{content:"\\f118"}.fa-frown-o:before{content:"\\f119"}.fa-meh-o:before{content:"\\f11a"}.fa-gamepad:before{content:"\\f11b"}.fa-keyboard-o:before{content:"\\f11c"}.fa-flag-o:before{content:"\\f11d"}.fa-flag-checkered:before{content:"\\f11e"}.fa-terminal:before{content:"\\f120"}.fa-code:before{content:"\\f121"}.fa-mail-reply-all:before,.fa-reply-all:before{content:"\\f122"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:"\\f123"}.fa-location-arrow:before{content:"\\f124"}.fa-crop:before{content:"\\f125"}.fa-code-fork:before{content:"\\f126"}.fa-unlink:before,.fa-chain-broken:before{content:"\\f127"}.fa-question:before{content:"\\f128"}.fa-info:before{content:"\\f129"}.fa-exclamation:before{content:"\\f12a"}.fa-superscript:before{content:"\\f12b"}.fa-subscript:before{content:"\\f12c"}.fa-eraser:before{content:"\\f12d"}.fa-puzzle-piece:before{content:"\\f12e"}.fa-microphone:before{content:"\\f130"}.fa-microphone-slash:before{content:"\\f131"}.fa-shield:before{content:"\\f132"}.fa-calendar-o:before{content:"\\f133"}.fa-fire-extinguisher:before{content:"\\f134"}.fa-rocket:before{content:"\\f135"}.fa-maxcdn:before{content:"\\f136"}.fa-chevron-circle-left:before{content:"\\f137"}.fa-chevron-circle-right:before{content:"\\f138"}.fa-chevron-circle-up:before{content:"\\f139"}.fa-chevron-circle-down:before{content:"\\f13a"}.fa-html5:before{content:"\\f13b"}.fa-css3:before{content:"\\f13c"}.fa-anchor:before{content:"\\f13d"}.fa-unlock-alt:before{content:"\\f13e"}.fa-bullseye:before{content:"\\f140"}.fa-ellipsis-h:before{content:"\\f141"}.fa-ellipsis-v:before{content:"\\f142"}.fa-rss-square:before{content:"\\f143"}.fa-play-circle:before{content:"\\f144"}.fa-ticket:before{content:"\\f145"}.fa-minus-square:before{content:"\\f146"}.fa-minus-square-o:before{content:"\\f147"}.fa-level-up:before{content:"\\f148"}.fa-level-down:before{content:"\\f149"}.fa-check-square:before{content:"\\f14a"}.fa-pencil-square:before{content:"\\f14b"}.fa-external-link-square:before{content:"\\f14c"}.fa-share-square:before{content:"\\f14d"}.fa-compass:before{content:"\\f14e"}.fa-toggle-down:before,.fa-caret-square-o-down:before{content:"\\f150"}.fa-toggle-up:before,.fa-caret-square-o-up:before{content:"\\f151"}.fa-toggle-right:before,.fa-caret-square-o-right:before{content:"\\f152"}.fa-euro:before,.fa-eur:before{content:"\\f153"}.fa-gbp:before{content:"\\f154"}.fa-dollar:before,.fa-usd:before{content:"\\f155"}.fa-rupee:before,.fa-inr:before{content:"\\f156"}.fa-cny:before,.fa-rmb:before,.fa-yen:before,.fa-jpy:before{content:"\\f157"}.fa-ruble:before,.fa-rouble:before,.fa-rub:before{content:"\\f158"}.fa-won:before,.fa-krw:before{content:"\\f159"}.fa-bitcoin:before,.fa-btc:before{content:"\\f15a"}.fa-file:before{content:"\\f15b"}.fa-file-text:before{content:"\\f15c"}.fa-sort-alpha-asc:before{content:"\\f15d"}.fa-sort-alpha-desc:before{content:"\\f15e"}.fa-sort-amount-asc:before{content:"\\f160"}.fa-sort-amount-desc:before{content:"\\f161"}.fa-sort-numeric-asc:before{content:"\\f162"}.fa-sort-numeric-desc:before{content:"\\f163"}.fa-thumbs-up:before{content:"\\f164"}.fa-thumbs-down:before{content:"\\f165"}.fa-youtube-square:before{content:"\\f166"}.fa-youtube:before{content:"\\f167"}.fa-xing:before{content:"\\f168"}.fa-xing-square:before{content:"\\f169"}.fa-youtube-play:before{content:"\\f16a"}.fa-dropbox:before{content:"\\f16b"}.fa-stack-overflow:before{content:"\\f16c"}.fa-instagram:before{content:"\\f16d"}.fa-flickr:before{content:"\\f16e"}.fa-adn:before{content:"\\f170"}.fa-bitbucket:before{content:"\\f171"}.fa-bitbucket-square:before{content:"\\f172"}.fa-tumblr:before{content:"\\f173"}.fa-tumblr-square:before{content:"\\f174"}.fa-long-arrow-down:before{content:"\\f175"}.fa-long-arrow-up:before{content:"\\f176"}.fa-long-arrow-left:before{content:"\\f177"}.fa-long-arrow-right:before{content:"\\f178"}.fa-apple:before{content:"\\f179"}.fa-windows:before{content:"\\f17a"}.fa-android:before{content:"\\f17b"}.fa-linux:before{content:"\\f17c"}.fa-dribbble:before{content:"\\f17d"}.fa-skype:before{content:"\\f17e"}.fa-foursquare:before{content:"\\f180"}.fa-trello:before{content:"\\f181"}.fa-female:before{content:"\\f182"}.fa-male:before{content:"\\f183"}.fa-gittip:before,.fa-gratipay:before{content:"\\f184"}.fa-sun-o:before{content:"\\f185"}.fa-moon-o:before{content:"\\f186"}.fa-archive:before{content:"\\f187"}.fa-bug:before{content:"\\f188"}.fa-vk:before{content:"\\f189"}.fa-weibo:before{content:"\\f18a"}.fa-renren:before{content:"\\f18b"}.fa-pagelines:before{content:"\\f18c"}.fa-stack-exchange:before{content:"\\f18d"}.fa-arrow-circle-o-right:before{content:"\\f18e"}.fa-arrow-circle-o-left:before{content:"\\f190"}.fa-toggle-left:before,.fa-caret-square-o-left:before{content:"\\f191"}.fa-dot-circle-o:before{content:"\\f192"}.fa-wheelchair:before{content:"\\f193"}.fa-vimeo-square:before{content:"\\f194"}.fa-turkish-lira:before,.fa-try:before{content:"\\f195"}.fa-plus-square-o:before{content:"\\f196"}.fa-space-shuttle:before{content:"\\f197"}.fa-slack:before{content:"\\f198"}.fa-envelope-square:before{content:"\\f199"}.fa-wordpress:before{content:"\\f19a"}.fa-openid:before{content:"\\f19b"}.fa-institution:before,.fa-bank:before,.fa-university:before{content:"\\f19c"}.fa-mortar-board:before,.fa-graduation-cap:before{content:"\\f19d"}.fa-yahoo:before{content:"\\f19e"}.fa-google:before{content:"\\f1a0"}.fa-reddit:before{content:"\\f1a1"}.fa-reddit-square:before{content:"\\f1a2"}.fa-stumbleupon-circle:before{content:"\\f1a3"}.fa-stumbleupon:before{content:"\\f1a4"}.fa-delicious:before{content:"\\f1a5"}.fa-digg:before{content:"\\f1a6"}.fa-pied-piper-pp:before{content:"\\f1a7"}.fa-pied-piper-alt:before{content:"\\f1a8"}.fa-drupal:before{content:"\\f1a9"}.fa-joomla:before{content:"\\f1aa"}.fa-language:before{content:"\\f1ab"}.fa-fax:before{content:"\\f1ac"}.fa-building:before{content:"\\f1ad"}.fa-child:before{content:"\\f1ae"}.fa-paw:before{content:"\\f1b0"}.fa-spoon:before{content:"\\f1b1"}.fa-cube:before{content:"\\f1b2"}.fa-cubes:before{content:"\\f1b3"}.fa-behance:before{content:"\\f1b4"}.fa-behance-square:before{content:"\\f1b5"}.fa-steam:before{content:"\\f1b6"}.fa-steam-square:before{content:"\\f1b7"}.fa-recycle:before{content:"\\f1b8"}.fa-automobile:before,.fa-car:before{content:"\\f1b9"}.fa-cab:before,.fa-taxi:before{content:"\\f1ba"}.fa-tree:before{content:"\\f1bb"}.fa-spotify:before{content:"\\f1bc"}.fa-deviantart:before{content:"\\f1bd"}.fa-soundcloud:before{content:"\\f1be"}.fa-database:before{content:"\\f1c0"}.fa-file-pdf-o:before{content:"\\f1c1"}.fa-file-word-o:before{content:"\\f1c2"}.fa-file-excel-o:before{content:"\\f1c3"}.fa-file-powerpoint-o:before{content:"\\f1c4"}.fa-file-photo-o:before,.fa-file-picture-o:before,.fa-file-image-o:before{content:"\\f1c5"}.fa-file-zip-o:before,.fa-file-archive-o:before{content:"\\f1c6"}.fa-file-sound-o:before,.fa-file-audio-o:before{content:"\\f1c7"}.fa-file-movie-o:before,.fa-file-video-o:before{content:"\\f1c8"}.fa-file-code-o:before{content:"\\f1c9"}.fa-vine:before{content:"\\f1ca"}.fa-codepen:before{content:"\\f1cb"}.fa-jsfiddle:before{content:"\\f1cc"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-saver:before,.fa-support:before,.fa-life-ring:before{content:"\\f1cd"}.fa-circle-o-notch:before{content:"\\f1ce"}.fa-ra:before,.fa-resistance:before,.fa-rebel:before{content:"\\f1d0"}.fa-ge:before,.fa-empire:before{content:"\\f1d1"}.fa-git-square:before{content:"\\f1d2"}.fa-git:before{content:"\\f1d3"}.fa-y-combinator-square:before,.fa-yc-square:before,.fa-hacker-news:before{content:"\\f1d4"}.fa-tencent-weibo:before{content:"\\f1d5"}.fa-qq:before{content:"\\f1d6"}.fa-wechat:before,.fa-weixin:before{content:"\\f1d7"}.fa-send:before,.fa-paper-plane:before{content:"\\f1d8"}.fa-send-o:before,.fa-paper-plane-o:before{content:"\\f1d9"}.fa-history:before{content:"\\f1da"}.fa-circle-thin:before{content:"\\f1db"}.fa-header:before{content:"\\f1dc"}.fa-paragraph:before{content:"\\f1dd"}.fa-sliders:before{content:"\\f1de"}.fa-share-alt:before{content:"\\f1e0"}.fa-share-alt-square:before{content:"\\f1e1"}.fa-bomb:before{content:"\\f1e2"}.fa-soccer-ball-o:before,.fa-futbol-o:before{content:"\\f1e3"}.fa-tty:before{content:"\\f1e4"}.fa-binoculars:before{content:"\\f1e5"}.fa-plug:before{content:"\\f1e6"}.fa-slideshare:before{content:"\\f1e7"}.fa-twitch:before{content:"\\f1e8"}.fa-yelp:before{content:"\\f1e9"}.fa-newspaper-o:before{content:"\\f1ea"}.fa-wifi:before{content:"\\f1eb"}.fa-calculator:before{content:"\\f1ec"}.fa-paypal:before{content:"\\f1ed"}.fa-google-wallet:before{content:"\\f1ee"}.fa-cc-visa:before{content:"\\f1f0"}.fa-cc-mastercard:before{content:"\\f1f1"}.fa-cc-discover:before{content:"\\f1f2"}.fa-cc-amex:before{content:"\\f1f3"}.fa-cc-paypal:before{content:"\\f1f4"}.fa-cc-stripe:before{content:"\\f1f5"}.fa-bell-slash:before{content:"\\f1f6"}.fa-bell-slash-o:before{content:"\\f1f7"}.fa-trash:before{content:"\\f1f8"}.fa-copyright:before{content:"\\f1f9"}.fa-at:before{content:"\\f1fa"}.fa-eyedropper:before{content:"\\f1fb"}.fa-paint-brush:before{content:"\\f1fc"}.fa-birthday-cake:before{content:"\\f1fd"}.fa-area-chart:before{content:"\\f1fe"}.fa-pie-chart:before{content:"\\f200"}.fa-line-chart:before{content:"\\f201"}.fa-lastfm:before{content:"\\f202"}.fa-lastfm-square:before{content:"\\f203"}.fa-toggle-off:before{content:"\\f204"}.fa-toggle-on:before{content:"\\f205"}.fa-bicycle:before{content:"\\f206"}.fa-bus:before{content:"\\f207"}.fa-ioxhost:before{content:"\\f208"}.fa-angellist:before{content:"\\f209"}.fa-cc:before{content:"\\f20a"}.fa-shekel:before,.fa-sheqel:before,.fa-ils:before{content:"\\f20b"}.fa-meanpath:before{content:"\\f20c"}.fa-buysellads:before{content:"\\f20d"}.fa-connectdevelop:before{content:"\\f20e"}.fa-dashcube:before{content:"\\f210"}.fa-forumbee:before{content:"\\f211"}.fa-leanpub:before{content:"\\f212"}.fa-sellsy:before{content:"\\f213"}.fa-shirtsinbulk:before{content:"\\f214"}.fa-simplybuilt:before{content:"\\f215"}.fa-skyatlas:before{content:"\\f216"}.fa-cart-plus:before{content:"\\f217"}.fa-cart-arrow-down:before{content:"\\f218"}.fa-diamond:before{content:"\\f219"}.fa-ship:before{content:"\\f21a"}.fa-user-secret:before{content:"\\f21b"}.fa-motorcycle:before{content:"\\f21c"}.fa-street-view:before{content:"\\f21d"}.fa-heartbeat:before{content:"\\f21e"}.fa-venus:before{content:"\\f221"}.fa-mars:before{content:"\\f222"}.fa-mercury:before{content:"\\f223"}.fa-intersex:before,.fa-transgender:before{content:"\\f224"}.fa-transgender-alt:before{content:"\\f225"}.fa-venus-double:before{content:"\\f226"}.fa-mars-double:before{content:"\\f227"}.fa-venus-mars:before{content:"\\f228"}.fa-mars-stroke:before{content:"\\f229"}.fa-mars-stroke-v:before{content:"\\f22a"}.fa-mars-stroke-h:before{content:"\\f22b"}.fa-neuter:before{content:"\\f22c"}.fa-genderless:before{content:"\\f22d"}.fa-facebook-official:before{content:"\\f230"}.fa-pinterest-p:before{content:"\\f231"}.fa-whatsapp:before{content:"\\f232"}.fa-server:before{content:"\\f233"}.fa-user-plus:before{content:"\\f234"}.fa-user-times:before{content:"\\f235"}.fa-hotel:before,.fa-bed:before{content:"\\f236"}.fa-viacoin:before{content:"\\f237"}.fa-train:before{content:"\\f238"}.fa-subway:before{content:"\\f239"}.fa-medium:before{content:"\\f23a"}.fa-yc:before,.fa-y-combinator:before{content:"\\f23b"}.fa-optin-monster:before{content:"\\f23c"}.fa-opencart:before{content:"\\f23d"}.fa-expeditedssl:before{content:"\\f23e"}.fa-battery-4:before,.fa-battery:before,.fa-battery-full:before{content:"\\f240"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:"\\f241"}.fa-battery-2:before,.fa-battery-half:before{content:"\\f242"}.fa-battery-1:before,.fa-battery-quarter:before{content:"\\f243"}.fa-battery-0:before,.fa-battery-empty:before{content:"\\f244"}.fa-mouse-pointer:before{content:"\\f245"}.fa-i-cursor:before{content:"\\f246"}.fa-object-group:before{content:"\\f247"}.fa-object-ungroup:before{content:"\\f248"}.fa-sticky-note:before{content:"\\f249"}.fa-sticky-note-o:before{content:"\\f24a"}.fa-cc-jcb:before{content:"\\f24b"}.fa-cc-diners-club:before{content:"\\f24c"}.fa-clone:before{content:"\\f24d"}.fa-balance-scale:before{content:"\\f24e"}.fa-hourglass-o:before{content:"\\f250"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:"\\f251"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:"\\f252"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:"\\f253"}.fa-hourglass:before{content:"\\f254"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:"\\f255"}.fa-hand-stop-o:before,.fa-hand-paper-o:before{content:"\\f256"}.fa-hand-scissors-o:before{content:"\\f257"}.fa-hand-lizard-o:before{content:"\\f258"}.fa-hand-spock-o:before{content:"\\f259"}.fa-hand-pointer-o:before{content:"\\f25a"}.fa-hand-peace-o:before{content:"\\f25b"}.fa-trademark:before{content:"\\f25c"}.fa-registered:before{content:"\\f25d"}.fa-creative-commons:before{content:"\\f25e"}.fa-gg:before{content:"\\f260"}.fa-gg-circle:before{content:"\\f261"}.fa-tripadvisor:before{content:"\\f262"}.fa-odnoklassniki:before{content:"\\f263"}.fa-odnoklassniki-square:before{content:"\\f264"}.fa-get-pocket:before{content:"\\f265"}.fa-wikipedia-w:before{content:"\\f266"}.fa-safari:before{content:"\\f267"}.fa-chrome:before{content:"\\f268"}.fa-firefox:before{content:"\\f269"}.fa-opera:before{content:"\\f26a"}.fa-internet-explorer:before{content:"\\f26b"}.fa-tv:before,.fa-television:before{content:"\\f26c"}.fa-contao:before{content:"\\f26d"}.fa-500px:before{content:"\\f26e"}.fa-amazon:before{content:"\\f270"}.fa-calendar-plus-o:before{content:"\\f271"}.fa-calendar-minus-o:before{content:"\\f272"}.fa-calendar-times-o:before{content:"\\f273"}.fa-calendar-check-o:before{content:"\\f274"}.fa-industry:before{content:"\\f275"}.fa-map-pin:before{content:"\\f276"}.fa-map-signs:before{content:"\\f277"}.fa-map-o:before{content:"\\f278"}.fa-map:before{content:"\\f279"}.fa-commenting:before{content:"\\f27a"}.fa-commenting-o:before{content:"\\f27b"}.fa-houzz:before{content:"\\f27c"}.fa-vimeo:before{content:"\\f27d"}.fa-black-tie:before{content:"\\f27e"}.fa-fonticons:before{content:"\\f280"}.fa-reddit-alien:before{content:"\\f281"}.fa-edge:before{content:"\\f282"}.fa-credit-card-alt:before{content:"\\f283"}.fa-codiepie:before{content:"\\f284"}.fa-modx:before{content:"\\f285"}.fa-fort-awesome:before{content:"\\f286"}.fa-usb:before{content:"\\f287"}.fa-product-hunt:before{content:"\\f288"}.fa-mixcloud:before{content:"\\f289"}.fa-scribd:before{content:"\\f28a"}.fa-pause-circle:before{content:"\\f28b"}.fa-pause-circle-o:before{content:"\\f28c"}.fa-stop-circle:before{content:"\\f28d"}.fa-stop-circle-o:before{content:"\\f28e"}.fa-shopping-bag:before{content:"\\f290"}.fa-shopping-basket:before{content:"\\f291"}.fa-hashtag:before{content:"\\f292"}.fa-bluetooth:before{content:"\\f293"}.fa-bluetooth-b:before{content:"\\f294"}.fa-percent:before{content:"\\f295"}.fa-gitlab:before{content:"\\f296"}.fa-wpbeginner:before{content:"\\f297"}.fa-wpforms:before{content:"\\f298"}.fa-envira:before{content:"\\f299"}.fa-universal-access:before{content:"\\f29a"}.fa-wheelchair-alt:before{content:"\\f29b"}.fa-question-circle-o:before{content:"\\f29c"}.fa-blind:before{content:"\\f29d"}.fa-audio-description:before{content:"\\f29e"}.fa-volume-control-phone:before{content:"\\f2a0"}.fa-braille:before{content:"\\f2a1"}.fa-assistive-listening-systems:before{content:"\\f2a2"}.fa-asl-interpreting:before,.fa-american-sign-language-interpreting:before{content:"\\f2a3"}.fa-deafness:before,.fa-hard-of-hearing:before,.fa-deaf:before{content:"\\f2a4"}.fa-glide:before{content:"\\f2a5"}.fa-glide-g:before{content:"\\f2a6"}.fa-signing:before,.fa-sign-language:before{content:"\\f2a7"}.fa-low-vision:before{content:"\\f2a8"}.fa-viadeo:before{content:"\\f2a9"}.fa-viadeo-square:before{content:"\\f2aa"}.fa-snapchat:before{content:"\\f2ab"}.fa-snapchat-ghost:before{content:"\\f2ac"}.fa-snapchat-square:before{content:"\\f2ad"}.fa-pied-piper:before{content:"\\f2ae"}.fa-first-order:before{content:"\\f2b0"}.fa-yoast:before{content:"\\f2b1"}.fa-themeisle:before{content:"\\f2b2"}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:"\\f2b3"}.fa-fa:before,.fa-font-awesome:before{content:"\\f2b4"}.fa-handshake-o:before{content:"\\f2b5"}.fa-envelope-open:before{content:"\\f2b6"}.fa-envelope-open-o:before{content:"\\f2b7"}.fa-linode:before{content:"\\f2b8"}.fa-address-book:before{content:"\\f2b9"}.fa-address-book-o:before{content:"\\f2ba"}.fa-vcard:before,.fa-address-card:before{content:"\\f2bb"}.fa-vcard-o:before,.fa-address-card-o:before{content:"\\f2bc"}.fa-user-circle:before{content:"\\f2bd"}.fa-user-circle-o:before{content:"\\f2be"}.fa-user-o:before{content:"\\f2c0"}.fa-id-badge:before{content:"\\f2c1"}.fa-drivers-license:before,.fa-id-card:before{content:"\\f2c2"}.fa-drivers-license-o:before,.fa-id-card-o:before{content:"\\f2c3"}.fa-quora:before{content:"\\f2c4"}.fa-free-code-camp:before{content:"\\f2c5"}.fa-telegram:before{content:"\\f2c6"}.fa-thermometer-4:before,.fa-thermometer:before,.fa-thermometer-full:before{content:"\\f2c7"}.fa-thermometer-3:before,.fa-thermometer-three-quarters:before{content:"\\f2c8"}.fa-thermometer-2:before,.fa-thermometer-half:before{content:"\\f2c9"}.fa-thermometer-1:before,.fa-thermometer-quarter:before{content:"\\f2ca"}.fa-thermometer-0:before,.fa-thermometer-empty:before{content:"\\f2cb"}.fa-shower:before{content:"\\f2cc"}.fa-bathtub:before,.fa-s15:before,.fa-bath:before{content:"\\f2cd"}.fa-podcast:before{content:"\\f2ce"}.fa-window-maximize:before{content:"\\f2d0"}.fa-window-minimize:before{content:"\\f2d1"}.fa-window-restore:before{content:"\\f2d2"}.fa-times-rectangle:before,.fa-window-close:before{content:"\\f2d3"}.fa-times-rectangle-o:before,.fa-window-close-o:before{content:"\\f2d4"}.fa-bandcamp:before{content:"\\f2d5"}.fa-grav:before{content:"\\f2d6"}.fa-etsy:before{content:"\\f2d7"}.fa-imdb:before{content:"\\f2d8"}.fa-ravelry:before{content:"\\f2d9"}.fa-eercast:before{content:"\\f2da"}.fa-microchip:before{content:"\\f2db"}.fa-snowflake-o:before{content:"\\f2dc"}.fa-superpowers:before{content:"\\f2dd"}.fa-wpexplorer:before{content:"\\f2de"}.fa-meetup:before{content:"\\f2e0"}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}a{cursor:pointer}.angular-editor-textarea{min-height:150px;overflow:auto;margin-top:5px;resize:vertical}.angular-editor-textarea:after{content:"";position:absolute;bottom:0;right:0;display:block;width:8px;height:8px;cursor:nwse-resize;background-color:#ffffff80}.angular-editor-toolbar{font:100 14px/15px Roboto,Arial,sans-serif;background-color:#f5f5f5;font-size:.8rem;padding:.2rem;border:1px solid #ddd}.angular-editor-toolbar .angular-editor-toolbar-set{display:none;margin-right:5px;vertical-align:baseline}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button{background-color:#fff;vertical-align:middle;border:1px solid #ddd;padding:.4rem;min-width:2rem;float:left}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:focus,.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.focus{outline:0}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label{pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label.foreground :after{background:#555555}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label.background{background:#555555}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.active{background:#fff5b9}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.active:hover{background-color:#fffa98}.angular-editor-toolbar .angular-editor-toolbar-set select{font-size:11px;width:90px;vertical-align:middle;background-color:transparent;border:.5px solid rgba(255,255,255,0);border-radius:5px;outline:none;padding:.4rem;cursor:pointer}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-heading optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading option{border:1px solid;background-color:#fff}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .default{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h1{font-size:24px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h2{font-size:20px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h3{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h4{font-size:15px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h5{font-size:14px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h6{font-size:13px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .div,.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .pre{font-size:12px}}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-font{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-font optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font option{border:1px solid;background-color:#fff}}.angular-editor-toolbar .angular-editor-toolbar-set .select-font:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-font:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size{display:inline-block;width:50px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size option{border:1px solid;background-color:#fff}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size1{font-size:10px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size2{font-size:12px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size3{font-size:14px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size4{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size5{font-size:18px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size6{font-size:20px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size7{font-size:22px}}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style option{border:1px solid;background-color:#fff}}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .color-label{position:relative;cursor:pointer}.angular-editor-toolbar .angular-editor-toolbar-set .background{font-size:smaller;background:#1b1b1b;color:#fff;padding:3px}.angular-editor-toolbar .angular-editor-toolbar-set .foreground :after{position:absolute;content:"";left:-1px;top:auto;bottom:-3px;right:auto;width:15px;height:2px;z-index:0;background:#1b1b1b}.angular-editor-toolbar .angular-editor-toolbar-set:not([style*="display:none"]):not([style*="display: none"]){display:inline-block}.select-button{display:inline-block}.select-button.disabled{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}\n'],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AeButtonComponent, [{
    type: Component,
    args: [{
      selector: "ae-button",
      encapsulation: ViewEncapsulation.None,
      template: '<button type="button" [title]="title" class="angular-editor-button" (click)="buttonClick.emit()" tabindex="-1"><i\n    [class]="iconClass"></i></button>\n\n',
      styles: ['/*!\n *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome\n *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)\n */@font-face{font-family:FontAwesome;src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?v=4.7.0);src:url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.eot?#iefix&v=4.7.0) format("embedded-opentype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff2?v=4.7.0) format("woff2"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.woff?v=4.7.0) format("woff"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.ttf?v=4.7.0) format("truetype"),url(https://netdna.bootstrapcdn.com/font-awesome/4.7.0/fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular) format("svg");font-weight:400;font-style:normal}.fa{display:inline-block;font: 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.3333333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.2857142857em;text-align:center}.fa-ul{padding-left:0;margin-left:2.1428571429em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.1428571429em;width:2.1428571429em;top:.1428571429em;text-align:center}.fa-li.fa-lg{left:-1.8571428571em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{animation:fa-spin 2s infinite linear}.fa-pulse{animation:fa-spin 1s infinite steps(8)}@keyframes fa-spin{0%{transform:rotate(0)}to{transform:rotate(359deg)}}.fa-rotate-90{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";transform:rotate(90deg)}.fa-rotate-180{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";transform:rotate(180deg)}.fa-rotate-270{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";transform:rotate(270deg)}.fa-flip-horizontal{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";transform:scaleX(-1)}.fa-flip-vertical{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";transform:scaleY(-1)}:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-flip-horizontal,:root .fa-flip-vertical{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:"\\f000"}.fa-music:before{content:"\\f001"}.fa-search:before{content:"\\f002"}.fa-envelope-o:before{content:"\\f003"}.fa-heart:before{content:"\\f004"}.fa-star:before{content:"\\f005"}.fa-star-o:before{content:"\\f006"}.fa-user:before{content:"\\f007"}.fa-film:before{content:"\\f008"}.fa-th-large:before{content:"\\f009"}.fa-th:before{content:"\\f00a"}.fa-th-list:before{content:"\\f00b"}.fa-check:before{content:"\\f00c"}.fa-remove:before,.fa-close:before,.fa-times:before{content:"\\f00d"}.fa-search-plus:before{content:"\\f00e"}.fa-search-minus:before{content:"\\f010"}.fa-power-off:before{content:"\\f011"}.fa-signal:before{content:"\\f012"}.fa-gear:before,.fa-cog:before{content:"\\f013"}.fa-trash-o:before{content:"\\f014"}.fa-home:before{content:"\\f015"}.fa-file-o:before{content:"\\f016"}.fa-clock-o:before{content:"\\f017"}.fa-road:before{content:"\\f018"}.fa-download:before{content:"\\f019"}.fa-arrow-circle-o-down:before{content:"\\f01a"}.fa-arrow-circle-o-up:before{content:"\\f01b"}.fa-inbox:before{content:"\\f01c"}.fa-play-circle-o:before{content:"\\f01d"}.fa-rotate-right:before,.fa-repeat:before{content:"\\f01e"}.fa-refresh:before{content:"\\f021"}.fa-list-alt:before{content:"\\f022"}.fa-lock:before{content:"\\f023"}.fa-flag:before{content:"\\f024"}.fa-headphones:before{content:"\\f025"}.fa-volume-off:before{content:"\\f026"}.fa-volume-down:before{content:"\\f027"}.fa-volume-up:before{content:"\\f028"}.fa-qrcode:before{content:"\\f029"}.fa-barcode:before{content:"\\f02a"}.fa-tag:before{content:"\\f02b"}.fa-tags:before{content:"\\f02c"}.fa-book:before{content:"\\f02d"}.fa-bookmark:before{content:"\\f02e"}.fa-print:before{content:"\\f02f"}.fa-camera:before{content:"\\f030"}.fa-font:before{content:"\\f031"}.fa-bold:before{content:"\\f032"}.fa-italic:before{content:"\\f033"}.fa-text-height:before{content:"\\f034"}.fa-text-width:before{content:"\\f035"}.fa-align-left:before{content:"\\f036"}.fa-align-center:before{content:"\\f037"}.fa-align-right:before{content:"\\f038"}.fa-align-justify:before{content:"\\f039"}.fa-list:before{content:"\\f03a"}.fa-dedent:before,.fa-outdent:before{content:"\\f03b"}.fa-indent:before{content:"\\f03c"}.fa-video-camera:before{content:"\\f03d"}.fa-photo:before,.fa-image:before,.fa-picture-o:before{content:"\\f03e"}.fa-pencil:before{content:"\\f040"}.fa-map-marker:before{content:"\\f041"}.fa-adjust:before{content:"\\f042"}.fa-tint:before{content:"\\f043"}.fa-edit:before,.fa-pencil-square-o:before{content:"\\f044"}.fa-share-square-o:before{content:"\\f045"}.fa-check-square-o:before{content:"\\f046"}.fa-arrows:before{content:"\\f047"}.fa-step-backward:before{content:"\\f048"}.fa-fast-backward:before{content:"\\f049"}.fa-backward:before{content:"\\f04a"}.fa-play:before{content:"\\f04b"}.fa-pause:before{content:"\\f04c"}.fa-stop:before{content:"\\f04d"}.fa-forward:before{content:"\\f04e"}.fa-fast-forward:before{content:"\\f050"}.fa-step-forward:before{content:"\\f051"}.fa-eject:before{content:"\\f052"}.fa-chevron-left:before{content:"\\f053"}.fa-chevron-right:before{content:"\\f054"}.fa-plus-circle:before{content:"\\f055"}.fa-minus-circle:before{content:"\\f056"}.fa-times-circle:before{content:"\\f057"}.fa-check-circle:before{content:"\\f058"}.fa-question-circle:before{content:"\\f059"}.fa-info-circle:before{content:"\\f05a"}.fa-crosshairs:before{content:"\\f05b"}.fa-times-circle-o:before{content:"\\f05c"}.fa-check-circle-o:before{content:"\\f05d"}.fa-ban:before{content:"\\f05e"}.fa-arrow-left:before{content:"\\f060"}.fa-arrow-right:before{content:"\\f061"}.fa-arrow-up:before{content:"\\f062"}.fa-arrow-down:before{content:"\\f063"}.fa-mail-forward:before,.fa-share:before{content:"\\f064"}.fa-expand:before{content:"\\f065"}.fa-compress:before{content:"\\f066"}.fa-plus:before{content:"\\f067"}.fa-minus:before{content:"\\f068"}.fa-asterisk:before{content:"\\f069"}.fa-exclamation-circle:before{content:"\\f06a"}.fa-gift:before{content:"\\f06b"}.fa-leaf:before{content:"\\f06c"}.fa-fire:before{content:"\\f06d"}.fa-eye:before{content:"\\f06e"}.fa-eye-slash:before{content:"\\f070"}.fa-warning:before,.fa-exclamation-triangle:before{content:"\\f071"}.fa-plane:before{content:"\\f072"}.fa-calendar:before{content:"\\f073"}.fa-random:before{content:"\\f074"}.fa-comment:before{content:"\\f075"}.fa-magnet:before{content:"\\f076"}.fa-chevron-up:before{content:"\\f077"}.fa-chevron-down:before{content:"\\f078"}.fa-retweet:before{content:"\\f079"}.fa-shopping-cart:before{content:"\\f07a"}.fa-folder:before{content:"\\f07b"}.fa-folder-open:before{content:"\\f07c"}.fa-arrows-v:before{content:"\\f07d"}.fa-arrows-h:before{content:"\\f07e"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:"\\f080"}.fa-twitter-square:before{content:"\\f081"}.fa-facebook-square:before{content:"\\f082"}.fa-camera-retro:before{content:"\\f083"}.fa-key:before{content:"\\f084"}.fa-gears:before,.fa-cogs:before{content:"\\f085"}.fa-comments:before{content:"\\f086"}.fa-thumbs-o-up:before{content:"\\f087"}.fa-thumbs-o-down:before{content:"\\f088"}.fa-star-half:before{content:"\\f089"}.fa-heart-o:before{content:"\\f08a"}.fa-sign-out:before{content:"\\f08b"}.fa-linkedin-square:before{content:"\\f08c"}.fa-thumb-tack:before{content:"\\f08d"}.fa-external-link:before{content:"\\f08e"}.fa-sign-in:before{content:"\\f090"}.fa-trophy:before{content:"\\f091"}.fa-github-square:before{content:"\\f092"}.fa-upload:before{content:"\\f093"}.fa-lemon-o:before{content:"\\f094"}.fa-phone:before{content:"\\f095"}.fa-square-o:before{content:"\\f096"}.fa-bookmark-o:before{content:"\\f097"}.fa-phone-square:before{content:"\\f098"}.fa-twitter:before{content:"\\f099"}.fa-facebook-f:before,.fa-facebook:before{content:"\\f09a"}.fa-github:before{content:"\\f09b"}.fa-unlock:before{content:"\\f09c"}.fa-credit-card:before{content:"\\f09d"}.fa-feed:before,.fa-rss:before{content:"\\f09e"}.fa-hdd-o:before{content:"\\f0a0"}.fa-bullhorn:before{content:"\\f0a1"}.fa-bell:before{content:"\\f0f3"}.fa-certificate:before{content:"\\f0a3"}.fa-hand-o-right:before{content:"\\f0a4"}.fa-hand-o-left:before{content:"\\f0a5"}.fa-hand-o-up:before{content:"\\f0a6"}.fa-hand-o-down:before{content:"\\f0a7"}.fa-arrow-circle-left:before{content:"\\f0a8"}.fa-arrow-circle-right:before{content:"\\f0a9"}.fa-arrow-circle-up:before{content:"\\f0aa"}.fa-arrow-circle-down:before{content:"\\f0ab"}.fa-globe:before{content:"\\f0ac"}.fa-wrench:before{content:"\\f0ad"}.fa-tasks:before{content:"\\f0ae"}.fa-filter:before{content:"\\f0b0"}.fa-briefcase:before{content:"\\f0b1"}.fa-arrows-alt:before{content:"\\f0b2"}.fa-group:before,.fa-users:before{content:"\\f0c0"}.fa-chain:before,.fa-link:before{content:"\\f0c1"}.fa-cloud:before{content:"\\f0c2"}.fa-flask:before{content:"\\f0c3"}.fa-cut:before,.fa-scissors:before{content:"\\f0c4"}.fa-copy:before,.fa-files-o:before{content:"\\f0c5"}.fa-paperclip:before{content:"\\f0c6"}.fa-save:before,.fa-floppy-o:before{content:"\\f0c7"}.fa-square:before{content:"\\f0c8"}.fa-navicon:before,.fa-reorder:before,.fa-bars:before{content:"\\f0c9"}.fa-list-ul:before{content:"\\f0ca"}.fa-list-ol:before{content:"\\f0cb"}.fa-strikethrough:before{content:"\\f0cc"}.fa-underline:before{content:"\\f0cd"}.fa-table:before{content:"\\f0ce"}.fa-magic:before{content:"\\f0d0"}.fa-truck:before{content:"\\f0d1"}.fa-pinterest:before{content:"\\f0d2"}.fa-pinterest-square:before{content:"\\f0d3"}.fa-google-plus-square:before{content:"\\f0d4"}.fa-google-plus:before{content:"\\f0d5"}.fa-money:before{content:"\\f0d6"}.fa-caret-down:before{content:"\\f0d7"}.fa-caret-up:before{content:"\\f0d8"}.fa-caret-left:before{content:"\\f0d9"}.fa-caret-right:before{content:"\\f0da"}.fa-columns:before{content:"\\f0db"}.fa-unsorted:before,.fa-sort:before{content:"\\f0dc"}.fa-sort-down:before,.fa-sort-desc:before{content:"\\f0dd"}.fa-sort-up:before,.fa-sort-asc:before{content:"\\f0de"}.fa-envelope:before{content:"\\f0e0"}.fa-linkedin:before{content:"\\f0e1"}.fa-rotate-left:before,.fa-undo:before{content:"\\f0e2"}.fa-legal:before,.fa-gavel:before{content:"\\f0e3"}.fa-dashboard:before,.fa-tachometer:before{content:"\\f0e4"}.fa-comment-o:before{content:"\\f0e5"}.fa-comments-o:before{content:"\\f0e6"}.fa-flash:before,.fa-bolt:before{content:"\\f0e7"}.fa-sitemap:before{content:"\\f0e8"}.fa-umbrella:before{content:"\\f0e9"}.fa-paste:before,.fa-clipboard:before{content:"\\f0ea"}.fa-lightbulb-o:before{content:"\\f0eb"}.fa-exchange:before{content:"\\f0ec"}.fa-cloud-download:before{content:"\\f0ed"}.fa-cloud-upload:before{content:"\\f0ee"}.fa-user-md:before{content:"\\f0f0"}.fa-stethoscope:before{content:"\\f0f1"}.fa-suitcase:before{content:"\\f0f2"}.fa-bell-o:before{content:"\\f0a2"}.fa-coffee:before{content:"\\f0f4"}.fa-cutlery:before{content:"\\f0f5"}.fa-file-text-o:before{content:"\\f0f6"}.fa-building-o:before{content:"\\f0f7"}.fa-hospital-o:before{content:"\\f0f8"}.fa-ambulance:before{content:"\\f0f9"}.fa-medkit:before{content:"\\f0fa"}.fa-fighter-jet:before{content:"\\f0fb"}.fa-beer:before{content:"\\f0fc"}.fa-h-square:before{content:"\\f0fd"}.fa-plus-square:before{content:"\\f0fe"}.fa-angle-double-left:before{content:"\\f100"}.fa-angle-double-right:before{content:"\\f101"}.fa-angle-double-up:before{content:"\\f102"}.fa-angle-double-down:before{content:"\\f103"}.fa-angle-left:before{content:"\\f104"}.fa-angle-right:before{content:"\\f105"}.fa-angle-up:before{content:"\\f106"}.fa-angle-down:before{content:"\\f107"}.fa-desktop:before{content:"\\f108"}.fa-laptop:before{content:"\\f109"}.fa-tablet:before{content:"\\f10a"}.fa-mobile-phone:before,.fa-mobile:before{content:"\\f10b"}.fa-circle-o:before{content:"\\f10c"}.fa-quote-left:before{content:"\\f10d"}.fa-quote-right:before{content:"\\f10e"}.fa-spinner:before{content:"\\f110"}.fa-circle:before{content:"\\f111"}.fa-mail-reply:before,.fa-reply:before{content:"\\f112"}.fa-github-alt:before{content:"\\f113"}.fa-folder-o:before{content:"\\f114"}.fa-folder-open-o:before{content:"\\f115"}.fa-smile-o:before{content:"\\f118"}.fa-frown-o:before{content:"\\f119"}.fa-meh-o:before{content:"\\f11a"}.fa-gamepad:before{content:"\\f11b"}.fa-keyboard-o:before{content:"\\f11c"}.fa-flag-o:before{content:"\\f11d"}.fa-flag-checkered:before{content:"\\f11e"}.fa-terminal:before{content:"\\f120"}.fa-code:before{content:"\\f121"}.fa-mail-reply-all:before,.fa-reply-all:before{content:"\\f122"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:"\\f123"}.fa-location-arrow:before{content:"\\f124"}.fa-crop:before{content:"\\f125"}.fa-code-fork:before{content:"\\f126"}.fa-unlink:before,.fa-chain-broken:before{content:"\\f127"}.fa-question:before{content:"\\f128"}.fa-info:before{content:"\\f129"}.fa-exclamation:before{content:"\\f12a"}.fa-superscript:before{content:"\\f12b"}.fa-subscript:before{content:"\\f12c"}.fa-eraser:before{content:"\\f12d"}.fa-puzzle-piece:before{content:"\\f12e"}.fa-microphone:before{content:"\\f130"}.fa-microphone-slash:before{content:"\\f131"}.fa-shield:before{content:"\\f132"}.fa-calendar-o:before{content:"\\f133"}.fa-fire-extinguisher:before{content:"\\f134"}.fa-rocket:before{content:"\\f135"}.fa-maxcdn:before{content:"\\f136"}.fa-chevron-circle-left:before{content:"\\f137"}.fa-chevron-circle-right:before{content:"\\f138"}.fa-chevron-circle-up:before{content:"\\f139"}.fa-chevron-circle-down:before{content:"\\f13a"}.fa-html5:before{content:"\\f13b"}.fa-css3:before{content:"\\f13c"}.fa-anchor:before{content:"\\f13d"}.fa-unlock-alt:before{content:"\\f13e"}.fa-bullseye:before{content:"\\f140"}.fa-ellipsis-h:before{content:"\\f141"}.fa-ellipsis-v:before{content:"\\f142"}.fa-rss-square:before{content:"\\f143"}.fa-play-circle:before{content:"\\f144"}.fa-ticket:before{content:"\\f145"}.fa-minus-square:before{content:"\\f146"}.fa-minus-square-o:before{content:"\\f147"}.fa-level-up:before{content:"\\f148"}.fa-level-down:before{content:"\\f149"}.fa-check-square:before{content:"\\f14a"}.fa-pencil-square:before{content:"\\f14b"}.fa-external-link-square:before{content:"\\f14c"}.fa-share-square:before{content:"\\f14d"}.fa-compass:before{content:"\\f14e"}.fa-toggle-down:before,.fa-caret-square-o-down:before{content:"\\f150"}.fa-toggle-up:before,.fa-caret-square-o-up:before{content:"\\f151"}.fa-toggle-right:before,.fa-caret-square-o-right:before{content:"\\f152"}.fa-euro:before,.fa-eur:before{content:"\\f153"}.fa-gbp:before{content:"\\f154"}.fa-dollar:before,.fa-usd:before{content:"\\f155"}.fa-rupee:before,.fa-inr:before{content:"\\f156"}.fa-cny:before,.fa-rmb:before,.fa-yen:before,.fa-jpy:before{content:"\\f157"}.fa-ruble:before,.fa-rouble:before,.fa-rub:before{content:"\\f158"}.fa-won:before,.fa-krw:before{content:"\\f159"}.fa-bitcoin:before,.fa-btc:before{content:"\\f15a"}.fa-file:before{content:"\\f15b"}.fa-file-text:before{content:"\\f15c"}.fa-sort-alpha-asc:before{content:"\\f15d"}.fa-sort-alpha-desc:before{content:"\\f15e"}.fa-sort-amount-asc:before{content:"\\f160"}.fa-sort-amount-desc:before{content:"\\f161"}.fa-sort-numeric-asc:before{content:"\\f162"}.fa-sort-numeric-desc:before{content:"\\f163"}.fa-thumbs-up:before{content:"\\f164"}.fa-thumbs-down:before{content:"\\f165"}.fa-youtube-square:before{content:"\\f166"}.fa-youtube:before{content:"\\f167"}.fa-xing:before{content:"\\f168"}.fa-xing-square:before{content:"\\f169"}.fa-youtube-play:before{content:"\\f16a"}.fa-dropbox:before{content:"\\f16b"}.fa-stack-overflow:before{content:"\\f16c"}.fa-instagram:before{content:"\\f16d"}.fa-flickr:before{content:"\\f16e"}.fa-adn:before{content:"\\f170"}.fa-bitbucket:before{content:"\\f171"}.fa-bitbucket-square:before{content:"\\f172"}.fa-tumblr:before{content:"\\f173"}.fa-tumblr-square:before{content:"\\f174"}.fa-long-arrow-down:before{content:"\\f175"}.fa-long-arrow-up:before{content:"\\f176"}.fa-long-arrow-left:before{content:"\\f177"}.fa-long-arrow-right:before{content:"\\f178"}.fa-apple:before{content:"\\f179"}.fa-windows:before{content:"\\f17a"}.fa-android:before{content:"\\f17b"}.fa-linux:before{content:"\\f17c"}.fa-dribbble:before{content:"\\f17d"}.fa-skype:before{content:"\\f17e"}.fa-foursquare:before{content:"\\f180"}.fa-trello:before{content:"\\f181"}.fa-female:before{content:"\\f182"}.fa-male:before{content:"\\f183"}.fa-gittip:before,.fa-gratipay:before{content:"\\f184"}.fa-sun-o:before{content:"\\f185"}.fa-moon-o:before{content:"\\f186"}.fa-archive:before{content:"\\f187"}.fa-bug:before{content:"\\f188"}.fa-vk:before{content:"\\f189"}.fa-weibo:before{content:"\\f18a"}.fa-renren:before{content:"\\f18b"}.fa-pagelines:before{content:"\\f18c"}.fa-stack-exchange:before{content:"\\f18d"}.fa-arrow-circle-o-right:before{content:"\\f18e"}.fa-arrow-circle-o-left:before{content:"\\f190"}.fa-toggle-left:before,.fa-caret-square-o-left:before{content:"\\f191"}.fa-dot-circle-o:before{content:"\\f192"}.fa-wheelchair:before{content:"\\f193"}.fa-vimeo-square:before{content:"\\f194"}.fa-turkish-lira:before,.fa-try:before{content:"\\f195"}.fa-plus-square-o:before{content:"\\f196"}.fa-space-shuttle:before{content:"\\f197"}.fa-slack:before{content:"\\f198"}.fa-envelope-square:before{content:"\\f199"}.fa-wordpress:before{content:"\\f19a"}.fa-openid:before{content:"\\f19b"}.fa-institution:before,.fa-bank:before,.fa-university:before{content:"\\f19c"}.fa-mortar-board:before,.fa-graduation-cap:before{content:"\\f19d"}.fa-yahoo:before{content:"\\f19e"}.fa-google:before{content:"\\f1a0"}.fa-reddit:before{content:"\\f1a1"}.fa-reddit-square:before{content:"\\f1a2"}.fa-stumbleupon-circle:before{content:"\\f1a3"}.fa-stumbleupon:before{content:"\\f1a4"}.fa-delicious:before{content:"\\f1a5"}.fa-digg:before{content:"\\f1a6"}.fa-pied-piper-pp:before{content:"\\f1a7"}.fa-pied-piper-alt:before{content:"\\f1a8"}.fa-drupal:before{content:"\\f1a9"}.fa-joomla:before{content:"\\f1aa"}.fa-language:before{content:"\\f1ab"}.fa-fax:before{content:"\\f1ac"}.fa-building:before{content:"\\f1ad"}.fa-child:before{content:"\\f1ae"}.fa-paw:before{content:"\\f1b0"}.fa-spoon:before{content:"\\f1b1"}.fa-cube:before{content:"\\f1b2"}.fa-cubes:before{content:"\\f1b3"}.fa-behance:before{content:"\\f1b4"}.fa-behance-square:before{content:"\\f1b5"}.fa-steam:before{content:"\\f1b6"}.fa-steam-square:before{content:"\\f1b7"}.fa-recycle:before{content:"\\f1b8"}.fa-automobile:before,.fa-car:before{content:"\\f1b9"}.fa-cab:before,.fa-taxi:before{content:"\\f1ba"}.fa-tree:before{content:"\\f1bb"}.fa-spotify:before{content:"\\f1bc"}.fa-deviantart:before{content:"\\f1bd"}.fa-soundcloud:before{content:"\\f1be"}.fa-database:before{content:"\\f1c0"}.fa-file-pdf-o:before{content:"\\f1c1"}.fa-file-word-o:before{content:"\\f1c2"}.fa-file-excel-o:before{content:"\\f1c3"}.fa-file-powerpoint-o:before{content:"\\f1c4"}.fa-file-photo-o:before,.fa-file-picture-o:before,.fa-file-image-o:before{content:"\\f1c5"}.fa-file-zip-o:before,.fa-file-archive-o:before{content:"\\f1c6"}.fa-file-sound-o:before,.fa-file-audio-o:before{content:"\\f1c7"}.fa-file-movie-o:before,.fa-file-video-o:before{content:"\\f1c8"}.fa-file-code-o:before{content:"\\f1c9"}.fa-vine:before{content:"\\f1ca"}.fa-codepen:before{content:"\\f1cb"}.fa-jsfiddle:before{content:"\\f1cc"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-saver:before,.fa-support:before,.fa-life-ring:before{content:"\\f1cd"}.fa-circle-o-notch:before{content:"\\f1ce"}.fa-ra:before,.fa-resistance:before,.fa-rebel:before{content:"\\f1d0"}.fa-ge:before,.fa-empire:before{content:"\\f1d1"}.fa-git-square:before{content:"\\f1d2"}.fa-git:before{content:"\\f1d3"}.fa-y-combinator-square:before,.fa-yc-square:before,.fa-hacker-news:before{content:"\\f1d4"}.fa-tencent-weibo:before{content:"\\f1d5"}.fa-qq:before{content:"\\f1d6"}.fa-wechat:before,.fa-weixin:before{content:"\\f1d7"}.fa-send:before,.fa-paper-plane:before{content:"\\f1d8"}.fa-send-o:before,.fa-paper-plane-o:before{content:"\\f1d9"}.fa-history:before{content:"\\f1da"}.fa-circle-thin:before{content:"\\f1db"}.fa-header:before{content:"\\f1dc"}.fa-paragraph:before{content:"\\f1dd"}.fa-sliders:before{content:"\\f1de"}.fa-share-alt:before{content:"\\f1e0"}.fa-share-alt-square:before{content:"\\f1e1"}.fa-bomb:before{content:"\\f1e2"}.fa-soccer-ball-o:before,.fa-futbol-o:before{content:"\\f1e3"}.fa-tty:before{content:"\\f1e4"}.fa-binoculars:before{content:"\\f1e5"}.fa-plug:before{content:"\\f1e6"}.fa-slideshare:before{content:"\\f1e7"}.fa-twitch:before{content:"\\f1e8"}.fa-yelp:before{content:"\\f1e9"}.fa-newspaper-o:before{content:"\\f1ea"}.fa-wifi:before{content:"\\f1eb"}.fa-calculator:before{content:"\\f1ec"}.fa-paypal:before{content:"\\f1ed"}.fa-google-wallet:before{content:"\\f1ee"}.fa-cc-visa:before{content:"\\f1f0"}.fa-cc-mastercard:before{content:"\\f1f1"}.fa-cc-discover:before{content:"\\f1f2"}.fa-cc-amex:before{content:"\\f1f3"}.fa-cc-paypal:before{content:"\\f1f4"}.fa-cc-stripe:before{content:"\\f1f5"}.fa-bell-slash:before{content:"\\f1f6"}.fa-bell-slash-o:before{content:"\\f1f7"}.fa-trash:before{content:"\\f1f8"}.fa-copyright:before{content:"\\f1f9"}.fa-at:before{content:"\\f1fa"}.fa-eyedropper:before{content:"\\f1fb"}.fa-paint-brush:before{content:"\\f1fc"}.fa-birthday-cake:before{content:"\\f1fd"}.fa-area-chart:before{content:"\\f1fe"}.fa-pie-chart:before{content:"\\f200"}.fa-line-chart:before{content:"\\f201"}.fa-lastfm:before{content:"\\f202"}.fa-lastfm-square:before{content:"\\f203"}.fa-toggle-off:before{content:"\\f204"}.fa-toggle-on:before{content:"\\f205"}.fa-bicycle:before{content:"\\f206"}.fa-bus:before{content:"\\f207"}.fa-ioxhost:before{content:"\\f208"}.fa-angellist:before{content:"\\f209"}.fa-cc:before{content:"\\f20a"}.fa-shekel:before,.fa-sheqel:before,.fa-ils:before{content:"\\f20b"}.fa-meanpath:before{content:"\\f20c"}.fa-buysellads:before{content:"\\f20d"}.fa-connectdevelop:before{content:"\\f20e"}.fa-dashcube:before{content:"\\f210"}.fa-forumbee:before{content:"\\f211"}.fa-leanpub:before{content:"\\f212"}.fa-sellsy:before{content:"\\f213"}.fa-shirtsinbulk:before{content:"\\f214"}.fa-simplybuilt:before{content:"\\f215"}.fa-skyatlas:before{content:"\\f216"}.fa-cart-plus:before{content:"\\f217"}.fa-cart-arrow-down:before{content:"\\f218"}.fa-diamond:before{content:"\\f219"}.fa-ship:before{content:"\\f21a"}.fa-user-secret:before{content:"\\f21b"}.fa-motorcycle:before{content:"\\f21c"}.fa-street-view:before{content:"\\f21d"}.fa-heartbeat:before{content:"\\f21e"}.fa-venus:before{content:"\\f221"}.fa-mars:before{content:"\\f222"}.fa-mercury:before{content:"\\f223"}.fa-intersex:before,.fa-transgender:before{content:"\\f224"}.fa-transgender-alt:before{content:"\\f225"}.fa-venus-double:before{content:"\\f226"}.fa-mars-double:before{content:"\\f227"}.fa-venus-mars:before{content:"\\f228"}.fa-mars-stroke:before{content:"\\f229"}.fa-mars-stroke-v:before{content:"\\f22a"}.fa-mars-stroke-h:before{content:"\\f22b"}.fa-neuter:before{content:"\\f22c"}.fa-genderless:before{content:"\\f22d"}.fa-facebook-official:before{content:"\\f230"}.fa-pinterest-p:before{content:"\\f231"}.fa-whatsapp:before{content:"\\f232"}.fa-server:before{content:"\\f233"}.fa-user-plus:before{content:"\\f234"}.fa-user-times:before{content:"\\f235"}.fa-hotel:before,.fa-bed:before{content:"\\f236"}.fa-viacoin:before{content:"\\f237"}.fa-train:before{content:"\\f238"}.fa-subway:before{content:"\\f239"}.fa-medium:before{content:"\\f23a"}.fa-yc:before,.fa-y-combinator:before{content:"\\f23b"}.fa-optin-monster:before{content:"\\f23c"}.fa-opencart:before{content:"\\f23d"}.fa-expeditedssl:before{content:"\\f23e"}.fa-battery-4:before,.fa-battery:before,.fa-battery-full:before{content:"\\f240"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:"\\f241"}.fa-battery-2:before,.fa-battery-half:before{content:"\\f242"}.fa-battery-1:before,.fa-battery-quarter:before{content:"\\f243"}.fa-battery-0:before,.fa-battery-empty:before{content:"\\f244"}.fa-mouse-pointer:before{content:"\\f245"}.fa-i-cursor:before{content:"\\f246"}.fa-object-group:before{content:"\\f247"}.fa-object-ungroup:before{content:"\\f248"}.fa-sticky-note:before{content:"\\f249"}.fa-sticky-note-o:before{content:"\\f24a"}.fa-cc-jcb:before{content:"\\f24b"}.fa-cc-diners-club:before{content:"\\f24c"}.fa-clone:before{content:"\\f24d"}.fa-balance-scale:before{content:"\\f24e"}.fa-hourglass-o:before{content:"\\f250"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:"\\f251"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:"\\f252"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:"\\f253"}.fa-hourglass:before{content:"\\f254"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:"\\f255"}.fa-hand-stop-o:before,.fa-hand-paper-o:before{content:"\\f256"}.fa-hand-scissors-o:before{content:"\\f257"}.fa-hand-lizard-o:before{content:"\\f258"}.fa-hand-spock-o:before{content:"\\f259"}.fa-hand-pointer-o:before{content:"\\f25a"}.fa-hand-peace-o:before{content:"\\f25b"}.fa-trademark:before{content:"\\f25c"}.fa-registered:before{content:"\\f25d"}.fa-creative-commons:before{content:"\\f25e"}.fa-gg:before{content:"\\f260"}.fa-gg-circle:before{content:"\\f261"}.fa-tripadvisor:before{content:"\\f262"}.fa-odnoklassniki:before{content:"\\f263"}.fa-odnoklassniki-square:before{content:"\\f264"}.fa-get-pocket:before{content:"\\f265"}.fa-wikipedia-w:before{content:"\\f266"}.fa-safari:before{content:"\\f267"}.fa-chrome:before{content:"\\f268"}.fa-firefox:before{content:"\\f269"}.fa-opera:before{content:"\\f26a"}.fa-internet-explorer:before{content:"\\f26b"}.fa-tv:before,.fa-television:before{content:"\\f26c"}.fa-contao:before{content:"\\f26d"}.fa-500px:before{content:"\\f26e"}.fa-amazon:before{content:"\\f270"}.fa-calendar-plus-o:before{content:"\\f271"}.fa-calendar-minus-o:before{content:"\\f272"}.fa-calendar-times-o:before{content:"\\f273"}.fa-calendar-check-o:before{content:"\\f274"}.fa-industry:before{content:"\\f275"}.fa-map-pin:before{content:"\\f276"}.fa-map-signs:before{content:"\\f277"}.fa-map-o:before{content:"\\f278"}.fa-map:before{content:"\\f279"}.fa-commenting:before{content:"\\f27a"}.fa-commenting-o:before{content:"\\f27b"}.fa-houzz:before{content:"\\f27c"}.fa-vimeo:before{content:"\\f27d"}.fa-black-tie:before{content:"\\f27e"}.fa-fonticons:before{content:"\\f280"}.fa-reddit-alien:before{content:"\\f281"}.fa-edge:before{content:"\\f282"}.fa-credit-card-alt:before{content:"\\f283"}.fa-codiepie:before{content:"\\f284"}.fa-modx:before{content:"\\f285"}.fa-fort-awesome:before{content:"\\f286"}.fa-usb:before{content:"\\f287"}.fa-product-hunt:before{content:"\\f288"}.fa-mixcloud:before{content:"\\f289"}.fa-scribd:before{content:"\\f28a"}.fa-pause-circle:before{content:"\\f28b"}.fa-pause-circle-o:before{content:"\\f28c"}.fa-stop-circle:before{content:"\\f28d"}.fa-stop-circle-o:before{content:"\\f28e"}.fa-shopping-bag:before{content:"\\f290"}.fa-shopping-basket:before{content:"\\f291"}.fa-hashtag:before{content:"\\f292"}.fa-bluetooth:before{content:"\\f293"}.fa-bluetooth-b:before{content:"\\f294"}.fa-percent:before{content:"\\f295"}.fa-gitlab:before{content:"\\f296"}.fa-wpbeginner:before{content:"\\f297"}.fa-wpforms:before{content:"\\f298"}.fa-envira:before{content:"\\f299"}.fa-universal-access:before{content:"\\f29a"}.fa-wheelchair-alt:before{content:"\\f29b"}.fa-question-circle-o:before{content:"\\f29c"}.fa-blind:before{content:"\\f29d"}.fa-audio-description:before{content:"\\f29e"}.fa-volume-control-phone:before{content:"\\f2a0"}.fa-braille:before{content:"\\f2a1"}.fa-assistive-listening-systems:before{content:"\\f2a2"}.fa-asl-interpreting:before,.fa-american-sign-language-interpreting:before{content:"\\f2a3"}.fa-deafness:before,.fa-hard-of-hearing:before,.fa-deaf:before{content:"\\f2a4"}.fa-glide:before{content:"\\f2a5"}.fa-glide-g:before{content:"\\f2a6"}.fa-signing:before,.fa-sign-language:before{content:"\\f2a7"}.fa-low-vision:before{content:"\\f2a8"}.fa-viadeo:before{content:"\\f2a9"}.fa-viadeo-square:before{content:"\\f2aa"}.fa-snapchat:before{content:"\\f2ab"}.fa-snapchat-ghost:before{content:"\\f2ac"}.fa-snapchat-square:before{content:"\\f2ad"}.fa-pied-piper:before{content:"\\f2ae"}.fa-first-order:before{content:"\\f2b0"}.fa-yoast:before{content:"\\f2b1"}.fa-themeisle:before{content:"\\f2b2"}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:"\\f2b3"}.fa-fa:before,.fa-font-awesome:before{content:"\\f2b4"}.fa-handshake-o:before{content:"\\f2b5"}.fa-envelope-open:before{content:"\\f2b6"}.fa-envelope-open-o:before{content:"\\f2b7"}.fa-linode:before{content:"\\f2b8"}.fa-address-book:before{content:"\\f2b9"}.fa-address-book-o:before{content:"\\f2ba"}.fa-vcard:before,.fa-address-card:before{content:"\\f2bb"}.fa-vcard-o:before,.fa-address-card-o:before{content:"\\f2bc"}.fa-user-circle:before{content:"\\f2bd"}.fa-user-circle-o:before{content:"\\f2be"}.fa-user-o:before{content:"\\f2c0"}.fa-id-badge:before{content:"\\f2c1"}.fa-drivers-license:before,.fa-id-card:before{content:"\\f2c2"}.fa-drivers-license-o:before,.fa-id-card-o:before{content:"\\f2c3"}.fa-quora:before{content:"\\f2c4"}.fa-free-code-camp:before{content:"\\f2c5"}.fa-telegram:before{content:"\\f2c6"}.fa-thermometer-4:before,.fa-thermometer:before,.fa-thermometer-full:before{content:"\\f2c7"}.fa-thermometer-3:before,.fa-thermometer-three-quarters:before{content:"\\f2c8"}.fa-thermometer-2:before,.fa-thermometer-half:before{content:"\\f2c9"}.fa-thermometer-1:before,.fa-thermometer-quarter:before{content:"\\f2ca"}.fa-thermometer-0:before,.fa-thermometer-empty:before{content:"\\f2cb"}.fa-shower:before{content:"\\f2cc"}.fa-bathtub:before,.fa-s15:before,.fa-bath:before{content:"\\f2cd"}.fa-podcast:before{content:"\\f2ce"}.fa-window-maximize:before{content:"\\f2d0"}.fa-window-minimize:before{content:"\\f2d1"}.fa-window-restore:before{content:"\\f2d2"}.fa-times-rectangle:before,.fa-window-close:before{content:"\\f2d3"}.fa-times-rectangle-o:before,.fa-window-close-o:before{content:"\\f2d4"}.fa-bandcamp:before{content:"\\f2d5"}.fa-grav:before{content:"\\f2d6"}.fa-etsy:before{content:"\\f2d7"}.fa-imdb:before{content:"\\f2d8"}.fa-ravelry:before{content:"\\f2d9"}.fa-eercast:before{content:"\\f2da"}.fa-microchip:before{content:"\\f2db"}.fa-snowflake-o:before{content:"\\f2dc"}.fa-superpowers:before{content:"\\f2dd"}.fa-wpexplorer:before{content:"\\f2de"}.fa-meetup:before{content:"\\f2e0"}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}a{cursor:pointer}.angular-editor-textarea{min-height:150px;overflow:auto;margin-top:5px;resize:vertical}.angular-editor-textarea:after{content:"";position:absolute;bottom:0;right:0;display:block;width:8px;height:8px;cursor:nwse-resize;background-color:#ffffff80}.angular-editor-toolbar{font:100 14px/15px Roboto,Arial,sans-serif;background-color:#f5f5f5;font-size:.8rem;padding:.2rem;border:1px solid #ddd}.angular-editor-toolbar .angular-editor-toolbar-set{display:none;margin-right:5px;vertical-align:baseline}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button{background-color:#fff;vertical-align:middle;border:1px solid #ddd;padding:.4rem;min-width:2rem;float:left}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:focus,.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.focus{outline:0}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label{pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label.foreground :after{background:#555555}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button:disabled>.color-label.background{background:#555555}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.active{background:#fff5b9}.angular-editor-toolbar .angular-editor-toolbar-set .angular-editor-button.active:hover{background-color:#fffa98}.angular-editor-toolbar .angular-editor-toolbar-set select{font-size:11px;width:90px;vertical-align:middle;background-color:transparent;border:.5px solid rgba(255,255,255,0);border-radius:5px;outline:none;padding:.4rem;cursor:pointer}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-heading optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading option{border:1px solid;background-color:#fff}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .default{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h1{font-size:24px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h2{font-size:20px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h3{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h4{font-size:15px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h5{font-size:14px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .h6{font-size:13px}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .div,.angular-editor-toolbar .angular-editor-toolbar-set .select-heading .pre{font-size:12px}}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-heading:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-font{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-font optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font option{border:1px solid;background-color:#fff}}.angular-editor-toolbar .angular-editor-toolbar-set .select-font:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-font:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size{display:inline-block;width:50px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size option{border:1px solid;background-color:#fff}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size1{font-size:10px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size2{font-size:12px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size3{font-size:14px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size4{font-size:16px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size5{font-size:18px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size6{font-size:20px}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size .size7{font-size:22px}}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-font-size:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style{display:inline-block;width:90px}@supports not (-moz-appearance: none){.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style optgroup{font-size:12px;background-color:#f4f4f4;padding:5px}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style option{border:1px solid;background-color:#fff}}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style:disabled{background-color:#f5f5f5;pointer-events:none;cursor:not-allowed}.angular-editor-toolbar .angular-editor-toolbar-set .select-custom-style:hover{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}.angular-editor-toolbar .angular-editor-toolbar-set .color-label{position:relative;cursor:pointer}.angular-editor-toolbar .angular-editor-toolbar-set .background{font-size:smaller;background:#1b1b1b;color:#fff;padding:3px}.angular-editor-toolbar .angular-editor-toolbar-set .foreground :after{position:absolute;content:"";left:-1px;top:auto;bottom:-3px;right:auto;width:15px;height:2px;z-index:0;background:#1b1b1b}.angular-editor-toolbar .angular-editor-toolbar-set:not([style*="display:none"]):not([style*="display: none"]){display:inline-block}.select-button{display:inline-block}.select-button.disabled{cursor:pointer;background-color:#f1f1f1;transition:.2s ease}\n']
    }]
  }], function() {
    return [];
  }, {
    iconClass: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    buttonClick: [{
      type: Output
    }]
  });
})();
var AeToolbarSetComponent = class {
  constructor() {
  }
};
AeToolbarSetComponent.\u0275fac = function AeToolbarSetComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AeToolbarSetComponent)();
};
AeToolbarSetComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: AeToolbarSetComponent,
  selectors: [["ae-toolbar-set"]],
  standalone: false,
  ngContentSelectors: _c4,
  decls: 2,
  vars: 0,
  consts: [[1, "angular-editor-toolbar-set"]],
  template: function AeToolbarSetComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275projection(1);
      \u0275\u0275elementEnd();
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AeToolbarSetComponent, [{
    type: Component,
    args: [{
      selector: "ae-toolbar-set",
      encapsulation: ViewEncapsulation.None,
      template: '<div class="angular-editor-toolbar-set">\n  <ng-content></ng-content>\n</div>\n'
    }]
  }], function() {
    return [];
  }, null);
})();
var AngularEditorModule = class {
};
AngularEditorModule.\u0275fac = function AngularEditorModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || AngularEditorModule)();
};
AngularEditorModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: AngularEditorModule
});
AngularEditorModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, FormsModule, ReactiveFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AngularEditorModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ReactiveFormsModule],
      declarations: [AngularEditorComponent, AngularEditorToolbarComponent, AeSelectComponent, AeButtonComponent, AeToolbarSetComponent],
      exports: [AngularEditorComponent, AngularEditorToolbarComponent, AeButtonComponent, AeToolbarSetComponent]
    }]
  }], null, null);
})();

// src/app/write-us/write-us/write-us.component.ts
function WriteUsComponent_div_11_div_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 28)(1, "span", 22);
    \u0275\u0275element(2, "img", 23);
    \u0275\u0275elementStart(3, "span", 24);
    \u0275\u0275text(4);
    \u0275\u0275pipe(5, "date");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 29);
    \u0275\u0275element(7, "div", 30);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const email_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275propertyInterpolate("src", ctx_r2.imgLoginPath, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(5, 3, email_r2.answer.audit.createdAt, "dd.MM.yyyy hh:mm"));
    \u0275\u0275advance(3);
    \u0275\u0275property("innerHTML", email_r2.answer.body, \u0275\u0275sanitizeHtml);
  }
}
function WriteUsComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13)(1, "div", 21)(2, "span", 22);
    \u0275\u0275element(3, "img", 23);
    \u0275\u0275elementStart(4, "span", 24);
    \u0275\u0275text(5);
    \u0275\u0275pipe(6, "date");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 25)(8, "p", 26);
    \u0275\u0275text(9);
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(10, WriteUsComponent_div_11_div_10_Template, 8, 6, "div", 27);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const email_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275propertyInterpolate("src", ctx_r2.imgLoginPath, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(6, 4, email_r2.audit.createdAt, "dd.MM.yyyy hh:mm"));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(email_r2.body);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", email_r2.answer);
  }
}
function WriteUsComponent_div_15_div_3_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Nen\xED vypln\u011Bno.");
    \u0275\u0275elementEnd();
  }
}
function WriteUsComponent_div_15_div_3_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Odpove\u010F mus\xED m\xEDt alespo\u0148 20 znak\u016F.");
    \u0275\u0275elementEnd();
  }
}
function WriteUsComponent_div_15_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 35);
    \u0275\u0275template(1, WriteUsComponent_div_15_div_3_div_1_Template, 2, 0, "div", 36)(2, WriteUsComponent_div_15_div_3_div_2_Template, 2, 0, "div", 36);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const description_r6 = \u0275\u0275reference(5);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", description_r6.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", description_r6.errors.minlength);
  }
}
function WriteUsComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 31)(1, "label", 32);
    \u0275\u0275text(2, "Odpov\u011B\u010F");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, WriteUsComponent_div_15_div_3_Template, 3, 2, "div", 33);
    \u0275\u0275elementStart(4, "angular-editor", 34, 1);
    \u0275\u0275twoWayListener("ngModelChange", function WriteUsComponent_div_15_Template_angular_editor_ngModelChange_4_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r2 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r2.htmlContent, $event) || (ctx_r2.htmlContent = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const description_r6 = \u0275\u0275reference(5);
    const ctx_r2 = \u0275\u0275nextContext();
    const writeUsForm_r4 = \u0275\u0275reference(14);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", writeUsForm_r4.submitted && description_r6.invalid);
    \u0275\u0275advance();
    \u0275\u0275property("placeholder", "Enter text here...");
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.htmlContent);
    \u0275\u0275property("config", ctx_r2.editorConfig);
  }
}
function WriteUsComponent_div_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 37);
  }
}
function WriteUsComponent_button_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 38);
    \u0275\u0275text(1, "Odeslat ");
    \u0275\u0275elementEnd();
  }
}
var _WriteUsComponent = class _WriteUsComponent extends BaseService {
  constructor(actRoute, sharedService, writeUsService, spinner, toastr) {
    super();
    this.actRoute = actRoute;
    this.sharedService = sharedService;
    this.writeUsService = writeUsService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.emailAddress = "";
    this.info = "";
    this.imgLoginPath = "";
    this.emails = new Array();
    this.htmlContent = "";
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.faThrash = AppConstants.iconTrash;
    this.faEye = AppConstants.iconEye;
    this.errorDto = new ErrorDto();
    this.destroy$ = new Subject();
    this.editorConfig = {
      editable: true,
      spellcheck: true,
      height: "15rem",
      minHeight: "5rem",
      placeholder: "Enter text here...",
      translate: "no",
      defaultParagraphSeparator: "p",
      defaultFontName: "",
      toolbarHiddenButtons: [
        [
          "undo",
          "redo",
          "indent",
          "subscript",
          "superscript",
          "strikeThrough"
        ],
        [
          "link",
          "unlink",
          "insertImage",
          "insertVideo",
          "insertHorizontalRule"
        ]
      ]
    };
  }
  ngOnInit() {
    this.actRoute.paramMap.subscribe((params) => {
      this.emailAddress = params.get("email");
    });
    this.sharedService.currentImgPath.subscribe((data) => this.imgLoginPath = data);
    this.getEmails();
  }
  getEmails() {
    this.spinner.show().then((r2) => r2);
    this.writeUsService.loadEmailsWriteUs(this.errorDto, 0, 20, this.emailAddress, null).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        setTimeout(() => {
          this.info = null;
        }, AppConstants.toastSuccessDelay);
        this.spinner.hide().then(() => this.emails = response.data);
      },
      error: () => {
        this.spinner.hide().then(() => {
          this.toastr.error(this.errorDto.httpStatus + " emails reload failed", "Emails");
        });
      }
    });
  }
  hideAnswer() {
    return this.emails.filter((data) => data.replied == true).length == this.emails.length;
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  response(form) {
    this.spinner.show().then((r2) => r2);
    this.writeUsService.responseToEmail(this.errorDto, new Email(this.htmlContent, this.emailAddress)).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide().then(() => {
          form.resetForm();
          this.toastr.success("Odesl\xE1no", "Emails");
          this.info = "Email odesl\xE1n";
          setTimeout(() => {
            this.getEmails();
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide().then(() => {
          this.toastr.error(this.errorDto.httpStatus + " emails send failed", "Emails");
        });
      }
    });
  }
};
_WriteUsComponent.\u0275fac = function WriteUsComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _WriteUsComponent)(\u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(SharedImgService), \u0275\u0275directiveInject(WriteUsService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_WriteUsComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _WriteUsComponent, selectors: [["app-write-us"]], standalone: false, features: [\u0275\u0275InheritDefinitionFeature], decls: 26, vars: 8, consts: [["writeUsForm", "ngForm"], ["description", "ngModel"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-6", "col-sm-8", "align-self-center"], [1, "box-part", "text-center", "text-white"], [1, "d-block"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "card"], ["class", "card-body", 4, "ngFor", "ngForOf"], [1, "mb-3"], ["novalidate", "", 3, "ngSubmit"], ["class", "m-2", 4, "ngIf"], [1, "card-body"], [3, "info"], [3, "errorDto"], ["class", "mt-4", 4, "ngIf"], [1, "col-auto"], ["type", "submit", "class", "ms-3 ms-sm-5 btn btn-primary", 4, "ngIf"], ["type", "button", "appBackButton", "", 1, "ms-3", "ms-sm-5", "btn", "btn-danger"], [1, "me-2", 3, "icon"], [1, "d-block", "d-sm-flex", "flex-row", "justify-content-start", "mb-1", "mb-sm-3", "ms-0", "ms-sm-2", "pt-0", "pt-sm-2", "text-black"], [1, "d-inline-block", "d-sm-inline", "mb-auto"], ["alt", "john doe", 1, "img-customizer", "d-none", "d-sm-flex", 3, "src"], [1, "text-start", "customize-short", "mt-auto"], [1, "p-2", "p-sm-3", "ms-1", "ms-sm-3", "card-body-chat", "h-auto", "d-block", "d-sm-flex"], [1, "small", "mb-0"], ["class", "d-block d-sm-flex flex-row justify-content-start ms-0 ms-sm-4 pt-0 pt-sm-2 text-black", 4, "ngIf"], [1, "d-block", "d-sm-flex", "flex-row", "justify-content-start", "ms-0", "ms-sm-4", "pt-0", "pt-sm-2", "text-black"], [1, "p-2", "p-sm-3", "ms-1", "ms-sm-3", "card-body-chat-answer", "h-auto", "d-block", "d-sm-flex"], [1, "small", "mb-0", 3, "innerHTML"], [1, "m-2"], ["for", "product-edited-description", 1, "form-label", "pb-1", "pt-3"], ["class", "alert alert-danger", 4, "ngIf"], ["id", "product-edited-description", "name", "description", "minlength", "20", "required", "", 1, "form-control", 3, "ngModelChange", "placeholder", "ngModel", "config"], [1, "alert", "alert-danger"], [4, "ngIf"], [1, "mt-4"], ["type", "submit", 1, "ms-3", "ms-sm-5", "btn", "btn-primary"]], template: function WriteUsComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2)(1, "div", 3)(2, "div", 4)(3, "div", 5)(4, "h2");
    \u0275\u0275text(5, "Email Detail");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "span", 6);
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275element(8, "hr")(9, "ngx-spinner", 7);
    \u0275\u0275elementStart(10, "div", 8);
    \u0275\u0275template(11, WriteUsComponent_div_11_Template, 11, 7, "div", 9);
    \u0275\u0275element(12, "div", 10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "form", 11, 0);
    \u0275\u0275listener("ngSubmit", function WriteUsComponent_Template_form_ngSubmit_13_listener() {
      \u0275\u0275restoreView(_r1);
      const writeUsForm_r4 = \u0275\u0275reference(14);
      return \u0275\u0275resetView(writeUsForm_r4.valid && ctx.response(writeUsForm_r4));
    });
    \u0275\u0275template(15, WriteUsComponent_div_15_Template, 6, 4, "div", 12);
    \u0275\u0275elementStart(16, "div", 13);
    \u0275\u0275element(17, "app-info", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "div", 13);
    \u0275\u0275element(19, "app-error", 15);
    \u0275\u0275elementEnd();
    \u0275\u0275template(20, WriteUsComponent_div_20_Template, 1, 0, "div", 16);
    \u0275\u0275elementStart(21, "div", 17);
    \u0275\u0275template(22, WriteUsComponent_button_22_Template, 2, 0, "button", 18);
    \u0275\u0275elementStart(23, "button", 19);
    \u0275\u0275element(24, "fa-icon", 20);
    \u0275\u0275text(25, " Back ");
    \u0275\u0275elementEnd()()()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate(ctx.emailAddress);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngForOf", ctx.emails);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", ctx.emailAddress && !ctx.hideAnswer());
    \u0275\u0275advance(2);
    \u0275\u0275property("info", ctx.info);
    \u0275\u0275advance(2);
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.hideAnswer());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", !ctx.hideAnswer());
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faArrowLeft);
  }
}, dependencies: [NgForOf, NgIf, NgxSpinnerComponent, FaIconComponent, \u0275NgNoValidate, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, NgModel, NgForm, AngularEditorComponent, ErrorComponent, InfoComponent, BackButtonDirective, DatePipe], styles: ["\n\n.customize-short[_ngcontent-%COMP%] {\n  color: var(--color-text);\n  font-size: 10px;\n}\n.img-customizer[_ngcontent-%COMP%] {\n  width: 65px;\n  height: 65px;\n}\n@media only screen and (max-width: 600px) {\n  .card-body[_ngcontent-%COMP%] {\n    padding-top: 0 !important;\n    padding-bottom: 0 !important;\n  }\n}\n/*# sourceMappingURL=write-us.component.css.map */"] });
var WriteUsComponent = _WriteUsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(WriteUsComponent, { className: "WriteUsComponent", filePath: "src/app/write-us/write-us/write-us.component.ts", lineNumber: 23 });
})();

// src/app/model/variant-category/variant-category-wrapper.ts
var VariantCategoryWrapper = class {
  constructor(data) {
    this.data = data;
  }
};

// src/app/model/variant-category/variants-request.ts
var VariantsRequest = class {
  constructor(data) {
    this.data = data;
  }
};

// src/app/service/variant-catalog.service.ts
var _VariantCatalogService = class _VariantCatalogService extends BaseService {
  constructor(httpClient) {
    super();
    this.httpClient = httpClient;
    this.variantCategoryUri = AppConstants.baseUrl + "/api/variant-catalog";
  }
  listAll(errorDto) {
    return this.httpClient.get(this.variantCategoryUri.concat("/all"), { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  deleteVariantCatalog(variantCategory, errorDto) {
    const deleteVariantUrl = this.addParamIntoUrl(this.variantCategoryUri, variantCategory.paramName);
    return this.httpClient.delete(deleteVariantUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  deleteVariant(variantName, errorDto) {
    const deleteVariantUrl = this.addParamIntoUrl(this.variantCategoryUri.concat("/variant"), variantName.name);
    return this.httpClient.delete(deleteVariantUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  getVariantCatalog(pathParamName, errorDto) {
    const getVariantUrl = this.addParamIntoUrl(this.variantCategoryUri, pathParamName);
    return this.httpClient.get(getVariantUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  createVariantCatalog(variantCategory, errorDto) {
    const body = JSON.stringify(new VariantCategoryWrapper(variantCategory));
    return this.httpClient.post(this.variantCategoryUri, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  putVariantCatalog(originalPathParam, variantCategory, errorDto) {
    const putVariantUrl = this.addParamIntoUrl(this.variantCategoryUri, originalPathParam);
    const body = JSON.stringify(new VariantCategoryWrapper(variantCategory));
    return this.httpClient.put(putVariantUrl, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  addVariants(categoryVariantParamName, variantCategory, errorDto) {
    const putVariantsUrl = this.addParamIntoUrl(this.variantCategoryUri.concat("/add-variants"), categoryVariantParamName);
    const body = JSON.stringify(variantCategory);
    return this.httpClient.post(putVariantsUrl, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  updateVariantsArrangement(categoryVariantParamName, variantCategory, errorDto) {
    const putVariantsUrl = this.addParamIntoUrl(this.variantCategoryUri.concat("/upsert-variants-arrangement"), categoryVariantParamName);
    const body = JSON.stringify(new VariantsRequest(variantCategory.variants));
    return this.httpClient.post(putVariantsUrl, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
};
_VariantCatalogService.\u0275fac = function VariantCatalogService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _VariantCatalogService)(\u0275\u0275inject(HttpClient));
};
_VariantCatalogService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _VariantCatalogService, factory: _VariantCatalogService.\u0275fac, providedIn: "root" });
var VariantCatalogService = _VariantCatalogService;

// src/app/variant-catalog-list/variant-catalog-list.component.ts
var _c012 = () => ["/variant-catalogs/create"];
var _c15 = (a0) => ["/variant-catalogs/", a0];
function VariantCatalogListComponent_div_22_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 16)(1, "div", 17)(2, "div", 18);
    \u0275\u0275element(3, "span", 19);
    \u0275\u0275elementStart(4, "span", 20);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 18);
    \u0275\u0275element(7, "span", 21);
    \u0275\u0275elementStart(8, "span", 20);
    \u0275\u0275text(9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "div", 22);
    \u0275\u0275element(11, "span", 23);
    \u0275\u0275elementStart(12, "span", 20);
    \u0275\u0275text(13);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "div", 24)(15, "button", 25);
    \u0275\u0275element(16, "fa-icon", 26);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 24)(18, "button", 27);
    \u0275\u0275listener("click", function VariantCatalogListComponent_div_22_Template_button_click_18_listener() {
      const variantCategory_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.deleteVariantCatalog(variantCategory_r2));
    });
    \u0275\u0275element(19, "fa-icon", 26);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const variantCategory_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(variantCategory_r2.paramName);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(variantCategory_r2.name);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(variantCategory_r2.variants == null ? null : variantCategory_r2.variants.length);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(6, _c15, variantCategory_r2.paramName));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r2.faEdit);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx_r2.faDelete);
  }
}
var _VariantCatalogListComponent = class _VariantCatalogListComponent {
  constructor(variantCatalogService, spinner, toastr) {
    this.variantCatalogService = variantCatalogService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.destroy$ = new Subject();
    this.faEdit = AppConstants.iconEdit;
    this.faDelete = AppConstants.iconDelete;
    this.errorDto = new ErrorDto();
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  ngOnInit() {
    this.loadVariantCatalog();
  }
  loadVariantCatalog() {
    this.spinner.show("Variant Catalog").then((r2) => r2);
    this.variantCatalogService.listAll(this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (catalogVariants) => {
        this.spinner.hide("Variant Catalog").then(() => this.toastr.info(catalogVariants.data?.length + "reloaded", "VariantCatalogSpinner"));
        this.variantCategories = catalogVariants.data;
      },
      error: () => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.toastr.error(this.errorDto?.httpStatus + " category variants failed", "VariantCatalogSpinner");
          this.variantCategories = [];
        });
      }
    });
  }
  deleteVariantCatalog(variantCategory) {
    if (!confirm("Are you sure to delete catalog?" + variantCategory.paramName + "?")) {
      return;
    }
    this.spinner.show("Variant Catalog").then((r2) => r2);
    this.variantCatalogService.deleteVariantCatalog(variantCategory, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.loadVariantCatalog();
          this.toastr.info(variantCategory.paramName + " deleted", "VariantCatalogSpinner");
        });
      },
      error: () => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.toastr.error(this.errorDto?.httpStatus + " delete failed", "VariantCatalogSpinner");
        });
      }
    });
  }
};
_VariantCatalogListComponent.\u0275fac = function VariantCatalogListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _VariantCatalogListComponent)(\u0275\u0275directiveInject(VariantCatalogService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_VariantCatalogListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _VariantCatalogListComponent, selectors: [["app-variant-catalog-list"]], standalone: false, decls: 26, vars: 6, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-6", "col-md-8", "col-12", "align-self-center"], [1, "box-part", "text-center"], [1, "text-orange", "mb-3"], [1, "row"], [1, "input-group", "d-none", "d-sm-flex", "text-center"], [1, "col-sm-4"], [1, "text-darkorange"], [1, "col-sm-2"], [1, "col-sm-1"], [1, "text-darkorange", 3, "icon"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["class", "row text-center text-sm-center", 4, "ngFor", "ngForOf"], [3, "errorDto"], ["routerLinkActive", "active", 1, "btn", "btn-primary", "mt-3", 3, "routerLink"], [1, "row", "text-center", "text-sm-center"], [1, "input-group", "link"], [1, "col-sm-4", "border-bottom"], ["data-label", "Param Name", 1, "d-sm-none", "text-darkorange"], [1, "text-white"], ["data-label", "Name", 1, "d-sm-none", "text-darkorange"], [1, "col-sm-2", "border-bottom"], ["data-label", "Variants", 1, "d-sm-none", "text-darkorange"], [1, "col-sm-1", "border-bottom", "text-center"], ["routerLinkActive", "active", 1, "btn", "btn-primary", "btn-sm", 3, "routerLink"], [3, "icon"], ["routerLinkActive", "active", 1, "btn", "btn-danger", "btn-sm", 3, "click"]], template: function VariantCatalogListComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h3", 4);
    \u0275\u0275text(5, "Variant Catalog");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 5)(7, "div", 6)(8, "div", 7)(9, "span", 8);
    \u0275\u0275text(10, "Param Name");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 7)(12, "span", 8);
    \u0275\u0275text(13, "Name");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "div", 9)(15, "span", 8);
    \u0275\u0275text(16, "Variants [ks]");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 10);
    \u0275\u0275element(18, "fa-icon", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "div", 10);
    \u0275\u0275element(20, "fa-icon", 11);
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(21, "ngx-spinner", 12);
    \u0275\u0275template(22, VariantCatalogListComponent_div_22_Template, 20, 8, "div", 13);
    \u0275\u0275element(23, "app-error", 14);
    \u0275\u0275elementStart(24, "button", 15);
    \u0275\u0275text(25, " Create Catalog ");
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(18);
    \u0275\u0275property("icon", ctx.faEdit);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faDelete);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.variantCategories);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(5, _c012));
  }
}, dependencies: [NgForOf, RouterLink, RouterLinkActive, NgxSpinnerComponent, FaIconComponent, ErrorComponent], encapsulation: 2 });
var VariantCatalogListComponent = _VariantCatalogListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(VariantCatalogListComponent, { className: "VariantCatalogListComponent", filePath: "src/app/variant-catalog-list/variant-catalog-list.component.ts", lineNumber: 16 });
})();

// src/app/model/variant-category/variant-catalog.ts
var VariantCatalog = class {
};

// src/app/model/variant-category/variant-detail.ts
var VariantDetail = class {
  constructor(name, arrangement) {
    this.name = name;
    this.arrangement = arrangement;
  }
};

// src/app/upsert-variant-catalog/upsert-variant-catalog.component.ts
function UpsertVariantCatalogComponent_div_13_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Name is required.");
    \u0275\u0275elementEnd();
  }
}
function UpsertVariantCatalogComponent_div_13_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Name must be at least 4 characters long.");
    \u0275\u0275elementEnd();
  }
}
function UpsertVariantCatalogComponent_div_13_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Name must be at maximum 100 characters long.");
    \u0275\u0275elementEnd();
  }
}
function UpsertVariantCatalogComponent_div_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 25);
    \u0275\u0275template(1, UpsertVariantCatalogComponent_div_13_div_1_Template, 2, 0, "div", 26)(2, UpsertVariantCatalogComponent_div_13_div_2_Template, 2, 0, "div", 26)(3, UpsertVariantCatalogComponent_div_13_div_3_Template, 2, 0, "div", 26);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const catName_r3 = \u0275\u0275reference(12);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", catName_r3.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", catName_r3.errors.minlength);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", catName_r3.errors.maxlength);
  }
}
function UpsertVariantCatalogComponent_div_20_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Param Name is required.");
    \u0275\u0275elementEnd();
  }
}
function UpsertVariantCatalogComponent_div_20_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Param Name must be at least 4 characters long.");
    \u0275\u0275elementEnd();
  }
}
function UpsertVariantCatalogComponent_div_20_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Param Name must be at maximum 24 characters long.");
    \u0275\u0275elementEnd();
  }
}
function UpsertVariantCatalogComponent_div_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 25);
    \u0275\u0275template(1, UpsertVariantCatalogComponent_div_20_div_1_Template, 2, 0, "div", 26)(2, UpsertVariantCatalogComponent_div_20_div_2_Template, 2, 0, "div", 26)(3, UpsertVariantCatalogComponent_div_20_div_3_Template, 2, 0, "div", 26);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const paramName_r4 = \u0275\u0275reference(19);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", paramName_r4.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", paramName_r4.errors.minlength);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", paramName_r4.errors.maxlength);
  }
}
function UpsertVariantCatalogComponent_div_28_div_3_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 41);
    \u0275\u0275listener("click", function UpsertVariantCatalogComponent_div_28_div_3_button_6_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r6 = \u0275\u0275nextContext();
      const variant_r8 = ctx_r6.$implicit;
      const i_r9 = ctx_r6.index;
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.up(variant_r8, i_r9));
    });
    \u0275\u0275element(1, "fa-icon", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r9.faArrowUp);
  }
}
function UpsertVariantCatalogComponent_div_28_div_3_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 41);
    \u0275\u0275listener("click", function UpsertVariantCatalogComponent_div_28_div_3_button_7_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r11);
      const ctx_r6 = \u0275\u0275nextContext();
      const variant_r8 = ctx_r6.$implicit;
      const i_r9 = ctx_r6.index;
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.down(variant_r8, i_r9));
    });
    \u0275\u0275element(1, "fa-icon", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r9.faArrowDown);
  }
}
function UpsertVariantCatalogComponent_div_28_div_3_button_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 42);
    \u0275\u0275listener("click", function UpsertVariantCatalogComponent_div_28_div_3_button_11_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r6 = \u0275\u0275nextContext();
      const variant_r8 = ctx_r6.$implicit;
      const i_r9 = ctx_r6.index;
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.up(variant_r8, i_r9));
    });
    \u0275\u0275element(1, "fa-icon", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r9.faArrowUp);
  }
}
function UpsertVariantCatalogComponent_div_28_div_3_button_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 42);
    \u0275\u0275listener("click", function UpsertVariantCatalogComponent_div_28_div_3_button_12_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r13);
      const ctx_r6 = \u0275\u0275nextContext();
      const variant_r8 = ctx_r6.$implicit;
      const i_r9 = ctx_r6.index;
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.down(variant_r8, i_r9));
    });
    \u0275\u0275element(1, "fa-icon", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r9.faArrowDown);
  }
}
function UpsertVariantCatalogComponent_div_28_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 30)(1, "div", 31)(2, "div", 32);
    \u0275\u0275element(3, "span", 33);
    \u0275\u0275elementStart(4, "span", 34);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, UpsertVariantCatalogComponent_div_28_div_3_button_6_Template, 2, 1, "button", 35)(7, UpsertVariantCatalogComponent_div_28_div_3_button_7_Template, 2, 1, "button", 35);
    \u0275\u0275elementStart(8, "button", 36);
    \u0275\u0275listener("click", function UpsertVariantCatalogComponent_div_28_div_3_Template_button_click_8_listener() {
      const variant_r8 = \u0275\u0275restoreView(_r5).$implicit;
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.deleteVariant(variant_r8));
    });
    \u0275\u0275element(9, "fa-icon", 21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "div", 37);
    \u0275\u0275template(11, UpsertVariantCatalogComponent_div_28_div_3_button_11_Template, 2, 1, "button", 38)(12, UpsertVariantCatalogComponent_div_28_div_3_button_12_Template, 2, 1, "button", 38);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "div", 39)(14, "button", 40);
    \u0275\u0275listener("click", function UpsertVariantCatalogComponent_div_28_div_3_Template_button_click_14_listener() {
      const variant_r8 = \u0275\u0275restoreView(_r5).$implicit;
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.deleteVariant(variant_r8));
    });
    \u0275\u0275element(15, "fa-icon", 21);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const variant_r8 = ctx.$implicit;
    const i_r9 = ctx.index;
    const ctx_r9 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(variant_r8.name);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", i_r9 > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", i_r9 + 1 < (ctx_r9.variantCatalog == null ? null : ctx_r9.variantCatalog.variants.length));
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx_r9.faDelete);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", i_r9 > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", i_r9 + 1 < (ctx_r9.variantCatalog == null ? null : ctx_r9.variantCatalog.variants.length));
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx_r9.faDelete);
  }
}
function UpsertVariantCatalogComponent_div_28_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 43);
    \u0275\u0275listener("click", function UpsertVariantCatalogComponent_div_28_button_4_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r14);
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.upsertArrangement());
    });
    \u0275\u0275text(1, "Update ");
    \u0275\u0275elementEnd();
  }
}
function UpsertVariantCatalogComponent_div_28_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 27)(1, "h5");
    \u0275\u0275text(2, "Variant param names");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, UpsertVariantCatalogComponent_div_28_div_3_Template, 16, 7, "div", 28)(4, UpsertVariantCatalogComponent_div_28_button_4_Template, 2, 0, "button", 29);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r9.variantCatalog.variants);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r9.visible);
  }
}
function UpsertVariantCatalogComponent_button_29_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 44);
    \u0275\u0275listener("click", function UpsertVariantCatalogComponent_button_29_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r15);
      const ctx_r9 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r9.addVariant());
    });
    \u0275\u0275element(1, "fa-icon", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r9.faPlus);
  }
}
function UpsertVariantCatalogComponent_form_30_div_3_div_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 25);
    \u0275\u0275text(1, " Variant is invalid (1-24 length) ");
    \u0275\u0275elementEnd();
  }
}
function UpsertVariantCatalogComponent_form_30_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 49)(1, "div", 50);
    \u0275\u0275element(2, "input", 51);
    \u0275\u0275elementStart(3, "button", 52);
    \u0275\u0275listener("click", function UpsertVariantCatalogComponent_form_30_div_3_Template_button_click_3_listener() {
      const i_r18 = \u0275\u0275restoreView(_r17).index;
      const ctx_r9 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r9.removeAddedVariant(i_r18));
    });
    \u0275\u0275element(4, "fa-icon", 21);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(5, UpsertVariantCatalogComponent_form_30_div_3_div_5_Template, 2, 0, "div", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const variantGroups_r19 = ctx.$implicit;
    const i_r18 = ctx.index;
    \u0275\u0275nextContext();
    const ngForm_r20 = \u0275\u0275reference(1);
    const ctx_r9 = \u0275\u0275nextContext();
    \u0275\u0275property("formGroupName", i_r18);
    \u0275\u0275advance(4);
    \u0275\u0275property("icon", ctx_r9.faDelete);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ngForm_r20.submitted && variantGroups_r19.invalid);
  }
}
function UpsertVariantCatalogComponent_form_30_button_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 53);
    \u0275\u0275text(1, "Add variant ");
    \u0275\u0275elementEnd();
  }
}
function UpsertVariantCatalogComponent_form_30_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "form", 45, 3);
    \u0275\u0275listener("ngSubmit", function UpsertVariantCatalogComponent_form_30_Template_form_ngSubmit_0_listener() {
      \u0275\u0275restoreView(_r16);
      const ctx_r9 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r9.form.valid && ctx_r9.addVariants());
    });
    \u0275\u0275elementStart(2, "div", 46);
    \u0275\u0275template(3, UpsertVariantCatalogComponent_form_30_div_3_Template, 6, 3, "div", 47);
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, UpsertVariantCatalogComponent_form_30_button_4_Template, 2, 0, "button", 48);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = \u0275\u0275nextContext();
    \u0275\u0275property("formGroup", ctx_r9.form);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r9.variant == null ? null : ctx_r9.variant.controls);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", (ctx_r9.variant == null ? null : ctx_r9.variant.controls == null ? null : ctx_r9.variant.controls.length) > 0);
  }
}
var _UpsertVariantCatalogComponent = class _UpsertVariantCatalogComponent {
  constructor(variantCatalogService, route, actRoute, spinner, toastr) {
    this.variantCatalogService = variantCatalogService;
    this.route = route;
    this.actRoute = actRoute;
    this.spinner = spinner;
    this.toastr = toastr;
    this.variantCatalog = new VariantCatalog();
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.faPlus = AppConstants.iconPlus;
    this.destroy$ = new Subject();
    this.errorDto = new ErrorDto();
    this.faDelete = AppConstants.iconDelete;
    this.faArrowUp = AppConstants.iconArrowUp;
    this.faArrowDown = AppConstants.iconArrowDown;
    this.visible = false;
  }
  ngOnInit() {
    this.actRoute.paramMap.subscribe((params) => {
      this.originalPathParamName = params.get("paramName");
      this.findByParamName();
    });
    this.form = new FormGroup({
      variant: new FormArray([])
    });
  }
  get variant() {
    return this.form.get("variant");
  }
  findByParamName() {
    if (!this.originalPathParamName) {
      this.operation = "Create";
      this.variantCatalog = new VariantCatalog();
      return;
    }
    this.operation = "Update";
    this.spinner.show("Variant Catalog").then((r2) => r2);
    this.variantCatalogService.getVariantCatalog(this.originalPathParamName, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.variantCatalog = response.data;
          this.variantCatalog.variants = this.variantCatalog.variants.sort((a, b) => a.arrangement - b.arrangement);
        });
      },
      error: () => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.toastr.error("Loading variant catalog failed " + this.errorDto.httpStatus, "Variant Catalog");
        });
      }
    });
  }
  deleteVariant(variant) {
    if (!confirm("Are you sure to delete variant?" + variant.name + "?")) {
      return;
    }
    this.spinner.show("Variant Catalog").then((r2) => r2);
    this.variantCatalogService.deleteVariant(variant, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.toastr.success(variant.name + " deleted");
          this.findByParamName();
        });
      },
      error: () => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.toastr.error("Delete variant failed " + this.errorDto.httpStatus, "Variant Catalog");
        });
      }
    });
  }
  upsertCatalogVariant() {
    if (this.operation == "Create") {
      this.createCatalogVariant();
    }
    if (this.operation == "Update") {
      this.updateCatalogVariant();
    }
  }
  updateCatalogVariant() {
    this.variantCatalogService.putVariantCatalog(this.originalPathParamName, this.variantCatalog, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.variantCatalog = response.data;
          setTimeout(() => {
            this.route.navigate(["/variant-catalogs"]);
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.toastr.error("Create catalog failed " + this.errorDto.httpStatus, "Variant Catalog");
        });
      }
    });
  }
  createCatalogVariant() {
    this.variantCatalogService.createVariantCatalog(this.variantCatalog, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.variantCatalog = response.data;
          setTimeout(() => {
            this.route.navigate(["/variant-catalogs"]);
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.toastr.error("Create catalog failed " + this.errorDto.httpStatus, "Variant Catalog");
        });
      }
    });
  }
  addVariant() {
    this.variant.setValidators(Validators.required);
    this.variant.push(new FormGroup({
      name: new FormControl(""),
      index: new FormControl(this.variant.length + 1)
    }));
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  removeAddedVariant(index) {
    this.variant.removeAt(index);
  }
  addVariants() {
    const variantDetail = [];
    const variantsRequests = new VariantsRequest(variantDetail);
    this.variant.getRawValue().forEach((data) => variantDetail.push(new VariantDetail(data.name, data.index)));
    this.variantCatalogService.addVariants(this.originalPathParamName, variantsRequests, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.variantCatalog = response.data;
          this.form = new FormGroup({
            variant: new FormArray([])
          });
          this.findByParamName();
        });
      },
      error: () => {
        this.spinner.hide("Variant Catalog").then(() => {
          this.toastr.error("Addind variant to catalog failed " + this.errorDto.httpStatus, "Variant Catalog");
        });
      }
    });
  }
  down(variant, i) {
    this.visible = true;
    const val = this.variantCatalog.variants[i + 1];
    this.variantCatalog.variants[i + 1] = this.variantCatalog.variants[i];
    this.variantCatalog.variants[i] = val;
    this.reArrangement();
  }
  up(variant, i) {
    this.visible = true;
    const val = this.variantCatalog.variants[i - 1];
    this.variantCatalog.variants[i - 1] = this.variantCatalog.variants[i];
    this.variantCatalog.variants[i] = val;
    this.reArrangement();
  }
  reArrangement() {
    this.variantCatalog.variants.forEach((val, index) => {
      val.arrangement = index;
    });
  }
  upsertArrangement() {
    this.spinner.show("variant").then((r2) => r2);
    this.variantCatalogService.updateVariantsArrangement(this.originalPathParamName, this.variantCatalog, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.visible = false;
        this.spinner.hide("variant").then(() => {
          this.variantCatalog = response.data;
          this.variantCatalog.variants = this.variantCatalog.variants.sort((a, b) => a.arrangement - b.arrangement);
        });
      },
      error: () => {
        this.visible = false;
        this.spinner.hide("variant").then(() => {
          this.toastr.error("Upsert variants arrangement failed " + this.errorDto.httpStatus, "Variant Catalog");
        });
      }
    });
  }
};
_UpsertVariantCatalogComponent.\u0275fac = function UpsertVariantCatalogComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _UpsertVariantCatalogComponent)(\u0275\u0275directiveInject(VariantCatalogService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_UpsertVariantCatalogComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _UpsertVariantCatalogComponent, selectors: [["app-upsert-variant-catalog"]], standalone: false, decls: 31, vars: 11, consts: [["upsertCatalogVariantForm", "ngForm"], ["catName", "ngModel"], ["paramName", "ngModel"], ["ngForm", "ngForm"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-4", "col-sm-8", "align-self-center"], [1, "box-part", "text-center"], ["novalidate", "", 3, "ngSubmit"], [1, "mb-3"], ["for", "category-name", 1, "form-label"], ["id", "category-name", "name", "catName", "type", "text", "placeholder", "required", "required", "", "minlength", "4", "maxlength", "100", 1, "form-control", 3, "ngModelChange", "ngModel"], ["class", "alert alert-danger", 4, "ngIf"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "mb-4"], ["for", "category-param-name", 1, "form-label"], ["id", "category-param-name", "name", "paramName", "type", "text", "placeholder", "required", "required", "", "minlength", "4", "maxlength", "24", 1, "form-control", 3, "ngModelChange", "ngModel"], [3, "errorDto"], [1, "col-auto", "mb-4"], ["type", "submit", 1, "btn", "btn-primary", "mx-3", "mx-sm-5"], ["type", "button", "appBackButton", "", 1, "btn", "btn-danger", "mx-3", "mx-sm-5"], [3, "icon"], ["class", "box-part section m-auto", 4, "ngIf"], ["type", "button", "class", "btn btn-primary mx-3 mx-sm-5 mt-4 mb-3", 3, "click", 4, "ngIf"], ["class", "mt-1 section m-auto", 3, "formGroup", "ngSubmit", 4, "ngIf"], [1, "alert", "alert-danger"], [4, "ngIf"], [1, "box-part", "section", "m-auto"], ["class", "row text-center text-sm-center", 4, "ngFor", "ngForOf"], ["class", "btn btn-primary mt-2 mx-3 mx-sm-5", 3, "click", 4, "ngIf"], [1, "row", "text-center", "text-sm-center"], [1, "input-group", "link", "border-bottom"], [1, "col-sm-10", "col"], ["data-label", "Name", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "d-inline-block", "m-2", "text-white"], ["class", "btn btn-primary btn-sm m-2 d-sm-none", 3, "click", 4, "ngIf"], [1, "btn", "btn-danger", "btn-sm", "m-2", "d-sm-none", 3, "click"], [1, "btn-group-vertical", "d-sm-inline-flex", "d-none", "float-end", "m-2"], ["class", "btn btn-primary btn btn-danger btn-sm", 3, "click", 4, "ngIf"], [1, "col-sm-2", "d-sm-inline-flex", "d-none"], [1, "btn", "btn-danger", "btn-sm", "m-2", 3, "click"], [1, "btn", "btn-primary", "btn-sm", "m-2", "d-sm-none", 3, "click"], [1, "btn", "btn-primary", "btn", "btn-danger", "btn-sm", 3, "click"], [1, "btn", "btn-primary", "mt-2", "mx-3", "mx-sm-5", 3, "click"], ["type", "button", 1, "btn", "btn-primary", "mx-3", "mx-sm-5", "mt-4", "mb-3", 3, "click"], [1, "mt-1", "section", "m-auto", 3, "ngSubmit", "formGroup"], ["formArrayName", "variant"], [3, "formGroupName", 4, "ngFor", "ngForOf"], ["class", "btn btn-primary mx-3 mx-sm-5 mt-4 mb-3", 4, "ngIf"], [3, "formGroupName"], [1, "input-group", "mb-2"], ["type", "text", "formControlName", "name", "placeholder", "variant name", "maxlength", "24", "required", "", 1, "form-control"], ["type", "submit", 1, "btn", "btn-primary", 3, "click"], [1, "btn", "btn-primary", "mx-3", "mx-sm-5", "mt-4", "mb-3"]], template: function UpsertVariantCatalogComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 5)(2, "div", 6)(3, "div", 7)(4, "form", 8, 0);
    \u0275\u0275listener("ngSubmit", function UpsertVariantCatalogComponent_Template_form_ngSubmit_4_listener() {
      \u0275\u0275restoreView(_r1);
      const upsertCatalogVariantForm_r2 = \u0275\u0275reference(5);
      return \u0275\u0275resetView(upsertCatalogVariantForm_r2.valid && upsertCatalogVariantForm_r2.dirty && ctx.upsertCatalogVariant());
    });
    \u0275\u0275elementStart(6, "h2");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 9)(9, "label", 10);
    \u0275\u0275text(10, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "input", 11, 1);
    \u0275\u0275twoWayListener("ngModelChange", function UpsertVariantCatalogComponent_Template_input_ngModelChange_11_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.variantCatalog.name, $event) || (ctx.variantCatalog.name = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(13, UpsertVariantCatalogComponent_div_13_Template, 4, 3, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275element(14, "ngx-spinner", 13);
    \u0275\u0275elementStart(15, "div", 14)(16, "label", 15);
    \u0275\u0275text(17, "Param Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "input", 16, 2);
    \u0275\u0275twoWayListener("ngModelChange", function UpsertVariantCatalogComponent_Template_input_ngModelChange_18_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.variantCatalog.paramName, $event) || (ctx.variantCatalog.paramName = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(20, UpsertVariantCatalogComponent_div_20_Template, 4, 3, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275element(21, "app-error", 17);
    \u0275\u0275elementStart(22, "div", 18)(23, "button", 19);
    \u0275\u0275text(24);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(25, "button", 20);
    \u0275\u0275element(26, "fa-icon", 21);
    \u0275\u0275text(27, "\xA0Back ");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(28, UpsertVariantCatalogComponent_div_28_Template, 5, 2, "div", 22)(29, UpsertVariantCatalogComponent_button_29_Template, 2, 1, "button", 23)(30, UpsertVariantCatalogComponent_form_30_Template, 5, 3, "form", 24);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const upsertCatalogVariantForm_r2 = \u0275\u0275reference(5);
    const catName_r3 = \u0275\u0275reference(12);
    const paramName_r4 = \u0275\u0275reference(19);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1("", ctx.operation, " category variant");
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.variantCatalog.name);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", upsertCatalogVariantForm_r2.submitted && catName_r3.invalid);
    \u0275\u0275advance(5);
    \u0275\u0275twoWayProperty("ngModel", ctx.variantCatalog.paramName);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", upsertCatalogVariantForm_r2.submitted && paramName_r4.invalid && (paramName_r4.dirty || paramName_r4.touched));
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx.operation);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faArrowLeft);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", (ctx.variantCatalog == null ? null : ctx.variantCatalog.variants == null ? null : ctx.variantCatalog.variants.length) > 0);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.route.url !== "/variant-catalogs/create");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.route.url !== "/variant-catalogs/create");
  }
}, dependencies: [NgForOf, NgIf, NgxSpinnerComponent, FaIconComponent, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, NgModel, NgForm, FormGroupDirective, FormControlName, FormGroupName, FormArrayName, ErrorComponent, BackButtonDirective], styles: ["\n\n.section[_ngcontent-%COMP%] {\n  max-width: 400px;\n  width: auto;\n}\n@media screen and (max-width: 576px) {\n  section[_ngcontent-%COMP%] {\n    max-width: 300px;\n  }\n}\n/*# sourceMappingURL=upsert-variant-catalog.component.css.map */"] });
var UpsertVariantCatalogComponent = _UpsertVariantCatalogComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(UpsertVariantCatalogComponent, { className: "UpsertVariantCatalogComponent", filePath: "src/app/upsert-variant-catalog/upsert-variant-catalog.component.ts", lineNumber: 21 });
})();

// src/app/model/stats/graph-pie-vo.ts
var GraphPieVo = class {
  constructor(name, value2) {
    this.name = name;
    this.value = value2;
  }
};

// src/app/model/stats/graph-line-vo.ts
var GraphLineVo = class {
  constructor(name, value2) {
    this.name = name;
    this.value = value2;
  }
};

// src/app/service/statistics.service.ts
var _StatisticsService = class _StatisticsService extends BaseService {
  constructor(httpClient) {
    super();
    this.httpClient = httpClient;
    this.orderPieEndpoint = AppConstants.baseUrl + "/api/statistics/orders/pie/status";
    this.categoryLineEndpoint = AppConstants.baseUrl + "/api/statistics/category/line/count";
    this.orderTotalPerDayEndpoint = AppConstants.baseUrl + "/api/statistics/orders/line/sold";
  }
  getOrderPieStatus(errorDto) {
    return this.httpClient.get(this.orderPieEndpoint, { headers: AppConstants.acceptJson }).pipe(retry(1), catchError((err) => this.handleError(err, errorDto)));
  }
  getCategoryToProductCount(errorDto) {
    return this.httpClient.get(this.categoryLineEndpoint, { headers: AppConstants.acceptJson }).pipe(retry(1), catchError((err) => this.handleError(err, errorDto)));
  }
  getOrderTotalPerDay(errorDto) {
    return this.httpClient.get(this.orderTotalPerDayEndpoint, { headers: AppConstants.acceptJson }).pipe(retry(1), catchError((err) => this.handleError(err, errorDto)));
  }
};
_StatisticsService.\u0275fac = function StatisticsService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _StatisticsService)(\u0275\u0275inject(HttpClient));
};
_StatisticsService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _StatisticsService, factory: _StatisticsService.\u0275fac, providedIn: "root" });
var StatisticsService = _StatisticsService;

// node_modules/@angular/cdk/fesm2022/portal.mjs
function throwNullPortalError() {
  throw Error("Must provide a portal to attach");
}
function throwPortalAlreadyAttachedError() {
  throw Error("Host already has a portal attached");
}
function throwPortalOutletAlreadyDisposedError() {
  throw Error("This PortalOutlet has already been disposed");
}
function throwUnknownPortalTypeError() {
  throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.");
}
function throwNullPortalOutletError() {
  throw Error("Attempting to attach a portal to a null PortalOutlet");
}
function throwNoPortalAttachedError() {
  throw Error("Attempting to detach a portal that is not attached to a host");
}
var Portal = class {
  /** Attach this portal to a host. */
  attach(host) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (host == null) {
        throwNullPortalOutletError();
      }
      if (host.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
    }
    this._attachedHost = host;
    return host.attach(this);
  }
  /** Detach this portal from its host */
  detach() {
    let host = this._attachedHost;
    if (host != null) {
      this._attachedHost = null;
      host.detach();
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwNoPortalAttachedError();
    }
  }
  /** Whether this portal is attached to a host. */
  get isAttached() {
    return this._attachedHost != null;
  }
  /**
   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
   * the PortalOutlet when it is performing an `attach()` or `detach()`.
   */
  setAttachedHost(host) {
    this._attachedHost = host;
  }
};
var ComponentPortal2 = class extends Portal {
  constructor(component, viewContainerRef, injector, componentFactoryResolver, projectableNodes) {
    super();
    this.component = component;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.componentFactoryResolver = componentFactoryResolver;
    this.projectableNodes = projectableNodes;
  }
};
var TemplatePortal = class extends Portal {
  constructor(templateRef, viewContainerRef, context2, injector) {
    super();
    this.templateRef = templateRef;
    this.viewContainerRef = viewContainerRef;
    this.context = context2;
    this.injector = injector;
  }
  get origin() {
    return this.templateRef.elementRef;
  }
  /**
   * Attach the portal to the provided `PortalOutlet`.
   * When a context is provided it will override the `context` property of the `TemplatePortal`
   * instance.
   */
  attach(host, context2 = this.context) {
    this.context = context2;
    return super.attach(host);
  }
  detach() {
    this.context = void 0;
    return super.detach();
  }
};
var DomPortal = class extends Portal {
  constructor(element) {
    super();
    this.element = element instanceof ElementRef ? element.nativeElement : element;
  }
};
var BasePortalOutlet = class {
  constructor() {
    this._isDisposed = false;
    this.attachDomPortal = null;
  }
  /** Whether this host has an attached portal. */
  hasAttached() {
    return !!this._attachedPortal;
  }
  /** Attaches a portal. */
  attach(portal) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!portal) {
        throwNullPortalError();
      }
      if (this.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
      if (this._isDisposed) {
        throwPortalOutletAlreadyDisposedError();
      }
    }
    if (portal instanceof ComponentPortal2) {
      this._attachedPortal = portal;
      return this.attachComponentPortal(portal);
    } else if (portal instanceof TemplatePortal) {
      this._attachedPortal = portal;
      return this.attachTemplatePortal(portal);
    } else if (this.attachDomPortal && portal instanceof DomPortal) {
      this._attachedPortal = portal;
      return this.attachDomPortal(portal);
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwUnknownPortalTypeError();
    }
  }
  /** Detaches a previously attached portal. */
  detach() {
    if (this._attachedPortal) {
      this._attachedPortal.setAttachedHost(null);
      this._attachedPortal = null;
    }
    this._invokeDisposeFn();
  }
  /** Permanently dispose of this portal host. */
  dispose() {
    if (this.hasAttached()) {
      this.detach();
    }
    this._invokeDisposeFn();
    this._isDisposed = true;
  }
  /** @docs-private */
  setDisposeFn(fn) {
    this._disposeFn = fn;
  }
  _invokeDisposeFn() {
    if (this._disposeFn) {
      this._disposeFn();
      this._disposeFn = null;
    }
  }
};
var DomPortalOutlet = class extends BasePortalOutlet {
  /**
   * @param outletElement Element into which the content is projected.
   * @param _componentFactoryResolver Used to resolve the component factory.
   *   Only required when attaching component portals.
   * @param _appRef Reference to the application. Only used in component portals when there
   *   is no `ViewContainerRef` available.
   * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't
   *   have one. Only used for component portals.
   * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually
   *   become a required parameter.
   */
  constructor(outletElement, _componentFactoryResolver, _appRef, _defaultInjector, _document2) {
    super();
    this.outletElement = outletElement;
    this._componentFactoryResolver = _componentFactoryResolver;
    this._appRef = _appRef;
    this._defaultInjector = _defaultInjector;
    this.attachDomPortal = (portal) => {
      if (!this._document && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("Cannot attach DOM portal without _document constructor parameter");
      }
      const element = portal.element;
      if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("DOM portal content must be attached to a parent node.");
      }
      const anchorNode = this._document.createComment("dom-portal");
      element.parentNode.insertBefore(anchorNode, element);
      this.outletElement.appendChild(element);
      this._attachedPortal = portal;
      super.setDisposeFn(() => {
        if (anchorNode.parentNode) {
          anchorNode.parentNode.replaceChild(element, anchorNode);
        }
      });
    };
    this._document = _document2;
  }
  /**
   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
   * @param portal Portal to be attached
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !resolver) {
      throw Error("Cannot attach component portal to outlet without a ComponentFactoryResolver.");
    }
    const componentFactory = resolver.resolveComponentFactory(portal.component);
    let componentRef;
    if (portal.viewContainerRef) {
      componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector, portal.projectableNodes || void 0);
      this.setDisposeFn(() => componentRef.destroy());
    } else {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._appRef) {
        throw Error("Cannot attach component portal to outlet without an ApplicationRef.");
      }
      componentRef = componentFactory.create(portal.injector || this._defaultInjector || Injector.NULL);
      this._appRef.attachView(componentRef.hostView);
      this.setDisposeFn(() => {
        if (this._appRef.viewCount > 0) {
          this._appRef.detachView(componentRef.hostView);
        }
        componentRef.destroy();
      });
    }
    this.outletElement.appendChild(this._getComponentRootNode(componentRef));
    this._attachedPortal = portal;
    return componentRef;
  }
  /**
   * Attaches a template portal to the DOM as an embedded view.
   * @param portal Portal to be attached.
   * @returns Reference to the created embedded view.
   */
  attachTemplatePortal(portal) {
    let viewContainer = portal.viewContainerRef;
    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    viewRef.rootNodes.forEach((rootNode) => this.outletElement.appendChild(rootNode));
    viewRef.detectChanges();
    this.setDisposeFn(() => {
      let index = viewContainer.indexOf(viewRef);
      if (index !== -1) {
        viewContainer.remove(index);
      }
    });
    this._attachedPortal = portal;
    return viewRef;
  }
  /**
   * Clears out a portal from the DOM.
   */
  dispose() {
    super.dispose();
    this.outletElement.remove();
  }
  /** Gets the root HTMLElement for an instantiated component. */
  _getComponentRootNode(componentRef) {
    return componentRef.hostView.rootNodes[0];
  }
};
var _CdkPortal = class _CdkPortal extends TemplatePortal {
  constructor(templateRef, viewContainerRef) {
    super(templateRef, viewContainerRef);
  }
};
_CdkPortal.\u0275fac = function CdkPortal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkPortal)(\u0275\u0275directiveInject(TemplateRef), \u0275\u0275directiveInject(ViewContainerRef));
};
_CdkPortal.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkPortal,
  selectors: [["", "cdkPortal", ""]],
  exportAs: ["cdkPortal"],
  features: [\u0275\u0275InheritDefinitionFeature]
});
var CdkPortal = _CdkPortal;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortal, [{
    type: Directive,
    args: [{
      selector: "[cdkPortal]",
      exportAs: "cdkPortal",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }], null);
})();
var _TemplatePortalDirective = class _TemplatePortalDirective extends CdkPortal {
};
_TemplatePortalDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275TemplatePortalDirective_BaseFactory;
  return function TemplatePortalDirective_Factory(__ngFactoryType__) {
    return (\u0275TemplatePortalDirective_BaseFactory || (\u0275TemplatePortalDirective_BaseFactory = \u0275\u0275getInheritedFactory(_TemplatePortalDirective)))(__ngFactoryType__ || _TemplatePortalDirective);
  };
})();
_TemplatePortalDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _TemplatePortalDirective,
  selectors: [["", "cdk-portal", ""], ["", "portal", ""]],
  exportAs: ["cdkPortal"],
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkPortal,
    useExisting: _TemplatePortalDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var TemplatePortalDirective = _TemplatePortalDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplatePortalDirective, [{
    type: Directive,
    args: [{
      selector: "[cdk-portal], [portal]",
      exportAs: "cdkPortal",
      providers: [{
        provide: CdkPortal,
        useExisting: TemplatePortalDirective
      }],
      standalone: true
    }]
  }], null, null);
})();
var _CdkPortalOutlet = class _CdkPortalOutlet extends BasePortalOutlet {
  constructor(_componentFactoryResolver, _viewContainerRef, _document2) {
    super();
    this._componentFactoryResolver = _componentFactoryResolver;
    this._viewContainerRef = _viewContainerRef;
    this._isInitialized = false;
    this.attached = new EventEmitter();
    this.attachDomPortal = (portal) => {
      if (!this._document && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("Cannot attach DOM portal without _document constructor parameter");
      }
      const element = portal.element;
      if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("DOM portal content must be attached to a parent node.");
      }
      const anchorNode = this._document.createComment("dom-portal");
      portal.setAttachedHost(this);
      element.parentNode.insertBefore(anchorNode, element);
      this._getRootNode().appendChild(element);
      this._attachedPortal = portal;
      super.setDisposeFn(() => {
        if (anchorNode.parentNode) {
          anchorNode.parentNode.replaceChild(element, anchorNode);
        }
      });
    };
    this._document = _document2;
  }
  /** Portal associated with the Portal outlet. */
  get portal() {
    return this._attachedPortal;
  }
  set portal(portal) {
    if (this.hasAttached() && !portal && !this._isInitialized) {
      return;
    }
    if (this.hasAttached()) {
      super.detach();
    }
    if (portal) {
      super.attach(portal);
    }
    this._attachedPortal = portal || null;
  }
  /** Component or view reference that is attached to the portal. */
  get attachedRef() {
    return this._attachedRef;
  }
  ngOnInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    super.dispose();
    this._attachedRef = this._attachedPortal = null;
  }
  /**
   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
   *
   * @param portal Portal to be attached to the portal outlet.
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    portal.setAttachedHost(this);
    const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;
    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
    const componentFactory = resolver.resolveComponentFactory(portal.component);
    const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector, portal.projectableNodes || void 0);
    if (viewContainerRef !== this._viewContainerRef) {
      this._getRootNode().appendChild(ref.hostView.rootNodes[0]);
    }
    super.setDisposeFn(() => ref.destroy());
    this._attachedPortal = portal;
    this._attachedRef = ref;
    this.attached.emit(ref);
    return ref;
  }
  /**
   * Attach the given TemplatePortal to this PortalHost as an embedded View.
   * @param portal Portal to be attached.
   * @returns Reference to the created embedded view.
   */
  attachTemplatePortal(portal) {
    portal.setAttachedHost(this);
    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    super.setDisposeFn(() => this._viewContainerRef.clear());
    this._attachedPortal = portal;
    this._attachedRef = viewRef;
    this.attached.emit(viewRef);
    return viewRef;
  }
  /** Gets the root node of the portal outlet. */
  _getRootNode() {
    const nativeElement = this._viewContainerRef.element.nativeElement;
    return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;
  }
};
_CdkPortalOutlet.\u0275fac = function CdkPortalOutlet_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CdkPortalOutlet)(\u0275\u0275directiveInject(ComponentFactoryResolver$1), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(DOCUMENT2));
};
_CdkPortalOutlet.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _CdkPortalOutlet,
  selectors: [["", "cdkPortalOutlet", ""]],
  inputs: {
    portal: [0, "cdkPortalOutlet", "portal"]
  },
  outputs: {
    attached: "attached"
  },
  exportAs: ["cdkPortalOutlet"],
  features: [\u0275\u0275InheritDefinitionFeature]
});
var CdkPortalOutlet = _CdkPortalOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortalOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalOutlet]",
      exportAs: "cdkPortalOutlet",
      standalone: true
    }]
  }], () => [{
    type: ComponentFactoryResolver$1
  }, {
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }], {
    portal: [{
      type: Input,
      args: ["cdkPortalOutlet"]
    }],
    attached: [{
      type: Output
    }]
  });
})();
var _PortalHostDirective = class _PortalHostDirective extends CdkPortalOutlet {
};
_PortalHostDirective.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275PortalHostDirective_BaseFactory;
  return function PortalHostDirective_Factory(__ngFactoryType__) {
    return (\u0275PortalHostDirective_BaseFactory || (\u0275PortalHostDirective_BaseFactory = \u0275\u0275getInheritedFactory(_PortalHostDirective)))(__ngFactoryType__ || _PortalHostDirective);
  };
})();
_PortalHostDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _PortalHostDirective,
  selectors: [["", "cdkPortalHost", ""], ["", "portalHost", ""]],
  inputs: {
    portal: [0, "cdkPortalHost", "portal"]
  },
  exportAs: ["cdkPortalHost"],
  features: [\u0275\u0275ProvidersFeature([{
    provide: CdkPortalOutlet,
    useExisting: _PortalHostDirective
  }]), \u0275\u0275InheritDefinitionFeature]
});
var PortalHostDirective = _PortalHostDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalHostDirective, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalHost], [portalHost]",
      exportAs: "cdkPortalHost",
      inputs: [{
        name: "portal",
        alias: "cdkPortalHost"
      }],
      providers: [{
        provide: CdkPortalOutlet,
        useExisting: PortalHostDirective
      }],
      standalone: true
    }]
  }], null, null);
})();
var _PortalModule = class _PortalModule {
};
_PortalModule.\u0275fac = function PortalModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PortalModule)();
};
_PortalModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PortalModule
});
_PortalModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
var PortalModule = _PortalModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalModule, [{
    type: NgModule,
    args: [{
      imports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]
    }]
  }], null, null);
})();

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces_default.hasOwnProperty(prefix) ? {
    space: namespaces_default[prefix],
    local: name
  } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x4) {
  return x4 == null ? [] : Array.isArray(x4) ? x4 : Array.from(x4);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match2) {
  return function() {
    return find.call(this.children, match2);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match2) {
  return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter2 = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match2) {
  return function() {
    return filter2.call(this.children, match2);
  };
}
function selectChildren_default(match2) {
  return this.selectAll(match2 == null ? children : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match2) {
  if (typeof match2 !== "function") match2 = matcher_default(match2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match2.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function data_default(value2, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind2 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value2 !== "function") value2 = constant_default(value2);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value2.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind2(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context2) {
  var selection2 = context2.selection ? context2.selection() : context2;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge2[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare2) {
  if (!compare2) compare2 = ascending;
  function compareNode(a, b) {
    return a && b ? compare2(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size2 = 0;
  for (const node of this) ++size2;
  return size2;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value2) {
  return function() {
    this.setAttribute(name, value2);
  };
}
function attrConstantNS(fullname, value2) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value2);
  };
}
function attrFunction(name, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function attr_default(name, value2) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value2 == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value2 === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value2));
}

// node_modules/d3-selection/src/window.js
function window_default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value2, priority) {
  return function() {
    this.style.setProperty(name, value2, priority);
  };
}
function styleFunction(name, value2, priority) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}
function style_default(name, value2, priority) {
  return arguments.length > 1 ? this.each((value2 == null ? styleRemove : typeof value2 === "function" ? styleFunction : styleConstant)(name, value2, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value2) {
  return function() {
    this[name] = value2;
  };
}
function propertyFunction(name, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}
function property_default(name, value2) {
  return arguments.length > 1 ? this.each((value2 == null ? propertyRemove : typeof value2 === "function" ? propertyFunction : propertyConstant)(name, value2)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray2(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray2(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value2) {
  return function() {
    (value2.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value2) {
  var names = classArray2(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value2 === "function" ? classedFunction : value2 ? classedTrue : classedFalse)(names, value2));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction(value2) {
  return function() {
    var v = value2.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function text_default(value2) {
  return arguments.length ? this.each(value2 == null ? textRemove : (typeof value2 === "function" ? textFunction : textConstant)(value2)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value2) {
  return function() {
    this.innerHTML = value2;
  };
}
function htmlFunction(value2) {
  return function() {
    var v = value2.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function html_default(value2) {
  return arguments.length ? this.each(value2 == null ? htmlRemove : (typeof value2 === "function" ? htmlFunction : htmlConstant)(value2)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove2() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function remove_default() {
  return this.each(remove2);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value2) {
  return arguments.length ? this.property("__data__", value2) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener2) {
  return function(event) {
    listener2.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i = t2.indexOf(".");
    if (i >= 0) name = t2.slice(i + 1), t2 = t2.slice(0, i);
    return {
      type: t2,
      name
    };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o2; j < m; ++j) {
      if (o2 = on[j], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
      } else {
        on[++i] = o2;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value2, options) {
  return function() {
    var on = this.__on, o2, listener2 = contextListener(value2);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o2 = on[j]).type === typename.type && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
        this.addEventListener(o2.type, o2.listener = listener2, o2.options = options);
        o2.value = value2;
        return;
      }
    }
    this.addEventListener(typename.type, listener2, options);
    o2 = {
      type: typename.type,
      name: typename.name,
      value: value2,
      listener: listener2,
      options
    };
    if (!on) this.__on = [o2];
    else on.push(o2);
  };
}
function on_default(typename, value2, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t2;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o2; j < m; ++j) {
      for (i = 0, o2 = on[j]; i < n; ++i) {
        if ((t2 = typenames[i]).type === o2.type && t2.name === o2.name) {
          return o2.value;
        }
      }
    }
    return;
  }
  on = value2 ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value2, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type2, params) {
  var window2 = window_default(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
  event = sourceEvent_default(event);
  if (node === void 0) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point3 = svg.createSVGPoint();
      point3.x = event.clientX, point3.y = event.clientY;
      point3 = point3.matrixTransform(node.getScreenCTM().inverse());
      return [point3.x, point3.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/d3-dispatch/src/dispatch.js
var noop5 = {
  value: () => {
  }
};
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t2; i < n; ++i) {
    if (!(t2 = arguments[i] + "") || t2 in _ || /[\s.]/.test(t2)) throw new Error("illegal type: " + t2);
    _[t2] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames2(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i = t2.indexOf(".");
    if (i >= 0) name = t2.slice(i + 1), t2 = t2.slice(0, i);
    if (t2 && !types.hasOwnProperty(t2)) throw new Error("unknown type: " + t2);
    return {
      type: t2,
      name
    };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames2(typename + "", _), t2, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t2 = (typename = T[i]).type) && (t2 = get2(_[t2], typename.name))) return t2;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t2 = (typename = T[i]).type) _[t2] = set(_[t2], typename.name, callback);
      else if (callback == null) for (t2 in _) _[t2] = set(_[t2], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t2 in _) copy2[t2] = _[t2].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t2; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
    for (t2 = this._[type2], i = 0, n = t2.length; i < n; ++i) t2[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
    for (var t2 = this._[type2], i = 0, n = t2.length; i < n; ++i) t2[i].value.apply(that, args);
  }
};
function get2(type2, name) {
  for (var i = 0, n = type2.length, c; i < n; ++i) {
    if ((c = type2[i]).name === name) {
      return c.value;
    }
  }
}
function set(type2, name, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name) {
      type2[i] = noop5, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null) type2.push({
    name,
    value: callback
  });
  return type2;
}
var dispatch_default2 = dispatch;

// node_modules/d3-drag/src/noevent.js
var nonpassivecapture = {
  capture: true,
  passive: false
};
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root3.__noselect = root3.style.MozUserSelect;
    root3.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", null);
  } else {
    root3.style.MozUserSelect = root3.__noselect;
    delete root3.__noselect;
  }
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r2, g2, b, a) {
  if (a <= 0) r2 = g2 = b = NaN;
  return new Rgb(r2, g2, b, a);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r2, g2, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b, opacity == null ? 1 : opacity);
}
function Rgb(r2, g2, b, opacity) {
  this.r = +r2;
  this.g = +g2;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value2) {
  return Math.max(0, Math.min(255, Math.round(value2) || 0));
}
function hex(value2) {
  value2 = clampi(value2);
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h, s2, l, a) {
  if (a <= 0) h = s2 = l = NaN;
  else if (l <= 0 || l >= 1) h = s2 = NaN;
  else if (s2 <= 0) h = NaN;
  return new Hsl(h, s2, l, a);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g2 = o2.g / 255, b = o2.b / 255, min6 = Math.min(r2, g2, b), max6 = Math.max(r2, g2, b), h = NaN, s2 = max6 - min6, l = (max6 + min6) / 2;
  if (s2) {
    if (r2 === max6) h = (g2 - b) / s2 + (g2 < b) * 6;
    else if (g2 === max6) h = (b - r2) / s2 + 2;
    else h = (r2 - g2) / s2 + 4;
    s2 /= l < 0.5 ? max6 + min6 : 2 - max6 - min6;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o2.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value2) {
  value2 = (value2 || 0) % 360;
  return value2 < 0 ? value2 + 360 : value2;
}
function clampt(value2) {
  return Math.max(0, Math.min(1, value2 || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t2 = t12 * t12, t3 = t2 * t12;
  return ((1 - 3 * t12 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t12 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t2) {
    var i = t2 <= 0 ? t2 = 0 : t2 >= 1 ? (t2 = 1, n - 1) : Math.floor(t2 * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t2 - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t2) {
    var i = Math.floor(((t2 %= 1) < 0 ? ++t2 : t2) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t2 - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x4) => () => x4;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t2) {
    return a + t2 * d;
  };
}
function exponential(a, b, y3) {
  return a = Math.pow(a, y3), b = Math.pow(b, y3) - a, y3 = 1 / y3, function(t2) {
    return Math.pow(a + t2 * b, y3);
  };
}
function gamma(y3) {
  return (y3 = +y3) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y3) : constant_default2(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y3) {
  var color2 = gamma(y3);
  function rgb2(start2, end2) {
    var r2 = color2((start2 = rgb(start2)).r, (end2 = rgb(end2)).r), g2 = color2(start2.g, end2.g), b = color2(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t2) {
      start2.r = r2(t2);
      start2.g = g2(t2);
      start2.b = b(t2);
      start2.opacity = opacity(t2);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r2 = new Array(n), g2 = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r2[i] = color2.r || 0;
      g2[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r2 = spline(r2);
    g2 = spline(g2);
    b = spline(b);
    color2.opacity = 1;
    return function(t2) {
      color2.r = r2(t2);
      color2.g = g2(t2);
      color2.b = b(t2);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t2) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t2) + b[i] * t2;
    return c;
  };
}
function isNumberArray(x4) {
  return ArrayBuffer.isView(x4) && !(x4 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x4 = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i) x4[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];
  return function(t2) {
    for (i = 0; i < na; ++i) c[i] = x4[i](t2);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t2) {
    return d.setTime(a * (1 - t2) + b * t2), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t2) {
    return a * (1 - t2) + b * t2;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t2) {
    for (k in i) c[k] = i[k](t2);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t2) {
    return b(t2) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i]) s2[i] += bs;
      else s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i]) s2[i] += bm;
      else s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({
        i,
        x: number_default(am, bm)
      });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i]) s2[i] += bs;
    else s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t2) {
    for (var i2 = 0, o2; i2 < b; ++i2) s2[(o2 = q[i2]).i] = o2.x(t2);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t2 = typeof b, c;
  return b == null || t2 === "boolean" ? constant_default2(b) : (t2 === "number" ? number_default : t2 === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a, b) {
  return a = +a, b = +b, function(t2) {
    return Math.round(a * (1 - t2) + b * t2);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value2) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m.isIdentity ? identity2 : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value2) {
  if (value2 == null) return identity2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate())) return identity2;
  value2 = value2.matrix;
  return decompose_default(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate2(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({
        i: i - 4,
        x: number_default(xa, xb)
      }, {
        i: i - 2,
        x: number_default(ya, yb)
      });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s2, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;
      else if (b - a > 180) a += 360;
      q.push({
        i: s2.push(pop(s2) + "rotate(", null, degParen) - 2,
        x: number_default(a, b)
      });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s2, q) {
    if (a !== b) {
      q.push({
        i: s2.push(pop(s2) + "skewX(", null, degParen) - 2,
        x: number_default(a, b)
      });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: number_default(xa, xb)
      }, {
        i: i - 2,
        x: number_default(ya, yb)
      });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s2 = [], q = [];
    a = parse2(a), b = parse2(b);
    translate2(a.translateX, a.translateY, b.translateX, b.translateY, s2, q);
    rotate(a.rotate, b.rotate, s2, q);
    skewX(a.skewX, b.skewX, s2, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s2, q);
    a = b = null;
    return function(t2) {
      var i = -1, n = q.length, o2;
      while (++i < n) s2[(o2 = q[i]).i] = o2.x(t2);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer2.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer2(callback, delay, time2) {
  var t2 = new Timer();
  t2.restart(callback, delay, time2);
  return t2;
}
function timerFlush() {
  now();
  ++frame;
  var t2 = taskHead, e;
  while (t2) {
    if ((e = clockNow - t2._time) >= 0) t2._call.call(void 0, e);
    t2 = t2._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t2, time2 = Infinity;
  while (t12) {
    if (t12._call) {
      if (time2 > t12._time) time2 = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t2 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t2 : taskHead = t2;
    }
  }
  taskTail = t02;
  sleep(time2);
}
function sleep(time2) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity) timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time2) {
  var t2 = new Timer();
  delay = delay == null ? 0 : +delay;
  t2.restart((elapsed) => {
    t2.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t2;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default2("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id3, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id3 in schedules) return;
  create(node, id3, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node, id3) {
  var schedule = get3(node, id3);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node, id3) {
  var schedule = get3(node, id3);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get3(node, id3) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id3])) throw new Error("transition not found");
  return schedule;
}
function create(node, id3, self) {
  var schedules = node.__transition, tween;
  schedules[id3] = self;
  self.timer = timer2(schedule, 0, self.time);
  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed) start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o2;
    if (self.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o2 = schedules[i];
      if (o2.name !== self.name) continue;
      if (o2.state === STARTED) return timeout_default(start2);
      if (o2.state === RUNNING) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("interrupt", node, node.__data__, o2.index, o2.group);
        delete schedules[i];
      } else if (+i < id3) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("cancel", node, node.__data__, o2.index, o2.group);
        delete schedules[i];
      }
    }
    timeout_default(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o2 = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o2;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t2 = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node, t2);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id3];
    for (var i in schedules) return;
    delete node.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
  var schedules = node.__transition, schedule, active, empty3 = true, i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty3 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }
  if (empty3) delete node.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id3, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id3), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id3, name, value2) {
  var tween0, tween1;
  if (typeof value2 !== "function") throw new Error();
  return function() {
    var schedule = set2(this, id3), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t2 = {
        name,
        value: value2
      }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t2;
          break;
        }
      }
      if (i === n) tween1.push(t2);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value2) {
  var id3 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get3(this.node(), id3).tween;
    for (var i = 0, n = tween.length, t2; i < n; ++i) {
      if ((t2 = tween[i]).name === name) {
        return t2.value;
      }
    }
    return null;
  }
  return this.each((value2 == null ? tweenRemove : tweenFunction)(id3, name, value2));
}
function tweenValue(transition3, name, value2) {
  var id3 = transition3._id;
  transition3.each(function() {
    var schedule = set2(this, id3);
    (schedule.value || (schedule.value = {}))[name] = value2.apply(this, arguments);
  });
  return function(node) {
    return get3(node, id3).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a, b) {
  var c;
  return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value2(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value2(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value2) {
  var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value2 === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value2)) : value2 == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value2));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i) {
  return function(t2) {
    this.setAttribute(name, i.call(this, t2));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t2) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t2));
  };
}
function attrTweenNS(fullname, value2) {
  var t02, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function attrTween(name, value2) {
  var t02, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && attrInterpolate(name, i);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function attrTween_default(name, value2) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value2 == null) return this.tween(key, null);
  if (typeof value2 !== "function") throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value2));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id3, value2) {
  return function() {
    init(this, id3).delay = +value2.apply(this, arguments);
  };
}
function delayConstant(id3, value2) {
  return value2 = +value2, function() {
    init(this, id3).delay = value2;
  };
}
function delay_default(value2) {
  var id3 = this._id;
  return arguments.length ? this.each((typeof value2 === "function" ? delayFunction : delayConstant)(id3, value2)) : get3(this.node(), id3).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id3, value2) {
  return function() {
    set2(this, id3).duration = +value2.apply(this, arguments);
  };
}
function durationConstant(id3, value2) {
  return value2 = +value2, function() {
    set2(this, id3).duration = value2;
  };
}
function duration_default(value2) {
  var id3 = this._id;
  return arguments.length ? this.each((typeof value2 === "function" ? durationFunction : durationConstant)(id3, value2)) : get3(this.node(), id3).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id3, value2) {
  if (typeof value2 !== "function") throw new Error();
  return function() {
    set2(this, id3).ease = value2;
  };
}
function ease_default(value2) {
  var id3 = this._id;
  return arguments.length ? this.each(easeConstant(id3, value2)) : get3(this.node(), id3).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id3, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (typeof v !== "function") throw new Error();
    set2(this, id3).ease = v;
  };
}
function easeVarying_default(value2) {
  if (typeof value2 !== "function") throw new Error();
  return this.each(easeVarying(this._id, value2));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match2) {
  if (typeof match2 !== "function") match2 = matcher_default(match2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match2.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition3) {
  if (transition3._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition3._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge2[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t2) {
    var i = t2.indexOf(".");
    if (i >= 0) t2 = t2.slice(0, i);
    return !t2 || t2 === "start";
  });
}
function onFunction(id3, name, listener2) {
  var on0, on1, sit = start(name) ? init : set2;
  return function() {
    var schedule = sit(this, id3), on = schedule.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener2);
    schedule.on = on1;
  };
}
function on_default2(name, listener2) {
  var id3 = this._id;
  return arguments.length < 2 ? get3(this.node(), id3).on.on(name) : this.each(onFunction(id3, name, listener2));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id3) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id3) return;
    if (parent) parent.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id3 = this._id;
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule_default(subgroup[i], name, id3, i, subgroup, get3(node, id3));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id3);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select) {
  var name = this._name, id3 = this._id;
  if (typeof select !== "function") select = selectorAll_default(select);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get3(node, id3), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule_default(child, name, id3, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id3);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value2(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id3, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove3;
  return function() {
    var schedule = set2(this, id3), on = schedule.on, listener2 = schedule.value[key] == null ? remove3 || (remove3 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener2) (on1 = (on0 = on).copy()).on(event, listener0 = listener2);
    schedule.on = on1;
  };
}
function style_default2(name, value2, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value2 == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value2 === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value2))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value2), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i, priority) {
  return function(t2) {
    this.style.setProperty(name, i.call(this, t2), priority);
  };
}
function styleTween(name, value2, priority) {
  var t2, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0) t2 = (i0 = i) && styleInterpolate(name, i, priority);
    return t2;
  }
  tween._value = value2;
  return tween;
}
function styleTween_default(name, value2, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value2 == null) return this.tween(key, null);
  if (typeof value2 !== "function") throw new Error();
  return this.tween(key, styleTween(name, value2, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction2(value2) {
  return function() {
    var value1 = value2(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value2) {
  return this.tween("text", typeof value2 === "function" ? textFunction2(tweenValue(this, "text", value2)) : textConstant2(value2 == null ? "" : value2 + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i) {
  return function(t2) {
    this.textContent = i.call(this, t2);
  };
}
function textTween(value2) {
  var t02, i0;
  function tween() {
    var i = value2.apply(this, arguments);
    if (i !== i0) t02 = (i0 = i) && textInterpolate(i);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function textTween_default(value2) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value2 == null) return this.tween(key, null);
  if (typeof value2 !== "function") throw new Error();
  return this.tween(key, textTween(value2));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit2 = get3(node, id0);
        schedule_default(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id3 = that._id, size2 = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {
      value: reject
    }, end2 = {
      value: function() {
        if (--size2 === 0) resolve();
      }
    };
    that.each(function() {
      var schedule = set2(this, id3), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end2);
      }
      schedule.on = on1;
    });
    if (size2 === 0) resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id3) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id3;
}
function transition2(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition2.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default2,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}

// node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;
function sinInOut(t2) {
  return (1 - Math.cos(pi * t2)) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id3) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id3])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id3} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id3, timing;
  if (name instanceof Transition) {
    id3 = name._id, name = name._name;
  } else {
    id3 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule_default(node, name, id3, i, group, timing || inherit(node, id3));
      }
    }
  }
  return new Transition(groups, this._parents, name, id3);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-brush/src/constant.js
var constant_default3 = (x4) => () => x4;

// node_modules/d3-brush/src/event.js
function BrushEvent(type2, {
  sourceEvent,
  target,
  selection: selection2,
  mode,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: {
      value: type2,
      enumerable: true,
      configurable: true
    },
    sourceEvent: {
      value: sourceEvent,
      enumerable: true,
      configurable: true
    },
    target: {
      value: target,
      enumerable: true,
      configurable: true
    },
    selection: {
      value: selection2,
      enumerable: true,
      configurable: true
    },
    mode: {
      value: mode,
      enumerable: true,
      configurable: true
    },
    _: {
      value: dispatch2
    }
  });
}

// node_modules/d3-brush/src/noevent.js
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-brush/src/brush.js
var MODE_DRAG = {
  name: "drag"
};
var MODE_SPACE = {
  name: "space"
};
var MODE_HANDLE = {
  name: "handle"
};
var MODE_CENTER = {
  name: "center"
};
var {
  abs,
  max: max2,
  min: min2
} = Math;
function number1(e) {
  return [+e[0], +e[1]];
}
function number2(e) {
  return [number1(e[0]), number1(e[1])];
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x4, e) {
    return x4 == null ? null : [[+x4[0], e[0][1]], [+x4[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y3, e) {
    return y3 == null ? null : [[e[0][0], +y3[0]], [e[1][0], +y3[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number2(xy);
  },
  output: function(xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
};
var signsY = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function type(t2) {
  return {
    type: t2
  };
}
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}
function empty2(extent) {
  return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
}
function brushX() {
  return brush(X);
}
function brush(dim) {
  var extent = defaultExtent, filter3 = defaultFilter, touchable = defaultTouchable, keys = true, listeners = dispatch_default2("start", "brush", "end"), handleSize = 6, touchending;
  function brush2(group) {
    var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
      var extent2 = local(this).extent;
      select_default2(this).attr("x", extent2[0][0]).attr("y", extent2[0][1]).attr("width", extent2[1][0] - extent2[0][0]).attr("height", extent2[1][1] - extent2[0][1]);
    });
    group.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group.selectAll(".handle").data(dim.handles, function(d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function(d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function(d) {
      return cursors[d.type];
    });
    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush2.move = function(group, selection2, event) {
    if (group.tween) {
      group.on("start.brush", function(event2) {
        emitter(this, arguments).beforestart().start(event2);
      }).on("interrupt.brush end.brush", function(event2) {
        emitter(this, arguments).end(event2);
      }).tween("brush", function() {
        var that = this, state2 = that.__brush, emit = emitter(that, arguments), selection0 = state2.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state2.extent), i = value_default(selection0, selection1);
        function tween(t2) {
          state2.selection = t2 === 1 && selection1 === null ? null : i(t2);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group.each(function() {
        var that = this, args = arguments, state2 = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state2.extent), emit = emitter(that, args).beforestart();
        interrupt_default(that);
        state2.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start(event).brush(event).end(event);
      });
    }
  };
  brush2.clear = function(group, event) {
    brush2.move(group, null, event);
  };
  function redraw() {
    var group = select_default2(this), selection2 = local(this).selection;
    if (selection2) {
      group.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
      group.selectAll(".handle").style("display", null).attr("x", function(d) {
        return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
      }).attr("y", function(d) {
        return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
      }).attr("width", function(d) {
        return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
      }).attr("height", function(d) {
        return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }
  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }
  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function(event, mode) {
      if (this.starting) this.starting = false, this.emit("start", event, mode);
      else this.emit("brush", event);
      return this;
    },
    brush: function(event, mode) {
      this.emit("brush", event, mode);
      return this;
    },
    end: function(event, mode) {
      if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
      return this;
    },
    emit: function(type2, event, mode) {
      var d = select_default2(this.that).datum();
      listeners.call(type2, this.that, new BrushEvent(type2, {
        sourceEvent: event,
        target: brush2,
        selection: dim.output(this.state.selection),
        mode,
        dispatch: listeners
      }), d);
    }
  };
  function started(event) {
    if (touchending && !event.touches) return;
    if (!filter3.apply(this, arguments)) return;
    var that = this, type2 = event.target.__data__.type, mode = (keys && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state2 = local(that), extent2 = state2.extent, selection2 = state2.selection, W = extent2[0][0], w0, w1, N = extent2[0][1], n0, n1, E = extent2[1][0], e0, e1, S2 = extent2[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, points = Array.from(event.touches || [event], (t2) => {
      const i = t2.identifier;
      t2 = pointer_default(t2, that);
      t2.point0 = t2.slice();
      t2.identifier = i;
      return t2;
    });
    interrupt_default(that);
    var emit = emitter(that, arguments, true).beforestart();
    if (type2 === "overlay") {
      if (selection2) moving = true;
      const pts = [points[0], points[1] || points[0]];
      state2.selection = selection2 = [[w0 = dim === Y ? W : min2(pts[0][0], pts[1][0]), n0 = dim === X ? N : min2(pts[0][1], pts[1][1])], [e0 = dim === Y ? E : max2(pts[0][0], pts[1][0]), s0 = dim === X ? S2 : max2(pts[0][1], pts[1][1])]];
      if (points.length > 1) move(event);
    } else {
      w0 = selection2[0][0];
      n0 = selection2[0][1];
      e0 = selection2[1][0];
      s0 = selection2[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group = select_default2(that).attr("pointer-events", "none");
    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type2]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select_default2(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys) view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      nodrag_default(event.view);
    }
    redraw.call(that);
    emit.start(event, mode.name);
    function moved(event2) {
      for (const p2 of event2.changedTouches || [event2]) {
        for (const d of points) if (d.identifier === p2.identifier) d.cur = pointer_default(p2, that);
      }
      if (shifting && !lockX && !lockY && points.length === 1) {
        const point3 = points[0];
        if (abs(point3.cur[0] - point3[0]) > abs(point3.cur[1] - point3[1])) lockY = true;
        else lockX = true;
      }
      for (const point3 of points) if (point3.cur) point3[0] = point3.cur[0], point3[1] = point3.cur[1];
      moving = true;
      noevent_default2(event2);
      move(event2);
    }
    function move(event2) {
      const point3 = points[0], point0 = point3.point0;
      var t2;
      dx = point3[0] - point0[0];
      dy = point3[1] - point0[1];
      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = max2(W - w0, min2(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = max2(N - n0, min2(S2 - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (points[1]) {
            if (signX) w1 = max2(W, min2(E, points[0][0])), e1 = max2(W, min2(E, points[1][0])), signX = 1;
            if (signY) n1 = max2(N, min2(S2, points[0][1])), s1 = max2(N, min2(S2, points[1][1])), signY = 1;
          } else {
            if (signX < 0) dx = max2(W - w0, min2(E - w0, dx)), w1 = w0 + dx, e1 = e0;
            else if (signX > 0) dx = max2(W - e0, min2(E - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0) dy = max2(N - n0, min2(S2 - n0, dy)), n1 = n0 + dy, s1 = s0;
            else if (signY > 0) dy = max2(N - s0, min2(S2 - s0, dy)), n1 = n0, s1 = s0 + dy;
          }
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = max2(W, min2(E, w0 - dx * signX)), e1 = max2(W, min2(E, e0 + dx * signX));
          if (signY) n1 = max2(N, min2(S2, n0 - dy * signY)), s1 = max2(N, min2(S2, s0 + dy * signY));
          break;
        }
      }
      if (e1 < w1) {
        signX *= -1;
        t2 = w0, w0 = e0, e0 = t2;
        t2 = w1, w1 = e1, e1 = t2;
        if (type2 in flipX) overlay.attr("cursor", cursors[type2 = flipX[type2]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t2 = n0, n0 = s0, s0 = t2;
        t2 = n1, n1 = s1, s1 = t2;
        if (type2 in flipY) overlay.attr("cursor", cursors[type2 = flipY[type2]]);
      }
      if (state2.selection) selection2 = state2.selection;
      if (lockX) w1 = selection2[0][0], e1 = selection2[1][0];
      if (lockY) n1 = selection2[0][1], s1 = selection2[1][1];
      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
        state2.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush(event2, mode.name);
      }
    }
    function ended(event2) {
      nopropagation(event2);
      if (event2.touches) {
        if (event2.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
      } else {
        yesdrag(event2.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state2.selection) selection2 = state2.selection;
      if (empty2(selection2)) state2.selection = null, redraw.call(that);
      emit.end(event2, mode.name);
    }
    function keydowned(event2) {
      switch (event2.keyCode) {
        case 16: {
          shifting = signX && signY;
          break;
        }
        case 18: {
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx;
            else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy;
            else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
    function keyupped(event2) {
      switch (event2.keyCode) {
        case 16: {
          if (shifting) {
            lockX = lockY = shifting = false;
            move(event2);
          }
          break;
        }
        case 18: {
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1;
            else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1;
            else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode === MODE_SPACE) {
            if (event2.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1;
              else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1;
              else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type2]);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent_default2(event2);
    }
  }
  function touchmoved(event) {
    emitter(this, arguments).moved(event);
  }
  function touchended(event) {
    emitter(this, arguments).ended(event);
  }
  function initialize() {
    var state2 = this.__brush || {
      selection: null
    };
    state2.extent = number2(extent.apply(this, arguments));
    state2.dim = dim;
    return state2;
  }
  brush2.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant_default3(number2(_)), brush2) : extent;
  };
  brush2.filter = function(_) {
    return arguments.length ? (filter3 = typeof _ === "function" ? _ : constant_default3(!!_), brush2) : filter3;
  };
  brush2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant_default3(!!_), brush2) : touchable;
  };
  brush2.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush2) : handleSize;
  };
  brush2.keyModifiers = function(_) {
    return arguments.length ? (keys = !!_, brush2) : keys;
  };
  brush2.on = function() {
    var value2 = listeners.on.apply(listeners, arguments);
    return value2 === listeners ? brush2 : value2;
  };
  return brush2;
}

// node_modules/d3-array/src/ascending.js
function ascending2(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a, b) {
  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending2;
    compare2 = (d, x4) => ascending2(f(d), x4);
    delta = (d, x4) => f(d) - x4;
  } else {
    compare1 = f === ascending2 || f === descending ? f : zero2;
    compare2 = f;
    delta = f;
  }
  function left2(a, x4, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x4, x4) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x4) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a, x4, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x4, x4) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x4) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a, x4, lo = 0, hi = a.length) {
    const i = left2(a, x4, lo, hi - 1);
    return i > lo && delta(a[i - 1], x4) > -delta(a[i], x4) ? i - 1 : i;
  }
  return {
    left: left2,
    center: center2,
    right: right2
  };
}
function zero2() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x4) {
  return x4 === null ? NaN : +x4;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value2 of values) {
      if (value2 != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index, values)) != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending2);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/internmap/src/index.js
var InternMap = class extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, {
      _intern: {
        value: /* @__PURE__ */ new Map()
      },
      _key: {
        value: key
      }
    });
    if (entries != null) for (const [key2, value2] of entries) this.set(key2, value2);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value2) {
    return super.set(intern_set(this, key), value2);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
};
function intern_get({
  _intern,
  _key
}, value2) {
  const key = _key(value2);
  return _intern.has(key) ? _intern.get(key) : value2;
}
function intern_set({
  _intern,
  _key
}, value2) {
  const key = _key(value2);
  if (_intern.has(key)) return _intern.get(key);
  _intern.set(key, value2);
  return value2;
}
function intern_delete({
  _intern,
  _key
}, value2) {
  const key = _key(value2);
  if (_intern.has(key)) {
    value2 = _intern.get(value2);
    _intern.delete(key);
  }
  return value2;
}
function keyof(value2) {
  return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
}

// node_modules/d3-array/src/sort.js
function compareDefined(compare2 = ascending2) {
  if (compare2 === ascending2) return ascendingDefined;
  if (typeof compare2 !== "function") throw new TypeError("compare is not a function");
  return (a, b) => {
    const x4 = compare2(a, b);
    if (x4 || x4 === 0) return x4;
    return (compare2(b, b) === 0) - (compare2(a, a) === 0);
  };
}
function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start2, stop, count3) {
  const step = (stop - start2) / Math.max(0, count3), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start2) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start2) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count3 && count3 < 2) return tickSpec(start2, stop, count3 * 2);
  return [i1, i2, inc];
}
function ticks(start2, stop, count3) {
  stop = +stop, start2 = +start2, count3 = +count3;
  if (!(count3 > 0)) return [];
  if (start2 === stop) return [start2];
  const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count3) : tickSpec(start2, stop, count3);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count3) {
  stop = +stop, start2 = +start2, count3 = +count3;
  return tickSpec(start2, stop, count3)[2];
}
function tickStep(start2, stop, count3) {
  stop = +stop, start2 = +start2, count3 = +count3;
  const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count3) : tickIncrement(start2, stop, count3);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/max.js
function max3(values, valueof) {
  let max6;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (max6 < value2 || max6 === void 0 && value2 >= value2)) {
        max6 = value2;
      }
    }
  } else {
    let index = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index, values)) != null && (max6 < value2 || max6 === void 0 && value2 >= value2)) {
        max6 = value2;
      }
    }
  }
  return max6;
}

// node_modules/d3-array/src/min.js
function min3(values, valueof) {
  let min6;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2;
      }
    }
  } else {
    let index = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index, values)) != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2;
      }
    }
  }
  return min6;
}

// node_modules/d3-array/src/quickselect.js
function quickselect(array2, k, left2 = 0, right2 = Infinity, compare2) {
  k = Math.floor(k);
  left2 = Math.floor(Math.max(0, left2));
  right2 = Math.floor(Math.min(array2.length - 1, right2));
  if (!(left2 <= k && k <= right2)) return array2;
  compare2 = compare2 === void 0 ? ascendingDefined : compareDefined(compare2);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n = right2 - left2 + 1;
      const m = k - left2 + 1;
      const z = Math.log(n);
      const s2 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k - m * s2 / n + sd));
      const newRight = Math.min(right2, Math.floor(k + (n - m) * s2 / n + sd));
      quickselect(array2, k, newLeft, newRight, compare2);
    }
    const t2 = array2[k];
    let i = left2;
    let j = right2;
    swap(array2, left2, k);
    if (compare2(array2[right2], t2) > 0) swap(array2, left2, right2);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare2(array2[i], t2) < 0) ++i;
      while (compare2(array2[j], t2) > 0) --j;
    }
    if (compare2(array2[left2], t2) === 0) swap(array2, left2, j);
    else ++j, swap(array2, j, right2);
    if (j <= k) left2 = j + 1;
    if (k <= j) right2 = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t2 = array2[i];
  array2[i] = array2[j];
  array2[j] = t2;
}

// node_modules/d3-array/src/quantile.js
function quantile(values, p2, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length) || isNaN(p2 = +p2)) return;
  if (p2 <= 0 || n < 2) return min3(values);
  if (p2 >= 1) return max3(values);
  var n, i = (n - 1) * p2, i0 = Math.floor(i), value0 = max3(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min3(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values, p2, valueof = number) {
  if (!(n = values.length) || isNaN(p2 = +p2)) return;
  if (p2 <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p2 >= 1) return +valueof(values[n - 1], n - 1, values);
  var n, i = (n - 1) * p2, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

// node_modules/d3-array/src/range.js
function range(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range2 = new Array(n);
  while (++i < n) {
    range2[i] = start2 + i * step;
  }
  return range2;
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");
function ordinal() {
  var index = new InternMap(), domain = [], range2 = [], unknown = implicit;
  function scale(d) {
    let i = index.get(d);
    if (i === void 0) {
      if (unknown !== implicit) return unknown;
      index.set(d, i = domain.push(d) - 1);
    }
    return range2[i % range2.length];
  }
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new InternMap();
    for (const value2 of _) {
      if (index.has(value2)) continue;
      index.set(value2, domain.push(value2) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), scale) : range2.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range2).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}

// node_modules/d3-scale/src/band.js
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round3 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length, reverse = r1 < r0, start2 = reverse ? r1 : r0, stop = reverse ? r0 : r1;
    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round3) step = Math.floor(step);
    start2 += (stop - start2 - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round3) start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function(i) {
      return start2 + step * i;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round3 = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_) {
    return arguments.length ? (round3 = !!_, rescale()) : round3;
  };
  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round3).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy2 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy2());
  };
  return scale;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

// node_modules/d3-scale/src/constant.js
function constants(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-scale/src/number.js
function number3(x4) {
  return +x4;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x4) {
  return x4;
}
function normalize(a, b) {
  return (b -= a = +a) ? function(x4) {
    return (x4 - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t2;
  if (a > b) t2 = a, a = b, b = t2;
  return function(x4) {
    return Math.max(a, Math.min(b, x4));
  };
}
function bimap(domain, range2, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x4) {
    return r0(d0(x4));
  };
}
function polymap(domain, range2, interpolate) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r2 = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r2[i] = interpolate(range2[i], range2[i + 1]);
  }
  return function(x4) {
    var i2 = bisect_default(domain, x4, 1, j) - 1;
    return r2[i2](d[i2](x4));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range2 = unit, interpolate = value_default, transform, untransform, unknown, clamp2 = identity3, piecewise, output, input2;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp2 !== identity3) clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input2 = null;
    return scale;
  }
  function scale(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : (output || (output = piecewise(domain.map(transform), range2, interpolate)))(transform(clamp2(x4)));
  }
  scale.invert = function(y3) {
    return clamp2(untransform((input2 || (input2 = piecewise(range2, domain.map(transform), number_default)))(y3)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number3), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_) {
    return range2 = Array.from(_), interpolate = round_default, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity3, rescale()) : clamp2 !== identity3;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t2, u2) {
    transform = t2, untransform = u2;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity3, identity3);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x4) {
  return Math.abs(x4 = Math.round(x4)) >= 1e21 ? x4.toLocaleString("en").replace(/,/g, "") : x4.toString(10);
}
function formatDecimalParts(x4, p2) {
  if ((i = (x4 = p2 ? x4.toExponential(p2 - 1) : x4.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x4.slice(0, i);
  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x4.slice(i + 1)];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x4) {
  return x4 = formatDecimalParts(Math.abs(x4)), x4 ? x4[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value2, width) {
    var i = value2.length, t2 = [], j = 0, g2 = grouping[0], length = 0;
    while (i > 0 && g2 > 0) {
      if (length + g2 + 1 > width) g2 = Math.max(1, width - length);
      t2.push(value2.substring(i -= g2, i + g2));
      if ((length += g2 + 1) > width) break;
      g2 = grouping[j = (j + 1) % grouping.length];
    }
    return t2.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match2 = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match2;
  return new FormatSpecifier({
    fill: match2[1],
    align: match2[2],
    sign: match2[3],
    symbol: match2[4],
    zero: match2[5],
    width: match2[6],
    comma: match2[7],
    precision: match2[8] && match2[8].slice(1),
    trim: match2[9],
    type: match2[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out: for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s2[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s2[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x4, p2) {
  var d = formatDecimalParts(x4, p2);
  if (!d) return x4 + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x4, Math.max(0, p2 + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x4, p2) {
  var d = formatDecimalParts(x4, p2);
  if (!d) return x4 + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x4, p2) => (x4 * 100).toFixed(p2),
  "b": (x4) => Math.round(x4).toString(2),
  "c": (x4) => x4 + "",
  "d": formatDecimal_default,
  "e": (x4, p2) => x4.toExponential(p2),
  "f": (x4, p2) => x4.toFixed(p2),
  "g": (x4, p2) => x4.toPrecision(p2),
  "o": (x4) => Math.round(x4).toString(8),
  "p": (x4, p2) => formatRounded_default(x4 * 100, p2),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x4) => Math.round(x4).toString(16).toUpperCase(),
  "x": (x4) => Math.round(x4).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x4) {
  return x4;
}

// node_modules/d3-format/src/locale.js
var map2 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map2.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map2.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n") comma = true, type2 = "g";
    else if (!formatTypes_default[type2]) precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero3 || fill === "0" && align === "=") zero3 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type2 === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim) value2 = formatTrim_default(value2);
        if (valueNegative && +value2 === 0 && sign !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value2.length;
          while (++i < n) {
            if (c = value2.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
              value2 = value2.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3) value2 = group(value2, Infinity);
      var length = valuePrefix.length + value2.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero3) value2 = group(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value2) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value3) {
      return f(k * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value2) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max6) {
  step = Math.abs(step), max6 = Math.abs(max6) - step;
  return Math.max(0, exponent_default(max6) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count3, specifier) {
  var step = tickStep(start2, stop, count3), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value2 = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value2))) specifier.precision = precision;
      return formatPrefix(specifier, value2);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count3) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count3 == null ? 10 : count3);
  };
  scale.tickFormat = function(count3, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count3 == null ? 10 : count3, specifier);
  };
  scale.nice = function(count3) {
    if (count3 == null) count3 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count3);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-scale/src/nice.js
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t2;
  if (x1 < x0) {
    t2 = i0, i0 = i1, i1 = t2;
    t2 = x0, x0 = x1, x1 = t2;
  }
  domain[i0] = interval2.floor(x0);
  domain[i1] = interval2.ceil(x1);
  return domain;
}

// node_modules/d3-scale/src/quantile.js
function quantile2() {
  var domain = [], range2 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range2.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
    return scale;
  }
  function scale(x4) {
    return x4 == null || isNaN(x4 = +x4) ? unknown : range2[bisect_default(thresholds, x4)];
  }
  scale.invertExtent = function(y3) {
    var i = range2.indexOf(y3);
    return i < 0 ? [NaN, NaN] : [i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1]];
  };
  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending2);
    return rescale();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile2().domain(domain).range(range2).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}

// node_modules/d3-time/src/interval.js
var t0 = /* @__PURE__ */ new Date();
var t1 = /* @__PURE__ */ new Date();
function newInterval(floori, offseti, count3, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step) {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = function(start2, stop, step) {
    var range2 = [], previous;
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0)) return range2;
    do
      range2.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range2;
  };
  interval2.filter = function(test) {
    return newInterval(function(date2) {
      if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date2, -1), !test(date2)) {
          }
        }
        else while (--step >= 0) {
          while (offseti(date2, 1), !test(date2)) {
          }
        }
      }
    });
  };
  if (count3) {
    interval2.count = function(start2, end2) {
      t0.setTime(+start2), t1.setTime(+end2);
      floori(t0), floori(t1);
      return Math.floor(count3(t0, t1));
    };
    interval2.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? function(d) {
        return field(d) % step === 0;
      } : function(d) {
        return interval2.count(0, d) % step === 0;
      });
    };
  }
  return interval2;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = newInterval(function() {
}, function(date2, step) {
  date2.setTime(+date2 + step);
}, function(start2, end2) {
  return end2 - start2;
});
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k) * k);
  }, function(date2, step) {
    date2.setTime(+date2 + step * k);
  }, function(start2, end2) {
    return (end2 - start2) / k;
  });
};
var millisecond_default = millisecond;
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step) {
  date2.setTime(+date2 + step * durationSecond);
}, function(start2, end2) {
  return (end2 - start2) / durationSecond;
}, function(date2) {
  return date2.getUTCSeconds();
});
var second_default = second;
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start2, end2) {
  return (end2 - start2) / durationMinute;
}, function(date2) {
  return date2.getMinutes();
});
var minute_default = minute;
var minutes = minute.range;

// node_modules/d3-time/src/hour.js
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start2, end2) {
  return (end2 - start2) / durationHour;
}, function(date2) {
  return date2.getHours();
});
var hour_default = hour;
var hours = hour.range;

// node_modules/d3-time/src/day.js
var day = newInterval((date2) => date2.setHours(0, 0, 0, 0), (date2, step) => date2.setDate(date2.getDate() + step), (start2, end2) => (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay, (date2) => date2.getDate() - 1);
var day_default = day;
var days = day.range;

// node_modules/d3-time/src/week.js
function weekday(i) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start2, end2) {
    return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

// node_modules/d3-time/src/month.js
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setMonth(date2.getMonth() + step);
}, function(start2, end2) {
  return end2.getMonth() - start2.getMonth() + (end2.getFullYear() - start2.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
var month_default = month;
var months = month.range;

// node_modules/d3-time/src/year.js
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setFullYear(date2.getFullYear() + step);
}, function(start2, end2) {
  return end2.getFullYear() - start2.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setFullYear(date2.getFullYear() + step * k);
  });
};
var year_default = year;
var years = year.range;

// node_modules/d3-time/src/utcMinute.js
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationMinute);
}, function(start2, end2) {
  return (end2 - start2) / durationMinute;
}, function(date2) {
  return date2.getUTCMinutes();
});
var utcMinute_default = utcMinute;
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/utcHour.js
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step) {
  date2.setTime(+date2 + step * durationHour);
}, function(start2, end2) {
  return (end2 - start2) / durationHour;
}, function(date2) {
  return date2.getUTCHours();
});
var utcHour_default = utcHour;
var utcHours = utcHour.range;

// node_modules/d3-time/src/utcDay.js
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCDate(date2.getUTCDate() + step);
}, function(start2, end2) {
  return (end2 - start2) / durationDay;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
var utcDay_default = utcDay;
var utcDays = utcDay.range;

// node_modules/d3-time/src/utcWeek.js
function utcWeekday(i) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start2, end2) {
    return (end2 - start2) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/utcMonth.js
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, function(start2, end2) {
  return end2.getUTCMonth() - start2.getUTCMonth() + (end2.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
var utcMonth_default = utcMonth;
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/utcYear.js
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, function(start2, end2) {
  return end2.getUTCFullYear() - start2.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
  });
};
var utcYear_default = utcYear;
var utcYears = utcYear.range;

// node_modules/d3-time/node_modules/d3-array/src/ascending.js
function ascending_default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-time/node_modules/d3-array/src/bisector.js
function bisector_default(f) {
  let delta = f;
  let compare2 = f;
  if (f.length === 1) {
    delta = (d, x4) => f(d) - x4;
    compare2 = ascendingComparator(f);
  }
  function left2(a, x4, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare2(a[mid], x4) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  function right2(a, x4, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare2(a[mid], x4) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }
  function center2(a, x4, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left2(a, x4, lo, hi - 1);
    return i > lo && delta(a[i - 1], x4) > -delta(a[i], x4) ? i - 1 : i;
  }
  return {
    left: left2,
    center: center2,
    right: right2
  };
}
function ascendingComparator(f) {
  return (d, x4) => ascending_default(f(d), x4);
}

// node_modules/d3-time/node_modules/d3-array/src/ticks.js
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
function tickStep2(start2, stop, count3) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count3), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e102) step1 *= 10;
  else if (error >= e52) step1 *= 5;
  else if (error >= e22) step1 *= 2;
  return stop < start2 ? -step1 : step1;
}

// node_modules/d3-time/src/ticks.js
function ticker(year2, month2, week, day2, hour2, minute2) {
  const tickIntervals = [[second_default, 1, durationSecond], [second_default, 5, 5 * durationSecond], [second_default, 15, 15 * durationSecond], [second_default, 30, 30 * durationSecond], [minute2, 1, durationMinute], [minute2, 5, 5 * durationMinute], [minute2, 15, 15 * durationMinute], [minute2, 30, 30 * durationMinute], [hour2, 1, durationHour], [hour2, 3, 3 * durationHour], [hour2, 6, 6 * durationHour], [hour2, 12, 12 * durationHour], [day2, 1, durationDay], [day2, 2, 2 * durationDay], [week, 1, durationWeek], [month2, 1, durationMonth], [month2, 3, 3 * durationMonth], [year2, 1, durationYear]];
  function ticks2(start2, stop, count3) {
    const reverse = stop < start2;
    if (reverse) [start2, stop] = [stop, start2];
    const interval2 = count3 && typeof count3.range === "function" ? count3 : tickInterval(start2, stop, count3);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count3) {
    const target = Math.abs(stop - start2) / count3;
    const i = bisector_default(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length) return year2.every(tickStep2(start2 / durationYear, stop / durationYear, count3));
    if (i === 0) return millisecond_default.every(Math.max(tickStep2(start2, stop, count3), 1));
    const [t2, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t2.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear_default, utcMonth_default, utcSunday, utcDay_default, utcHour_default, utcMinute_default);
var [timeTicks, timeTickInterval] = ticker(year_default, month_default, sunday, day_default, hour_default, minute_default);

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y3, m, d) {
  return {
    y: y3,
    m,
    d,
    H: 0,
    M: 0,
    S: 0,
    L: 0
  };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c, pad2, format2;
      if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad2 = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad2 = c === "e" ? " " : "0";
          if (format2 = formats2[c]) c = format2(date2, pad2);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i != string.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay_default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = day_default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c, parse2;
    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse2 = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse2 || (j = parse2(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p2 = newParse(specifier += "", false);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p2 = newParse(specifier += "", true);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    }
  };
}
var pads = {
  "-": "",
  "_": " ",
  "0": "0"
};
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value2, fill, width) {
  var sign = value2 < 0 ? "-" : "", string = (sign ? -value2 : value2) + "", length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p2) {
  return pad(d.getDate(), p2, 2);
}
function formatHour24(d, p2) {
  return pad(d.getHours(), p2, 2);
}
function formatHour12(d, p2) {
  return pad(d.getHours() % 12 || 12, p2, 2);
}
function formatDayOfYear(d, p2) {
  return pad(1 + day_default.count(year_default(d), d), p2, 3);
}
function formatMilliseconds(d, p2) {
  return pad(d.getMilliseconds(), p2, 3);
}
function formatMicroseconds(d, p2) {
  return formatMilliseconds(d, p2) + "000";
}
function formatMonthNumber(d, p2) {
  return pad(d.getMonth() + 1, p2, 2);
}
function formatMinutes(d, p2) {
  return pad(d.getMinutes(), p2, 2);
}
function formatSeconds(d, p2) {
  return pad(d.getSeconds(), p2, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p2) {
  return pad(sunday.count(year_default(d) - 1, d), p2, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p2) {
  d = dISO(d);
  return pad(thursday.count(year_default(d), d) + (year_default(d).getDay() === 4), p2, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p2) {
  return pad(monday.count(year_default(d) - 1, d), p2, 2);
}
function formatYear(d, p2) {
  return pad(d.getFullYear() % 100, p2, 2);
}
function formatYearISO(d, p2) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p2, 2);
}
function formatFullYear(d, p2) {
  return pad(d.getFullYear() % 1e4, p2, 4);
}
function formatFullYearISO(d, p2) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p2, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p2) {
  return pad(d.getUTCDate(), p2, 2);
}
function formatUTCHour24(d, p2) {
  return pad(d.getUTCHours(), p2, 2);
}
function formatUTCHour12(d, p2) {
  return pad(d.getUTCHours() % 12 || 12, p2, 2);
}
function formatUTCDayOfYear(d, p2) {
  return pad(1 + utcDay_default.count(utcYear_default(d), d), p2, 3);
}
function formatUTCMilliseconds(d, p2) {
  return pad(d.getUTCMilliseconds(), p2, 3);
}
function formatUTCMicroseconds(d, p2) {
  return formatUTCMilliseconds(d, p2) + "000";
}
function formatUTCMonthNumber(d, p2) {
  return pad(d.getUTCMonth() + 1, p2, 2);
}
function formatUTCMinutes(d, p2) {
  return pad(d.getUTCMinutes(), p2, 2);
}
function formatUTCSeconds(d, p2) {
  return pad(d.getUTCSeconds(), p2, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p2) {
  return pad(utcSunday.count(utcYear_default(d) - 1, d), p2, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p2) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear_default(d), d) + (utcYear_default(d).getUTCDay() === 4), p2, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p2) {
  return pad(utcMonday.count(utcYear_default(d) - 1, d), p2, 2);
}
function formatUTCYear(d, p2) {
  return pad(d.getUTCFullYear() % 100, p2, 2);
}
function formatUTCYearISO(d, p2) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p2, 2);
}
function formatUTCFullYear(d, p2) {
  return pad(d.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCFullYearISO(d, p2) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-scale/src/time.js
function date(t2) {
  return new Date(t2);
}
function number4(t2) {
  return t2 instanceof Date ? +t2 : +/* @__PURE__ */ new Date(+t2);
}
function calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2) {
  var scale = continuous(), invert = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y3) {
    return new Date(invert(y3));
  };
  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number4)) : domain().map(date);
  };
  scale.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale.tickFormat = function(count3, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function") interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice(d, interval2)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, year_default, month_default, sunday, day_default, hour_default, minute_default, second_default, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

// node_modules/d3-shape/src/constant.js
function constant_default4(x4) {
  return function constant2() {
    return x4;
  };
}

// node_modules/d3-shape/src/math.js
var abs2 = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max4 = Math.max;
var min4 = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon = 1e-12;
var pi2 = Math.PI;
var halfPi2 = pi2 / 2;
var tau = 2 * pi2;
function acos(x4) {
  return x4 > 1 ? 0 : x4 < -1 ? pi2 : Math.acos(x4);
}
function asin(x4) {
  return x4 >= 1 ? halfPi2 : x4 <= -1 ? -halfPi2 : Math.asin(x4);
}

// node_modules/d3-path/src/path.js
var pi3 = Math.PI;
var tau2 = 2 * pi3;
var epsilon2 = 1e-6;
var tauEpsilon = tau2 - epsilon2;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x4, y3) {
    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y3}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x4, y3) {
    this._append`L${this._x1 = +x4},${this._y1 = +y3}`;
  }
  quadraticCurveTo(x1, y1, x4, y3) {
    this._append`Q${+x1},${+y1},${this._x1 = +x4},${this._y1 = +y3}`;
  }
  bezierCurveTo(x1, y1, x22, y22, x4, y3) {
    this._append`C${+x1},${+y1},${+x22},${+y22},${this._x1 = +x4},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x22, y22, r2) {
    x1 = +x1, y1 = +y1, x22 = +x22, y22 = +y22, r2 = +r2;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x22 - x1, y21 = y22 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon2)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r2) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x22 - x0, y20 = y22 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi3 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon2) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x4, y3, r2, a0, a1, ccw) {
    x4 = +x4, y3 = +y3, r2 = +r2, ccw = !!ccw;
    if (r2 < 0) throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x4 + dx, y0 = y3 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon2 || Math.abs(this._y1 - y0) > epsilon2) {
      this._append`L${x0},${y0}`;
    }
    if (!r2) return;
    if (da < 0) da = da % tau2 + tau2;
    if (da > tauEpsilon) {
      this._append`A${r2},${r2},0,1,${cw},${x4 - dx},${y3 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon2) {
      this._append`A${r2},${r2},0,${+(da >= pi3)},${cw},${this._x1 = x4 + r2 * Math.cos(a1)},${this._y1 = y3 + r2 * Math.sin(a1)}`;
    }
  }
  rect(x4, y3, w2, h) {
    this._append`M${this._x0 = this._x1 = +x4},${this._y0 = this._y1 = +y3}h${w2 = +w2}v${+h}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/d3-shape/src/path.js
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };
  return () => new Path(digits);
}

// node_modules/d3-shape/src/arc.js
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x22, y22, x32, y3) {
  var x10 = x1 - x0, y10 = y1 - y0, x322 = x32 - x22, y32 = y3 - y22, t2 = y32 * x10 - x322 * y10;
  if (t2 * t2 < epsilon) return;
  t2 = (x322 * (y0 - y22) - y32 * (x0 - x22)) / t2;
  return [x0 + t2 * x10, y0 + t2 * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r2 = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max4(0, r2 * r2 * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function arc_default() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default4(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context2 = null, path3 = withPath(arc);
  function arc() {
    var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi2, a1 = endAngle.apply(this, arguments) - halfPi2, da = abs2(a1 - a0), cw = a1 > a0;
    if (!context2) context2 = buffer = path3();
    if (r1 < r0) r2 = r1, r1 = r0, r0 = r2;
    if (!(r1 > epsilon)) context2.moveTo(0, 0);
    else if (da > tau - epsilon) {
      context2.moveTo(r1 * cos(a0), r1 * sin(a0));
      context2.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context2.moveTo(r0 * cos(a1), r0 * sin(a1));
        context2.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min4(abs2(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da < pi2) {
          if (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10)) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min4(rc, (r0 - lc) / (kc - 1));
            rc1 = min4(rc, (r1 - lc) / (kc + 1));
          } else {
            rc0 = rc1 = 0;
          }
        }
      }
      if (!(da1 > epsilon)) context2.moveTo(x01, y01);
      else if (rc1 > epsilon) {
        t02 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context2.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc) context2.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
        else {
          context2.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
          context2.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
          context2.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
        }
      } else context2.moveTo(x01, y01), context2.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon) || !(da0 > epsilon)) context2.lineTo(x10, y10);
      else if (rc0 > epsilon) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t12 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
        context2.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc) context2.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
        else {
          context2.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
          context2.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw);
          context2.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
        }
      } else context2.arc(0, 0, r0, a10, a00, cw);
    }
    context2.closePath();
    if (buffer) return context2 = null, buffer + "" || null;
  }
  arc.centroid = function() {
    var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi2 / 2;
    return [cos(a) * r2, sin(a) * r2];
  };
  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant_default4(+_), arc) : innerRadius;
  };
  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant_default4(+_), arc) : outerRadius;
  };
  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant_default4(+_), arc) : cornerRadius;
  };
  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant_default4(+_), arc) : padRadius;
  };
  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default4(+_), arc) : startAngle;
  };
  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default4(+_), arc) : endAngle;
  };
  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default4(+_), arc) : padAngle;
  };
  arc.context = function(_) {
    return arguments.length ? (context2 = _ == null ? null : _, arc) : context2;
  };
  return arc;
}

// node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default(x4) {
  return typeof x4 === "object" && "length" in x4 ? x4 : Array.from(x4);
}

// node_modules/d3-shape/src/curve/linear.js
function Linear(context2) {
  this._context = context2;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y3) {
    x4 = +x4, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y3) : this._context.moveTo(x4, y3);
        break;
      case 1:
        this._point = 2;
      // falls through
      default:
        this._context.lineTo(x4, y3);
        break;
    }
  }
};
function linear_default(context2) {
  return new Linear(context2);
}

// node_modules/d3-shape/src/point.js
function x2(p2) {
  return p2[0];
}
function y(p2) {
  return p2[1];
}

// node_modules/d3-shape/src/line.js
function line_default(x4, y3) {
  var defined = constant_default4(true), context2 = null, curve = linear_default, output = null, path3 = withPath(line);
  x4 = typeof x4 === "function" ? x4 : x4 === void 0 ? x2 : constant_default4(x4);
  y3 = typeof y3 === "function" ? y3 : y3 === void 0 ? y : constant_default4(y3);
  function line(data) {
    var i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
    if (context2 == null) output = curve(buffer = path3());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x4(d, i, data), +y3(d, i, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x4 = typeof _ === "function" ? _ : constant_default4(+_), line) : x4;
  };
  line.y = function(_) {
    return arguments.length ? (y3 = typeof _ === "function" ? _ : constant_default4(+_), line) : y3;
  };
  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default4(!!_), line) : defined;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context2 != null && (output = curve(context2)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context2 = output = null : output = curve(context2 = _), line) : context2;
  };
  return line;
}

// node_modules/d3-shape/src/area.js
function area_default(x0, y0, y1) {
  var x1 = null, defined = constant_default4(true), context2 = null, curve = linear_default, output = null, path3 = withPath(area);
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x2 : constant_default4(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant_default4(0) : constant_default4(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant_default4(+y1);
  function area(data) {
    var i, j, k, n = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context2 == null) output = curve(buffer = path3());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  function arealine() {
    return line_default().defined(defined).curve(curve).context(context2);
  }
  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default4(+_), x1 = null, area) : x0;
  };
  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default4(+_), area) : x0;
  };
  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant_default4(+_), area) : x1;
  };
  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default4(+_), y1 = null, area) : y0;
  };
  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default4(+_), area) : y0;
  };
  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant_default4(+_), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant_default4(!!_), area) : defined;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context2 != null && (output = curve(context2)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context2 = output = null : output = curve(context2 = _), area) : context2;
  };
  return area;
}

// node_modules/d3-shape/src/descending.js
function descending_default(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

// node_modules/d3-shape/src/identity.js
function identity_default2(d) {
  return d;
}

// node_modules/d3-shape/src/pie.js
function pie_default() {
  var value2 = identity_default2, sortValues = descending_default, sort = null, startAngle = constant_default4(0), endAngle = constant_default4(tau), padAngle = constant_default4(0);
  function pie(data) {
    var i, n = (data = array_default(data)).length, j, k, sum2 = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p2 = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p2 * (da < 0 ? -1 : 1), v;
    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value2(data[i], i, data)) > 0) {
        sum2 += v;
      }
    }
    if (sortValues != null) index.sort(function(i2, j2) {
      return sortValues(arcs[i2], arcs[j2]);
    });
    else if (sort != null) index.sort(function(i2, j2) {
      return sort(data[i2], data[j2]);
    });
    for (i = 0, k = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p2
      };
    }
    return arcs;
  }
  pie.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant_default4(+_), pie) : value2;
  };
  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };
  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };
  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant_default4(+_), pie) : startAngle;
  };
  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant_default4(+_), pie) : endAngle;
  };
  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant_default4(+_), pie) : padAngle;
  };
  return pie;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r2) {
    this._curve.point(r2 * Math.sin(a), r2 * -Math.cos(a));
  }
};
function curveRadial(curve) {
  function radial(context2) {
    return new Radial(curve(context2));
  }
  radial._curve = curve;
  return radial;
}

// node_modules/d3-shape/src/lineRadial.js
function lineRadial(l) {
  var c = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };
  return l;
}
function lineRadial_default() {
  return lineRadial(line_default().curve(curveRadialLinear));
}

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x4, y3) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x4), that._y2 + that._k * (that._y1 - y3), that._x2, that._y2);
}
function Cardinal(context2, tension) {
  this._context = context2;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x4, y3) {
    x4 = +x4, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x4, y3) : this._context.moveTo(x4, y3);
        break;
      case 1:
        this._point = 2;
        this._x1 = x4, this._y1 = y3;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        point2(this, x4, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinal_default = function custom(tension) {
  function cardinal(context2) {
    return new Cardinal(context2, tension);
  }
  cardinal.tension = function(tension2) {
    return custom(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context2, tension) {
  this._context = context2;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x4, y3) {
    x4 = +x4, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x4, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x4, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x4, this._y5 = y3;
        break;
      default:
        point2(this, x4, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x4;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalClosed_default = function custom2(tension) {
  function cardinal(context2) {
    return new CardinalClosed(context2, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-hierarchy/src/hierarchy/count.js
function count(node) {
  var sum2 = 0, children2 = node.children, i = children2 && children2.length;
  if (!i) sum2 = 1;
  else while (--i >= 0) sum2 += children2[i].value;
  node.value = sum2;
}
function count_default() {
  return this.eachAfter(count);
}

// node_modules/d3-hierarchy/src/hierarchy/each.js
function each_default2(callback, that) {
  let index = -1;
  for (const node of this) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
function eachBefore_default(callback, that) {
  var node = this, nodes = [node], children2, i, index = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);
    if (children2 = node.children) {
      for (i = children2.length - 1; i >= 0; --i) {
        nodes.push(children2[i]);
      }
    }
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
function eachAfter_default(callback, that) {
  var node = this, nodes = [node], next = [], children2, i, n, index = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i = 0, n = children2.length; i < n; ++i) {
        nodes.push(children2[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

// node_modules/d3-hierarchy/src/hierarchy/find.js
function find_default(callback, that) {
  let index = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index, this)) {
      return node;
    }
  }
}

// node_modules/d3-hierarchy/src/hierarchy/sum.js
function sum_default(value2) {
  return this.eachAfter(function(node) {
    var sum2 = +value2(node.data) || 0, children2 = node.children, i = children2 && children2.length;
    while (--i >= 0) sum2 += children2[i].value;
    node.value = sum2;
  });
}

// node_modules/d3-hierarchy/src/hierarchy/sort.js
function sort_default2(compare2) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare2);
    }
  });
}

// node_modules/d3-hierarchy/src/hierarchy/path.js
function path_default(end2) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end2), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k = nodes.length;
  while (end2 !== ancestor) {
    nodes.splice(k, 0, end2);
    end2 = end2.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

// node_modules/d3-hierarchy/src/hierarchy/ancestors.js
function ancestors_default() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

// node_modules/d3-hierarchy/src/hierarchy/descendants.js
function descendants_default() {
  return Array.from(this);
}

// node_modules/d3-hierarchy/src/hierarchy/leaves.js
function leaves_default() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

// node_modules/d3-hierarchy/src/hierarchy/links.js
function links_default() {
  var root3 = this, links = [];
  root3.each(function(node) {
    if (node !== root3) {
      links.push({
        source: node.parent,
        target: node
      });
    }
  });
  return links;
}

// node_modules/d3-hierarchy/src/hierarchy/iterator.js
function* iterator_default2() {
  var node = this, current, next = [node], children2, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i = 0, n = children2.length; i < n; ++i) {
          next.push(children2[i]);
        }
      }
    }
  } while (next.length);
}

// node_modules/d3-hierarchy/src/hierarchy/index.js
function hierarchy(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0) children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root3 = new Node2(data), node, nodes = [root3], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node2(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root3.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node2(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node2.prototype = hierarchy.prototype = {
  constructor: Node2,
  count: count_default,
  each: each_default2,
  eachAfter: eachAfter_default,
  eachBefore: eachBefore_default,
  find: find_default,
  sum: sum_default,
  sort: sort_default2,
  path: path_default,
  ancestors: ancestors_default,
  descendants: descendants_default,
  leaves: leaves_default,
  links: links_default,
  copy: node_copy,
  [Symbol.iterator]: iterator_default2
};

// node_modules/d3-hierarchy/src/accessors.js
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}

// node_modules/d3-hierarchy/src/constant.js
function constantZero() {
  return 0;
}
function constant_default5(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-hierarchy/src/treemap/round.js
function round_default2(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

// node_modules/d3-hierarchy/src/treemap/dice.js
function dice_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/stratify.js
var preroot = {
  depth: -1
};
var ambiguous = {};
var imputed = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify_default() {
  var id3 = defaultId, parentId = defaultParentId, path3;
  function stratify(data) {
    var nodes = Array.from(data), currentId = id3, currentParentId = parentId, n, d, i, root3, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path3 != null) {
      const I = nodes.map((d2, i2) => normalize2(path3(d2, i2, data)));
      const P2 = I.map(parentof);
      const S2 = new Set(I).add("");
      for (const i2 of P2) {
        if (!S2.has(i2)) {
          S2.add(i2);
          I.push(i2);
          P2.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_, i2) => I[i2];
      currentParentId = (_, i2) => P2[i2];
    }
    for (i = 0, n = nodes.length; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node2(d);
      if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root3) throw new Error("multiple roots");
        root3 = node;
      }
    }
    if (!root3) throw new Error("no root");
    if (path3 != null) {
      while (root3.data === imputed && root3.children.length === 1) {
        root3 = root3.children[0], --n;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed) break;
        node.data = null;
      }
    }
    root3.parent = preroot;
    root3.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root3.parent = null;
    if (n > 0) throw new Error("cycle");
    return root3;
  }
  stratify.id = function(x4) {
    return arguments.length ? (id3 = optional(x4), stratify) : id3;
  };
  stratify.parentId = function(x4) {
    return arguments.length ? (parentId = optional(x4), stratify) : parentId;
  };
  stratify.path = function(x4) {
    return arguments.length ? (path3 = optional(x4), stratify) : path3;
  };
  return stratify;
}
function normalize2(path3) {
  path3 = `${path3}`;
  let i = path3.length;
  if (slash(path3, i - 1) && !slash(path3, i - 2)) path3 = path3.slice(0, -1);
  return path3[0] === "/" ? path3 : `/${path3}`;
}
function parentof(path3) {
  let i = path3.length;
  if (i < 2) return "";
  while (--i > 1) if (slash(path3, i)) break;
  return path3.slice(0, i);
}
function slash(path3, i) {
  if (path3[i] === "/") {
    let k = 0;
    while (i > 0 && path3[--i] === "\\") ++k;
    if ((k & 1) === 0) return true;
  }
  return false;
}

// node_modules/d3-hierarchy/src/treemap/slice.js
function slice_default(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

// node_modules/d3-hierarchy/src/treemap/squarify.js
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = {
      value: sumValue,
      dice: dx < dy,
      children: nodes.slice(i0, i1)
    });
    if (row.dice) dice_default(row, x0, y0, x1, value2 ? y0 += dy * sumValue / value2 : y1);
    else slice_default(row, x0, y0, value2 ? x0 += dx * sumValue / value2 : x1, y1);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
var squarify_default = function custom3(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify.ratio = function(x4) {
    return custom3((x4 = +x4) > 1 ? x4 : 1);
  };
  return squarify;
}(phi);

// node_modules/d3-hierarchy/src/treemap/index.js
function treemap_default() {
  var tile = squarify_default, round3 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root3) {
    root3.x0 = root3.y0 = 0;
    root3.x1 = dx;
    root3.y1 = dy;
    root3.eachBefore(positionNode);
    paddingStack = [0];
    if (round3) root3.eachBefore(round_default2);
    return root3;
  }
  function positionNode(node) {
    var p2 = paddingStack[node.depth], x0 = node.x0 + p2, y0 = node.y0 + p2, x1 = node.x1 - p2, y1 = node.y1 - p2;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p2 = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p2;
      y0 += paddingTop(node) - p2;
      x1 -= paddingRight(node) - p2;
      y1 -= paddingBottom(node) - p2;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap.round = function(x4) {
    return arguments.length ? (round3 = !!x4, treemap) : round3;
  };
  treemap.size = function(x4) {
    return arguments.length ? (dx = +x4[0], dy = +x4[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x4) {
    return arguments.length ? (tile = required(x4), treemap) : tile;
  };
  treemap.padding = function(x4) {
    return arguments.length ? treemap.paddingInner(x4).paddingOuter(x4) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x4) {
    return arguments.length ? (paddingInner = typeof x4 === "function" ? x4 : constant_default5(+x4), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x4) {
    return arguments.length ? treemap.paddingTop(x4).paddingRight(x4).paddingBottom(x4).paddingLeft(x4) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x4) {
    return arguments.length ? (paddingTop = typeof x4 === "function" ? x4 : constant_default5(+x4), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x4) {
    return arguments.length ? (paddingRight = typeof x4 === "function" ? x4 : constant_default5(+x4), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x4) {
    return arguments.length ? (paddingBottom = typeof x4 === "function" ? x4 : constant_default5(+x4), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x4) {
    return arguments.length ? (paddingLeft = typeof x4 === "function" ? x4 : constant_default5(+x4), treemap) : paddingLeft;
  };
  return treemap;
}

// node_modules/d3-sankey/node_modules/d3-array/src/max.js
function max5(values, valueof) {
  let max6;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (max6 < value2 || max6 === void 0 && value2 >= value2)) {
        max6 = value2;
      }
    }
  } else {
    let index = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index, values)) != null && (max6 < value2 || max6 === void 0 && value2 >= value2)) {
        max6 = value2;
      }
    }
  }
  return max6;
}

// node_modules/d3-sankey/node_modules/d3-array/src/min.js
function min5(values, valueof) {
  let min6;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2;
      }
    }
  } else {
    let index = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index, values)) != null && (min6 > value2 || min6 === void 0 && value2 >= value2)) {
        min6 = value2;
      }
    }
  }
  return min6;
}

// node_modules/d3-sankey/node_modules/d3-array/src/sum.js
function sum(values, valueof) {
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value2 of values) {
      if (value2 = +value2) {
        sum2 += value2;
      }
    }
  } else {
    let index = -1;
    for (let value2 of values) {
      if (value2 = +valueof(value2, ++index, values)) {
        sum2 += value2;
      }
    }
  }
  return sum2;
}

// node_modules/d3-sankey/src/align.js
function left(node) {
  return node.depth;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}

// node_modules/d3-sankey/src/constant.js
function constant(x4) {
  return function() {
    return x4;
  };
}

// node_modules/d3-sankey/src/sankey.js
function ascendingSourceBreadth(a, b) {
  return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
  return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
  return a.y0 - b.y0;
}
function value(d) {
  return d.value;
}
function defaultId2(d) {
  return d.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find2(nodeById, id3) {
  const node = nodeById.get(id3);
  if (!node) throw new Error("missing: " + id3);
  return node;
}
function computeLinkBreadths({
  nodes
}) {
  for (const node of nodes) {
    let y0 = node.y0;
    let y1 = y0;
    for (const link2 of node.sourceLinks) {
      link2.y0 = y0 + link2.width / 2;
      y0 += link2.width;
    }
    for (const link2 of node.targetLinks) {
      link2.y1 = y1 + link2.width / 2;
      y1 += link2.width;
    }
  }
}
function Sankey() {
  let x0 = 0, y0 = 0, x1 = 1, y1 = 1;
  let dx = 24;
  let dy = 8, py;
  let id3 = defaultId2;
  let align = justify;
  let sort;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations = 6;
  function sankey() {
    const graph = {
      nodes: nodes.apply(null, arguments),
      links: links.apply(null, arguments)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_) {
    return arguments.length ? (id3 = typeof _ === "function" ? _ : constant(_), sankey) : id3;
  };
  sankey.nodeAlign = function(_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : constant(_), sankey) : align;
  };
  sankey.nodeSort = function(_) {
    return arguments.length ? (sort = _, sankey) : sort;
  };
  sankey.nodeWidth = function(_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };
  sankey.nodePadding = function(_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };
  sankey.nodes = function(_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : constant(_), sankey) : nodes;
  };
  sankey.links = function(_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : constant(_), sankey) : links;
  };
  sankey.linkSort = function(_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };
  sankey.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
  };
  sankey.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
  };
  sankey.iterations = function(_) {
    return arguments.length ? (iterations = +_, sankey) : iterations;
  };
  function computeNodeLinks({
    nodes: nodes2,
    links: links2
  }) {
    for (const [i, node] of nodes2.entries()) {
      node.index = i;
      node.sourceLinks = [];
      node.targetLinks = [];
    }
    const nodeById = new Map(nodes2.map((d, i) => [id3(d, i, nodes2), d]));
    for (const [i, link2] of links2.entries()) {
      link2.index = i;
      let {
        source,
        target
      } = link2;
      if (typeof source !== "object") source = link2.source = find2(nodeById, source);
      if (typeof target !== "object") target = link2.target = find2(nodeById, target);
      source.sourceLinks.push(link2);
      target.targetLinks.push(link2);
    }
    if (linkSort != null) {
      for (const {
        sourceLinks,
        targetLinks
      } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({
    nodes: nodes2
  }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({
    nodes: nodes2
  }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x4 = 0;
    while (current.size) {
      for (const node of current) {
        node.depth = x4;
        for (const {
          target
        } of node.sourceLinks) {
          next.add(target);
        }
      }
      if (++x4 > n) throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeHeights({
    nodes: nodes2
  }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x4 = 0;
    while (current.size) {
      for (const node of current) {
        node.height = x4;
        for (const {
          source
        } of node.targetLinks) {
          next.add(source);
        }
      }
      if (++x4 > n) throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({
    nodes: nodes2
  }) {
    const x4 = max5(nodes2, (d) => d.depth) + 1;
    const kx = (x1 - x0 - dx) / (x4 - 1);
    const columns = new Array(x4);
    for (const node of nodes2) {
      const i = Math.max(0, Math.min(x4 - 1, Math.floor(align.call(null, node, x4))));
      node.layer = i;
      node.x0 = x0 + i * kx;
      node.x1 = node.x0 + dx;
      if (columns[i]) columns[i].push(node);
      else columns[i] = [node];
    }
    if (sort) for (const column of columns) {
      column.sort(sort);
    }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky = min5(columns, (c) => (y1 - y0 - (c.length - 1) * py) / sum(c, value));
    for (const nodes2 of columns) {
      let y3 = y0;
      for (const node of nodes2) {
        node.y0 = y3;
        node.y1 = y3 + node.value * ky;
        y3 = node.y1 + py;
        for (const link2 of node.sourceLinks) {
          link2.width = link2.value * ky;
        }
      }
      y3 = (y1 - y3 + py) / (nodes2.length + 1);
      for (let i = 0; i < nodes2.length; ++i) {
        const node = nodes2[i];
        node.y0 += y3 * (i + 1);
        node.y1 += y3 * (i + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / (max5(columns, (c) => c.length) - 1));
    initializeNodeBreadths(columns);
    for (let i = 0; i < iterations; ++i) {
      const alpha = Math.pow(0.99, i);
      const beta = Math.max(1 - alpha, (i + 1) / iterations);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i = 1, n = columns.length; i < n; ++i) {
      const column = columns[i];
      for (const target of column) {
        let y3 = 0;
        let w2 = 0;
        for (const {
          source,
          value: value2
        } of target.targetLinks) {
          let v = value2 * (target.layer - source.layer);
          y3 += targetTop(source, target) * v;
          w2 += v;
        }
        if (!(w2 > 0)) continue;
        let dy2 = (y3 / w2 - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort === void 0) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n = columns.length, i = n - 2; i >= 0; --i) {
      const column = columns[i];
      for (const source of column) {
        let y3 = 0;
        let w2 = 0;
        for (const {
          target,
          value: value2
        } of source.sourceLinks) {
          let v = value2 * (target.layer - source.layer);
          y3 += sourceTop(source, target) * v;
          w2 += v;
        }
        if (!(w2 > 0)) continue;
        let dy2 = (y3 / w2 - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort === void 0) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i = nodes2.length >> 1;
    const subject = nodes2[i];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y3, i, alpha) {
    for (; i < nodes2.length; ++i) {
      const node = nodes2[i];
      const dy2 = (y3 - node.y0) * alpha;
      if (dy2 > 1e-6) node.y0 += dy2, node.y1 += dy2;
      y3 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y3, i, alpha) {
    for (; i >= 0; --i) {
      const node = nodes2[i];
      const dy2 = (node.y1 - y3) * alpha;
      if (dy2 > 1e-6) node.y0 -= dy2, node.y1 -= dy2;
      y3 = node.y0 - py;
    }
  }
  function reorderNodeLinks({
    sourceLinks,
    targetLinks
  }) {
    if (linkSort === void 0) {
      for (const {
        source: {
          sourceLinks: sourceLinks2
        }
      } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const {
        target: {
          targetLinks: targetLinks2
        }
      } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const {
        sourceLinks,
        targetLinks
      } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y3 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const {
      target: node,
      width
    } of source.sourceLinks) {
      if (node === target) break;
      y3 += width + py;
    }
    for (const {
      source: node,
      width
    } of target.targetLinks) {
      if (node === source) break;
      y3 -= width;
    }
    return y3;
  }
  function sourceTop(source, target) {
    let y3 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const {
      source: node,
      width
    } of target.targetLinks) {
      if (node === source) break;
      y3 += width + py;
    }
    for (const {
      target: node,
      width
    } of source.sourceLinks) {
      if (node === target) break;
      y3 -= width;
    }
    return y3;
  }
  return sankey;
}

// node_modules/d3-sankey/node_modules/d3-path/src/path.js
var pi4 = Math.PI;
var tau3 = 2 * pi4;
var epsilon3 = 1e-6;
var tauEpsilon2 = tau3 - epsilon3;
function Path2() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path2() {
  return new Path2();
}
Path2.prototype = path2.prototype = {
  constructor: Path2,
  moveTo: function(x4, y3) {
    this._ += "M" + (this._x0 = this._x1 = +x4) + "," + (this._y0 = this._y1 = +y3);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x4, y3) {
    this._ += "L" + (this._x1 = +x4) + "," + (this._y1 = +y3);
  },
  quadraticCurveTo: function(x1, y1, x4, y3) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x4) + "," + (this._y1 = +y3);
  },
  bezierCurveTo: function(x1, y1, x22, y22, x4, y3) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x22 + "," + +y22 + "," + (this._x1 = +x4) + "," + (this._y1 = +y3);
  },
  arcTo: function(x1, y1, x22, y22, r2) {
    x1 = +x1, y1 = +y1, x22 = +x22, y22 = +y22, r2 = +r2;
    var x0 = this._x1, y0 = this._y1, x21 = x22 - x1, y21 = y22 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r2 < 0) throw new Error("negative radius: " + r2);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon3)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon3) || !r2) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x22 - x0, y20 = y22 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi4 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon3) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r2 + "," + r2 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x4, y3, r2, a0, a1, ccw) {
    x4 = +x4, y3 = +y3, r2 = +r2, ccw = !!ccw;
    var dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x4 + dx, y0 = y3 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r2 < 0) throw new Error("negative radius: " + r2);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon3 || Math.abs(this._y1 - y0) > epsilon3) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r2) return;
    if (da < 0) da = da % tau3 + tau3;
    if (da > tauEpsilon2) {
      this._ += "A" + r2 + "," + r2 + ",0,1," + cw + "," + (x4 - dx) + "," + (y3 - dy) + "A" + r2 + "," + r2 + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon3) {
      this._ += "A" + r2 + "," + r2 + ",0," + +(da >= pi4) + "," + cw + "," + (this._x1 = x4 + r2 * Math.cos(a1)) + "," + (this._y1 = y3 + r2 * Math.sin(a1));
    }
  },
  rect: function(x4, y3, w2, h) {
    this._ += "M" + (this._x0 = this._x1 = +x4) + "," + (this._y0 = this._y1 = +y3) + "h" + +w2 + "v" + +h + "h" + -w2 + "Z";
  },
  toString: function() {
    return this._;
  }
};
var path_default2 = path2;

// node_modules/d3-sankey/node_modules/d3-shape/src/constant.js
function constant_default6(x4) {
  return function constant2() {
    return x4;
  };
}

// node_modules/d3-sankey/node_modules/d3-shape/src/point.js
function x3(p2) {
  return p2[0];
}
function y2(p2) {
  return p2[1];
}

// node_modules/d3-sankey/node_modules/d3-shape/src/array.js
var slice2 = Array.prototype.slice;

// node_modules/d3-sankey/node_modules/d3-shape/src/link/index.js
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link(curve) {
  var source = linkSource, target = linkTarget, x4 = x3, y3 = y2, context2 = null;
  function link2() {
    var buffer, argv = slice2.call(arguments), s2 = source.apply(this, argv), t2 = target.apply(this, argv);
    if (!context2) context2 = buffer = path_default2();
    curve(context2, +x4.apply(this, (argv[0] = s2, argv)), +y3.apply(this, argv), +x4.apply(this, (argv[0] = t2, argv)), +y3.apply(this, argv));
    if (buffer) return context2 = null, buffer + "" || null;
  }
  link2.source = function(_) {
    return arguments.length ? (source = _, link2) : source;
  };
  link2.target = function(_) {
    return arguments.length ? (target = _, link2) : target;
  };
  link2.x = function(_) {
    return arguments.length ? (x4 = typeof _ === "function" ? _ : constant_default6(+_), link2) : x4;
  };
  link2.y = function(_) {
    return arguments.length ? (y3 = typeof _ === "function" ? _ : constant_default6(+_), link2) : y3;
  };
  link2.context = function(_) {
    return arguments.length ? (context2 = _ == null ? null : _, link2) : context2;
  };
  return link2;
}
function curveHorizontal(context2, x0, y0, x1, y1) {
  context2.moveTo(x0, y0);
  context2.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}
function linkHorizontal() {
  return link(curveHorizontal);
}

// node_modules/d3-sankey/src/sankeyLinkHorizontal.js
function horizontalSource(d) {
  return [d.source.x1, d.y0];
}
function horizontalTarget(d) {
  return [d.target.x0, d.y1];
}
function sankeyLinkHorizontal_default() {
  return linkHorizontal().source(horizontalSource).target(horizontalTarget);
}

// node_modules/@swimlane/ngx-charts/fesm2022/swimlane-ngx-charts.mjs
var _c013 = ["caretElm"];
var _c16 = (a0) => ({
  model: a0
});
function TooltipContentComponent_span_4_ng_template_1_Template(rf, ctx) {
}
function TooltipContentComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275template(1, TooltipContentComponent_span_4_ng_template_1_Template, 0, 0, "ng-template", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c16, ctx_r0.context));
  }
}
function TooltipContentComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 6);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("innerHTML", ctx_r0.title, \u0275\u0275sanitizeHtml);
  }
}
function LegendComponent_header_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "header", 4)(1, "span", 5);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.title);
  }
}
function LegendComponent_li_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 6)(1, "ngx-charts-legend-entry", 7);
    \u0275\u0275listener("select", function LegendComponent_li_4_Template_ngx_charts_legend_entry_select_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.labelClick.emit($event));
    })("activate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_activate_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.activate($event));
    })("deactivate", function LegendComponent_li_4_Template_ngx_charts_legend_entry_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.deactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const entry_r3 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("label", entry_r3.label)("formattedLabel", entry_r3.formattedLabel)("color", entry_r3.color)("isActive", ctx_r0.isActive(entry_r3));
  }
}
var _c23 = ["*"];
function ChartComponent_ngx_charts_scale_legend_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "ngx-charts-scale-legend", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("horizontal", ctx_r0.legendOptions && ctx_r0.legendOptions.position === ctx_r0.LegendPosition.Below)("valueRange", ctx_r0.legendOptions.domain)("colors", ctx_r0.legendOptions.colors)("height", ctx_r0.view[1])("width", ctx_r0.legendWidth);
  }
}
function ChartComponent_ngx_charts_legend_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "ngx-charts-legend", 5);
    \u0275\u0275listener("labelClick", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelClick_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.legendLabelClick.emit($event));
    })("labelActivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelActivate_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.legendLabelActivate.emit($event));
    })("labelDeactivate", function ChartComponent_ngx_charts_legend_4_Template_ngx_charts_legend_labelDeactivate_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.legendLabelDeactivate.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("horizontal", ctx_r0.legendOptions && ctx_r0.legendOptions.position === ctx_r0.LegendPosition.Below)("data", ctx_r0.legendOptions.domain)("title", ctx_r0.legendOptions.title)("colors", ctx_r0.legendOptions.colors)("height", ctx_r0.view[1])("width", ctx_r0.legendWidth)("activeEntries", ctx_r0.activeEntries);
  }
}
var _c33 = ["ngx-charts-axis-label", ""];
var _c42 = ["ticksel"];
var _c52 = ["ngx-charts-x-axis-ticks", ""];
function XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainer(0);
  }
}
function XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_tspan_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "tspan", 10);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tickLine_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    \u0275\u0275attribute("y", i_r2 * 12);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", tickLine_r1, " ");
  }
}
function XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_tspan_1_Template, 2, 2, "tspan", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tickLines_r3 = ctx.ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", tickLines_r3);
  }
}
function XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0_Template, 2, 1, "ng-container", 6);
  }
  if (rf & 2) {
    const tick_r4 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r4.tickChunks(tick_r4));
  }
}
function XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const tickFormatted_r6 = \u0275\u0275nextContext().ngIf;
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate1(" ", ctx_r4.tickTrim(tickFormatted_r6), " ");
  }
}
function XAxisTicksComponent__svg_g_2__svg_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "title");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "text", 7);
    \u0275\u0275template(4, XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_container_4_Template, 1, 0, "ng-container", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(7, XAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_7_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tickFormatted_r6 = ctx.ngIf;
    const tmplMultilineTick_r7 = \u0275\u0275reference(6);
    const tmplSinglelineTick_r8 = \u0275\u0275reference(8);
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(tickFormatted_r6);
    \u0275\u0275advance();
    \u0275\u0275attribute("text-anchor", ctx_r4.textAnchor)("transform", ctx_r4.textTransform);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r4.isWrapTicksSupported)("ngIfThen", tmplMultilineTick_r7)("ngIfElse", tmplSinglelineTick_r8);
  }
}
function XAxisTicksComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275template(1, XAxisTicksComponent__svg_g_2__svg_ng_container_1_Template, 9, 6, "ng-container", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r4 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r4.tickTransform(tick_r4));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r4.tickFormat(tick_r4));
  }
}
function XAxisTicksComponent__svg_g_3__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "line", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r4.gridLineTransform());
    \u0275\u0275advance();
    \u0275\u0275attribute("y1", -ctx_r4.gridLineHeight);
  }
}
function XAxisTicksComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, XAxisTicksComponent__svg_g_3__svg_g_1_Template, 2, 2, "g", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r9 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r4.tickTransform(tick_r9));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r4.showGridLines);
  }
}
var _c62 = ["ngx-charts-x-axis", ""];
function XAxisComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("dimensionsChanged", function XAxisComponent__svg_g_1_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.emitTicksHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("trimTicks", ctx_r1.trimTicks)("rotateTicks", ctx_r1.rotateTicks)("maxTickLength", ctx_r1.maxTickLength)("tickFormatting", ctx_r1.tickFormatting)("tickArguments", ctx_r1.tickArguments)("tickStroke", ctx_r1.tickStroke)("scale", ctx_r1.xScale)("orient", ctx_r1.xOrient)("showGridLines", ctx_r1.showGridLines)("gridLineHeight", ctx_r1.dims.height)("width", ctx_r1.dims.width)("tickValues", ctx_r1.ticks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function XAxisComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 3);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", ctx_r1.orientation.Bottom)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
  }
}
var _c72 = ["ngx-charts-y-axis-ticks", ""];
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainer(0);
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_ng_container_1__svg_tspan_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "tspan", 12);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tickLine_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r2 = \u0275\u0275nextContext(6);
    \u0275\u0275attribute("y", i_r2 * (8 + ctx_r2.tickSpacing));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", tickLine_r1, " ");
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_ng_container_1__svg_tspan_1_Template, 2, 2, "tspan", 11);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tickLines_r4 = \u0275\u0275nextContext().ngIf;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", tickLines_r4);
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0__svg_ng_container_1_Template, 2, 1, "ng-container", 10);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tickLines_r4 = ctx.ngIf;
    \u0275\u0275nextContext(2);
    const tmplSinglelineTick_r5 = \u0275\u0275reference(8);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", tickLines_r4.length > 1)("ngIfElse", tmplSinglelineTick_r5);
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5__svg_ng_container_0_Template, 2, 2, "ng-container", 7);
  }
  if (rf & 2) {
    const tick_r6 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r2.tickChunks(tick_r6));
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const tickFormatted_r7 = \u0275\u0275nextContext().ngIf;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate1(" ", ctx_r2.tickTrim(tickFormatted_r7), " ");
  }
}
function YAxisTicksComponent__svg_g_2__svg_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "title");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "text", 8);
    \u0275\u0275template(4, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_container_4_Template, 1, 0, "ng-container", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_5_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(7, YAxisTicksComponent__svg_g_2__svg_ng_container_1__svg_ng_template_7_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const tickFormatted_r7 = ctx.ngIf;
    const tmplMultilineTick_r8 = \u0275\u0275reference(6);
    const tmplSinglelineTick_r5 = \u0275\u0275reference(8);
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(tickFormatted_r7);
    \u0275\u0275advance();
    \u0275\u0275styleProp("font-size", "12px");
    \u0275\u0275attribute("dy", ctx_r2.dy)("x", ctx_r2.x1)("y", ctx_r2.y1)("text-anchor", ctx_r2.textAnchor);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.wrapTicks)("ngIfThen", tmplMultilineTick_r8)("ngIfElse", tmplSinglelineTick_r5);
  }
}
function YAxisTicksComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_2__svg_ng_container_1_Template, 9, 10, "ng-container", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r6 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r2.transform(tick_r6));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.tickFormat(tick_r6));
  }
}
function YAxisTicksComponent__svg_path_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "path", 13);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("d", ctx_r2.referenceAreaPath)("transform", ctx_r2.gridLineTransform());
  }
}
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 15);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275attribute("x2", ctx_r2.gridLineWidth);
  }
}
function YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 15);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275attribute("x2", -ctx_r2.gridLineWidth);
  }
}
function YAxisTicksComponent__svg_g_4__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_1_Template, 1, 1, "line", 14)(2, YAxisTicksComponent__svg_g_4__svg_g_1__svg_line_2_Template, 1, 1, "line", 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r2.gridLineTransform());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.orient === ctx_r2.Orientation.Left);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.orient === ctx_r2.Orientation.Right);
  }
}
function YAxisTicksComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_4__svg_g_1_Template, 3, 3, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r9 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r2.transform(tick_r9));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.showGridLines);
  }
}
function YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "title");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "text", 17);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const refLine_r10 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r2.tickTrim(ctx_r2.tickFormat(refLine_r10.value)));
    \u0275\u0275advance();
    \u0275\u0275attribute("dy", ctx_r2.dy)("y", -6)("x", ctx_r2.gridLineWidth)("text-anchor", ctx_r2.textAnchor);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", refLine_r10.name, " ");
  }
}
function YAxisTicksComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "line", 16);
    \u0275\u0275template(2, YAxisTicksComponent__svg_g_5__svg_g_1__svg_g_2_Template, 5, 6, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const refLine_r10 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r2.transform(refLine_r10.value));
    \u0275\u0275advance();
    \u0275\u0275attribute("x2", ctx_r2.gridLineWidth)("transform", ctx_r2.gridLineTransform());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.showRefLabels);
  }
}
function YAxisTicksComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, YAxisTicksComponent__svg_g_5__svg_g_1_Template, 3, 4, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.showRefLines);
  }
}
var _c82 = ["ngx-charts-y-axis", ""];
function YAxisComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("dimensionsChanged", function YAxisComponent__svg_g_1_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.emitTicksWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("trimTicks", ctx_r1.trimTicks)("maxTickLength", ctx_r1.maxTickLength)("tickFormatting", ctx_r1.tickFormatting)("tickArguments", ctx_r1.tickArguments)("tickValues", ctx_r1.ticks)("tickStroke", ctx_r1.tickStroke)("scale", ctx_r1.yScale)("orient", ctx_r1.yOrient)("showGridLines", ctx_r1.showGridLines)("gridLineWidth", ctx_r1.dims.width)("referenceLines", ctx_r1.referenceLines)("showRefLines", ctx_r1.showRefLines)("showRefLabels", ctx_r1.showRefLabels)("height", ctx_r1.dims.height)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function YAxisComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 3);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("label", ctx_r1.labelText)("offset", ctx_r1.labelOffset)("orient", ctx_r1.yOrient)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
  }
}
var _c92 = ["ngx-charts-circle", ""];
var _c10 = ["ngx-charts-svg-linear-gradient", ""];
function SvgLinearGradientComponent__svg_stop_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "stop");
  }
  if (rf & 2) {
    const stop_r1 = ctx.$implicit;
    \u0275\u0275styleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    \u0275\u0275attribute("offset", stop_r1.offset + "%");
  }
}
var _c11 = ["ngx-charts-circle-series", ""];
var _c122 = (a0) => ({
  name: a0
});
function CircleSeriesComponent__svg_g_0__svg_rect_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect", 4);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("x", ctx_r1.circle.cx - ctx_r1.circle.radius)("y", ctx_r1.circle.cy)("width", ctx_r1.circle.radius * 2)("height", ctx_r1.circle.height)("fill", ctx_r1.gradientFill);
  }
}
function CircleSeriesComponent__svg_g_0__svg_rect_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect", 4);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("x", ctx_r1.circle.cx - ctx_r1.circle.radius)("y", ctx_r1.circle.cy)("width", ctx_r1.circle.radius * 2)("height", ctx_r1.circle.height)("fill", ctx_r1.gradientFill);
  }
}
function CircleSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "defs");
    \u0275\u0275element(2, "g", 1);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, CircleSeriesComponent__svg_g_0__svg_rect_3_Template, 1, 6, "rect", 2)(4, CircleSeriesComponent__svg_g_0__svg_rect_4_Template, 1, 5, "rect", 2);
    \u0275\u0275elementStart(5, "g", 3);
    \u0275\u0275listener("select", function CircleSeriesComponent__svg_g_0_Template_g_select_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick(ctx_r1.circle.data));
    })("activate", function CircleSeriesComponent__svg_g_0_Template_g_activate_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activateCircle());
    })("deactivate", function CircleSeriesComponent__svg_g_0_Template_g_deactivate_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.deactivateCircle());
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("orientation", ctx_r1.barOrientation.Vertical)("name", ctx_r1.gradientId)("stops", ctx_r1.circle.gradientStops);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.isSSR && ctx_r1.barVisible && ctx_r1.type === "standard");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isSSR && ctx_r1.barVisible && ctx_r1.type === "standard");
    \u0275\u0275advance();
    \u0275\u0275classProp("active", ctx_r1.isActive(\u0275\u0275pureFunction1(20, _c122, ctx_r1.circle.seriesName)));
    \u0275\u0275property("cx", ctx_r1.circle.cx)("cy", ctx_r1.circle.cy)("r", ctx_r1.circle.radius)("fill", ctx_r1.circle.color)("pointerEvents", ctx_r1.circle.value === 0 ? "none" : "all")("data", ctx_r1.circle.value)("classNames", ctx_r1.circle.classNames)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.placementTypes.Top)("tooltipType", ctx_r1.styleTypes.tooltip)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : ctx_r1.getTooltipText(ctx_r1.circle))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", ctx_r1.circle.data);
  }
}
var _c132 = ["ngx-charts-grid-panel", ""];
var _c142 = ["ngx-charts-grid-panel-series", ""];
function GridPanelSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 1);
  }
  if (rf & 2) {
    const gridPanel_r1 = ctx.$implicit;
    \u0275\u0275classProp("grid-panel", true)("odd", gridPanel_r1.class === "odd")("even", gridPanel_r1.class === "even");
    \u0275\u0275property("height", gridPanel_r1.height)("width", gridPanel_r1.width)("x", gridPanel_r1.x)("y", gridPanel_r1.y);
  }
}
var _c152 = ["ngx-charts-svg-radial-gradient", ""];
function SvgRadialGradientComponent__svg_stop_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "stop");
  }
  if (rf & 2) {
    const stop_r1 = ctx.$implicit;
    \u0275\u0275styleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    \u0275\u0275attribute("offset", stop_r1.offset + "%");
  }
}
var _c162 = ["ngx-charts-area", ""];
function AreaComponent__svg_defs_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs");
    \u0275\u0275element(1, "g", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("orientation", ctx_r0.barOrientation.Vertical)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
var _c17 = ["ngx-charts-count-up", ""];
var _c18 = ["tooltipAnchor"];
var _c19 = ["ngx-charts-tooltip-area", ""];
function TooltipArea__svg_ng_template_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275element(1, "span", 7);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tooltipItem_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275styleProp("background-color", tooltipItem_r2.color);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r2.getToolTipText(tooltipItem_r2), " ");
  }
}
function TooltipArea__svg_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275template(1, TooltipArea__svg_ng_template_2_div_1_Template, 3, 3, "div", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const model_r4 = ctx.model;
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", model_r4);
  }
}
var _c20 = ["ngx-charts-timeline", ""];
function AdvancedLegendComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 7);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("countTo", ctx_r0.roundedTotal)("valueFormatting", ctx_r0.valueFormatting);
  }
}
function AdvancedLegendComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.valueFormatting ? ctx_r0.valueFormatting(ctx_r0.roundedTotal) : ctx_r0.defaultValueFormatting(ctx_r0.roundedTotal), " ");
  }
}
function AdvancedLegendComponent_div_7_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 16);
  }
  if (rf & 2) {
    const legendItem_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("countTo", legendItem_r3._value)("valueFormatting", ctx_r0.valueFormatting);
  }
}
function AdvancedLegendComponent_div_7_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 17);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const legendItem_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.valueFormatting ? ctx_r0.valueFormatting(legendItem_r3.value) : ctx_r0.defaultValueFormatting(legendItem_r3.value), " ");
  }
}
function AdvancedLegendComponent_div_7_div_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 18);
  }
  if (rf & 2) {
    const legendItem_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("countTo", legendItem_r3.percentage)("countSuffix", "%");
  }
}
function AdvancedLegendComponent_div_7_div_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const legendItem_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("", legendItem_r3.percentage.toLocaleString(), "%");
  }
}
function AdvancedLegendComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275listener("mouseenter", function AdvancedLegendComponent_div_7_Template_div_mouseenter_0_listener() {
      const legendItem_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.activate.emit(legendItem_r3.data));
    })("mouseleave", function AdvancedLegendComponent_div_7_Template_div_mouseleave_0_listener() {
      const legendItem_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.deactivate.emit(legendItem_r3.data));
    })("click", function AdvancedLegendComponent_div_7_Template_div_click_0_listener() {
      const legendItem_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.select.emit(legendItem_r3.data));
    });
    \u0275\u0275element(1, "div", 10);
    \u0275\u0275template(2, AdvancedLegendComponent_div_7_div_2_Template, 1, 2, "div", 11)(3, AdvancedLegendComponent_div_7_div_3_Template, 2, 1, "div", 12);
    \u0275\u0275elementStart(4, "div", 13);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, AdvancedLegendComponent_div_7_div_6_Template, 1, 2, "div", 14)(7, AdvancedLegendComponent_div_7_div_7_Template, 2, 1, "div", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const legendItem_r3 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275styleProp("border-left-color", legendItem_r3.color);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.animations);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.animations);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(legendItem_r3.displayLabel);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.animations);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.animations);
  }
}
var _c21 = ["ngx-charts-area-series", ""];
var _c222 = ["tooltipTemplate"];
var _c232 = ["seriesTooltipTemplate"];
var _c24 = (a0, a1) => [a0, a1];
function AreaChartComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function AreaChartComponent__svg_g_5_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 8);
    \u0275\u0275listener("dimensionsChanged", function AreaChartComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("baseValue", ctx_r1.baseValue)("colors", ctx_r1.colors)("data", series_r4)("activeEntries", ctx_r1.activeEntries)("scaleType", ctx_r1.scaleType)("gradient", ctx_r1.gradient)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartComponent__svg_g_9__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 13);
    \u0275\u0275listener("select", function AreaChartComponent__svg_g_9__svg_g_2_Template_g_select_1_listener($event) {
      const series_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, series_r7));
    })("activate", function AreaChartComponent__svg_g_9__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function AreaChartComponent__svg_g_9__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("activeEntries", ctx_r1.activeEntries)("data", series_r7)("scaleType", ctx_r1.scaleType)("visibleValue", ctx_r1.hoveredVertical)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function AreaChartComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 10);
    \u0275\u0275listener("mouseleave", function AreaChartComponent__svg_g_9_Template_g_mouseleave_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideCircles());
    });
    \u0275\u0275elementStart(1, "g", 11);
    \u0275\u0275listener("hover", function AreaChartComponent__svg_g_9_Template_g_hover_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateHoveredVertical($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, AreaChartComponent__svg_g_9__svg_g_2_Template, 2, 9, "g", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("dims", ctx_r1.dims)("xSet", ctx_r1.xSet)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("results", ctx_r1.results)("colors", ctx_r1.colors)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.seriesTooltipTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results);
  }
}
function AreaChartComponent__svg_g_10__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r9 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.timelineXScale)("yScale", ctx_r1.timelineYScale)("baseValue", ctx_r1.baseValue)("colors", ctx_r1.colors)("data", series_r9)("scaleType", ctx_r1.scaleType)("gradient", ctx_r1.gradient)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartComponent__svg_g_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 14);
    \u0275\u0275listener("onDomainChange", function AreaChartComponent__svg_g_10_Template_g_onDomainChange_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateDomain($event));
    });
    \u0275\u0275template(1, AreaChartComponent__svg_g_10__svg_g_1_Template, 2, 9, "g", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("results", ctx_r1.results)("view", \u0275\u0275pureFunction2(10, _c24, ctx_r1.timelineWidth, ctx_r1.height))("height", ctx_r1.timelineHeight)("scheme", ctx_r1.scheme)("customColors", ctx_r1.customColors)("legend", ctx_r1.legend)("scaleType", ctx_r1.scaleType);
    \u0275\u0275attribute("transform", ctx_r1.timelineTransform);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function AreaChartNormalizedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_5_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartNormalizedComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 8);
    \u0275\u0275listener("dimensionsChanged", function AreaChartNormalizedComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartNormalizedComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r4)("scaleType", ctx_r1.scaleType)("activeEntries", ctx_r1.activeEntries)("gradient", ctx_r1.gradient)("normalized", true)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 13);
    \u0275\u0275listener("select", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template_g_select_1_listener($event) {
      const series_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, series_r7));
    })("activate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.seriesType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("activeEntries", ctx_r1.activeEntries)("data", series_r7)("scaleType", ctx_r1.scaleType)("visibleValue", ctx_r1.hoveredVertical)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function AreaChartNormalizedComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 10);
    \u0275\u0275listener("mouseleave", function AreaChartNormalizedComponent__svg_g_9_Template_g_mouseleave_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideCircles());
    });
    \u0275\u0275elementStart(1, "g", 11);
    \u0275\u0275listener("hover", function AreaChartNormalizedComponent__svg_g_9_Template_g_hover_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateHoveredVertical($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, AreaChartNormalizedComponent__svg_g_9__svg_g_2_Template, 2, 10, "g", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("dims", ctx_r1.dims)("xSet", ctx_r1.xSet)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("results", ctx_r1.results)("colors", ctx_r1.colors)("showPercentage", true)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.seriesTooltipTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results);
  }
}
function AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r9 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.timelineXScale)("yScale", ctx_r1.timelineYScale)("colors", ctx_r1.colors)("data", series_r9)("scaleType", ctx_r1.scaleType)("gradient", ctx_r1.gradient)("normalized", true)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartNormalizedComponent__svg_g_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 14);
    \u0275\u0275listener("onDomainChange", function AreaChartNormalizedComponent__svg_g_10_Template_g_onDomainChange_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateDomain($event));
    });
    \u0275\u0275template(1, AreaChartNormalizedComponent__svg_g_10__svg_g_1_Template, 2, 9, "g", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("results", ctx_r1.results)("view", \u0275\u0275pureFunction2(10, _c24, ctx_r1.timelineWidth, ctx_r1.height))("height", ctx_r1.timelineHeight)("scheme", ctx_r1.scheme)("customColors", ctx_r1.customColors)("legend", ctx_r1.legend)("scaleType", ctx_r1.scaleType);
    \u0275\u0275attribute("transform", ctx_r1.timelineTransform);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c25 = ".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n";
function AreaChartStackedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function AreaChartStackedComponent__svg_g_5_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartStackedComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 8);
    \u0275\u0275listener("dimensionsChanged", function AreaChartStackedComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function AreaChartStackedComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r4)("scaleType", ctx_r1.scaleType)("gradient", ctx_r1.gradient)("activeEntries", ctx_r1.activeEntries)("stacked", true)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartStackedComponent__svg_g_9__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 12);
    \u0275\u0275listener("select", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template_g_select_1_listener($event) {
      const series_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, series_r7));
    })("activate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function AreaChartStackedComponent__svg_g_9__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.seriesType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("activeEntries", ctx_r1.activeEntries)("data", series_r7)("scaleType", ctx_r1.scaleType)("visibleValue", ctx_r1.hoveredVertical)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function AreaChartStackedComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 10);
    \u0275\u0275listener("mouseleave", function AreaChartStackedComponent__svg_g_9_Template_g_mouseleave_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideCircles());
    });
    \u0275\u0275elementStart(1, "g", 11);
    \u0275\u0275listener("hover", function AreaChartStackedComponent__svg_g_9_Template_g_hover_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateHoveredVertical($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, AreaChartStackedComponent__svg_g_9__svg_g_2_Template, 2, 10, "g", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("dims", ctx_r1.dims)("xSet", ctx_r1.xSet)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("results", ctx_r1.results)("colors", ctx_r1.colors)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.seriesTooltipTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function AreaChartStackedComponent__svg_g_10__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r9 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.timelineXScale)("yScale", ctx_r1.timelineYScale)("colors", ctx_r1.colors)("data", series_r9)("scaleType", ctx_r1.scaleType)("gradient", ctx_r1.gradient)("stacked", true)("curve", ctx_r1.curve)("animations", ctx_r1.animations);
  }
}
function AreaChartStackedComponent__svg_g_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 13);
    \u0275\u0275listener("onDomainChange", function AreaChartStackedComponent__svg_g_10_Template_g_onDomainChange_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateDomain($event));
    });
    \u0275\u0275template(1, AreaChartStackedComponent__svg_g_10__svg_g_1_Template, 2, 9, "g", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("results", ctx_r1.results)("view", \u0275\u0275pureFunction2(10, _c24, ctx_r1.timelineWidth, ctx_r1.height))("height", ctx_r1.timelineHeight)("scheme", ctx_r1.scheme)("customColors", ctx_r1.customColors)("legend", ctx_r1.legend)("scaleType", ctx_r1.scaleType);
    \u0275\u0275attribute("transform", ctx_r1.timelineTransform);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c26 = ["ngx-charts-bar", ""];
function BarComponent__svg_defs_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs");
    \u0275\u0275element(1, "g", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("orientation", ctx_r0.orientation)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
var _c27 = ["ngx-charts-bar-label", ""];
var _c28 = ["ngx-charts-series-horizontal", ""];
function SeriesHorizontal__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function SeriesHorizontal__svg_g_0_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.click($event));
    })("activate", function SeriesHorizontal__svg_g_0_Template_g_activate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activate.emit($event));
    })("deactivate", function SeriesHorizontal__svg_g_0_Template_g_deactivate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.deactivate.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const bar_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("@animationState", "active")("width", bar_r3.width)("height", bar_r3.height)("x", bar_r3.x)("y", bar_r3.y)("fill", bar_r3.color)("stops", bar_r3.gradientStops)("data", bar_r3.data)("orientation", ctx_r1.barOrientation.Horizontal)("roundEdges", bar_r3.roundEdges)("gradient", ctx_r1.gradient)("isActive", ctx_r1.isActive(bar_r3.data))("ariaLabel", bar_r3.ariaLabel)("animations", ctx_r1.animations)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.tooltipPlacement)("tooltipType", ctx_r1.tooltipType)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : bar_r3.tooltipText)("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", bar_r3.data)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function SeriesHorizontal__svg_g_1__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 4);
    \u0275\u0275listener("dimensionsChanged", function SeriesHorizontal__svg_g_1__svg_g_1_Template_g_dimensionsChanged_0_listener($event) {
      const i_r5 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.dataLabelWidthChanged.emit({
        size: $event,
        index: i_r5
      }));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const b_r6 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("barX", b_r6.x)("barY", b_r6.y)("barWidth", b_r6.width)("barHeight", b_r6.height)("value", b_r6.total)("valueFormatting", ctx_r1.dataLabelFormatting)("orientation", ctx_r1.barOrientation.Horizontal);
  }
}
function SeriesHorizontal__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, SeriesHorizontal__svg_g_1__svg_g_1_Template, 1, 7, "g", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
  }
}
function BarHorizontalComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontalComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontal2DComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.valueScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontal2DComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontal2DComponent__svg_g_4_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.groupScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontal2DComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 9);
    \u0275\u0275listener("select", function BarHorizontal2DComponent__svg_g_5__svg_g_1_Template_g_select_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarHorizontal2DComponent__svg_g_5__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarHorizontal2DComponent__svg_g_5__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    })("dataLabelWidthChanged", function BarHorizontal2DComponent__svg_g_5__svg_g_1_Template_g_dataLabelWidthChanged_1_listener($event) {
      const index_r6 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxWidthChanged($event, index_r6));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.valueScale)("activeEntries", ctx_r1.activeEntries)("yScale", ctx_r1.innerScale)("colors", ctx_r1.colors)("series", group_r5.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r5.name)("roundEdges", ctx_r1.roundEdges)("animations", ctx_r1.animations)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontal2DComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontal2DComponent__svg_g_5__svg_g_1_Template, 2, 17, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarHorizontal2DComponent__svg_g_6__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 9);
    \u0275\u0275listener("select", function BarHorizontal2DComponent__svg_g_6__svg_g_1_Template_g_select_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r8));
    })("activate", function BarHorizontal2DComponent__svg_g_6__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r8));
    })("deactivate", function BarHorizontal2DComponent__svg_g_6__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r8));
    })("dataLabelWidthChanged", function BarHorizontal2DComponent__svg_g_6__svg_g_1_Template_g_dataLabelWidthChanged_1_listener($event) {
      const index_r9 = \u0275\u0275restoreView(_r7).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxWidthChanged($event, index_r9));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r8));
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.valueScale)("activeEntries", ctx_r1.activeEntries)("yScale", ctx_r1.innerScale)("colors", ctx_r1.colors)("series", group_r8.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r8.name)("roundEdges", ctx_r1.roundEdges)("animations", ctx_r1.animations)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontal2DComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontal2DComponent__svg_g_6__svg_g_1_Template, 2, 16, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarHorizontalNormalizedComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontalNormalizedComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalNormalizedComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontalNormalizedComponent__svg_g_4__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarHorizontalNormalizedComponent__svg_g_4__svg_g_1_Template_g_select_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarHorizontalNormalizedComponent__svg_g_4__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarHorizontalNormalizedComponent__svg_g_4__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Normalized)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r5.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r5.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontalNormalizedComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontalNormalizedComponent__svg_g_4__svg_g_1_Template, 2, 15, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarHorizontalNormalizedComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarHorizontalNormalizedComponent__svg_g_5__svg_g_1_Template_g_select_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r7));
    })("activate", function BarHorizontalNormalizedComponent__svg_g_5__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r7));
    })("deactivate", function BarHorizontalNormalizedComponent__svg_g_5__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r7));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r7));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Normalized)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r7.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontalNormalizedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontalNormalizedComponent__svg_g_5__svg_g_1_Template, 2, 14, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarHorizontalStackedComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontalStackedComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarHorizontalStackedComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("yAxisOffset", ctx_r1.dataLabelMaxWidth.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template_g_select_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    })("dataLabelWidthChanged", function BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template_g_dataLabelWidthChanged_1_listener($event) {
      const index_r6 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxWidthChanged($event, index_r6));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("series", group_r5.series)("activeEntries", ctx_r1.activeEntries)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r5.name)("animations", ctx_r1.animations)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontalStackedComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontalStackedComponent__svg_g_4__svg_g_1_Template, 2, 17, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template_g_select_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r8));
    })("activate", function BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r8));
    })("deactivate", function BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r8));
    })("dataLabelWidthChanged", function BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template_g_dataLabelWidthChanged_1_listener($event) {
      const index_r9 = \u0275\u0275restoreView(_r7).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxWidthChanged($event, index_r9));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r8));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("series", group_r8.series)("activeEntries", ctx_r1.activeEntries)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r8.name)("animations", ctx_r1.animations)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarHorizontalStackedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarHorizontalStackedComponent__svg_g_5__svg_g_1_Template, 2, 16, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c29 = ["ngx-charts-series-vertical", ""];
function SeriesVerticalComponent__svg_g_0__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function SeriesVerticalComponent__svg_g_0__svg_g_1_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function SeriesVerticalComponent__svg_g_0__svg_g_1_Template_g_activate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.activate.emit($event));
    })("deactivate", function SeriesVerticalComponent__svg_g_0__svg_g_1_Template_g_deactivate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.deactivate.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const bar_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active")("@.disabled", !ctx_r1.animations)("width", bar_r3.width)("height", bar_r3.height)("x", bar_r3.x)("y", bar_r3.y)("fill", bar_r3.color)("stops", bar_r3.gradientStops)("data", bar_r3.data)("orientation", ctx_r1.barOrientation.Vertical)("roundEdges", bar_r3.roundEdges)("gradient", ctx_r1.gradient)("ariaLabel", bar_r3.ariaLabel)("isActive", ctx_r1.isActive(bar_r3.data))("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.tooltipPlacement)("tooltipType", ctx_r1.tooltipType)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : bar_r3.tooltipText)("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", bar_r3.data)("noBarWhenZero", ctx_r1.noBarWhenZero)("animations", ctx_r1.animations);
  }
}
function SeriesVerticalComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, SeriesVerticalComponent__svg_g_0__svg_g_1_Template, 1, 22, "g", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.bars)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function SeriesVerticalComponent__svg_g_1__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function SeriesVerticalComponent__svg_g_1__svg_g_1_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function SeriesVerticalComponent__svg_g_1__svg_g_1_Template_g_activate_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.activate.emit($event));
    })("deactivate", function SeriesVerticalComponent__svg_g_1__svg_g_1_Template_g_deactivate_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.deactivate.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const bar_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("width", bar_r5.width)("height", bar_r5.height)("x", bar_r5.x)("y", bar_r5.y)("fill", bar_r5.color)("stops", bar_r5.gradientStops)("data", bar_r5.data)("orientation", ctx_r1.barOrientation.Vertical)("roundEdges", bar_r5.roundEdges)("gradient", ctx_r1.gradient)("ariaLabel", bar_r5.ariaLabel)("isActive", ctx_r1.isActive(bar_r5.data))("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.tooltipPlacement)("tooltipType", ctx_r1.tooltipType)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : bar_r5.tooltipText)("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", bar_r5.data)("noBarWhenZero", ctx_r1.noBarWhenZero)("animations", ctx_r1.animations);
  }
}
function SeriesVerticalComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, SeriesVerticalComponent__svg_g_1__svg_g_1_Template, 1, 20, "g", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.bars)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function SeriesVerticalComponent__svg_g_2__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 4);
    \u0275\u0275listener("dimensionsChanged", function SeriesVerticalComponent__svg_g_2__svg_g_1_Template_g_dimensionsChanged_0_listener($event) {
      const i_r7 = \u0275\u0275restoreView(_r6).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.dataLabelHeightChanged.emit({
        size: $event,
        index: i_r7
      }));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const b_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("barX", b_r8.x)("barY", b_r8.y)("barWidth", b_r8.width)("barHeight", b_r8.height)("value", b_r8.total)("valueFormatting", ctx_r1.dataLabelFormatting)("orientation", ctx_r1.barOrientation.Vertical);
  }
}
function SeriesVerticalComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, SeriesVerticalComponent__svg_g_2__svg_g_1_Template, 1, 7, "g", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.barsForDataLabels)("ngForTrackBy", ctx_r1.trackDataLabelBy);
  }
}
function BarVerticalComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("xAxisOffset", ctx_r1.dataLabelMaxHeight.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVerticalComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVertical2DComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarVertical2DComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.groupScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("xAxisOffset", ctx_r1.dataLabelMaxHeight.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVertical2DComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function BarVertical2DComponent__svg_g_4_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.valueScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVertical2DComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 9);
    \u0275\u0275listener("select", function BarVertical2DComponent__svg_g_5__svg_g_1_Template_g_select_0_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarVertical2DComponent__svg_g_5__svg_g_1_Template_g_activate_0_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarVertical2DComponent__svg_g_5__svg_g_1_Template_g_deactivate_0_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    })("dataLabelHeightChanged", function BarVertical2DComponent__svg_g_5__svg_g_1_Template_g_dataLabelHeightChanged_0_listener($event) {
      const index_r6 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxHeightChanged($event, index_r6));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active")("activeEntries", ctx_r1.activeEntries)("xScale", ctx_r1.innerScale)("yScale", ctx_r1.valueScale)("colors", ctx_r1.colors)("series", group_r5.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("seriesName", group_r5.name)("roundEdges", ctx_r1.roundEdges)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
  }
}
function BarVertical2DComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVertical2DComponent__svg_g_5__svg_g_1_Template, 1, 17, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarVertical2DComponent__svg_g_6__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 9);
    \u0275\u0275listener("select", function BarVertical2DComponent__svg_g_6__svg_g_1_Template_g_select_0_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r8));
    })("activate", function BarVertical2DComponent__svg_g_6__svg_g_1_Template_g_activate_0_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r8));
    })("deactivate", function BarVertical2DComponent__svg_g_6__svg_g_1_Template_g_deactivate_0_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r8));
    })("dataLabelHeightChanged", function BarVertical2DComponent__svg_g_6__svg_g_1_Template_g_dataLabelHeightChanged_0_listener($event) {
      const index_r9 = \u0275\u0275restoreView(_r7).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxHeightChanged($event, index_r9));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("activeEntries", ctx_r1.activeEntries)("xScale", ctx_r1.innerScale)("yScale", ctx_r1.valueScale)("colors", ctx_r1.colors)("series", group_r8.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("seriesName", group_r8.name)("roundEdges", ctx_r1.roundEdges)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r8));
  }
}
function BarVertical2DComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVertical2DComponent__svg_g_6__svg_g_1_Template, 1, 16, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarVerticalNormalizedComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVerticalNormalizedComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalNormalizedComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVerticalNormalizedComponent__svg_g_4__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarVerticalNormalizedComponent__svg_g_4__svg_g_1_Template_g_select_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarVerticalNormalizedComponent__svg_g_4__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarVerticalNormalizedComponent__svg_g_4__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Normalized)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r5.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r5.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarVerticalNormalizedComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVerticalNormalizedComponent__svg_g_4__svg_g_1_Template, 2, 15, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarVerticalNormalizedComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarVerticalNormalizedComponent__svg_g_5__svg_g_1_Template_g_select_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r7));
    })("activate", function BarVerticalNormalizedComponent__svg_g_5__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r7));
    })("deactivate", function BarVerticalNormalizedComponent__svg_g_5__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r7));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r7));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Normalized)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r7.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("seriesName", group_r7.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarVerticalNormalizedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVerticalNormalizedComponent__svg_g_5__svg_g_1_Template, 2, 14, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarVerticalStackedComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("xAxisOffset", ctx_r1.dataLabelMaxHeight.negative)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVerticalStackedComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BarVerticalStackedComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BarVerticalStackedComponent__svg_g_4__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarVerticalStackedComponent__svg_g_4__svg_g_1_Template_g_select_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r5));
    })("activate", function BarVerticalStackedComponent__svg_g_4__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r5));
    })("deactivate", function BarVerticalStackedComponent__svg_g_4__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r5));
    })("dataLabelHeightChanged", function BarVerticalStackedComponent__svg_g_4__svg_g_1_Template_g_dataLabelHeightChanged_1_listener($event) {
      const index_r6 = \u0275\u0275restoreView(_r4).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxHeightChanged($event, index_r6));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r5));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r5.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("seriesName", group_r5.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarVerticalStackedComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVerticalStackedComponent__svg_g_4__svg_g_1_Template, 2, 17, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BarVerticalStackedComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 8);
    \u0275\u0275listener("select", function BarVerticalStackedComponent__svg_g_5__svg_g_1_Template_g_select_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, group_r8));
    })("activate", function BarVerticalStackedComponent__svg_g_5__svg_g_1_Template_g_activate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event, group_r8));
    })("deactivate", function BarVerticalStackedComponent__svg_g_5__svg_g_1_Template_g_deactivate_1_listener($event) {
      const group_r8 = \u0275\u0275restoreView(_r7).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event, group_r8));
    })("dataLabelHeightChanged", function BarVerticalStackedComponent__svg_g_5__svg_g_1_Template_g_dataLabelHeightChanged_1_listener($event) {
      const index_r9 = \u0275\u0275restoreView(_r7).index;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDataLabelMaxHeightChanged($event, index_r9));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("transform", ctx_r1.groupTransform(group_r8));
    \u0275\u0275advance();
    \u0275\u0275property("type", ctx_r1.barChartType.Stacked)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("activeEntries", ctx_r1.activeEntries)("colors", ctx_r1.colors)("series", group_r8.series)("dims", ctx_r1.dims)("gradient", ctx_r1.gradient)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("showDataLabel", ctx_r1.showDataLabel)("dataLabelFormatting", ctx_r1.dataLabelFormatting)("seriesName", group_r8.name)("animations", ctx_r1.animations)("noBarWhenZero", ctx_r1.noBarWhenZero);
  }
}
function BarVerticalStackedComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BarVerticalStackedComponent__svg_g_5__svg_g_1_Template, 2, 16, "g", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c30 = ["ngx-charts-box", ""];
function BoxComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 5);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("orientation", ctx_r0.BarOrientation.Vertical)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
function BoxComponent__svg_line_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 6);
  }
  if (rf & 2) {
    const line_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("hidden", ctx_r0.hideBar);
    \u0275\u0275attribute("x1", line_r2.v1.x)("y1", line_r2.v1.y)("x2", line_r2.v2.x)("y2", line_r2.v2.y)("stroke", ctx_r0.strokeColor)("stroke-width", i_r3 === 2 ? ctx_r0.medianLineWidth : ctx_r0.whiskerStrokeWidth)("mask", i_r3 ? void 0 : ctx_r0.maskLine);
  }
}
var _c31 = ["ngx-charts-box-series", ""];
function BoxChartComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 5);
    \u0275\u0275listener("activate", function BoxChartComponent__svg_g_5_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function BoxChartComponent__svg_g_5_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    })("select", function BoxChartComponent__svg_g_5_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const result_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("roundEdges", ctx_r1.roundEdges)("strokeColor", ctx_r1.strokeColor)("strokeWidth", ctx_r1.strokeWidth)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("series", result_r3)("dims", ctx_r1.dims)("animations", ctx_r1.animations)("gradient", ctx_r1.gradient);
  }
}
var _c322 = ["ngx-charts-bubble-series", ""];
function BubbleSeriesComponent__svg_g_0__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function BubbleSeriesComponent__svg_g_0__svg_g_2_Template_g_select_0_listener() {
      \u0275\u0275restoreView(_r1);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClick(circle_r2.data));
    })("activate", function BubbleSeriesComponent__svg_g_0__svg_g_2_Template_g_activate_0_listener() {
      \u0275\u0275restoreView(_r1);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activateCircle(circle_r2));
    })("deactivate", function BubbleSeriesComponent__svg_g_0__svg_g_2_Template_g_deactivate_0_listener() {
      \u0275\u0275restoreView(_r1);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.deactivateCircle(circle_r2));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const circle_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("opacity", circle_r2.opacity);
    \u0275\u0275classProp("active", circle_r2.isActive);
    \u0275\u0275property("@animationState", "active")("cx", 0)("cy", 0)("r", circle_r2.radius)("fill", circle_r2.color)("pointerEvents", "all")("data", circle_r2.value)("classNames", circle_r2.classNames)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipPlacement", ctx_r2.placementTypes.Top)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipTitle", ctx_r2.tooltipTemplate ? void 0 : ctx_r2.getTooltipText(circle_r2))("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", circle_r2.data);
  }
}
function BubbleSeriesComponent__svg_g_0__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function BubbleSeriesComponent__svg_g_0__svg_g_3_Template_g_select_0_listener() {
      \u0275\u0275restoreView(_r4);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClick(circle_r2.data));
    })("activate", function BubbleSeriesComponent__svg_g_0__svg_g_3_Template_g_activate_0_listener() {
      \u0275\u0275restoreView(_r4);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activateCircle(circle_r2));
    })("deactivate", function BubbleSeriesComponent__svg_g_0__svg_g_3_Template_g_deactivate_0_listener() {
      \u0275\u0275restoreView(_r4);
      const circle_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.deactivateCircle(circle_r2));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const circle_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("opacity", circle_r2.opacity);
    \u0275\u0275classProp("active", circle_r2.isActive);
    \u0275\u0275property("cx", 0)("cy", 0)("r", circle_r2.radius)("fill", circle_r2.color)("pointerEvents", "all")("data", circle_r2.value)("classNames", circle_r2.classNames)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipPlacement", ctx_r2.placementTypes.Top)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipTitle", ctx_r2.tooltipTemplate ? void 0 : ctx_r2.getTooltipText(circle_r2))("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", circle_r2.data);
  }
}
function BubbleSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g");
    \u0275\u0275template(2, BubbleSeriesComponent__svg_g_0__svg_g_2_Template, 1, 18, "g", 1)(3, BubbleSeriesComponent__svg_g_0__svg_g_3_Template, 1, 17, "g", 1);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const circle_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("transform", circle_r2.transform);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r2.isSSR);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.isSSR);
  }
}
function BubbleChartComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function BubbleChartComponent__svg_g_5_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("showGridLines", ctx_r1.showGridLines)("dims", ctx_r1.dims)("xScale", ctx_r1.xScale)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BubbleChartComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function BubbleChartComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("showGridLines", ctx_r1.showGridLines)("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function BubbleChartComponent__svg_g_8__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 9);
    \u0275\u0275listener("select", function BubbleChartComponent__svg_g_8__svg_g_1_Template_g_select_1_listener($event) {
      const series_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, series_r5));
    })("activate", function BubbleChartComponent__svg_g_8__svg_g_1_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function BubbleChartComponent__svg_g_8__svg_g_1_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("rScale", ctx_r1.rScale)("xScaleType", ctx_r1.xScaleType)("yScaleType", ctx_r1.yScaleType)("xAxisLabel", ctx_r1.xAxisLabel)("yAxisLabel", ctx_r1.yAxisLabel)("colors", ctx_r1.colors)("data", series_r5)("activeEntries", ctx_r1.activeEntries)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function BubbleChartComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BubbleChartComponent__svg_g_8__svg_g_1_Template, 2, 13, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("clip-path", ctx_r1.clipPath);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.data)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function BubbleChartComponent__svg_g_9__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 9);
    \u0275\u0275listener("select", function BubbleChartComponent__svg_g_9__svg_g_1_Template_g_select_1_listener($event) {
      const series_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event, series_r7));
    })("activate", function BubbleChartComponent__svg_g_9__svg_g_1_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function BubbleChartComponent__svg_g_9__svg_g_1_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("rScale", ctx_r1.rScale)("xScaleType", ctx_r1.xScaleType)("yScaleType", ctx_r1.yScaleType)("xAxisLabel", ctx_r1.xAxisLabel)("yAxisLabel", ctx_r1.yAxisLabel)("colors", ctx_r1.colors)("data", series_r7)("activeEntries", ctx_r1.activeEntries)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function BubbleChartComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, BubbleChartComponent__svg_g_9__svg_g_1_Template, 2, 12, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("clip-path", ctx_r1.clipPath);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.data)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c332 = ["ngx-charts-heat-map-cell", ""];
function HeatMapCellComponent__svg_defs_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs");
    \u0275\u0275element(1, "g", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("orientation", ctx_r0.barOrientation.Vertical)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
var _c34 = ["ngx-charts-heat-map-cell-series", ""];
var _c35 = (a0, a1, a2) => ({
  series: a0,
  name: a1,
  value: a2
});
function HeatCellSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 1);
    \u0275\u0275listener("select", function HeatCellSeriesComponent__svg_g_0_Template_g_select_0_listener() {
      const c_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClick(c_r2.cell));
    })("activate", function HeatCellSeriesComponent__svg_g_0_Template_g_activate_0_listener() {
      const c_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activate.emit(c_r2.cell));
    })("deactivate", function HeatCellSeriesComponent__svg_g_0_Template_g_deactivate_0_listener() {
      const c_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.deactivate.emit(c_r2.cell));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const c_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("x", c_r2.x)("y", c_r2.y)("width", c_r2.width)("height", c_r2.height)("fill", c_r2.fill)("data", c_r2.data)("gradient", ctx_r2.gradient)("animations", ctx_r2.animations)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipPlacement", ctx_r2.placementTypes.Top)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipTitle", ctx_r2.tooltipTemplate ? void 0 : ctx_r2.tooltipText(c_r2))("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", \u0275\u0275pureFunction3(14, _c35, c_r2.series, c_r2.label, c_r2.data));
  }
}
function HeatMapComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 6);
    \u0275\u0275listener("dimensionsChanged", function HeatMapComponent__svg_g_2_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function HeatMapComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function HeatMapComponent__svg_g_3_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function HeatMapComponent__svg_rect_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect");
  }
  if (rf & 2) {
    const rect_r4 = ctx.$implicit;
    \u0275\u0275attribute("x", rect_r4.x)("y", rect_r4.y)("rx", rect_r4.rx)("width", rect_r4.width)("height", rect_r4.height)("fill", rect_r4.fill);
  }
}
var _c36 = ["ngx-charts-line", ""];
function LineComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "path", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275attribute("d", ctx_r0.initialPath)("fill", ctx_r0.fill)("stroke", ctx_r0.stroke);
  }
}
function LineComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "path", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("d", ctx_r0.initialPath)("fill", ctx_r0.fill)("stroke", ctx_r0.stroke);
  }
}
var _c37 = ["ngx-charts-line-series", ""];
function LineSeriesComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("orientation", ctx_r0.barOrientation.Vertical)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
function LineSeriesComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 5);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("active", ctx_r0.isActive(ctx_r0.data))("inactive", ctx_r0.isInactive(ctx_r0.data));
    \u0275\u0275property("data", ctx_r0.data)("path", ctx_r0.outerPath)("fill", ctx_r0.hasGradient ? ctx_r0.gradientUrl : ctx_r0.colors.getColor(ctx_r0.data.name))("opacity", ctx_r0.rangeFillOpacity)("animations", ctx_r0.animations);
  }
}
function LineChartComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 7);
    \u0275\u0275listener("dimensionsChanged", function LineChartComponent__svg_g_5_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateXAxisHeight($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("xScale", ctx_r1.xScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showXAxisLabel)("labelText", ctx_r1.xAxisLabel)("trimTicks", ctx_r1.trimXAxisTicks)("rotateTicks", ctx_r1.rotateXAxisTicks)("maxTickLength", ctx_r1.maxXAxisTickLength)("tickFormatting", ctx_r1.xAxisTickFormatting)("ticks", ctx_r1.xAxisTicks)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function LineChartComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 8);
    \u0275\u0275listener("dimensionsChanged", function LineChartComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yScale)("dims", ctx_r1.dims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("ticks", ctx_r1.yAxisTicks)("referenceLines", ctx_r1.referenceLines)("showRefLines", ctx_r1.showRefLines)("showRefLabels", ctx_r1.showRefLabels)("wrapTicks", ctx_r1.wrapTicks);
  }
}
function LineChartComponent__svg_g_8__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r4)("activeEntries", ctx_r1.activeEntries)("scaleType", ctx_r1.scaleType)("curve", ctx_r1.curve)("rangeFillOpacity", ctx_r1.rangeFillOpacity)("hasRange", ctx_r1.hasRange)("animations", ctx_r1.animations);
  }
}
function LineChartComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, LineChartComponent__svg_g_8__svg_g_1_Template, 2, 11, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function LineChartComponent__svg_g_9__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r5)("activeEntries", ctx_r1.activeEntries)("scaleType", ctx_r1.scaleType)("curve", ctx_r1.curve)("rangeFillOpacity", ctx_r1.rangeFillOpacity)("hasRange", ctx_r1.hasRange)("animations", ctx_r1.animations);
  }
}
function LineChartComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, LineChartComponent__svg_g_9__svg_g_1_Template, 2, 10, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function LineChartComponent__svg_g_10__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 14);
    \u0275\u0275listener("select", function LineChartComponent__svg_g_10__svg_g_2_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function LineChartComponent__svg_g_10__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function LineChartComponent__svg_g_10__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r8)("scaleType", ctx_r1.scaleType)("visibleValue", ctx_r1.hoveredVertical)("activeEntries", ctx_r1.activeEntries)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function LineChartComponent__svg_g_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 11);
    \u0275\u0275listener("mouseleave", function LineChartComponent__svg_g_10_Template_g_mouseleave_0_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.hideCircles());
    });
    \u0275\u0275elementStart(1, "g", 12);
    \u0275\u0275listener("hover", function LineChartComponent__svg_g_10_Template_g_hover_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateHoveredVertical($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, LineChartComponent__svg_g_10__svg_g_2_Template, 2, 9, "g", 13);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("dims", ctx_r1.dims)("xSet", ctx_r1.xSet)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("results", ctx_r1.results)("colors", ctx_r1.colors)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.seriesTooltipTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results);
  }
}
function LineChartComponent__svg_g_11__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275element(1, "g", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r10 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("xScale", ctx_r1.timelineXScale)("yScale", ctx_r1.timelineYScale)("colors", ctx_r1.colors)("data", series_r10)("scaleType", ctx_r1.scaleType)("curve", ctx_r1.curve)("hasRange", ctx_r1.hasRange)("animations", ctx_r1.animations);
  }
}
function LineChartComponent__svg_g_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 15);
    \u0275\u0275listener("onDomainChange", function LineChartComponent__svg_g_11_Template_g_onDomainChange_0_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateDomain($event));
    });
    \u0275\u0275template(1, LineChartComponent__svg_g_11__svg_g_1_Template, 2, 8, "g", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("results", ctx_r1.results)("view", \u0275\u0275pureFunction2(10, _c24, ctx_r1.timelineWidth, ctx_r1.height))("height", ctx_r1.timelineHeight)("scheme", ctx_r1.scheme)("customColors", ctx_r1.customColors)("scaleType", ctx_r1.scaleType)("legend", ctx_r1.legend);
    \u0275\u0275attribute("transform", ctx_r1.timelineTransform);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c38 = ["ngx-charts-pie-label", ""];
var _c39 = ["ngx-charts-polar-series", ""];
function PolarSeriesComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("color", ctx_r0.seriesColor)("name", ctx_r0.gradientId)("startOpacity", 0.25)("endOpacity", 1)("stops", ctx_r0.gradientStops);
  }
}
function PolarSeriesComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5);
    \u0275\u0275listener("select", function PolarSeriesComponent__svg_g_4_Template_g_select_0_listener() {
      const circle_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.select.emit(circle_r3.data));
    })("activate", function PolarSeriesComponent__svg_g_4_Template_g_activate_0_listener() {
      const circle_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.activate.emit({
        name: circle_r3.data.series
      }));
    })("deactivate", function PolarSeriesComponent__svg_g_4_Template_g_deactivate_0_listener() {
      const circle_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.deactivate.emit({
        name: circle_r3.data.series
      }));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const circle_r3 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("opacity", ctx_r0.inactive ? 0.2 : 1);
    \u0275\u0275property("cx", circle_r3.cx)("cy", circle_r3.cy)("r", ctx_r0.circleRadius)("fill", circle_r3.color)("tooltipDisabled", ctx_r0.tooltipDisabled)("tooltipPlacement", ctx_r0.placementTypes.Top)("tooltipType", ctx_r0.styleTypes.tooltip)("tooltipTitle", ctx_r0.tooltipTemplate ? void 0 : ctx_r0.tooltipText(circle_r3))("tooltipTemplate", ctx_r0.tooltipTemplate)("tooltipContext", circle_r3.data);
  }
}
function PolarChartComponent__svg_g_4__svg_circle_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "circle", 7);
  }
  if (rf & 2) {
    const r_r1 = ctx.$implicit;
    \u0275\u0275attribute("r", r_r1);
  }
}
function PolarChartComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, PolarChartComponent__svg_g_4__svg_circle_1_Template, 1, 1, "circle", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.radiusTicks);
  }
}
function PolarChartComponent__svg_g_5__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 9);
  }
  if (rf & 2) {
    const tick_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("data", tick_r3)("radius", ctx_r1.outerRadius)("label", tick_r3.label)("max", ctx_r1.outerRadius)("value", ctx_r1.showGridLines ? 1 : ctx_r1.outerRadius)("explodeSlices", true)("animations", ctx_r1.animations)("labelTrim", ctx_r1.labelTrim)("labelTrimSize", ctx_r1.labelTrimSize);
  }
}
function PolarChartComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, PolarChartComponent__svg_g_5__svg_g_1_Template, 1, 9, "g", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.thetaTicks);
  }
}
function PolarChartComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 10);
    \u0275\u0275listener("dimensionsChanged", function PolarChartComponent__svg_g_6_Template_g_dimensionsChanged_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateYAxisWidth($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("yScale", ctx_r1.yAxisScale)("dims", ctx_r1.yAxisDims)("showGridLines", ctx_r1.showGridLines)("showLabel", ctx_r1.showYAxisLabel)("labelText", ctx_r1.yAxisLabel)("trimTicks", ctx_r1.trimYAxisTicks)("maxTickLength", ctx_r1.maxYAxisTickLength)("tickFormatting", ctx_r1.yAxisTickFormatting)("wrapTicks", ctx_r1.wrapTicks);
    \u0275\u0275attribute("transform", ctx_r1.transformYAxis);
  }
}
function PolarChartComponent__svg_g_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 11);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("label", ctx_r1.xAxisLabel)("offset", ctx_r1.labelOffset)("orient", ctx_r1.orientation.Bottom)("height", ctx_r1.dims.height)("width", ctx_r1.dims.width);
  }
}
function PolarChartComponent__svg_g_8__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 13);
    \u0275\u0275listener("select", function PolarChartComponent__svg_g_8__svg_g_1_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function PolarChartComponent__svg_g_8__svg_g_1_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function PolarChartComponent__svg_g_8__svg_g_1_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r6 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("@animationState", "active");
    \u0275\u0275advance();
    \u0275\u0275property("gradient", ctx_r1.gradient)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r6)("activeEntries", ctx_r1.activeEntries)("scaleType", ctx_r1.scaleType)("curve", ctx_r1.curve)("rangeFillOpacity", ctx_r1.rangeFillOpacity)("animations", ctx_r1.animations)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function PolarChartComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, PolarChartComponent__svg_g_8__svg_g_1_Template, 2, 13, "g", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.transformPlot);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
function PolarChartComponent__svg_g_9__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 13);
    \u0275\u0275listener("select", function PolarChartComponent__svg_g_9__svg_g_1_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function PolarChartComponent__svg_g_9__svg_g_1_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function PolarChartComponent__svg_g_9__svg_g_1_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const series_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("gradient", ctx_r1.gradient)("xScale", ctx_r1.xScale)("yScale", ctx_r1.yScale)("colors", ctx_r1.colors)("data", series_r8)("activeEntries", ctx_r1.activeEntries)("scaleType", ctx_r1.scaleType)("curve", ctx_r1.curve)("rangeFillOpacity", ctx_r1.rangeFillOpacity)("animations", ctx_r1.animations)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate);
  }
}
function PolarChartComponent__svg_g_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, PolarChartComponent__svg_g_9__svg_g_1_Template, 2, 12, "g", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.transformPlot);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.results)("ngForTrackBy", ctx_r1.trackBy);
  }
}
var _c40 = ["ngx-charts-pie-arc", ""];
function PieArcComponent__svg_defs_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs");
    \u0275\u0275element(1, "g", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("color", ctx_r0.fill)("name", ctx_r0.radialGradientId)("startOpacity", ctx_r0.startOpacity);
  }
}
var _c41 = ["ngx-charts-pie-series", ""];
function PieSeriesComponent__svg_g_0__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 3);
  }
  if (rf & 2) {
    const arc_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("data", arc_r2)("radius", ctx_r2.outerRadius)("color", ctx_r2.color(arc_r2))("label", ctx_r2.labelText(arc_r2))("labelTrim", ctx_r2.trimLabels)("labelTrimSize", ctx_r2.maxLabelLength)("max", ctx_r2.max)("value", arc_r2.value)("explodeSlices", ctx_r2.explodeSlices)("animations", ctx_r2.animations);
  }
}
function PieSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, PieSeriesComponent__svg_g_0__svg_g_1_Template, 1, 10, "g", 1);
    \u0275\u0275elementStart(2, "g", 2);
    \u0275\u0275listener("select", function PieSeriesComponent__svg_g_0_Template_g_select_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClick($event));
    })("activate", function PieSeriesComponent__svg_g_0_Template_g_activate_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activate.emit($event));
    })("deactivate", function PieSeriesComponent__svg_g_0_Template_g_deactivate_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.deactivate.emit($event));
    })("dblclick", function PieSeriesComponent__svg_g_0_Template_g_dblclick_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.dblclick.emit($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const arc_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.labelVisible(arc_r2));
    \u0275\u0275advance();
    \u0275\u0275property("startAngle", arc_r2.startAngle)("endAngle", arc_r2.endAngle)("innerRadius", ctx_r2.innerRadius)("outerRadius", ctx_r2.outerRadius)("fill", ctx_r2.color(arc_r2))("value", arc_r2.data.value)("gradient", ctx_r2.gradient)("data", arc_r2.data)("max", ctx_r2.max)("explodeSlices", ctx_r2.explodeSlices)("isActive", ctx_r2.isActive(arc_r2.data))("animate", ctx_r2.animations)("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipPlacement", ctx_r2.placementTypes.Top)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipTitle", ctx_r2.getTooltipTitle(arc_r2))("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", arc_r2.data);
  }
}
var _c422 = ".pie-label{font-size:11px}.pie-label.animation{animation:.75s ease-in fadeIn}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d .75s}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}\n";
var _c43 = ["ngx-charts-pie-grid-series", ""];
function PieGridSeriesComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275listener("select", function PieGridSeriesComponent__svg_g_1_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function PieGridSeriesComponent__svg_g_1_Template_g_activate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.activate.emit($event));
    })("deactivate", function PieGridSeriesComponent__svg_g_1_Template_g_deactivate_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.deactivate.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const arc_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("startAngle", arc_r3.startAngle)("endAngle", arc_r3.endAngle)("innerRadius", ctx_r1.innerRadius)("outerRadius", ctx_r1.outerRadius)("fill", ctx_r1.color(arc_r3))("value", arc_r3.data.value)("data", arc_r3.data)("gradient", false)("pointerEvents", arc_r3.pointerEvents)("animate", arc_r3.animate);
    \u0275\u0275attribute("class", arc_r3.class);
  }
}
var _c44 = (a0) => ({
  data: a0
});
function PieGridComponent__svg_g_2__svg_text_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "text", 10);
  }
  if (rf & 2) {
    const series_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("countTo", series_r3.percent)("countSuffix", "%");
  }
}
function PieGridComponent__svg_g_2__svg_text_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 11);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", series_r3.percent.toLocaleString(), " ");
  }
}
function PieGridComponent__svg_g_2__svg_text_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "text", 12);
  }
  if (rf & 2) {
    const series_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("countTo", series_r3.total)("countPrefix", ctx_r1.label + ": ");
    \u0275\u0275attribute("y", series_r3.outerRadius);
  }
}
function PieGridComponent__svg_g_2__svg_text_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 13);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("y", series_r3.outerRadius);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate2(" ", ctx_r1.label, ": ", series_r3.total.toLocaleString(), " ");
  }
}
function PieGridComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 3)(1, "g", 4);
    \u0275\u0275listener("select", function PieGridComponent__svg_g_2_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function PieGridComponent__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function PieGridComponent__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(2, PieGridComponent__svg_g_2__svg_text_2_Template, 1, 2, "text", 5)(3, PieGridComponent__svg_g_2__svg_text_3_Template, 2, 1, "text", 6);
    \u0275\u0275elementStart(4, "text", 7);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, PieGridComponent__svg_g_2__svg_text_6_Template, 1, 3, "text", 8)(7, PieGridComponent__svg_g_2__svg_text_7_Template, 2, 3, "text", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const series_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", series_r3.transform);
    \u0275\u0275advance();
    \u0275\u0275property("colors", series_r3.colors)("data", series_r3.data)("innerRadius", series_r3.innerRadius)("outerRadius", series_r3.outerRadius)("animations", ctx_r1.animations)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.placementTypes.Top)("tooltipType", ctx_r1.styleTypes.tooltip)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : ctx_r1.tooltipText(\u0275\u0275pureFunction1(17, _c44, series_r3)))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", series_r3.data[0].data);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.animations);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.animations);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", series_r3.label, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.animations);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.animations);
  }
}
var _c45 = ["textEl"];
var _c46 = ["ngx-charts-card", ""];
function CardComponent__svg_path_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "path", 7);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("fill", ctx_r1.bandColor)("transform", ctx_r1.transformBand)("d", ctx_r1.bandPath);
  }
}
var _c47 = ["ngx-charts-card-series", ""];
function CardSeriesComponent__svg_rect_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect", 2);
  }
  if (rf & 2) {
    const c_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("fill", ctx_r1.emptyColor);
    \u0275\u0275attribute("x", c_r1.x)("y", c_r1.y)("width", c_r1.width)("height", c_r1.height);
  }
}
function CardSeriesComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 3);
    \u0275\u0275listener("select", function CardSeriesComponent__svg_g_1_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const c_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("x", c_r4.x)("y", c_r4.y)("width", c_r4.width)("height", c_r4.height)("color", c_r4.color)("bandColor", c_r4.bandColor)("textColor", c_r4.textColor)("data", c_r4.data)("label", c_r4.label)("medianSize", ctx_r1.medianSize)("valueFormatting", ctx_r1.valueFormatting)("labelFormatting", ctx_r1.labelFormatting)("animations", ctx_r1.animations);
  }
}
var _c48 = ["ngx-charts-tree-map-cell", ""];
function TreeMapCellComponent__svg_defs_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "defs");
    \u0275\u0275element(1, "g", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("orientation", ctx_r0.orientation.Vertical)("name", ctx_r0.gradientId)("stops", ctx_r0.gradientStops);
  }
}
function TreeMapCellComponent__svg_foreignObject_3_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("countTo", ctx_r0.value)("valueFormatting", ctx_r0.valueFormatting);
  }
}
function TreeMapCellComponent__svg_foreignObject_3_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 9);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.formattedValue, " ");
  }
}
function TreeMapCellComponent__svg_foreignObject_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "foreignObject", 4);
    \u0275\u0275namespaceHTML();
    \u0275\u0275elementStart(1, "p");
    \u0275\u0275element(2, "span", 5)(3, "br");
    \u0275\u0275template(4, TreeMapCellComponent__svg_foreignObject_3_span_4_Template, 1, 2, "span", 6)(5, TreeMapCellComponent__svg_foreignObject_3_span_5_Template, 2, 1, "span", 7);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("pointer-events", "none");
    \u0275\u0275attribute("x", ctx_r0.x)("y", ctx_r0.y)("width", ctx_r0.width)("height", ctx_r0.height);
    \u0275\u0275advance();
    \u0275\u0275styleProp("color", ctx_r0.getTextColor())("height", ctx_r0.height + "px")("width", ctx_r0.width + "px");
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", ctx_r0.formattedLabel, \u0275\u0275sanitizeHtml);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.animations);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.animations);
  }
}
var _c49 = ["ngx-charts-tree-map-cell-series", ""];
function TreeMapCellSeriesComponent__svg_g_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 1);
    \u0275\u0275listener("select", function TreeMapCellSeriesComponent__svg_g_0_Template_g_select_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const c_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("data", c_r3.data)("x", c_r3.x)("y", c_r3.y)("width", c_r3.width)("height", c_r3.height)("fill", c_r3.fill)("label", c_r3.label)("value", c_r3.value)("valueFormatting", ctx_r1.valueFormatting)("labelFormatting", ctx_r1.labelFormatting)("gradient", ctx_r1.gradient)("animations", ctx_r1.animations)("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipPlacement", ctx_r1.placementTypes.Top)("tooltipType", ctx_r1.styleTypes.tooltip)("tooltipTitle", ctx_r1.tooltipTemplate ? void 0 : ctx_r1.getTooltipText(c_r3))("tooltipTemplate", ctx_r1.tooltipTemplate)("tooltipContext", c_r3.data);
  }
}
var _c50 = ["valueTextEl"];
var _c51 = ["unitsTextEl"];
var _c522 = () => ({});
function LinearGaugeComponent__svg_line_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 10);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.transformLine)("stroke", ctx_r1.colors.getColor(ctx_r1.units));
  }
}
function LinearGaugeComponent__svg_line_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 11);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.transformLine)("stroke", ctx_r1.colors.getColor(ctx_r1.units));
  }
}
var _c53 = ["ngx-charts-gauge-arc", ""];
var _c54 = ["ngx-charts-gauge-axis", ""];
function GaugeAxisComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2);
    \u0275\u0275element(1, "path");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r1 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275attribute("d", tick_r1.line);
  }
}
function GaugeAxisComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 2)(1, "text", 3);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const tick_r2 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275styleProp("text-anchor", tick_r2.textAnchor);
    \u0275\u0275attribute("transform", tick_r2.textTransform);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", tick_r2.text, " ");
  }
}
function GaugeAxisComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 4);
    \u0275\u0275element(1, "path");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r3 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275attribute("d", tick_r3.line);
  }
}
function GaugeComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g")(1, "g", 6);
    \u0275\u0275listener("select", function GaugeComponent__svg_g_2_Template_g_select_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onClick($event));
    })("activate", function GaugeComponent__svg_g_2_Template_g_activate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onActivate($event));
    })("deactivate", function GaugeComponent__svg_g_2_Template_g_deactivate_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDeactivate($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const arc_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", ctx_r1.rotation);
    \u0275\u0275advance();
    \u0275\u0275property("backgroundArc", arc_r3.backgroundArc)("valueArc", arc_r3.valueArc)("cornerRadius", ctx_r1.cornerRadius)("colors", ctx_r1.colors)("isActive", ctx_r1.isActive(arc_r3.valueArc.data))("tooltipDisabled", ctx_r1.tooltipDisabled)("tooltipTemplate", ctx_r1.tooltipTemplate)("valueFormatting", ctx_r1.valueFormatting)("animations", ctx_r1.animations);
  }
}
function GaugeComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "g", 7);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("bigSegments", ctx_r1.bigSegments)("smallSegments", ctx_r1.smallSegments)("min", ctx_r1.min)("max", ctx_r1.max)("radius", ctx_r1.outerRadius)("angleSpan", ctx_r1.angleSpan)("valueScale", ctx_r1.valueScale)("startAngle", ctx_r1.startAngle)("tickFormatting", ctx_r1.axisTickFormatting);
  }
}
function GaugeComponent__svg_text_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 8, 0)(2, "tspan", 9);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "tspan", 10);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("text-anchor", "middle");
    \u0275\u0275attribute("transform", ctx_r1.textTransform);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.displayValue);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.units);
  }
}
function SankeyComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 5)(1, "defs")(2, "linearGradient", 6);
    \u0275\u0275element(3, "stop", 7)(4, "stop", 8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "path", 9);
    \u0275\u0275listener("click", function SankeyComponent__svg_g_2_Template_path_click_5_listener() {
      const link_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.select.emit(link_r2.data));
    })("mouseenter", function SankeyComponent__svg_g_2_Template_path_mouseenter_5_listener() {
      const link_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activate.emit(link_r2.data));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const link_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipPlacement", "top")("tooltipTitle", ctx_r2.tooltipTemplate ? void 0 : link_r2.tooltip)("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", link_r2.data);
    \u0275\u0275advance(2);
    \u0275\u0275attribute("id", link_r2.id)("x1", link_r2.source.x1)("x2", link_r2.target.x0);
    \u0275\u0275advance();
    \u0275\u0275attribute("stop-color", link_r2.startColor);
    \u0275\u0275advance();
    \u0275\u0275attribute("stop-color", link_r2.endColor);
    \u0275\u0275advance();
    \u0275\u0275attribute("d", link_r2.path)("stroke", link_r2.gradientFill)("stroke-width", link_r2.strokeWidth);
  }
}
function SankeyComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g", 10)(1, "rect", 11);
    \u0275\u0275listener("click", function SankeyComponent__svg_g_3_Template_rect_click_1_listener() {
      const rect_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.select.emit(rect_r5.data));
    })("mouseenter", function SankeyComponent__svg_g_3_Template_rect_mouseenter_1_listener() {
      const rect_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.activate.emit(rect_r5.data));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const rect_r5 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", rect_r5.transform);
    \u0275\u0275advance();
    \u0275\u0275property("tooltipDisabled", ctx_r2.tooltipDisabled)("tooltipType", ctx_r2.styleTypes.tooltip)("tooltipPlacement", "top")("tooltipTitle", ctx_r2.tooltipTemplate ? void 0 : rect_r5.tooltip)("tooltipTemplate", ctx_r2.tooltipTemplate)("tooltipContext", rect_r5.data);
    \u0275\u0275attribute("x", 0)("y", 0)("width", rect_r5.width)("height", rect_r5.height)("fill", rect_r5.fill);
  }
}
function SankeyComponent__svg_g_4__svg_text_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 13);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const rect_r6 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275attribute("x", rect_r6.width + 5)("y", rect_r6.height / 2)("text-anchor", rect_r6.labelAnchor)("dx", rect_r6.labelAnchor === "end" ? -25 : 0);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", rect_r6.label, " ");
  }
}
function SankeyComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "g");
    \u0275\u0275template(1, SankeyComponent__svg_g_4__svg_text_1_Template, 2, 5, "text", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const rect_r6 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275attribute("transform", rect_r6.transform);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.showLabels && rect_r6.height > 15);
  }
}
function throttle(func, wait, options) {
  options = options || {};
  let context2;
  let args;
  let result;
  let timeout2 = null;
  let previous = 0;
  function later() {
    previous = options.leading === false ? 0 : +/* @__PURE__ */ new Date();
    timeout2 = null;
    result = func.apply(context2, args);
  }
  return function() {
    const now2 = +/* @__PURE__ */ new Date();
    if (!previous && options.leading === false) {
      previous = now2;
    }
    const remaining = wait - (now2 - previous);
    context2 = this;
    args = arguments;
    if (remaining <= 0) {
      clearTimeout(timeout2);
      timeout2 = null;
      previous = now2;
      result = func.apply(context2, args);
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result;
  };
}
function throttleable(duration, options) {
  return function innerDecorator(target, key, descriptor) {
    return {
      configurable: true,
      enumerable: descriptor.enumerable,
      get: function getter() {
        Object.defineProperty(this, key, {
          configurable: true,
          enumerable: descriptor.enumerable,
          value: throttle(descriptor.value, duration, options)
        });
        return this[key];
      }
    };
  };
}
var PlacementTypes;
(function(PlacementTypes2) {
  PlacementTypes2["Top"] = "top";
  PlacementTypes2["Bottom"] = "bottom";
  PlacementTypes2["Left"] = "left";
  PlacementTypes2["Right"] = "right";
  PlacementTypes2["Center"] = "center";
})(PlacementTypes || (PlacementTypes = {}));
var caretOffset = 7;
function verticalPosition(elDimensions, popoverDimensions, alignment) {
  if (alignment === PlacementTypes.Top) {
    return elDimensions.top - caretOffset;
  }
  if (alignment === PlacementTypes.Bottom) {
    return elDimensions.top + elDimensions.height - popoverDimensions.height + caretOffset;
  }
  if (alignment === PlacementTypes.Center) {
    return elDimensions.top + elDimensions.height / 2 - popoverDimensions.height / 2;
  }
  return void 0;
}
function horizontalPosition(elDimensions, popoverDimensions, alignment) {
  if (alignment === PlacementTypes.Left) {
    return elDimensions.left - caretOffset;
  }
  if (alignment === PlacementTypes.Right) {
    return elDimensions.left + elDimensions.width - popoverDimensions.width + caretOffset;
  }
  if (alignment === PlacementTypes.Center) {
    return elDimensions.left + elDimensions.width / 2 - popoverDimensions.width / 2;
  }
  return void 0;
}
var PositionHelper = class _PositionHelper {
  /**
   * Calculate vertical alignment position
   *
   * @memberOf PositionHelper
   */
  static calculateVerticalAlignment(elDimensions, popoverDimensions, alignment) {
    let result = verticalPosition(elDimensions, popoverDimensions, alignment);
    if (result + popoverDimensions.height > window.innerHeight) {
      result = window.innerHeight - popoverDimensions.height;
    }
    return result;
  }
  /**
   * Calculate vertical caret position
   *
   * @memberOf PositionHelper
   */
  static calculateVerticalCaret(elDimensions, popoverDimensions, caretDimensions, alignment) {
    let result;
    if (alignment === PlacementTypes.Top) {
      result = elDimensions.height / 2 - caretDimensions.height / 2 + caretOffset;
    }
    if (alignment === PlacementTypes.Bottom) {
      result = popoverDimensions.height - elDimensions.height / 2 - caretDimensions.height / 2 - caretOffset;
    }
    if (alignment === PlacementTypes.Center) {
      result = popoverDimensions.height / 2 - caretDimensions.height / 2;
    }
    const popoverPosition = verticalPosition(elDimensions, popoverDimensions, alignment);
    if (popoverPosition + popoverDimensions.height > window.innerHeight) {
      result += popoverPosition + popoverDimensions.height - window.innerHeight;
    }
    return result;
  }
  /**
   * Calculate horz alignment position
   *
   * @memberOf PositionHelper
   */
  static calculateHorizontalAlignment(elDimensions, popoverDimensions, alignment) {
    let result = horizontalPosition(elDimensions, popoverDimensions, alignment);
    if (result + popoverDimensions.width > window.innerWidth) {
      result = window.innerWidth - popoverDimensions.width;
    }
    return result;
  }
  /**
   * Calculate horz caret position
   *
   * @memberOf PositionHelper
   */
  static calculateHorizontalCaret(elDimensions, popoverDimensions, caretDimensions, alignment) {
    let result;
    if (alignment === PlacementTypes.Left) {
      result = elDimensions.width / 2 - caretDimensions.width / 2 + caretOffset;
    }
    if (alignment === PlacementTypes.Right) {
      result = popoverDimensions.width - elDimensions.width / 2 - caretDimensions.width / 2 - caretOffset;
    }
    if (alignment === PlacementTypes.Center) {
      result = popoverDimensions.width / 2 - caretDimensions.width / 2;
    }
    const popoverPosition = horizontalPosition(elDimensions, popoverDimensions, alignment);
    if (popoverPosition + popoverDimensions.width > window.innerWidth) {
      result += popoverPosition + popoverDimensions.width - window.innerWidth;
    }
    return result;
  }
  /**
   * Checks if the element's position should be flipped
   *
   * @memberOf PositionHelper
   */
  static shouldFlip(elDimensions, popoverDimensions, placement, spacing) {
    let flip2 = false;
    if (placement === PlacementTypes.Right) {
      if (elDimensions.left + elDimensions.width + popoverDimensions.width + spacing > window.innerWidth) {
        flip2 = true;
      }
    }
    if (placement === PlacementTypes.Left) {
      if (elDimensions.left - popoverDimensions.width - spacing < 0) {
        flip2 = true;
      }
    }
    if (placement === PlacementTypes.Top) {
      if (elDimensions.top - popoverDimensions.height - spacing < 0) {
        flip2 = true;
      }
    }
    if (placement === PlacementTypes.Bottom) {
      if (elDimensions.top + elDimensions.height + popoverDimensions.height + spacing > window.innerHeight) {
        flip2 = true;
      }
    }
    return flip2;
  }
  /**
   * Position caret
   *
   * @memberOf PositionHelper
   */
  static positionCaret(placement, elmDim, hostDim, caretDimensions, alignment) {
    let top = 0;
    let left2 = 0;
    if (placement === PlacementTypes.Right) {
      left2 = -7;
      top = _PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
    } else if (placement === PlacementTypes.Left) {
      left2 = elmDim.width;
      top = _PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
    } else if (placement === PlacementTypes.Top) {
      top = elmDim.height;
      left2 = _PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
    } else if (placement === PlacementTypes.Bottom) {
      top = -7;
      left2 = _PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
    }
    return {
      top,
      left: left2
    };
  }
  /**
   * Position content
   *
   * @memberOf PositionHelper
   */
  static positionContent(placement, elmDim, hostDim, spacing, alignment) {
    let top = 0;
    let left2 = 0;
    if (placement === PlacementTypes.Right) {
      left2 = hostDim.left + hostDim.width + spacing;
      top = _PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
    } else if (placement === PlacementTypes.Left) {
      left2 = hostDim.left - elmDim.width - spacing;
      top = _PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
    } else if (placement === PlacementTypes.Top) {
      top = hostDim.top - elmDim.height - spacing;
      left2 = _PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
    } else if (placement === PlacementTypes.Bottom) {
      top = hostDim.top + hostDim.height + spacing;
      left2 = _PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
    }
    return {
      top,
      left: left2
    };
  }
  /**
   * Determine placement based on flip
   *
   * @memberOf PositionHelper
   */
  static determinePlacement(placement, elmDim, hostDim, spacing) {
    const shouldFlip = _PositionHelper.shouldFlip(hostDim, elmDim, placement, spacing);
    if (shouldFlip) {
      if (placement === PlacementTypes.Right) {
        return PlacementTypes.Left;
      } else if (placement === PlacementTypes.Left) {
        return PlacementTypes.Right;
      } else if (placement === PlacementTypes.Top) {
        return PlacementTypes.Bottom;
      } else if (placement === PlacementTypes.Bottom) {
        return PlacementTypes.Top;
      }
    }
    return placement;
  }
};
var _TooltipContentComponent = class _TooltipContentComponent {
  get cssClasses() {
    let clz = "ngx-charts-tooltip-content";
    clz += ` position-${this.placement}`;
    clz += ` type-${this.type}`;
    clz += ` ${this.cssClass}`;
    return clz;
  }
  constructor(element, renderer, platformId) {
    this.element = element;
    this.renderer = renderer;
    this.platformId = platformId;
  }
  ngAfterViewInit() {
    setTimeout(this.position.bind(this));
  }
  position() {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    const nativeElm = this.element.nativeElement;
    const hostDim = this.host.nativeElement.getBoundingClientRect();
    if (!hostDim.height && !hostDim.width) return;
    const elmDim = nativeElm.getBoundingClientRect();
    this.checkFlip(hostDim, elmDim);
    this.positionContent(nativeElm, hostDim, elmDim);
    if (this.showCaret) {
      this.positionCaret(hostDim, elmDim);
    }
    setTimeout(() => this.renderer.addClass(nativeElm, "animate"), 1);
  }
  positionContent(nativeElm, hostDim, elmDim) {
    const {
      top,
      left: left2
    } = PositionHelper.positionContent(this.placement, elmDim, hostDim, this.spacing, this.alignment);
    this.renderer.setStyle(nativeElm, "top", `${top}px`);
    this.renderer.setStyle(nativeElm, "left", `${left2}px`);
  }
  positionCaret(hostDim, elmDim) {
    const caretElm = this.caretElm.nativeElement;
    const caretDimensions = caretElm.getBoundingClientRect();
    const {
      top,
      left: left2
    } = PositionHelper.positionCaret(this.placement, elmDim, hostDim, caretDimensions, this.alignment);
    this.renderer.setStyle(caretElm, "top", `${top}px`);
    this.renderer.setStyle(caretElm, "left", `${left2}px`);
  }
  checkFlip(hostDim, elmDim) {
    this.placement = PositionHelper.determinePlacement(this.placement, elmDim, hostDim, this.spacing);
  }
  onWindowResize() {
    this.position();
  }
};
_TooltipContentComponent.\u0275fac = function TooltipContentComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TooltipContentComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(PLATFORM_ID));
};
_TooltipContentComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TooltipContentComponent,
  selectors: [["ngx-tooltip-content"]],
  viewQuery: function TooltipContentComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c013, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.caretElm = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function TooltipContentComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("resize", function TooltipContentComponent_resize_HostBindingHandler() {
        return ctx.onWindowResize();
      }, false, \u0275\u0275resolveWindow);
    }
    if (rf & 2) {
      \u0275\u0275classMap(ctx.cssClasses);
    }
  },
  inputs: {
    host: "host",
    showCaret: "showCaret",
    type: "type",
    placement: "placement",
    alignment: "alignment",
    spacing: "spacing",
    cssClass: "cssClass",
    title: "title",
    template: "template",
    context: "context"
  },
  standalone: false,
  decls: 6,
  vars: 6,
  consts: [["caretElm", ""], [3, "hidden"], [1, "tooltip-content"], [4, "ngIf"], [3, "innerHTML", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"]],
  template: function TooltipContentComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div");
      \u0275\u0275element(1, "span", 1, 0);
      \u0275\u0275elementStart(3, "div", 2);
      \u0275\u0275template(4, TooltipContentComponent_span_4_Template, 2, 4, "span", 3)(5, TooltipContentComponent_span_5_Template, 1, 1, "span", 4);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275classMapInterpolate1("tooltip-caret position-", ctx.placement, "");
      \u0275\u0275property("hidden", !ctx.showCaret);
      \u0275\u0275advance(3);
      \u0275\u0275property("ngIf", !ctx.title);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.title);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px #0003,0 1px 1px #00000024,0 2px 1px -1px #0000001f;font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:#000000bf;font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translateZ(0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}\n"],
  encapsulation: 2
});
var TooltipContentComponent = _TooltipContentComponent;
__decorate([throttleable(100)], TooltipContentComponent.prototype, "onWindowResize", null);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipContentComponent, [{
    type: Component,
    args: [{
      selector: "ngx-tooltip-content",
      template: `
    <div>
      <span #caretElm [hidden]="!showCaret" class="tooltip-caret position-{{ this.placement }}"> </span>
      <div class="tooltip-content">
        <span *ngIf="!title">
          <ng-template [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ model: context }"> </ng-template>
        </span>
        <span *ngIf="title" [innerHTML]="title"> </span>
      </div>
    </div>
  `,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:400;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px #0003,0 1px 1px #00000024,0 2px 1px -1px #0000001f;font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:#000000bf;font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate3d(10px,0,0)}.ngx-charts-tooltip-content.position-left{transform:translate3d(-10px,0,0)}.ngx-charts-tooltip-content.position-top{transform:translate3d(0,-10px,0)}.ngx-charts-tooltip-content.position-bottom{transform:translate3d(0,10px,0)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translateZ(0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}\n"]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    host: [{
      type: Input
    }],
    showCaret: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    placement: [{
      type: Input
    }],
    alignment: [{
      type: Input
    }],
    spacing: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    caretElm: [{
      type: ViewChild,
      args: ["caretElm"]
    }],
    cssClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    onWindowResize: [{
      type: HostListener,
      args: ["window:resize"]
    }]
  });
})();
var InjectionRegisteryService = class {
  constructor(injectionService) {
    this.injectionService = injectionService;
    this.defaults = {};
    this.components = /* @__PURE__ */ new Map();
  }
  getByType(type2 = this.type) {
    return this.components.get(type2);
  }
  create(bindings) {
    return this.createByType(this.type, bindings);
  }
  createByType(type2, bindings) {
    bindings = this.assignDefaults(bindings);
    const component = this.injectComponent(type2, bindings);
    this.register(type2, component);
    return component;
  }
  destroy(instance) {
    const compsByType = this.components.get(instance.componentType);
    if (compsByType && compsByType.length) {
      const idx = compsByType.indexOf(instance);
      if (idx > -1) {
        const component = compsByType[idx];
        component.destroy();
        compsByType.splice(idx, 1);
      }
    }
  }
  destroyAll() {
    this.destroyByType(this.type);
  }
  destroyByType(type2) {
    const comps = this.components.get(type2);
    if (comps && comps.length) {
      let i = comps.length - 1;
      while (i >= 0) {
        this.destroy(comps[i--]);
      }
    }
  }
  injectComponent(type2, bindings) {
    return this.injectionService.appendComponent(type2, bindings);
  }
  assignDefaults(bindings) {
    const inputs = __spreadValues({}, this.defaults.inputs);
    const outputs = __spreadValues({}, this.defaults.outputs);
    if (!bindings.inputs && !bindings.outputs) {
      bindings = {
        inputs: bindings
      };
    }
    if (inputs) {
      bindings.inputs = __spreadValues(__spreadValues({}, inputs), bindings.inputs);
    }
    if (outputs) {
      bindings.outputs = __spreadValues(__spreadValues({}, outputs), bindings.outputs);
    }
    return bindings;
  }
  register(type2, component) {
    if (!this.components.has(type2)) {
      this.components.set(type2, []);
    }
    const types = this.components.get(type2);
    types.push(component);
  }
};
function isViewContainerRef(x4) {
  return x4.element;
}
var _InjectionService = class _InjectionService {
  /**
   * Sets a default global root view container. This is useful for
   * things like ngUpgrade that doesn't have a ApplicationRef root.
   *
   * @param container
   */
  static setGlobalRootViewContainer(container) {
    _InjectionService.globalRootViewContainer = container;
  }
  constructor(applicationRef, componentFactoryResolver, injector) {
    this.applicationRef = applicationRef;
    this.componentFactoryResolver = componentFactoryResolver;
    this.injector = injector;
  }
  /**
   * Gets the root view container to inject the component to.
   *
   * @memberOf InjectionService
   */
  getRootViewContainer() {
    if (this._container) return this._container;
    if (_InjectionService.globalRootViewContainer) return _InjectionService.globalRootViewContainer;
    if (this.applicationRef.components.length) return this.applicationRef.components[0];
    throw new Error("View Container not found! ngUpgrade needs to manually set this via setRootViewContainer or setGlobalRootViewContainer.");
  }
  /**
   * Overrides the default root view container. This is useful for
   * things like ngUpgrade that doesn't have a ApplicationRef root.
   *
   * @param container
   *
   * @memberOf InjectionService
   */
  setRootViewContainer(container) {
    this._container = container;
  }
  /**
   * Gets the html element for a component ref.
   *
   * @param componentRef
   *
   * @memberOf InjectionService
   */
  getComponentRootNode(component) {
    if (isViewContainerRef(component)) {
      return component.element.nativeElement;
    }
    if (component.hostView && component.hostView.rootNodes.length > 0) {
      return component.hostView.rootNodes[0];
    }
    return component.location.nativeElement;
  }
  /**
   * Gets the root component container html element.
   *
   * @memberOf InjectionService
   */
  getRootViewContainerNode(component) {
    return this.getComponentRootNode(component);
  }
  /**
   * Projects the bindings onto the component
   *
   * @param component
   * @param options
   *
   * @memberOf InjectionService
   */
  projectComponentBindings(component, bindings) {
    if (bindings) {
      if (bindings.inputs !== void 0) {
        const bindingKeys = Object.getOwnPropertyNames(bindings.inputs);
        for (const bindingName of bindingKeys) {
          component.instance[bindingName] = bindings.inputs[bindingName];
        }
      }
      if (bindings.outputs !== void 0) {
        const eventKeys = Object.getOwnPropertyNames(bindings.outputs);
        for (const eventName of eventKeys) {
          component.instance[eventName] = bindings.outputs[eventName];
        }
      }
    }
    return component;
  }
  /**
   * Appends a component to a adjacent location
   *
   * @param componentClass
   * @param [options={}]
   * @param [location]
   *
   * @memberOf InjectionService
   */
  appendComponent(componentClass, bindings = {}, location2) {
    if (!location2) location2 = this.getRootViewContainer();
    const appendLocation = this.getComponentRootNode(location2);
    const portalHost = new DomPortalOutlet(appendLocation, this.componentFactoryResolver, this.applicationRef, this.injector);
    const portal = new ComponentPortal2(componentClass);
    const componentRef = portalHost.attach(portal);
    this.projectComponentBindings(componentRef, bindings);
    return componentRef;
  }
};
_InjectionService.globalRootViewContainer = null;
_InjectionService.\u0275fac = function InjectionService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _InjectionService)(\u0275\u0275inject(ApplicationRef), \u0275\u0275inject(ComponentFactoryResolver$1), \u0275\u0275inject(Injector));
};
_InjectionService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _InjectionService,
  factory: _InjectionService.\u0275fac
});
var InjectionService = _InjectionService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InjectionService, [{
    type: Injectable
  }], () => [{
    type: ApplicationRef
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: Injector
  }], null);
})();
var _TooltipService = class _TooltipService extends InjectionRegisteryService {
  constructor(injectionService) {
    super(injectionService);
    this.type = TooltipContentComponent;
  }
};
_TooltipService.\u0275fac = function TooltipService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TooltipService)(\u0275\u0275inject(InjectionService));
};
_TooltipService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
  token: _TooltipService,
  factory: _TooltipService.\u0275fac
});
var TooltipService = _TooltipService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipService, [{
    type: Injectable
  }], () => [{
    type: InjectionService
  }], null);
})();
var LegendPosition;
(function(LegendPosition2) {
  LegendPosition2["Right"] = "right";
  LegendPosition2["Below"] = "below";
})(LegendPosition || (LegendPosition = {}));
var LegendType;
(function(LegendType2) {
  LegendType2["ScaleLegend"] = "scaleLegend";
  LegendType2["Legend"] = "legend";
})(LegendType || (LegendType = {}));
var ScaleType;
(function(ScaleType2) {
  ScaleType2["Time"] = "time";
  ScaleType2["Linear"] = "linear";
  ScaleType2["Ordinal"] = "ordinal";
  ScaleType2["Quantile"] = "quantile";
})(ScaleType || (ScaleType = {}));
function formatLabel(label) {
  if (label instanceof Date) {
    label = label.toLocaleDateString();
  } else {
    label = label.toLocaleString();
  }
  return label;
}
function escapeLabel(label) {
  return label.toLocaleString().replace(/[&'`"<>]/g, (match2) => {
    return {
      "&": "&amp;",
      // tslint:disable-next-line: quotemark
      "'": "&#x27;",
      "`": "&#x60;",
      '"': "&quot;",
      "<": "&lt;",
      ">": "&gt;"
    }[match2];
  });
}
var _LegendEntryComponent = class _LegendEntryComponent {
  constructor() {
    this.isActive = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.toggle = new EventEmitter();
  }
  get trimmedLabel() {
    return this.formattedLabel || "(empty)";
  }
  onMouseEnter() {
    this.activate.emit({
      name: this.label
    });
  }
  onMouseLeave() {
    this.deactivate.emit({
      name: this.label
    });
  }
};
_LegendEntryComponent.\u0275fac = function LegendEntryComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _LegendEntryComponent)();
};
_LegendEntryComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LegendEntryComponent,
  selectors: [["ngx-charts-legend-entry"]],
  hostBindings: function LegendEntryComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseenter", function LegendEntryComponent_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function LegendEntryComponent_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      });
    }
  },
  inputs: {
    color: "color",
    label: "label",
    formattedLabel: "formattedLabel",
    isActive: "isActive"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate",
    toggle: "toggle"
  },
  standalone: false,
  decls: 4,
  vars: 6,
  consts: [["tabindex", "-1", 3, "click", "title"], [1, "legend-label-color", 3, "click"], [1, "legend-label-text"]],
  template: function LegendEntryComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "span", 0);
      \u0275\u0275listener("click", function LegendEntryComponent_Template_span_click_0_listener() {
        return ctx.select.emit(ctx.formattedLabel);
      });
      \u0275\u0275elementStart(1, "span", 1);
      \u0275\u0275listener("click", function LegendEntryComponent_Template_span_click_1_listener() {
        return ctx.toggle.emit(ctx.formattedLabel);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(2, "span", 2);
      \u0275\u0275text(3);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275classProp("active", ctx.isActive);
      \u0275\u0275property("title", ctx.formattedLabel);
      \u0275\u0275advance();
      \u0275\u0275styleProp("background-color", ctx.color);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.trimmedLabel, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var LegendEntryComponent = _LegendEntryComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LegendEntryComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-legend-entry",
      template: `
    <span [title]="formattedLabel" tabindex="-1" [class.active]="isActive" (click)="select.emit(formattedLabel)">
      <span class="legend-label-color" [style.background-color]="color" (click)="toggle.emit(formattedLabel)"> </span>
      <span class="legend-label-text">
        {{ trimmedLabel }}
      </span>
    </span>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    color: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    formattedLabel: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    toggle: [{
      type: Output
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var _LegendComponent = class _LegendComponent {
  constructor(cd) {
    this.cd = cd;
    this.horizontal = false;
    this.labelClick = new EventEmitter();
    this.labelActivate = new EventEmitter();
    this.labelDeactivate = new EventEmitter();
    this.legendEntries = [];
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.cd.markForCheck();
    this.legendEntries = this.getLegendEntries();
  }
  getLegendEntries() {
    const items = [];
    for (const label of this.data) {
      const formattedLabel = formatLabel(label);
      const idx = items.findIndex((i) => {
        return i.label === formattedLabel;
      });
      if (idx === -1) {
        items.push({
          label,
          formattedLabel,
          color: this.colors.getColor(label)
        });
      }
    }
    return items;
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.label === d.name;
    });
    return item !== void 0;
  }
  activate(item) {
    this.labelActivate.emit(item);
  }
  deactivate(item) {
    this.labelDeactivate.emit(item);
  }
  trackBy(index, item) {
    return item.label;
  }
};
_LegendComponent.\u0275fac = function LegendComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _LegendComponent)(\u0275\u0275directiveInject(ChangeDetectorRef));
};
_LegendComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LegendComponent,
  selectors: [["ngx-charts-legend"]],
  inputs: {
    data: "data",
    title: "title",
    colors: "colors",
    height: "height",
    width: "width",
    activeEntries: "activeEntries",
    horizontal: "horizontal"
  },
  outputs: {
    labelClick: "labelClick",
    labelActivate: "labelActivate",
    labelDeactivate: "labelDeactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 5,
  vars: 9,
  consts: [["class", "legend-title", 4, "ngIf"], [1, "legend-wrap"], [1, "legend-labels"], ["class", "legend-label", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "legend-title"], [1, "legend-title-text"], [1, "legend-label"], [3, "select", "activate", "deactivate", "label", "formattedLabel", "color", "isActive"]],
  template: function LegendComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div");
      \u0275\u0275template(1, LegendComponent_header_1_Template, 3, 1, "header", 0);
      \u0275\u0275elementStart(2, "div", 1)(3, "ul", 2);
      \u0275\u0275template(4, LegendComponent_li_4_Template, 2, 4, "li", 3);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx.width, "px");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", (ctx.title == null ? null : ctx.title.length) > 0);
      \u0275\u0275advance(2);
      \u0275\u0275styleProp("max-height", ctx.height - 45, "px");
      \u0275\u0275classProp("horizontal-legend", ctx.horizontal);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.legendEntries)("ngForTrackBy", ctx.trackBy);
    }
  },
  dependencies: [NgForOf, NgIf, LegendEntryComponent],
  styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend ul,.chart-legend li{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:#0000000d}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var LegendComponent = _LegendComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LegendComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-legend",
      template: `
    <div [style.width.px]="width">
      <header class="legend-title" *ngIf="title?.length > 0">
        <span class="legend-title-text">{{ title }}</span>
      </header>
      <div class="legend-wrap">
        <ul class="legend-labels" [class.horizontal-legend]="horizontal" [style.max-height.px]="height - 45">
          <li *ngFor="let entry of legendEntries; trackBy: trackBy" class="legend-label">
            <ngx-charts-legend-entry
              [label]="entry.label"
              [formattedLabel]="entry.formattedLabel"
              [color]="entry.color"
              [isActive]="isActive(entry)"
              (select)="labelClick.emit($event)"
              (activate)="activate($event)"
              (deactivate)="deactivate($event)"
            >
            </ngx-charts-legend-entry>
          </li>
        </ul>
      </div>
    </div>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:700}.chart-legend ul,.chart-legend li{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:#0000000d}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    data: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    horizontal: [{
      type: Input
    }],
    labelClick: [{
      type: Output
    }],
    labelActivate: [{
      type: Output
    }],
    labelDeactivate: [{
      type: Output
    }]
  });
})();
var _ScaleLegendComponent = class _ScaleLegendComponent {
  constructor() {
    this.horizontal = false;
  }
  ngOnChanges(changes) {
    const gradientValues = this.gradientString(this.colors.range(), this.colors.domain());
    const direction = this.horizontal ? "right" : "bottom";
    this.gradient = `linear-gradient(to ${direction}, ${gradientValues})`;
  }
  /**
   * Generates the string used in the gradient stylesheet properties
   * @param colors array of colors
   * @param splits array of splits on a scale of (0, 1)
   */
  gradientString(colors, splits) {
    splits.push(1);
    const pairs = [];
    colors.reverse().forEach((c, i) => {
      pairs.push(`${c} ${Math.round(splits[i] * 100)}%`);
    });
    return pairs.join(", ");
  }
};
_ScaleLegendComponent.\u0275fac = function ScaleLegendComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ScaleLegendComponent)();
};
_ScaleLegendComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ScaleLegendComponent,
  selectors: [["ngx-charts-scale-legend"]],
  inputs: {
    valueRange: "valueRange",
    colors: "colors",
    height: "height",
    width: "width",
    horizontal: "horizontal"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 8,
  vars: 10,
  consts: [[1, "scale-legend"], [1, "scale-legend-label"], [1, "scale-legend-wrap"]],
  template: function ScaleLegendComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "span");
      \u0275\u0275text(3);
      \u0275\u0275elementEnd()();
      \u0275\u0275element(4, "div", 2);
      \u0275\u0275elementStart(5, "div", 1)(6, "span");
      \u0275\u0275text(7);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275styleProp("height", ctx.horizontal ? void 0 : ctx.height, "px")("width", ctx.width, "px");
      \u0275\u0275classProp("horizontal-legend", ctx.horizontal);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.valueRange[1].toLocaleString());
      \u0275\u0275advance();
      \u0275\u0275styleProp("background", ctx.gradient);
      \u0275\u0275advance(3);
      \u0275\u0275textInterpolate(ctx.valueRange[0].toLocaleString());
    }
  },
  styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var ScaleLegendComponent = _ScaleLegendComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScaleLegendComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-scale-legend",
      template: `
    <div
      class="scale-legend"
      [class.horizontal-legend]="horizontal"
      [style.height.px]="horizontal ? undefined : height"
      [style.width.px]="width"
    >
      <div class="scale-legend-label">
        <span>{{ valueRange[1].toLocaleString() }}</span>
      </div>
      <div class="scale-legend-wrap" [style.background]="gradient"></div>
      <div class="scale-legend-label">
        <span>{{ valueRange[0].toLocaleString() }}</span>
      </div>
    </div>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .scale-legend{text-align:center;display:flex;flex-direction:column}.chart-legend .scale-legend-wrap{display:inline-block;flex:1;width:30px;border-radius:5px;margin:0 auto}.chart-legend .scale-legend-label{font-size:12px}.chart-legend .horizontal-legend.scale-legend{flex-direction:row}.chart-legend .horizontal-legend .scale-legend-wrap{width:auto;height:30px;margin:0 16px}\n"]
    }]
  }], null, {
    valueRange: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    horizontal: [{
      type: Input
    }]
  });
})();
var _ChartComponent = class _ChartComponent {
  constructor() {
    this.showLegend = false;
    this.animations = true;
    this.legendLabelClick = new EventEmitter();
    this.legendLabelActivate = new EventEmitter();
    this.legendLabelDeactivate = new EventEmitter();
    this.LegendPosition = LegendPosition;
    this.LegendType = LegendType;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    let legendColumns = 0;
    if (this.showLegend) {
      this.legendType = this.getLegendType();
      if (!this.legendOptions || this.legendOptions.position === LegendPosition.Right) {
        if (this.legendType === LegendType.ScaleLegend) {
          legendColumns = 1;
        } else {
          legendColumns = 2;
        }
      }
    }
    const chartColumns = 12 - legendColumns;
    this.chartWidth = Math.floor(this.view[0] * chartColumns / 12);
    this.legendWidth = !this.legendOptions || this.legendOptions.position === LegendPosition.Right ? Math.floor(this.view[0] * legendColumns / 12) : this.chartWidth;
  }
  getLegendType() {
    return this.legendOptions.scaleType === ScaleType.Linear ? LegendType.ScaleLegend : LegendType.Legend;
  }
};
_ChartComponent.\u0275fac = function ChartComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ChartComponent)();
};
_ChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _ChartComponent,
  selectors: [["ngx-charts-chart"]],
  inputs: {
    view: "view",
    showLegend: "showLegend",
    legendOptions: "legendOptions",
    legendType: "legendType",
    activeEntries: "activeEntries",
    animations: "animations"
  },
  outputs: {
    legendLabelClick: "legendLabelClick",
    legendLabelActivate: "legendLabelActivate",
    legendLabelDeactivate: "legendLabelDeactivate"
  },
  standalone: false,
  features: [\u0275\u0275ProvidersFeature([TooltipService]), \u0275\u0275NgOnChangesFeature],
  ngContentSelectors: _c23,
  decls: 5,
  vars: 8,
  consts: [[1, "ngx-charts-outer"], [1, "ngx-charts"], ["class", "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width", 4, "ngIf"], ["class", "chart-legend", 3, "horizontal", "data", "title", "colors", "height", "width", "activeEntries", "labelClick", "labelActivate", "labelDeactivate", 4, "ngIf"], [1, "chart-legend", 3, "horizontal", "valueRange", "colors", "height", "width"], [1, "chart-legend", 3, "labelClick", "labelActivate", "labelDeactivate", "horizontal", "data", "title", "colors", "height", "width", "activeEntries"]],
  template: function ChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "svg", 1);
      \u0275\u0275projection(2);
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, ChartComponent_ngx_charts_scale_legend_3_Template, 1, 5, "ngx-charts-scale-legend", 2)(4, ChartComponent_ngx_charts_legend_4_Template, 1, 7, "ngx-charts-legend", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx.view[0], "px")("height", ctx.view[1], "px");
      \u0275\u0275advance();
      \u0275\u0275attribute("width", ctx.chartWidth)("height", ctx.view[1]);
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.showLegend && ctx.legendType === ctx.LegendType.ScaleLegend);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showLegend && ctx.legendType === ctx.LegendType.Legend);
    }
  },
  dependencies: [NgIf, LegendComponent, ScaleLegendComponent],
  encapsulation: 2,
  changeDetection: 0
});
var ChartComponent = _ChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartComponent, [{
    type: Component,
    args: [{
      providers: [TooltipService],
      selector: "ngx-charts-chart",
      template: `
    <div class="ngx-charts-outer" [style.width.px]="view[0]" [style.height.px]="view[1]">
      <svg class="ngx-charts" [attr.width]="chartWidth" [attr.height]="view[1]">
        <ng-content></ng-content>
      </svg>
      <ngx-charts-scale-legend
        *ngIf="showLegend && legendType === LegendType.ScaleLegend"
        class="chart-legend"
        [horizontal]="legendOptions && legendOptions.position === LegendPosition.Below"
        [valueRange]="legendOptions.domain"
        [colors]="legendOptions.colors"
        [height]="view[1]"
        [width]="legendWidth"
      >
      </ngx-charts-scale-legend>
      <ngx-charts-legend
        *ngIf="showLegend && legendType === LegendType.Legend"
        class="chart-legend"
        [horizontal]="legendOptions && legendOptions.position === LegendPosition.Below"
        [data]="legendOptions.domain"
        [title]="legendOptions.title"
        [colors]="legendOptions.colors"
        [height]="view[1]"
        [width]="legendWidth"
        [activeEntries]="activeEntries"
        (labelClick)="legendLabelClick.emit($event)"
        (labelActivate)="legendLabelActivate.emit($event)"
        (labelDeactivate)="legendLabelDeactivate.emit($event)"
      >
      </ngx-charts-legend>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    view: [{
      type: Input
    }],
    showLegend: [{
      type: Input
    }],
    legendOptions: [{
      type: Input
    }],
    legendType: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    legendLabelClick: [{
      type: Output
    }],
    legendLabelActivate: [{
      type: Output
    }],
    legendLabelDeactivate: [{
      type: Output
    }]
  });
})();
var _VisibilityObserver = class _VisibilityObserver {
  constructor(element, zone) {
    this.element = element;
    this.zone = zone;
    this.visible = new EventEmitter();
    this.isVisible = false;
    this.runCheck();
  }
  destroy() {
    clearTimeout(this.timeout);
  }
  onVisibilityChange() {
    this.zone.run(() => {
      this.isVisible = true;
      this.visible.emit(true);
    });
  }
  runCheck() {
    const check = () => {
      if (!this.element) {
        return;
      }
      const {
        offsetHeight,
        offsetWidth
      } = this.element.nativeElement;
      if (offsetHeight && offsetWidth) {
        clearTimeout(this.timeout);
        this.onVisibilityChange();
      } else {
        clearTimeout(this.timeout);
        this.zone.runOutsideAngular(() => {
          this.timeout = setTimeout(() => check(), 100);
        });
      }
    };
    this.zone.runOutsideAngular(() => {
      this.timeout = setTimeout(() => check());
    });
  }
};
_VisibilityObserver.\u0275fac = function VisibilityObserver_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _VisibilityObserver)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone));
};
_VisibilityObserver.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _VisibilityObserver,
  selectors: [["visibility-observer"]],
  outputs: {
    visible: "visible"
  },
  standalone: false
});
var VisibilityObserver = _VisibilityObserver;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VisibilityObserver, [{
    type: Directive,
    args: [{
      selector: "visibility-observer"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }], {
    visible: [{
      type: Output
    }]
  });
})();
function isDate2(value2) {
  return toString.call(value2) === "[object Date]";
}
function isNumber(value2) {
  return typeof value2 === "number";
}
var _BaseChartComponent = class _BaseChartComponent {
  constructor(chartElement, zone, cd, platformId) {
    this.chartElement = chartElement;
    this.zone = zone;
    this.cd = cd;
    this.platformId = platformId;
    this.scheme = "cool";
    this.schemeType = ScaleType.Ordinal;
    this.animations = true;
    this.select = new EventEmitter();
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.animations = false;
    }
  }
  ngAfterViewInit() {
    this.bindWindowResizeEvent();
    this.visibilityObserver = new VisibilityObserver(this.chartElement, this.zone);
    this.visibilityObserver.visible.subscribe(this.update.bind(this));
  }
  ngOnDestroy() {
    this.unbindEvents();
    if (this.visibilityObserver) {
      this.visibilityObserver.visible.unsubscribe();
      this.visibilityObserver.destroy();
    }
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    if (this.results) {
      this.results = this.cloneData(this.results);
    } else {
      this.results = [];
    }
    if (this.view) {
      this.width = this.view[0];
      this.height = this.view[1];
    } else {
      const dims = this.getContainerDims();
      if (dims) {
        this.width = dims.width;
        this.height = dims.height;
      }
    }
    if (!this.width) {
      this.width = 600;
    }
    if (!this.height) {
      this.height = 400;
    }
    this.width = Math.floor(this.width);
    this.height = Math.floor(this.height);
    if (this.cd) {
      this.cd.markForCheck();
    }
  }
  getContainerDims() {
    let width;
    let height;
    const hostElem = this.chartElement.nativeElement;
    if (isPlatformBrowser(this.platformId) && hostElem.parentNode !== null) {
      const dims = hostElem.parentNode.getBoundingClientRect();
      width = dims.width;
      height = dims.height;
    }
    if (width && height) {
      return {
        width,
        height
      };
    }
    return null;
  }
  /**
   * Converts all date objects that appear as name
   * into formatted date strings
   */
  formatDates() {
    for (let i = 0; i < this.results.length; i++) {
      const g2 = this.results[i];
      g2.label = g2.name;
      if (isDate2(g2.label)) {
        g2.label = g2.label.toLocaleDateString();
      }
      if (g2.series) {
        for (let j = 0; j < g2.series.length; j++) {
          const d = g2.series[j];
          d.label = d.name;
          if (isDate2(d.label)) {
            d.label = d.label.toLocaleDateString();
          }
        }
      }
    }
  }
  unbindEvents() {
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  bindWindowResizeEvent() {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    const source = fromEvent(window, "resize");
    const subscription = source.pipe(debounceTime(200)).subscribe((e) => {
      this.update();
      if (this.cd) {
        this.cd.markForCheck();
      }
    });
    this.resizeSubscription = subscription;
  }
  /**
   * Clones the data into a new object
   *
   * @memberOf BaseChart
   */
  cloneData(data) {
    const results = [];
    for (const item of data) {
      const copy2 = {};
      if (item["name"] !== void 0) {
        copy2["name"] = item["name"];
      }
      if (item["value"] !== void 0) {
        copy2["value"] = item["value"];
      }
      if (item["series"] !== void 0) {
        copy2["series"] = [];
        for (const seriesItem of item["series"]) {
          const seriesItemCopy = Object.assign({}, seriesItem);
          copy2["series"].push(seriesItemCopy);
        }
      }
      if (item["extra"] !== void 0) {
        copy2["extra"] = JSON.parse(JSON.stringify(item["extra"]));
      }
      if (item["source"] !== void 0) {
        copy2["source"] = item["source"];
      }
      if (item["target"] !== void 0) {
        copy2["target"] = item["target"];
      }
      results.push(copy2);
    }
    return results;
  }
};
_BaseChartComponent.\u0275fac = function BaseChartComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BaseChartComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(PLATFORM_ID));
};
_BaseChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BaseChartComponent,
  selectors: [["base-chart"]],
  inputs: {
    results: "results",
    view: "view",
    scheme: "scheme",
    schemeType: "schemeType",
    customColors: "customColors",
    animations: "animations"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 1,
  vars: 0,
  template: function BaseChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275element(0, "div");
    }
  },
  encapsulation: 2
});
var BaseChartComponent = _BaseChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseChartComponent, [{
    type: Component,
    args: [{
      selector: "base-chart",
      template: ` <div></div> `
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: ChangeDetectorRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    results: [{
      type: Input
    }],
    view: [{
      type: Input
    }],
    scheme: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    customColors: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
var Orientation;
(function(Orientation2) {
  Orientation2["Top"] = "top";
  Orientation2["Bottom"] = "bottom";
  Orientation2["Left"] = "left";
  Orientation2["Right"] = "right";
})(Orientation || (Orientation = {}));
var _AxisLabelComponent = class _AxisLabelComponent {
  constructor(element) {
    this.textHeight = 25;
    this.margin = 5;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.strokeWidth = "0.01";
    this.textAnchor = "middle";
    this.transform = "";
    switch (this.orient) {
      case Orientation.Top:
        this.y = this.offset;
        this.x = this.width / 2;
        break;
      case Orientation.Bottom:
        this.y = this.offset;
        this.x = this.width / 2;
        break;
      case Orientation.Left:
        this.y = -(this.offset + this.textHeight + this.margin);
        this.x = -this.height / 2;
        this.transform = "rotate(270)";
        break;
      case Orientation.Right:
        this.y = this.offset + this.margin;
        this.x = -this.height / 2;
        this.transform = "rotate(270)";
        break;
      default:
    }
  }
};
_AxisLabelComponent.\u0275fac = function AxisLabelComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AxisLabelComponent)(\u0275\u0275directiveInject(ElementRef));
};
_AxisLabelComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AxisLabelComponent,
  selectors: [["g", "ngx-charts-axis-label", ""]],
  inputs: {
    orient: "orient",
    label: "label",
    offset: "offset",
    width: "width",
    height: "height"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c33,
  decls: 2,
  vars: 6,
  template: function AxisLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "text");
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275attribute("stroke-width", ctx.strokeWidth)("x", ctx.x)("y", ctx.y)("text-anchor", ctx.textAnchor)("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.label, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var AxisLabelComponent = _AxisLabelComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxisLabelComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-axis-label]",
      template: `
    <svg:text
      [attr.stroke-width]="strokeWidth"
      [attr.x]="x"
      [attr.y]="y"
      [attr.text-anchor]="textAnchor"
      [attr.transform]="transform"
    >
      {{ label }}
    </svg:text>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    orient: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }]
  });
})();
function trimLabel(s2, max6 = 16) {
  if (typeof s2 !== "string") {
    if (typeof s2 === "number") {
      return s2 + "";
    } else {
      return "";
    }
  }
  s2 = s2.trim();
  if (s2.length <= max6) {
    return s2;
  } else {
    return `${s2.slice(0, max6)}...`;
  }
}
function reduceTicks(ticks2, maxTicks) {
  if (ticks2.length > maxTicks) {
    const reduced = [];
    const modulus = Math.floor(ticks2.length / maxTicks);
    for (let i = 0; i < ticks2.length; i++) {
      if (i % modulus === 0) {
        reduced.push(ticks2[i]);
      }
    }
    ticks2 = reduced;
  }
  return ticks2;
}
function getTickLines(label, maxLength, maxLines) {
  const labelString = (label || "").toString();
  let totalLines = [];
  if (/\s/.test(labelString)) {
    totalLines = labelString.split(/\s+/).reduce((lines, line) => {
      const last4 = (lines.pop() || "") + " ";
      return last4.length + line.length > maxLength ? [...lines, last4.trim(), line.trim()] : [...lines, last4 + line];
    }, []);
  } else {
    let startIndex = 0;
    while (startIndex < labelString.length) {
      totalLines.push(labelString.substring(startIndex, startIndex + maxLength));
      startIndex += maxLength;
    }
  }
  if (totalLines.length > maxLines) {
    totalLines = totalLines.splice(0, maxLines);
    totalLines[totalLines.length - 1] += "...";
  }
  return totalLines;
}
var TextAnchor;
(function(TextAnchor2) {
  TextAnchor2["Start"] = "start";
  TextAnchor2["Middle"] = "middle";
  TextAnchor2["End"] = "end";
})(TextAnchor || (TextAnchor = {}));
var _XAxisTicksComponent = class _XAxisTicksComponent {
  get isWrapTicksSupported() {
    return this.wrapTicks && this.scale.step;
  }
  constructor(platformId) {
    this.platformId = platformId;
    this.tickArguments = [5];
    this.tickStroke = "#ccc";
    this.trimTicks = true;
    this.maxTickLength = 16;
    this.showGridLines = false;
    this.rotateTicks = true;
    this.wrapTicks = false;
    this.dimensionsChanged = new EventEmitter();
    this.verticalSpacing = 20;
    this.rotateLabels = false;
    this.innerTickSize = 6;
    this.outerTickSize = 6;
    this.tickPadding = 3;
    this.textAnchor = TextAnchor.Middle;
    this.maxTicksLength = 0;
    this.maxAllowedLength = 16;
    this.height = 0;
    this.approxHeight = 10;
    this.maxPossibleLengthForTickIfWrapped = 16;
  }
  ngOnChanges(changes) {
    this.update();
  }
  ngAfterViewInit() {
    setTimeout(() => this.updateDims());
  }
  updateDims() {
    if (!isPlatformBrowser(this.platformId)) {
      this.dimensionsChanged.emit({
        height: this.approxHeight
      });
      return;
    }
    const height = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().height, 10);
    if (height !== this.height) {
      this.height = height;
      this.dimensionsChanged.emit({
        height: this.height
      });
      setTimeout(() => this.updateDims());
    }
  }
  update() {
    const scale = this.scale;
    this.ticks = this.getTicks();
    if (this.tickFormatting) {
      this.tickFormat = this.tickFormatting;
    } else if (scale.tickFormat) {
      this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
    } else {
      this.tickFormat = function(d) {
        if (d.constructor.name === "Date") {
          return d.toLocaleDateString();
        }
        return d.toLocaleString();
      };
    }
    const angle = this.rotateTicks ? this.getRotationAngle(this.ticks) : null;
    this.adjustedScale = this.scale.bandwidth ? function(d) {
      return this.scale(d) + this.scale.bandwidth() * 0.5;
    } : this.scale;
    this.textTransform = "";
    if (angle && angle !== 0) {
      this.textTransform = `rotate(${angle})`;
      this.textAnchor = TextAnchor.End;
      this.verticalSpacing = 10;
    } else {
      this.textAnchor = TextAnchor.Middle;
    }
    setTimeout(() => this.updateDims());
  }
  getRotationAngle(ticks2) {
    let angle = 0;
    this.maxTicksLength = 0;
    for (let i = 0; i < ticks2.length; i++) {
      const tick = this.tickFormat(ticks2[i]).toString();
      let tickLength = tick.length;
      if (this.trimTicks) {
        tickLength = this.tickTrim(tick).length;
      }
      if (tickLength > this.maxTicksLength) {
        this.maxTicksLength = tickLength;
      }
    }
    const len = Math.min(this.maxTicksLength, this.maxAllowedLength);
    const charWidth = 7;
    const wordWidth = len * charWidth;
    let baseWidth = wordWidth;
    const maxBaseWidth = Math.floor(this.width / ticks2.length);
    while (baseWidth > maxBaseWidth && angle > -90) {
      angle -= 30;
      baseWidth = Math.cos(angle * (Math.PI / 180)) * wordWidth;
    }
    let labelHeight = 14;
    if (this.isWrapTicksSupported) {
      const longestTick = this.ticks.reduce((earlier, current) => current.length > earlier.length ? current : earlier, "");
      const tickLines = this.tickChunks(longestTick);
      labelHeight = 14 * (tickLines.length || 1);
      this.maxPossibleLengthForTickIfWrapped = this.getMaxPossibleLengthForTick(longestTick);
    }
    const requiredHeight = angle !== 0 ? Math.max(Math.abs(Math.sin(angle * Math.PI / 180)) * this.maxTickLength * charWidth, 10) : labelHeight;
    this.approxHeight = Math.min(requiredHeight, 200);
    return angle;
  }
  getTicks() {
    let ticks2;
    const maxTicks = this.getMaxTicks(20);
    const maxScaleTicks = this.getMaxTicks(100);
    if (this.tickValues) {
      ticks2 = this.tickValues;
    } else if (this.scale.ticks) {
      ticks2 = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
    } else {
      ticks2 = this.scale.domain();
      ticks2 = reduceTicks(ticks2, maxTicks);
    }
    return ticks2;
  }
  getMaxTicks(tickWidth) {
    return Math.floor(this.width / tickWidth);
  }
  tickTransform(tick) {
    return "translate(" + this.adjustedScale(tick) + "," + this.verticalSpacing + ")";
  }
  gridLineTransform() {
    return `translate(0,${-this.verticalSpacing - 5})`;
  }
  tickTrim(label) {
    return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
  }
  getMaxPossibleLengthForTick(longestLabel) {
    if (this.scale.bandwidth) {
      const averageCharacterWidth = 7;
      const maxCharacters = Math.floor(this.scale.bandwidth() / averageCharacterWidth);
      const truncatedText = longestLabel.slice(0, maxCharacters);
      return Math.max(truncatedText.length, this.maxTickLength);
    }
    return this.maxTickLength;
  }
  tickChunks(label) {
    if (label.toString().length > this.maxTickLength && this.scale.bandwidth) {
      const maxAllowedLines = 5;
      let maxLines = this.rotateTicks ? Math.floor(this.scale.step() / 14) : maxAllowedLines;
      if (maxLines <= 1) {
        return [this.tickTrim(label)];
      }
      let possibleStringLength = Math.max(this.maxPossibleLengthForTickIfWrapped, this.maxTickLength);
      if (!isPlatformBrowser(this.platformId)) {
        possibleStringLength = Math.floor(Math.min(this.approxHeight / maxAllowedLines, Math.max(this.maxPossibleLengthForTickIfWrapped, this.maxTickLength)));
      }
      maxLines = Math.min(maxLines, maxAllowedLines);
      const lines = getTickLines(label, possibleStringLength, maxLines < 1 ? 1 : maxLines);
      return lines;
    }
    return [this.tickTrim(label)];
  }
};
_XAxisTicksComponent.\u0275fac = function XAxisTicksComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _XAxisTicksComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
};
_XAxisTicksComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _XAxisTicksComponent,
  selectors: [["g", "ngx-charts-x-axis-ticks", ""]],
  viewQuery: function XAxisTicksComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c42, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ticksElement = _t.first);
    }
  },
  inputs: {
    scale: "scale",
    orient: "orient",
    tickArguments: "tickArguments",
    tickValues: "tickValues",
    tickStroke: "tickStroke",
    trimTicks: "trimTicks",
    maxTickLength: "maxTickLength",
    tickFormatting: "tickFormatting",
    showGridLines: "showGridLines",
    gridLineHeight: "gridLineHeight",
    width: "width",
    rotateTicks: "rotateTicks",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    dimensionsChanged: "dimensionsChanged"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c52,
  decls: 4,
  vars: 2,
  consts: [["ticksel", ""], ["tmplMultilineTick", ""], ["tmplSinglelineTick", ""], ["class", "tick", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], [1, "tick"], [4, "ngIf"], ["stroke-width", "0.01", "font-size", "12px"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["x", "0", 4, "ngFor", "ngForOf"], ["x", "0"], ["y2", "0", 1, "gridline-path", "gridline-path-vertical"]],
  template: function XAxisTicksComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g", null, 0);
      \u0275\u0275template(2, XAxisTicksComponent__svg_g_2_Template, 2, 2, "g", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, XAxisTicksComponent__svg_g_3_Template, 2, 2, "g", 4);
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.ticks);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.ticks);
    }
  },
  dependencies: [NgForOf, NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var XAxisTicksComponent = _XAxisTicksComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisTicksComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-x-axis-ticks]",
      template: `
    <svg:g #ticksel>
      <svg:g *ngFor="let tick of ticks" class="tick" [attr.transform]="tickTransform(tick)">
        <ng-container *ngIf="tickFormat(tick) as tickFormatted">
          <title>{{ tickFormatted }}</title>
          <svg:text
            stroke-width="0.01"
            font-size="12px"
            [attr.text-anchor]="textAnchor"
            [attr.transform]="textTransform"
          >
            <ng-container *ngIf="isWrapTicksSupported; then tmplMultilineTick; else tmplSinglelineTick"></ng-container>
          </svg:text>

          <ng-template #tmplMultilineTick>
            <ng-container *ngIf="tickChunks(tick) as tickLines">
              <svg:tspan *ngFor="let tickLine of tickLines; let i = index" x="0" [attr.y]="i * 12">
                {{ tickLine }}
              </svg:tspan>
            </ng-container>
          </ng-template>

          <ng-template #tmplSinglelineTick>
            {{ tickTrim(tickFormatted) }}
          </ng-template>
        </ng-container>
      </svg:g>
    </svg:g>

    <svg:g *ngFor="let tick of ticks" [attr.transform]="tickTransform(tick)">
      <svg:g *ngIf="showGridLines" [attr.transform]="gridLineTransform()">
        <svg:line class="gridline-path gridline-path-vertical" [attr.y1]="-gridLineHeight" y2="0" />
      </svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    scale: [{
      type: Input
    }],
    orient: [{
      type: Input
    }],
    tickArguments: [{
      type: Input
    }],
    tickValues: [{
      type: Input
    }],
    tickStroke: [{
      type: Input
    }],
    trimTicks: [{
      type: Input
    }],
    maxTickLength: [{
      type: Input
    }],
    tickFormatting: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    gridLineHeight: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    rotateTicks: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    dimensionsChanged: [{
      type: Output
    }],
    ticksElement: [{
      type: ViewChild,
      args: ["ticksel"]
    }]
  });
})();
var _XAxisComponent = class _XAxisComponent {
  constructor() {
    this.rotateTicks = true;
    this.showGridLines = false;
    this.xOrient = Orientation.Bottom;
    this.xAxisOffset = 0;
    this.wrapTicks = false;
    this.dimensionsChanged = new EventEmitter();
    this.xAxisClassName = "x axis";
    this.labelOffset = 0;
    this.fill = "none";
    this.stroke = "stroke";
    this.tickStroke = "#ccc";
    this.strokeWidth = "none";
    this.padding = 5;
    this.orientation = Orientation;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.transform = `translate(0,${this.xAxisOffset + this.padding + this.dims.height})`;
    if (typeof this.xAxisTickCount !== "undefined") {
      this.tickArguments = [this.xAxisTickCount];
    }
  }
  emitTicksHeight({
    height
  }) {
    const newLabelOffset = height + 25 + 5;
    if (newLabelOffset !== this.labelOffset) {
      this.labelOffset = newLabelOffset;
      setTimeout(() => {
        this.dimensionsChanged.emit({
          height
        });
      }, 0);
    }
  }
};
_XAxisComponent.\u0275fac = function XAxisComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _XAxisComponent)();
};
_XAxisComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _XAxisComponent,
  selectors: [["g", "ngx-charts-x-axis", ""]],
  viewQuery: function XAxisComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(XAxisTicksComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ticksComponent = _t.first);
    }
  },
  inputs: {
    xScale: "xScale",
    dims: "dims",
    trimTicks: "trimTicks",
    rotateTicks: "rotateTicks",
    maxTickLength: "maxTickLength",
    tickFormatting: "tickFormatting",
    showGridLines: "showGridLines",
    showLabel: "showLabel",
    labelText: "labelText",
    ticks: "ticks",
    xAxisTickCount: "xAxisTickCount",
    xOrient: "xOrient",
    xAxisOffset: "xAxisOffset",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    dimensionsChanged: "dimensionsChanged"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c62,
  decls: 3,
  vars: 4,
  consts: [["ngx-charts-x-axis-ticks", "", 3, "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-x-axis-ticks", "", 3, "dimensionsChanged", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickStroke", "scale", "orient", "showGridLines", "gridLineHeight", "width", "tickValues", "wrapTicks"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]],
  template: function XAxisComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g");
      \u0275\u0275template(1, XAxisComponent__svg_g_1_Template, 1, 13, "g", 0)(2, XAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275attribute("class", ctx.xAxisClassName)("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xScale);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showLabel);
    }
  },
  dependencies: [NgIf, AxisLabelComponent, XAxisTicksComponent],
  encapsulation: 2,
  changeDetection: 0
});
var XAxisComponent = _XAxisComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-x-axis]",
      template: `
    <svg:g [attr.class]="xAxisClassName" [attr.transform]="transform">
      <svg:g
        ngx-charts-x-axis-ticks
        *ngIf="xScale"
        [trimTicks]="trimTicks"
        [rotateTicks]="rotateTicks"
        [maxTickLength]="maxTickLength"
        [tickFormatting]="tickFormatting"
        [tickArguments]="tickArguments"
        [tickStroke]="tickStroke"
        [scale]="xScale"
        [orient]="xOrient"
        [showGridLines]="showGridLines"
        [gridLineHeight]="dims.height"
        [width]="dims.width"
        [tickValues]="ticks"
        [wrapTicks]="wrapTicks"
        (dimensionsChanged)="emitTicksHeight($event)"
      />
      <svg:g
        ngx-charts-axis-label
        *ngIf="showLabel"
        [label]="labelText"
        [offset]="labelOffset"
        [orient]="orientation.Bottom"
        [height]="dims.height"
        [width]="dims.width"
      ></svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    xScale: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    trimTicks: [{
      type: Input
    }],
    rotateTicks: [{
      type: Input
    }],
    maxTickLength: [{
      type: Input
    }],
    tickFormatting: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    showLabel: [{
      type: Input
    }],
    labelText: [{
      type: Input
    }],
    ticks: [{
      type: Input
    }],
    xAxisTickCount: [{
      type: Input
    }],
    xOrient: [{
      type: Input
    }],
    xAxisOffset: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    dimensionsChanged: [{
      type: Output
    }],
    ticksComponent: [{
      type: ViewChild,
      args: [XAxisTicksComponent]
    }]
  });
})();
function roundedRect(x4, y3, w2, h, r2, [tl, tr, bl, br]) {
  let retval = "";
  w2 = Math.floor(w2);
  h = Math.floor(h);
  w2 = w2 === 0 ? 1 : w2;
  h = h === 0 ? 1 : h;
  retval = `M${[x4 + r2, y3]}`;
  retval += `h${w2 - 2 * r2}`;
  if (tr) {
    retval += `a${[r2, r2]} 0 0 1 ${[r2, r2]}`;
  } else {
    retval += `h${r2}v${r2}`;
  }
  retval += `v${h - 2 * r2}`;
  if (br) {
    retval += `a${[r2, r2]} 0 0 1 ${[-r2, r2]}`;
  } else {
    retval += `v${r2}h${-r2}`;
  }
  retval += `h${2 * r2 - w2}`;
  if (bl) {
    retval += `a${[r2, r2]} 0 0 1 ${[-r2, -r2]}`;
  } else {
    retval += `h${-r2}v${-r2}`;
  }
  retval += `v${2 * r2 - h}`;
  if (tl) {
    retval += `a${[r2, r2]} 0 0 1 ${[r2, -r2]}`;
  } else {
    retval += `v${-r2}h${r2}`;
  }
  retval += `z`;
  return retval;
}
var _YAxisTicksComponent = class _YAxisTicksComponent {
  constructor(platformId) {
    this.platformId = platformId;
    this.tickArguments = [5];
    this.tickStroke = "#ccc";
    this.trimTicks = true;
    this.maxTickLength = 16;
    this.showGridLines = false;
    this.showRefLabels = false;
    this.showRefLines = false;
    this.wrapTicks = false;
    this.dimensionsChanged = new EventEmitter();
    this.innerTickSize = 6;
    this.tickPadding = 3;
    this.verticalSpacing = 20;
    this.textAnchor = TextAnchor.Middle;
    this.width = 0;
    this.outerTickSize = 6;
    this.rotateLabels = false;
    this.referenceLineLength = 0;
    this.Orientation = Orientation;
  }
  ngOnChanges(changes) {
    this.update();
  }
  ngAfterViewInit() {
    setTimeout(() => this.updateDims());
  }
  updateDims() {
    if (!isPlatformBrowser(this.platformId)) {
      this.width = this.getApproximateAxisWidth();
      this.dimensionsChanged.emit({
        width: this.width
      });
      return;
    }
    const width = parseInt(this.ticksElement.nativeElement.getBoundingClientRect().width, 10);
    if (width !== this.width) {
      this.width = width;
      this.dimensionsChanged.emit({
        width
      });
      setTimeout(() => this.updateDims());
    }
  }
  update() {
    const scale = this.scale;
    const sign = this.orient === Orientation.Top || this.orient === Orientation.Right ? -1 : 1;
    this.tickSpacing = Math.max(this.innerTickSize, 0) + this.tickPadding;
    this.ticks = this.getTicks();
    if (this.tickFormatting) {
      this.tickFormat = this.tickFormatting;
    } else if (scale.tickFormat) {
      this.tickFormat = scale.tickFormat.apply(scale, this.tickArguments);
    } else {
      this.tickFormat = function(d) {
        if (d.constructor.name === "Date") {
          return d.toLocaleDateString();
        }
        return d.toLocaleString();
      };
    }
    this.adjustedScale = scale.bandwidth ? (d) => {
      const positionMiddle = scale(d) + scale.bandwidth() * 0.5;
      if (this.wrapTicks && d.toString().length > this.maxTickLength) {
        const chunksLength = this.tickChunks(d).length;
        if (chunksLength === 1) {
          return positionMiddle;
        }
        const bandWidth = scale.bandwidth();
        const heightOfLines = chunksLength * 8;
        const availableFreeSpace = bandWidth * 0.5 - heightOfLines * 0.5;
        return scale(d) + availableFreeSpace;
      }
      return positionMiddle;
    } : scale;
    if (this.showRefLines && this.referenceLines) {
      this.setReferencelines();
    }
    switch (this.orient) {
      case Orientation.Top:
        this.transform = function(tick) {
          return "translate(" + this.adjustedScale(tick) + ",0)";
        };
        this.textAnchor = TextAnchor.Middle;
        this.y2 = this.innerTickSize * sign;
        this.y1 = this.tickSpacing * sign;
        this.dy = sign < 0 ? "0em" : ".71em";
        break;
      case Orientation.Bottom:
        this.transform = function(tick) {
          return "translate(" + this.adjustedScale(tick) + ",0)";
        };
        this.textAnchor = TextAnchor.Middle;
        this.y2 = this.innerTickSize * sign;
        this.y1 = this.tickSpacing * sign;
        this.dy = sign < 0 ? "0em" : ".71em";
        break;
      case Orientation.Left:
        this.transform = function(tick) {
          return "translate(0," + this.adjustedScale(tick) + ")";
        };
        this.textAnchor = TextAnchor.End;
        this.x2 = this.innerTickSize * -sign;
        this.x1 = this.tickSpacing * -sign;
        this.dy = ".32em";
        break;
      case Orientation.Right:
        this.transform = function(tick) {
          return "translate(0," + this.adjustedScale(tick) + ")";
        };
        this.textAnchor = TextAnchor.Start;
        this.x2 = this.innerTickSize * -sign;
        this.x1 = this.tickSpacing * -sign;
        this.dy = ".32em";
        break;
      default:
    }
    setTimeout(() => this.updateDims());
  }
  setReferencelines() {
    this.refMin = this.adjustedScale(Math.min.apply(null, this.referenceLines.map((item) => item.value)));
    this.refMax = this.adjustedScale(Math.max.apply(null, this.referenceLines.map((item) => item.value)));
    this.referenceLineLength = this.referenceLines.length;
    this.referenceAreaPath = roundedRect(0, this.refMax, this.gridLineWidth, this.refMin - this.refMax, 0, [false, false, false, false]);
  }
  getTicks() {
    let ticks2;
    const maxTicks = this.getMaxTicks(20);
    const maxScaleTicks = this.getMaxTicks(50);
    if (this.tickValues) {
      ticks2 = this.tickValues;
    } else if (this.scale.ticks) {
      ticks2 = this.scale.ticks.apply(this.scale, [maxScaleTicks]);
    } else {
      ticks2 = this.scale.domain();
      ticks2 = reduceTicks(ticks2, maxTicks);
    }
    return ticks2;
  }
  getMaxTicks(tickHeight) {
    return Math.floor(this.height / tickHeight);
  }
  tickTransform(tick) {
    return `translate(${this.adjustedScale(tick)},${this.verticalSpacing})`;
  }
  gridLineTransform() {
    return `translate(5,0)`;
  }
  tickTrim(label) {
    return this.trimTicks ? trimLabel(label, this.maxTickLength) : label;
  }
  getApproximateAxisWidth() {
    const maxChars = Math.max(...this.ticks.map((t2) => this.tickTrim(this.tickFormat(t2)).length));
    const charWidth = 7;
    return maxChars * charWidth;
  }
  tickChunks(label) {
    if (label.toString().length > this.maxTickLength && this.scale.bandwidth) {
      const preferredWidth = this.maxTickLength;
      const maxLines = Math.floor(this.scale.bandwidth() / 15);
      if (maxLines <= 1) {
        return [this.tickTrim(label)];
      }
      return getTickLines(label, preferredWidth, Math.min(maxLines, 5));
    }
    return [this.tickFormat(label)];
  }
};
_YAxisTicksComponent.\u0275fac = function YAxisTicksComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _YAxisTicksComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
};
_YAxisTicksComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _YAxisTicksComponent,
  selectors: [["g", "ngx-charts-y-axis-ticks", ""]],
  viewQuery: function YAxisTicksComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c42, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ticksElement = _t.first);
    }
  },
  inputs: {
    scale: "scale",
    orient: "orient",
    tickArguments: "tickArguments",
    tickValues: "tickValues",
    tickStroke: "tickStroke",
    trimTicks: "trimTicks",
    maxTickLength: "maxTickLength",
    tickFormatting: "tickFormatting",
    showGridLines: "showGridLines",
    gridLineWidth: "gridLineWidth",
    height: "height",
    referenceLines: "referenceLines",
    showRefLabels: "showRefLabels",
    showRefLines: "showRefLines",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    dimensionsChanged: "dimensionsChanged"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c72,
  decls: 6,
  vars: 4,
  consts: [["ticksel", ""], ["tmplMultilineTick", ""], ["tmplSinglelineTick", ""], ["class", "tick", 4, "ngFor", "ngForOf"], ["class", "reference-area", 4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "tick"], [4, "ngIf"], ["stroke-width", "0.01"], [4, "ngIf", "ngIfThen", "ngIfElse"], [4, "ngIf", "ngIfElse"], ["x", "0", 4, "ngFor", "ngForOf"], ["x", "0"], [1, "reference-area"], ["class", "gridline-path gridline-path-horizontal", "x1", "0", 4, "ngIf"], ["x1", "0", 1, "gridline-path", "gridline-path-horizontal"], ["x1", "0", 1, "refline-path", "gridline-path-horizontal"], [1, "refline-label"]],
  template: function YAxisTicksComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g", null, 0);
      \u0275\u0275template(2, YAxisTicksComponent__svg_g_2_Template, 2, 2, "g", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, YAxisTicksComponent__svg_path_3_Template, 1, 2, "path", 4)(4, YAxisTicksComponent__svg_g_4_Template, 2, 2, "g", 5)(5, YAxisTicksComponent__svg_g_5_Template, 2, 1, "g", 5);
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngForOf", ctx.ticks);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.referenceLineLength > 1 && ctx.refMax && ctx.refMin && ctx.showRefLines);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.ticks);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.referenceLines);
    }
  },
  dependencies: [NgForOf, NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var YAxisTicksComponent = _YAxisTicksComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisTicksComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-y-axis-ticks]",
      template: `
    <svg:g #ticksel>
      <svg:g *ngFor="let tick of ticks" class="tick" [attr.transform]="transform(tick)">
        <ng-container *ngIf="tickFormat(tick) as tickFormatted">
          <title>{{ tickFormatted }}</title>
          <svg:text
            stroke-width="0.01"
            [attr.dy]="dy"
            [attr.x]="x1"
            [attr.y]="y1"
            [attr.text-anchor]="textAnchor"
            [style.font-size]="'12px'"
          >
            <ng-container *ngIf="wrapTicks; then tmplMultilineTick; else tmplSinglelineTick"></ng-container>
          </svg:text>

          <ng-template #tmplMultilineTick>
            <ng-container *ngIf="tickChunks(tick) as tickLines">
              <ng-container *ngIf="tickLines.length > 1; else tmplSinglelineTick">
                <svg:tspan *ngFor="let tickLine of tickLines; let i = index" x="0" [attr.y]="i * (8 + tickSpacing)">
                  {{ tickLine }}
                </svg:tspan>
              </ng-container>
            </ng-container>
          </ng-template>

          <ng-template #tmplSinglelineTick>
            {{ tickTrim(tickFormatted) }}
          </ng-template>
        </ng-container>
      </svg:g>
    </svg:g>

    <svg:path
      *ngIf="referenceLineLength > 1 && refMax && refMin && showRefLines"
      class="reference-area"
      [attr.d]="referenceAreaPath"
      [attr.transform]="gridLineTransform()"
    />
    <svg:g *ngFor="let tick of ticks" [attr.transform]="transform(tick)">
      <svg:g *ngIf="showGridLines" [attr.transform]="gridLineTransform()">
        <svg:line
          *ngIf="orient === Orientation.Left"
          class="gridline-path gridline-path-horizontal"
          x1="0"
          [attr.x2]="gridLineWidth"
        />
        <svg:line
          *ngIf="orient === Orientation.Right"
          class="gridline-path gridline-path-horizontal"
          x1="0"
          [attr.x2]="-gridLineWidth"
        />
      </svg:g>
    </svg:g>

    <svg:g *ngFor="let refLine of referenceLines">
      <svg:g *ngIf="showRefLines" [attr.transform]="transform(refLine.value)">
        <svg:line
          class="refline-path gridline-path-horizontal"
          x1="0"
          [attr.x2]="gridLineWidth"
          [attr.transform]="gridLineTransform()"
        />
        <svg:g *ngIf="showRefLabels">
          <title>{{ tickTrim(tickFormat(refLine.value)) }}</title>
          <svg:text
            class="refline-label"
            [attr.dy]="dy"
            [attr.y]="-6"
            [attr.x]="gridLineWidth"
            [attr.text-anchor]="textAnchor"
          >
            {{ refLine.name }}
          </svg:text>
        </svg:g>
      </svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    scale: [{
      type: Input
    }],
    orient: [{
      type: Input
    }],
    tickArguments: [{
      type: Input
    }],
    tickValues: [{
      type: Input
    }],
    tickStroke: [{
      type: Input
    }],
    trimTicks: [{
      type: Input
    }],
    maxTickLength: [{
      type: Input
    }],
    tickFormatting: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    gridLineWidth: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    referenceLines: [{
      type: Input
    }],
    showRefLabels: [{
      type: Input
    }],
    showRefLines: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    dimensionsChanged: [{
      type: Output
    }],
    ticksElement: [{
      type: ViewChild,
      args: ["ticksel"]
    }]
  });
})();
var _YAxisComponent = class _YAxisComponent {
  constructor() {
    this.showGridLines = false;
    this.yOrient = Orientation.Left;
    this.yAxisOffset = 0;
    this.wrapTicks = false;
    this.dimensionsChanged = new EventEmitter();
    this.yAxisClassName = "y axis";
    this.labelOffset = 15;
    this.fill = "none";
    this.stroke = "#CCC";
    this.tickStroke = "#CCC";
    this.strokeWidth = 1;
    this.padding = 5;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.offset = -(this.yAxisOffset + this.padding);
    if (this.yOrient === Orientation.Right) {
      this.labelOffset = 65;
      this.transform = `translate(${this.offset + this.dims.width} , 0)`;
    } else {
      this.transform = `translate(${this.offset} , 0)`;
    }
    if (this.yAxisTickCount !== void 0) {
      this.tickArguments = [this.yAxisTickCount];
    }
  }
  emitTicksWidth({
    width
  }) {
    if (width !== this.labelOffset && this.yOrient === Orientation.Right) {
      this.labelOffset = width + this.labelOffset;
      setTimeout(() => {
        this.dimensionsChanged.emit({
          width
        });
      }, 0);
    } else if (width !== this.labelOffset) {
      this.labelOffset = width;
      setTimeout(() => {
        this.dimensionsChanged.emit({
          width
        });
      }, 0);
    }
  }
};
_YAxisComponent.\u0275fac = function YAxisComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _YAxisComponent)();
};
_YAxisComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _YAxisComponent,
  selectors: [["g", "ngx-charts-y-axis", ""]],
  viewQuery: function YAxisComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(YAxisTicksComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ticksComponent = _t.first);
    }
  },
  inputs: {
    yScale: "yScale",
    dims: "dims",
    trimTicks: "trimTicks",
    maxTickLength: "maxTickLength",
    tickFormatting: "tickFormatting",
    ticks: "ticks",
    showGridLines: "showGridLines",
    showLabel: "showLabel",
    labelText: "labelText",
    yAxisTickCount: "yAxisTickCount",
    yOrient: "yOrient",
    referenceLines: "referenceLines",
    showRefLines: "showRefLines",
    showRefLabels: "showRefLabels",
    yAxisOffset: "yAxisOffset",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    dimensionsChanged: "dimensionsChanged"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c82,
  decls: 3,
  vars: 4,
  consts: [["ngx-charts-y-axis-ticks", "", 3, "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["ngx-charts-y-axis-ticks", "", 3, "dimensionsChanged", "trimTicks", "maxTickLength", "tickFormatting", "tickArguments", "tickValues", "tickStroke", "scale", "orient", "showGridLines", "gridLineWidth", "referenceLines", "showRefLines", "showRefLabels", "height", "wrapTicks"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"]],
  template: function YAxisComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g");
      \u0275\u0275template(1, YAxisComponent__svg_g_1_Template, 1, 15, "g", 0)(2, YAxisComponent__svg_g_2_Template, 1, 5, "g", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275attribute("class", ctx.yAxisClassName)("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yScale);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showLabel);
    }
  },
  dependencies: [NgIf, AxisLabelComponent, YAxisTicksComponent],
  encapsulation: 2,
  changeDetection: 0
});
var YAxisComponent = _YAxisComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-y-axis]",
      template: `
    <svg:g [attr.class]="yAxisClassName" [attr.transform]="transform">
      <svg:g
        ngx-charts-y-axis-ticks
        *ngIf="yScale"
        [trimTicks]="trimTicks"
        [maxTickLength]="maxTickLength"
        [tickFormatting]="tickFormatting"
        [tickArguments]="tickArguments"
        [tickValues]="ticks"
        [tickStroke]="tickStroke"
        [scale]="yScale"
        [orient]="yOrient"
        [showGridLines]="showGridLines"
        [gridLineWidth]="dims.width"
        [referenceLines]="referenceLines"
        [showRefLines]="showRefLines"
        [showRefLabels]="showRefLabels"
        [height]="dims.height"
        [wrapTicks]="wrapTicks"
        (dimensionsChanged)="emitTicksWidth($event)"
      />

      <svg:g
        ngx-charts-axis-label
        *ngIf="showLabel"
        [label]="labelText"
        [offset]="labelOffset"
        [orient]="yOrient"
        [height]="dims.height"
        [width]="dims.width"
      ></svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    yScale: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    trimTicks: [{
      type: Input
    }],
    maxTickLength: [{
      type: Input
    }],
    tickFormatting: [{
      type: Input
    }],
    ticks: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    showLabel: [{
      type: Input
    }],
    labelText: [{
      type: Input
    }],
    yAxisTickCount: [{
      type: Input
    }],
    yOrient: [{
      type: Input
    }],
    referenceLines: [{
      type: Input
    }],
    showRefLines: [{
      type: Input
    }],
    showRefLabels: [{
      type: Input
    }],
    yAxisOffset: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    dimensionsChanged: [{
      type: Output
    }],
    ticksComponent: [{
      type: ViewChild,
      args: [YAxisTicksComponent]
    }]
  });
})();
var _AxesModule = class _AxesModule {
};
_AxesModule.\u0275fac = function AxesModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AxesModule)();
};
_AxesModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _AxesModule
});
_AxesModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule]
});
var AxesModule = _AxesModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxesModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent],
      exports: [AxisLabelComponent, XAxisComponent, XAxisTicksComponent, YAxisComponent, YAxisTicksComponent]
    }]
  }], null, null);
})();
var StyleTypes;
(function(StyleTypes2) {
  StyleTypes2["popover"] = "popover";
  StyleTypes2["tooltip"] = "tooltip";
})(StyleTypes || (StyleTypes = {}));
var ShowTypes;
(function(ShowTypes2) {
  ShowTypes2[ShowTypes2["all"] = "all"] = "all";
  ShowTypes2[ShowTypes2["focus"] = "focus"] = "focus";
  ShowTypes2[ShowTypes2["mouseover"] = "mouseover"] = "mouseover";
})(ShowTypes || (ShowTypes = {}));
var _TooltipDirective = class _TooltipDirective {
  get listensForFocus() {
    return this.tooltipShowEvent === ShowTypes.all || this.tooltipShowEvent === ShowTypes.focus;
  }
  get listensForHover() {
    return this.tooltipShowEvent === ShowTypes.all || this.tooltipShowEvent === ShowTypes.mouseover;
  }
  constructor(tooltipService, viewContainerRef, renderer) {
    this.tooltipService = tooltipService;
    this.viewContainerRef = viewContainerRef;
    this.renderer = renderer;
    this.tooltipCssClass = "";
    this.tooltipAppendToBody = true;
    this.tooltipSpacing = 10;
    this.tooltipDisabled = false;
    this.tooltipShowCaret = true;
    this.tooltipPlacement = PlacementTypes.Top;
    this.tooltipAlignment = PlacementTypes.Center;
    this.tooltipType = StyleTypes.popover;
    this.tooltipCloseOnClickOutside = true;
    this.tooltipCloseOnMouseLeave = true;
    this.tooltipHideTimeout = 300;
    this.tooltipShowTimeout = 100;
    this.tooltipShowEvent = ShowTypes.all;
    this.tooltipImmediateExit = false;
    this.show = new EventEmitter();
    this.hide = new EventEmitter();
  }
  ngOnDestroy() {
    this.hideTooltip(true);
  }
  onFocus() {
    if (this.listensForFocus) {
      this.showTooltip();
    }
  }
  onBlur() {
    if (this.listensForFocus) {
      this.hideTooltip(true);
    }
  }
  onMouseEnter() {
    if (this.listensForHover) {
      this.showTooltip();
    }
  }
  onMouseLeave(target) {
    if (this.listensForHover && this.tooltipCloseOnMouseLeave) {
      clearTimeout(this.timeout);
      if (this.component) {
        const contentDom = this.component.instance.element.nativeElement;
        const contains = contentDom.contains(target);
        if (contains) return;
      }
      this.hideTooltip(this.tooltipImmediateExit);
    }
  }
  onMouseClick() {
    if (this.listensForHover) {
      this.hideTooltip(true);
    }
  }
  showTooltip(immediate) {
    if (this.component || this.tooltipDisabled) return;
    const time2 = immediate ? 0 : this.tooltipShowTimeout + (navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/) ? 400 : 0);
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => {
      this.tooltipService.destroyAll();
      const options = this.createBoundOptions();
      this.component = this.tooltipService.create(options);
      setTimeout(() => {
        if (this.component) {
          this.addHideListeners(this.component.instance.element.nativeElement);
        }
      }, 10);
      this.show.emit(true);
    }, time2);
  }
  addHideListeners(tooltip) {
    this.mouseEnterContentEvent = this.renderer.listen(tooltip, "mouseenter", () => {
      clearTimeout(this.timeout);
    });
    if (this.tooltipCloseOnMouseLeave) {
      this.mouseLeaveContentEvent = this.renderer.listen(tooltip, "mouseleave", () => {
        this.hideTooltip(this.tooltipImmediateExit);
      });
    }
    if (this.tooltipCloseOnClickOutside) {
      this.documentClickEvent = this.renderer.listen("window", "click", (event) => {
        const contains = tooltip.contains(event.target);
        if (!contains) this.hideTooltip();
      });
    }
  }
  hideTooltip(immediate = false) {
    if (!this.component) return;
    const destroyFn = () => {
      if (this.mouseLeaveContentEvent) this.mouseLeaveContentEvent();
      if (this.mouseEnterContentEvent) this.mouseEnterContentEvent();
      if (this.documentClickEvent) this.documentClickEvent();
      this.hide.emit(true);
      this.tooltipService.destroy(this.component);
      this.component = void 0;
    };
    clearTimeout(this.timeout);
    if (!immediate) {
      this.timeout = setTimeout(destroyFn, this.tooltipHideTimeout);
    } else {
      destroyFn();
    }
  }
  createBoundOptions() {
    return {
      title: this.tooltipTitle,
      template: this.tooltipTemplate,
      host: this.viewContainerRef.element,
      placement: this.tooltipPlacement,
      alignment: this.tooltipAlignment,
      type: this.tooltipType,
      showCaret: this.tooltipShowCaret,
      cssClass: this.tooltipCssClass,
      spacing: this.tooltipSpacing,
      context: this.tooltipContext
    };
  }
};
_TooltipDirective.\u0275fac = function TooltipDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TooltipDirective)(\u0275\u0275directiveInject(TooltipService), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(Renderer2));
};
_TooltipDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
  type: _TooltipDirective,
  selectors: [["", "ngx-tooltip", ""]],
  hostBindings: function TooltipDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("focusin", function TooltipDirective_focusin_HostBindingHandler() {
        return ctx.onFocus();
      })("blur", function TooltipDirective_blur_HostBindingHandler() {
        return ctx.onBlur();
      })("mouseenter", function TooltipDirective_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function TooltipDirective_mouseleave_HostBindingHandler($event) {
        return ctx.onMouseLeave($event.target);
      })("click", function TooltipDirective_click_HostBindingHandler() {
        return ctx.onMouseClick();
      });
    }
  },
  inputs: {
    tooltipCssClass: "tooltipCssClass",
    tooltipTitle: "tooltipTitle",
    tooltipAppendToBody: "tooltipAppendToBody",
    tooltipSpacing: "tooltipSpacing",
    tooltipDisabled: "tooltipDisabled",
    tooltipShowCaret: "tooltipShowCaret",
    tooltipPlacement: "tooltipPlacement",
    tooltipAlignment: "tooltipAlignment",
    tooltipType: "tooltipType",
    tooltipCloseOnClickOutside: "tooltipCloseOnClickOutside",
    tooltipCloseOnMouseLeave: "tooltipCloseOnMouseLeave",
    tooltipHideTimeout: "tooltipHideTimeout",
    tooltipShowTimeout: "tooltipShowTimeout",
    tooltipTemplate: "tooltipTemplate",
    tooltipShowEvent: "tooltipShowEvent",
    tooltipContext: "tooltipContext",
    tooltipImmediateExit: "tooltipImmediateExit"
  },
  outputs: {
    show: "show",
    hide: "hide"
  },
  standalone: false
});
var TooltipDirective = _TooltipDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[ngx-tooltip]"
    }]
  }], () => [{
    type: TooltipService
  }, {
    type: ViewContainerRef
  }, {
    type: Renderer2
  }], {
    tooltipCssClass: [{
      type: Input
    }],
    tooltipTitle: [{
      type: Input
    }],
    tooltipAppendToBody: [{
      type: Input
    }],
    tooltipSpacing: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipShowCaret: [{
      type: Input
    }],
    tooltipPlacement: [{
      type: Input
    }],
    tooltipAlignment: [{
      type: Input
    }],
    tooltipType: [{
      type: Input
    }],
    tooltipCloseOnClickOutside: [{
      type: Input
    }],
    tooltipCloseOnMouseLeave: [{
      type: Input
    }],
    tooltipHideTimeout: [{
      type: Input
    }],
    tooltipShowTimeout: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    tooltipShowEvent: [{
      type: Input
    }],
    tooltipContext: [{
      type: Input
    }],
    tooltipImmediateExit: [{
      type: Input
    }],
    show: [{
      type: Output
    }],
    hide: [{
      type: Output
    }],
    onFocus: [{
      type: HostListener,
      args: ["focusin"]
    }],
    onBlur: [{
      type: HostListener,
      args: ["blur"]
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave", ["$event.target"]]
    }],
    onMouseClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _TooltipModule = class _TooltipModule {
};
_TooltipModule.\u0275fac = function TooltipModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TooltipModule)();
};
_TooltipModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _TooltipModule
});
_TooltipModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  providers: [InjectionService, TooltipService],
  imports: [CommonModule]
});
var TooltipModule = _TooltipModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipModule, [{
    type: NgModule,
    args: [{
      declarations: [TooltipContentComponent, TooltipDirective],
      providers: [InjectionService, TooltipService],
      exports: [TooltipContentComponent, TooltipDirective],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var cache = {};
function id2() {
  let newId2 = ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
  newId2 = `a${newId2}`;
  if (!cache[newId2]) {
    cache[newId2] = true;
    return newId2;
  }
  return id2();
}
var BarOrientation;
(function(BarOrientation2) {
  BarOrientation2["Vertical"] = "vertical";
  BarOrientation2["Horizontal"] = "horizontal";
})(BarOrientation || (BarOrientation = {}));
var _CircleComponent = class _CircleComponent {
  constructor() {
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
  }
  onClick() {
    this.select.emit(this.data);
  }
  onMouseEnter() {
    this.activate.emit(this.data);
  }
  onMouseLeave() {
    this.deactivate.emit(this.data);
  }
  ngOnChanges(changes) {
    this.classNames = Array.isArray(this.classNames) ? this.classNames.join(" ") : "";
    this.classNames += "circle";
  }
};
_CircleComponent.\u0275fac = function CircleComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CircleComponent)();
};
_CircleComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CircleComponent,
  selectors: [["g", "ngx-charts-circle", ""]],
  hostBindings: function CircleComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("click", function CircleComponent_click_HostBindingHandler() {
        return ctx.onClick();
      })("mouseenter", function CircleComponent_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function CircleComponent_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      });
    }
  },
  inputs: {
    cx: "cx",
    cy: "cy",
    r: "r",
    fill: "fill",
    stroke: "stroke",
    data: "data",
    classNames: "classNames",
    circleOpacity: "circleOpacity",
    pointerEvents: "pointerEvents"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c92,
  decls: 1,
  vars: 8,
  template: function CircleComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275element(0, "circle");
    }
    if (rf & 2) {
      \u0275\u0275attribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r)("fill", ctx.fill)("stroke", ctx.stroke)("opacity", ctx.circleOpacity)("class", ctx.classNames)("pointer-events", ctx.pointerEvents);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var CircleComponent = _CircleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircleComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-circle]",
      template: `
    <svg:circle
      [attr.cx]="cx"
      [attr.cy]="cy"
      [attr.r]="r"
      [attr.fill]="fill"
      [attr.stroke]="stroke"
      [attr.opacity]="circleOpacity"
      [attr.class]="classNames"
      [attr.pointer-events]="pointerEvents"
    />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    cx: [{
      type: Input
    }],
    cy: [{
      type: Input
    }],
    r: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    stroke: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    classNames: [{
      type: Input
    }],
    circleOpacity: [{
      type: Input
    }],
    pointerEvents: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var _SvgLinearGradientComponent = class _SvgLinearGradientComponent {
  constructor() {
    this.orientation = BarOrientation.Vertical;
  }
  ngOnChanges(changes) {
    this.x1 = "0%";
    this.x2 = "0%";
    this.y1 = "0%";
    this.y2 = "0%";
    if (this.orientation === BarOrientation.Horizontal) {
      this.x2 = "100%";
    } else if (this.orientation === BarOrientation.Vertical) {
      this.y1 = "100%";
    }
  }
};
_SvgLinearGradientComponent.\u0275fac = function SvgLinearGradientComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _SvgLinearGradientComponent)();
};
_SvgLinearGradientComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SvgLinearGradientComponent,
  selectors: [["g", "ngx-charts-svg-linear-gradient", ""]],
  inputs: {
    orientation: "orientation",
    name: "name",
    stops: "stops"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c10,
  decls: 2,
  vars: 6,
  consts: [[3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]],
  template: function SvgLinearGradientComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "linearGradient", 0);
      \u0275\u0275template(1, SvgLinearGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("id", ctx.name);
      \u0275\u0275attribute("x1", ctx.x1)("y1", ctx.y1)("x2", ctx.x2)("y2", ctx.y2);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.stops);
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var SvgLinearGradientComponent = _SvgLinearGradientComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SvgLinearGradientComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-svg-linear-gradient]",
      template: `
    <svg:linearGradient [id]="name" [attr.x1]="x1" [attr.y1]="y1" [attr.x2]="x2" [attr.y2]="y2">
      <svg:stop
        *ngFor="let stop of stops"
        [attr.offset]="stop.offset + '%'"
        [style.stop-color]="stop.color"
        [style.stop-opacity]="stop.opacity"
      />
    </svg:linearGradient>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    orientation: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    stops: [{
      type: Input
    }]
  });
})();
var SeriesType;
(function(SeriesType2) {
  SeriesType2["Standard"] = "standard";
  SeriesType2["Stacked"] = "stacked";
})(SeriesType || (SeriesType = {}));
var _CircleSeriesComponent = class _CircleSeriesComponent {
  constructor(platformId) {
    this.platformId = platformId;
    this.type = SeriesType.Standard;
    this.tooltipDisabled = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.barVisible = false;
    this.barOrientation = BarOrientation;
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
    this.isSSR = false;
  }
  ngOnInit() {
    this.gradientId = "grad" + id2().toString();
    this.gradientFill = `url(#${this.gradientId})`;
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  ngOnChanges() {
    this.update();
  }
  update() {
    this.circle = this.getActiveCircle();
  }
  getActiveCircle() {
    const indexActiveDataPoint = this.data.series.findIndex((d) => {
      const label = d.name;
      return label && this.visibleValue && label.toString() === this.visibleValue.toString() && d.value !== void 0;
    });
    if (indexActiveDataPoint === -1) {
      return void 0;
    }
    return this.mapDataPointToCircle(this.data.series[indexActiveDataPoint], indexActiveDataPoint);
  }
  mapDataPointToCircle(d, i) {
    const seriesName = this.data.name;
    const value2 = d.value;
    const label = d.name;
    const tooltipLabel = formatLabel(label);
    let cx;
    if (this.scaleType === ScaleType.Time) {
      cx = this.xScale(label);
    } else if (this.scaleType === ScaleType.Linear) {
      cx = this.xScale(Number(label));
    } else {
      cx = this.xScale(label);
    }
    const cy = this.yScale(this.type === SeriesType.Standard ? value2 : d.d1);
    const radius = 5;
    const height = this.yScale.range()[0] - cy;
    const opacity = 1;
    let color2;
    if (this.colors.scaleType === ScaleType.Linear) {
      if (this.type === SeriesType.Standard) {
        color2 = this.colors.getColor(value2);
      } else {
        color2 = this.colors.getColor(d.d1);
      }
    } else {
      color2 = this.colors.getColor(seriesName);
    }
    const data = Object.assign({}, d, {
      series: seriesName,
      value: value2,
      name: label
    });
    return {
      classNames: [`circle-data-${i}`],
      value: value2,
      label,
      data,
      cx,
      cy,
      radius,
      height,
      tooltipLabel,
      color: color2,
      opacity,
      seriesName,
      gradientStops: this.getGradientStops(color2),
      min: d.min,
      max: d.max
    };
  }
  getTooltipText({
    tooltipLabel,
    value: value2,
    seriesName,
    min: min6,
    max: max6
  }) {
    return `
      <span class="tooltip-label">${escapeLabel(seriesName)} \u2022 ${escapeLabel(tooltipLabel)}</span>
      <span class="tooltip-val">${value2.toLocaleString()}${this.getTooltipMinMaxText(min6, max6)}</span>
    `;
  }
  getTooltipMinMaxText(min6, max6) {
    if (min6 !== void 0 || max6 !== void 0) {
      let result = " (";
      if (min6 !== void 0) {
        if (max6 === void 0) {
          result += "\u2265";
        }
        result += min6.toLocaleString();
        if (max6 !== void 0) {
          result += " - ";
        }
      } else if (max6 !== void 0) {
        result += "\u2264";
      }
      if (max6 !== void 0) {
        result += max6.toLocaleString();
      }
      result += ")";
      return result;
    } else {
      return "";
    }
  }
  getGradientStops(color2) {
    return [{
      offset: 0,
      color: color2,
      opacity: 0.2
    }, {
      offset: 100,
      color: color2,
      opacity: 1
    }];
  }
  onClick(data) {
    this.select.emit(data);
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item !== void 0;
  }
  activateCircle() {
    this.barVisible = true;
    this.activate.emit({
      name: this.data.name
    });
  }
  deactivateCircle() {
    this.barVisible = false;
    this.circle.opacity = 0;
    this.deactivate.emit({
      name: this.data.name
    });
  }
};
_CircleSeriesComponent.\u0275fac = function CircleSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CircleSeriesComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
};
_CircleSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CircleSeriesComponent,
  selectors: [["g", "ngx-charts-circle-series", ""]],
  inputs: {
    data: "data",
    type: "type",
    xScale: "xScale",
    yScale: "yScale",
    colors: "colors",
    scaleType: "scaleType",
    visibleValue: "visibleValue",
    activeEntries: "activeEntries",
    tooltipDisabled: "tooltipDisabled",
    tooltipTemplate: "tooltipTemplate"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c11,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"], ["class", "tooltip-bar", 4, "ngIf"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "select", "activate", "deactivate", "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"], [1, "tooltip-bar"]],
  template: function CircleSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, CircleSeriesComponent__svg_g_0_Template, 6, 22, "g", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.circle);
    }
  },
  dependencies: [NgIf, TooltipDirective, CircleComponent, SvgLinearGradientComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":enter", [style({
      opacity: 0
    }), animate(250, style({
      opacity: 1
    }))])])]
  },
  changeDetection: 0
});
var CircleSeriesComponent = _CircleSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CircleSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-circle-series]",
      template: `
    <svg:g *ngIf="circle">
      <defs>
        <svg:g
          ngx-charts-svg-linear-gradient
          [orientation]="barOrientation.Vertical"
          [name]="gradientId"
          [stops]="circle.gradientStops"
        />
      </defs>
      <svg:rect
        *ngIf="!isSSR && barVisible && type === 'standard'"
        [@animationState]="'active'"
        [attr.x]="circle.cx - circle.radius"
        [attr.y]="circle.cy"
        [attr.width]="circle.radius * 2"
        [attr.height]="circle.height"
        [attr.fill]="gradientFill"
        class="tooltip-bar"
      />
      <svg:rect
        *ngIf="isSSR && barVisible && type === 'standard'"
        [attr.x]="circle.cx - circle.radius"
        [attr.y]="circle.cy"
        [attr.width]="circle.radius * 2"
        [attr.height]="circle.height"
        [attr.fill]="gradientFill"
        class="tooltip-bar"
      />
      <svg:g
        ngx-charts-circle
        class="circle"
        [cx]="circle.cx"
        [cy]="circle.cy"
        [r]="circle.radius"
        [fill]="circle.color"
        [class.active]="isActive({ name: circle.seriesName })"
        [pointerEvents]="circle.value === 0 ? 'none' : 'all'"
        [data]="circle.value"
        [classNames]="circle.classNames"
        (select)="onClick(circle.data)"
        (activate)="activateCircle()"
        (deactivate)="deactivateCircle()"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="placementTypes.Top"
        [tooltipType]="styleTypes.tooltip"
        [tooltipTitle]="tooltipTemplate ? undefined : getTooltipText(circle)"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="circle.data"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":enter", [style({
        opacity: 0
      }), animate(250, style({
        opacity: 1
      }))])])]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    data: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    visibleValue: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var _GridPanelComponent = class _GridPanelComponent {
};
_GridPanelComponent.\u0275fac = function GridPanelComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GridPanelComponent)();
};
_GridPanelComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _GridPanelComponent,
  selectors: [["g", "ngx-charts-grid-panel", ""]],
  inputs: {
    width: "width",
    height: "height",
    x: "x",
    y: "y"
  },
  standalone: false,
  attrs: _c132,
  decls: 1,
  vars: 4,
  consts: [["stroke", "none", 1, "gridpanel"]],
  template: function GridPanelComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275element(0, "rect", 0);
    }
    if (rf & 2) {
      \u0275\u0275attribute("height", ctx.height)("width", ctx.width)("x", ctx.x)("y", ctx.y);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var GridPanelComponent = _GridPanelComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridPanelComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-grid-panel]",
      template: `
    <svg:rect [attr.height]="height" [attr.width]="width" [attr.x]="x" [attr.y]="y" stroke="none" class="gridpanel" />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }]
  });
})();
var ClassEnum;
(function(ClassEnum2) {
  ClassEnum2["Odd"] = "odd";
  ClassEnum2["Even"] = "even";
})(ClassEnum || (ClassEnum = {}));
var _GridPanelSeriesComponent = class _GridPanelSeriesComponent {
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.gridPanels = this.getGridPanels();
  }
  getGridPanels() {
    return this.data.map((d) => {
      let offset2;
      let width;
      let height;
      let x4;
      let y3;
      let className = ClassEnum.Odd;
      if (this.orient === BarOrientation.Vertical) {
        const position = this.xScale(d.name);
        const positionIndex = Number.parseInt((position / this.xScale.step()).toString(), 10);
        if (positionIndex % 2 === 1) {
          className = ClassEnum.Even;
        }
        offset2 = this.xScale.bandwidth() * this.xScale.paddingInner();
        width = this.xScale.bandwidth() + offset2;
        height = this.dims.height;
        x4 = this.xScale(d.name) - offset2 / 2;
        y3 = 0;
      } else if (this.orient === BarOrientation.Horizontal) {
        const position = this.yScale(d.name);
        const positionIndex = Number.parseInt((position / this.yScale.step()).toString(), 10);
        if (positionIndex % 2 === 1) {
          className = ClassEnum.Even;
        }
        offset2 = this.yScale.bandwidth() * this.yScale.paddingInner();
        width = this.dims.width;
        height = this.yScale.bandwidth() + offset2;
        x4 = 0;
        y3 = this.yScale(d.name) - offset2 / 2;
      }
      return {
        name: d.name,
        class: className,
        height,
        width,
        x: x4,
        y: y3
      };
    });
  }
};
_GridPanelSeriesComponent.\u0275fac = function GridPanelSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GridPanelSeriesComponent)();
};
_GridPanelSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _GridPanelSeriesComponent,
  selectors: [["g", "ngx-charts-grid-panel-series", ""]],
  inputs: {
    data: "data",
    dims: "dims",
    xScale: "xScale",
    yScale: "yScale",
    orient: "orient"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c142,
  decls: 1,
  vars: 1,
  consts: [["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y", "grid-panel", "odd", "even", 4, "ngFor", "ngForOf"], ["ngx-charts-grid-panel", "", 3, "height", "width", "x", "y"]],
  template: function GridPanelSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, GridPanelSeriesComponent__svg_g_0_Template, 1, 10, "g", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.gridPanels);
    }
  },
  dependencies: [NgForOf, GridPanelComponent],
  encapsulation: 2,
  changeDetection: 0
});
var GridPanelSeriesComponent = _GridPanelSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridPanelSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-grid-panel-series]",
      template: `
    <svg:g
      ngx-charts-grid-panel
      *ngFor="let gridPanel of gridPanels"
      [height]="gridPanel.height"
      [width]="gridPanel.width"
      [x]="gridPanel.x"
      [y]="gridPanel.y"
      [class.grid-panel]="true"
      [class.odd]="gridPanel.class === 'odd'"
      [class.even]="gridPanel.class === 'even'"
    ></svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    orient: [{
      type: Input
    }]
  });
})();
var _SvgRadialGradientComponent = class _SvgRadialGradientComponent {
  constructor() {
    this.endOpacity = 1;
    this.cx = 0;
    this.cy = 0;
  }
  get stops() {
    return this.stopsInput || this.stopsDefault;
  }
  set stops(value2) {
    this.stopsInput = value2;
  }
  ngOnChanges(changes) {
    this.r = "30%";
    if ("color" in changes || "startOpacity" in changes || "endOpacity" in changes) {
      this.stopsDefault = [{
        offset: 0,
        color: this.color,
        opacity: this.startOpacity
      }, {
        offset: 100,
        color: this.color,
        opacity: this.endOpacity
      }];
    }
  }
};
_SvgRadialGradientComponent.\u0275fac = function SvgRadialGradientComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _SvgRadialGradientComponent)();
};
_SvgRadialGradientComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SvgRadialGradientComponent,
  selectors: [["g", "ngx-charts-svg-radial-gradient", ""]],
  inputs: {
    color: "color",
    name: "name",
    startOpacity: "startOpacity",
    endOpacity: "endOpacity",
    cx: "cx",
    cy: "cy",
    stops: "stops"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c152,
  decls: 2,
  vars: 5,
  consts: [["gradientUnits", "userSpaceOnUse", 3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]],
  template: function SvgRadialGradientComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "radialGradient", 0);
      \u0275\u0275template(1, SvgRadialGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("id", ctx.name);
      \u0275\u0275attribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.stops);
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var SvgRadialGradientComponent = _SvgRadialGradientComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SvgRadialGradientComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-svg-radial-gradient]",
      template: `
    <svg:radialGradient [id]="name" [attr.cx]="cx" [attr.cy]="cy" [attr.r]="r" gradientUnits="userSpaceOnUse">
      <svg:stop
        *ngFor="let stop of stops"
        [attr.offset]="stop.offset + '%'"
        [style.stop-color]="stop.color"
        [style.stop-opacity]="stop.opacity"
      />
    </svg:radialGradient>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    color: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    startOpacity: [{
      type: Input
    }],
    endOpacity: [{
      type: Input
    }],
    cx: [{
      type: Input
    }],
    cy: [{
      type: Input
    }],
    stops: [{
      type: Input
    }]
  });
})();
var _AreaComponent = class _AreaComponent {
  constructor(element) {
    this.opacity = 1;
    this.startOpacity = 0.5;
    this.endOpacity = 1;
    this.gradient = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.animationsLoaded = false;
    this.hasGradient = false;
    this.barOrientation = BarOrientation;
    this.element = element.nativeElement;
  }
  ngOnChanges() {
    this.update();
    if (!this.animationsLoaded) {
      this.loadAnimation();
      this.animationsLoaded = true;
    }
  }
  update() {
    this.gradientId = "grad" + id2().toString();
    this.gradientFill = `url(#${this.gradientId})`;
    if (this.gradient || this.stops) {
      this.gradientStops = this.getGradient();
      this.hasGradient = true;
    } else {
      this.hasGradient = false;
    }
    this.updatePathEl();
  }
  loadAnimation() {
    this.areaPath = this.startingPath;
    setTimeout(this.updatePathEl.bind(this), 100);
  }
  updatePathEl() {
    const node = select_default2(this.element).select(".area");
    if (this.animations) {
      node.transition().duration(750).attr("d", this.path);
    } else {
      node.attr("d", this.path);
    }
  }
  getGradient() {
    if (this.stops) {
      return this.stops;
    }
    return [{
      offset: 0,
      color: this.fill,
      opacity: this.startOpacity
    }, {
      offset: 100,
      color: this.fill,
      opacity: this.endOpacity
    }];
  }
};
_AreaComponent.\u0275fac = function AreaComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AreaComponent)(\u0275\u0275directiveInject(ElementRef));
};
_AreaComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AreaComponent,
  selectors: [["g", "ngx-charts-area", ""]],
  inputs: {
    data: "data",
    path: "path",
    startingPath: "startingPath",
    fill: "fill",
    opacity: "opacity",
    startOpacity: "startOpacity",
    endOpacity: "endOpacity",
    gradient: "gradient",
    stops: "stops",
    animations: "animations"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c162,
  decls: 2,
  vars: 5,
  consts: [[4, "ngIf"], [1, "area"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]],
  template: function AreaComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, AreaComponent__svg_defs_0_Template, 2, 3, "defs", 0);
      \u0275\u0275namespaceSVG();
      \u0275\u0275element(1, "path", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.gradient);
      \u0275\u0275advance();
      \u0275\u0275styleProp("opacity", ctx.opacity);
      \u0275\u0275attribute("d", ctx.areaPath)("fill", ctx.gradient ? ctx.gradientFill : ctx.fill);
    }
  },
  dependencies: [NgIf, SvgLinearGradientComponent],
  encapsulation: 2,
  changeDetection: 0
});
var AreaComponent = _AreaComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-area]",
      template: `
    <svg:defs *ngIf="gradient">
      <svg:g
        ngx-charts-svg-linear-gradient
        [orientation]="barOrientation.Vertical"
        [name]="gradientId"
        [stops]="gradientStops"
      />
    </svg:defs>
    <svg:path class="area" [attr.d]="areaPath" [attr.fill]="gradient ? gradientFill : fill" [style.opacity]="opacity" />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    data: [{
      type: Input
    }],
    path: [{
      type: Input
    }],
    startingPath: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    startOpacity: [{
      type: Input
    }],
    endOpacity: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    stops: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
function easeOutExpo(t2, b, c, d) {
  return c * (-Math.pow(2, -10 * t2 / d) + 1) * 1024 / 1023 + b;
}
function count2(countFrom, countTo, countDecimals, countDuration, callback) {
  const startVal = Number(countFrom);
  const endVal = Number(countTo);
  const countDown = startVal > endVal;
  const decimals = Math.max(0, countDecimals);
  const dec = Math.pow(10, decimals);
  const duration = Number(countDuration) * 1e3;
  let startTime;
  function runCount(timestamp) {
    let frameVal;
    const progress = timestamp - startTime;
    if (countDown) {
      frameVal = startVal - easeOutExpo(progress, 0, startVal - endVal, duration);
    } else {
      frameVal = easeOutExpo(progress, startVal, endVal - startVal, duration);
    }
    if (countDown) {
      frameVal = frameVal < endVal ? endVal : frameVal;
    } else {
      frameVal = frameVal > endVal ? endVal : frameVal;
    }
    frameVal = Math.round(frameVal * dec) / dec;
    const tick = progress < duration;
    callback({
      value: frameVal,
      progress,
      timestamp,
      finished: !tick
    });
    if (tick) {
      return requestAnimationFrame((val) => runCount(val));
    }
  }
  return requestAnimationFrame((timestamp) => {
    startTime = timestamp;
    return runCount(timestamp);
  });
}
function decimalChecker(countTo) {
  const endVal = Number(countTo);
  if (endVal % 1 !== 0 && Math.abs(endVal) <= 10) {
    return 2;
  }
  return 0;
}
var _CountUpDirective = class _CountUpDirective {
  set countDecimals(val) {
    this._countDecimals = val;
  }
  get countDecimals() {
    if (this._countDecimals) return this._countDecimals;
    return decimalChecker(this.countTo);
  }
  set countTo(val) {
    this._countTo = parseFloat(val);
    this.start();
  }
  get countTo() {
    return this._countTo;
  }
  set countFrom(val) {
    this._countFrom = parseFloat(val);
    this.start();
  }
  get countFrom() {
    return this._countFrom;
  }
  constructor(cd, element) {
    this.cd = cd;
    this.countDuration = 1;
    this.countPrefix = "";
    this.countSuffix = "";
    this.countChange = new EventEmitter();
    this.countFinish = new EventEmitter();
    this.value = "";
    this._countDecimals = 0;
    this._countTo = 0;
    this._countFrom = 0;
    this.nativeElement = element.nativeElement;
  }
  ngOnDestroy() {
    cancelAnimationFrame(this.animationReq);
  }
  start() {
    cancelAnimationFrame(this.animationReq);
    const valueFormatting = this.valueFormatting || ((value2) => `${this.countPrefix}${value2.toLocaleString()}${this.countSuffix}`);
    const callback = ({
      value: value2,
      progress,
      finished
    }) => {
      this.value = valueFormatting(value2);
      this.cd.markForCheck();
      if (!finished) this.countChange.emit({
        value: this.value,
        progress
      });
      if (finished) this.countFinish.emit({
        value: this.value,
        progress
      });
    };
    this.animationReq = count2(this.countFrom, this.countTo, this.countDecimals, this.countDuration, callback);
  }
};
_CountUpDirective.\u0275fac = function CountUpDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CountUpDirective)(\u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(ElementRef));
};
_CountUpDirective.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CountUpDirective,
  selectors: [["", "ngx-charts-count-up", ""]],
  inputs: {
    countDuration: "countDuration",
    countPrefix: "countPrefix",
    countSuffix: "countSuffix",
    valueFormatting: "valueFormatting",
    countDecimals: "countDecimals",
    countTo: "countTo",
    countFrom: "countFrom"
  },
  outputs: {
    countChange: "countChange",
    countFinish: "countFinish"
  },
  standalone: false,
  attrs: _c17,
  decls: 1,
  vars: 1,
  template: function CountUpDirective_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275text(0);
    }
    if (rf & 2) {
      \u0275\u0275textInterpolate1(" ", ctx.value, " ");
    }
  },
  encapsulation: 2
});
var CountUpDirective = _CountUpDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CountUpDirective, [{
    type: Component,
    args: [{
      selector: "[ngx-charts-count-up]",
      template: ` {{ value }} `
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }], {
    countDuration: [{
      type: Input
    }],
    countPrefix: [{
      type: Input
    }],
    countSuffix: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    countDecimals: [{
      type: Input
    }],
    countTo: [{
      type: Input
    }],
    countFrom: [{
      type: Input
    }],
    countChange: [{
      type: Output
    }],
    countFinish: [{
      type: Output
    }]
  });
})();
var root2;
if (typeof window !== "undefined") {
  root2 = window;
} else if (typeof global !== "undefined") {
  root2 = global;
}
var MouseEvent = root2.MouseEvent;
function createMouseEvent(name, bubbles = false, cancelable = true) {
  if (typeof MouseEvent === "function") {
    return new MouseEvent(name, {
      bubbles,
      cancelable
    });
  } else {
    const event = document.createEvent("MouseEvent");
    event.initEvent(name, bubbles, cancelable);
    return event;
  }
}
var _TooltipArea = class _TooltipArea {
  constructor(platformId) {
    this.platformId = platformId;
    this.anchorOpacity = 0;
    this.anchorPos = -1;
    this.anchorValues = [];
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
    this.showPercentage = false;
    this.tooltipDisabled = false;
    this.hover = new EventEmitter();
  }
  getValues(xVal) {
    const results = [];
    for (const group of this.results) {
      const item = group.series.find((d) => d.name.toString() === xVal.toString());
      let groupName = group.name;
      if (groupName instanceof Date) {
        groupName = groupName.toLocaleDateString();
      }
      if (item) {
        const label = item.name;
        let val = item.value;
        if (this.showPercentage) {
          val = (item.d1 - item.d0).toFixed(2) + "%";
        }
        let color2;
        if (this.colors.scaleType === ScaleType.Linear) {
          let v = val;
          if (item.d1) {
            v = item.d1;
          }
          color2 = this.colors.getColor(v);
        } else {
          color2 = this.colors.getColor(group.name);
        }
        const data = Object.assign({}, item, {
          value: val,
          name: label,
          series: groupName,
          min: item.min,
          max: item.max,
          color: color2
        });
        results.push(data);
      }
    }
    return results;
  }
  mouseMove(event) {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    const xPos = event.pageX - event.target.getBoundingClientRect().left;
    const closestIndex = this.findClosestPointIndex(xPos);
    const closestPoint = this.xSet[closestIndex];
    this.anchorPos = this.xScale(closestPoint);
    this.anchorPos = Math.max(0, this.anchorPos);
    this.anchorPos = Math.min(this.dims.width, this.anchorPos);
    this.anchorValues = this.getValues(closestPoint);
    if (this.anchorPos !== this.lastAnchorPos) {
      const ev = createMouseEvent("mouseleave");
      this.tooltipAnchor.nativeElement.dispatchEvent(ev);
      this.anchorOpacity = 0.7;
      this.hover.emit({
        value: closestPoint
      });
      this.showTooltip();
      this.lastAnchorPos = this.anchorPos;
    }
  }
  findClosestPointIndex(xPos) {
    let minIndex = 0;
    let maxIndex = this.xSet.length - 1;
    let minDiff = Number.MAX_VALUE;
    let closestIndex = 0;
    while (minIndex <= maxIndex) {
      const currentIndex = (minIndex + maxIndex) / 2 | 0;
      const currentElement = this.xScale(this.xSet[currentIndex]);
      const curDiff = Math.abs(currentElement - xPos);
      if (curDiff < minDiff) {
        minDiff = curDiff;
        closestIndex = currentIndex;
      }
      if (currentElement < xPos) {
        minIndex = currentIndex + 1;
      } else if (currentElement > xPos) {
        maxIndex = currentIndex - 1;
      } else {
        minDiff = 0;
        closestIndex = currentIndex;
        break;
      }
    }
    return closestIndex;
  }
  showTooltip() {
    const event = createMouseEvent("mouseenter");
    this.tooltipAnchor.nativeElement.dispatchEvent(event);
  }
  hideTooltip() {
    const event = createMouseEvent("mouseleave");
    this.tooltipAnchor.nativeElement.dispatchEvent(event);
    this.anchorOpacity = 0;
    this.lastAnchorPos = -1;
  }
  getToolTipText(tooltipItem) {
    let result = "";
    if (tooltipItem.series !== void 0) {
      result += tooltipItem.series;
    } else {
      result += "???";
    }
    result += ": ";
    if (tooltipItem.value !== void 0) {
      result += tooltipItem.value.toLocaleString();
    }
    if (tooltipItem.min !== void 0 || tooltipItem.max !== void 0) {
      result += " (";
      if (tooltipItem.min !== void 0) {
        if (tooltipItem.max === void 0) {
          result += "\u2265";
        }
        result += tooltipItem.min.toLocaleString();
        if (tooltipItem.max !== void 0) {
          result += " - ";
        }
      } else if (tooltipItem.max !== void 0) {
        result += "\u2264";
      }
      if (tooltipItem.max !== void 0) {
        result += tooltipItem.max.toLocaleString();
      }
      result += ")";
    }
    return result;
  }
};
_TooltipArea.\u0275fac = function TooltipArea_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TooltipArea)(\u0275\u0275directiveInject(PLATFORM_ID));
};
_TooltipArea.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TooltipArea,
  selectors: [["g", "ngx-charts-tooltip-area", ""]],
  viewQuery: function TooltipArea_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c18, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipAnchor = _t.first);
    }
  },
  inputs: {
    dims: "dims",
    xSet: "xSet",
    xScale: "xScale",
    yScale: "yScale",
    results: "results",
    colors: "colors",
    showPercentage: "showPercentage",
    tooltipDisabled: "tooltipDisabled",
    tooltipTemplate: "tooltipTemplate"
  },
  outputs: {
    hover: "hover"
  },
  standalone: false,
  attrs: _c19,
  decls: 6,
  vars: 18,
  consts: [["defaultTooltipTemplate", ""], ["tooltipAnchor", ""], ["y", "0", 1, "tooltip-area", 2, "opacity", "0", "cursor", "'auto'", 3, "mousemove", "mouseleave"], ["y", "0", "ngx-tooltip", "", 1, "tooltip-anchor", 3, "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipSpacing", "tooltipTemplate", "tooltipContext", "tooltipImmediateExit"], [1, "area-tooltip-container"], ["class", "tooltip-item", 4, "ngFor", "ngForOf"], [1, "tooltip-item"], [1, "tooltip-item-color"]],
  template: function TooltipArea_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g")(1, "rect", 2);
      \u0275\u0275listener("mousemove", function TooltipArea_Template_rect_mousemove_1_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.mouseMove($event));
      })("mouseleave", function TooltipArea_Template_rect_mouseleave_1_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.hideTooltip());
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(2, TooltipArea__svg_ng_template_2_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
      \u0275\u0275element(4, "rect", 3, 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      const defaultTooltipTemplate_r5 = \u0275\u0275reference(3);
      \u0275\u0275advance();
      \u0275\u0275attribute("x", 0)("width", ctx.dims.width)("height", ctx.dims.height);
      \u0275\u0275advance(3);
      \u0275\u0275styleProp("opacity", ctx.anchorOpacity)("pointer-events", "none");
      \u0275\u0275property("@animationState", ctx.anchorOpacity !== 0 ? "active" : "inactive")("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", ctx.placementTypes.Right)("tooltipType", ctx.styleTypes.tooltip)("tooltipSpacing", 15)("tooltipTemplate", ctx.tooltipTemplate ? ctx.tooltipTemplate : defaultTooltipTemplate_r5)("tooltipContext", ctx.anchorValues)("tooltipImmediateExit", true);
      \u0275\u0275attribute("x", ctx.anchorPos)("width", 1)("height", ctx.dims.height);
    }
  },
  dependencies: [NgForOf, TooltipDirective],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition("inactive => active", [style({
      opacity: 0
    }), animate(250, style({
      opacity: 0.7
    }))]), transition("active => inactive", [style({
      opacity: 0.7
    }), animate(250, style({
      opacity: 0
    }))])])]
  },
  changeDetection: 0
});
var TooltipArea = _TooltipArea;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipArea, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-tooltip-area]",
      template: `
    <svg:g>
      <svg:rect
        class="tooltip-area"
        [attr.x]="0"
        y="0"
        [attr.width]="dims.width"
        [attr.height]="dims.height"
        style="opacity: 0; cursor: 'auto';"
        (mousemove)="mouseMove($event)"
        (mouseleave)="hideTooltip()"
      />
      <ng-template #defaultTooltipTemplate let-model="model">
        <xhtml:div class="area-tooltip-container">
          <xhtml:div *ngFor="let tooltipItem of model" class="tooltip-item">
            <xhtml:span class="tooltip-item-color" [style.background-color]="tooltipItem.color"></xhtml:span>
            {{ getToolTipText(tooltipItem) }}
          </xhtml:div>
        </xhtml:div>
      </ng-template>
      <svg:rect
        #tooltipAnchor
        [@animationState]="anchorOpacity !== 0 ? 'active' : 'inactive'"
        class="tooltip-anchor"
        [attr.x]="anchorPos"
        y="0"
        [attr.width]="1"
        [attr.height]="dims.height"
        [style.opacity]="anchorOpacity"
        [style.pointer-events]="'none'"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="placementTypes.Right"
        [tooltipType]="styleTypes.tooltip"
        [tooltipSpacing]="15"
        [tooltipTemplate]="tooltipTemplate ? tooltipTemplate : defaultTooltipTemplate"
        [tooltipContext]="anchorValues"
        [tooltipImmediateExit]="true"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition("inactive => active", [style({
        opacity: 0
      }), animate(250, style({
        opacity: 0.7
      }))]), transition("active => inactive", [style({
        opacity: 0.7
      }), animate(250, style({
        opacity: 0
      }))])])]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    dims: [{
      type: Input
    }],
    xSet: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    results: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    showPercentage: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    hover: [{
      type: Output
    }],
    tooltipAnchor: [{
      type: ViewChild,
      args: ["tooltipAnchor", {
        static: false
      }]
    }]
  });
})();
var _Timeline = class _Timeline {
  constructor(element, cd) {
    this.cd = cd;
    this.height = 50;
    this.select = new EventEmitter();
    this.onDomainChange = new EventEmitter();
    this.initialized = false;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
    if (!this.initialized) {
      this.addBrush();
      this.initialized = true;
    }
  }
  update() {
    this.dims = this.getDims();
    this.height = this.dims.height;
    const offsetY = this.view[1] - this.height;
    this.xDomain = this.getXDomain();
    this.xScale = this.getXScale();
    if (this.brush) {
      this.updateBrush();
    }
    this.transform = `translate(0 , ${offsetY})`;
    this.filterId = "filter" + id2().toString();
    this.filter = `url(#${this.filterId})`;
    this.cd.markForCheck();
  }
  getXDomain() {
    let values = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (!values.includes(d.name)) {
          values.push(d.name);
        }
      }
    }
    let domain = [];
    if (this.scaleType === ScaleType.Time) {
      const min6 = Math.min(...values);
      const max6 = Math.max(...values);
      domain = [min6, max6];
    } else if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
      const min6 = Math.min(...values);
      const max6 = Math.max(...values);
      domain = [min6, max6];
    } else {
      domain = values;
    }
    return domain;
  }
  getXScale() {
    let scale;
    if (this.scaleType === ScaleType.Time) {
      scale = time().range([0, this.dims.width]).domain(this.xDomain);
    } else if (this.scaleType === ScaleType.Linear) {
      scale = linear2().range([0, this.dims.width]).domain(this.xDomain);
    } else if (this.scaleType === ScaleType.Ordinal) {
      scale = point().range([0, this.dims.width]).padding(0.1).domain(this.xDomain);
    }
    return scale;
  }
  addBrush() {
    if (this.brush) return;
    const height = this.height;
    const width = this.view[0];
    this.brush = brushX().extent([[0, 0], [width, height]]).on("brush end", ({
      selection: selection2
    }) => {
      const newSelection = selection2 || this.xScale.range();
      const newDomain = newSelection.map(this.xScale.invert);
      this.onDomainChange.emit(newDomain);
      this.cd.markForCheck();
    });
    select_default2(this.element).select(".brush").call(this.brush);
  }
  updateBrush() {
    if (!this.brush) return;
    const height = this.height;
    const width = this.view[0];
    this.brush.extent([[0, 0], [width, height]]);
    select_default2(this.element).select(".brush").call(this.brush);
    select_default2(this.element).select(".selection").attr("fill", void 0).attr("stroke", void 0).attr("fill-opacity", void 0);
    this.cd.markForCheck();
  }
  getDims() {
    const width = this.view[0];
    const dims = {
      width,
      height: this.height
    };
    return dims;
  }
};
_Timeline.\u0275fac = function Timeline_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _Timeline)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_Timeline.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _Timeline,
  selectors: [["g", "ngx-charts-timeline", ""]],
  inputs: {
    view: "view",
    results: "results",
    scheme: "scheme",
    customColors: "customColors",
    legend: "legend",
    autoScale: "autoScale",
    scaleType: "scaleType",
    height: "height"
  },
  outputs: {
    select: "select",
    onDomainChange: "onDomainChange"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c20,
  ngContentSelectors: _c23,
  decls: 7,
  vars: 4,
  consts: [[1, "timeline"], ["in", "SourceGraphic", "type", "matrix", "values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"], [1, "embedded-chart"], ["x", "0", "y", "0", 1, "brush-background"], [1, "brush"]],
  template: function Timeline_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275projectionDef();
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g", 0)(1, "filter");
      \u0275\u0275element(2, "feColorMatrix", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "g", 2);
      \u0275\u0275projection(4);
      \u0275\u0275elementEnd();
      \u0275\u0275element(5, "rect", 3)(6, "g", 4);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275attribute("id", ctx.filterId);
      \u0275\u0275advance(4);
      \u0275\u0275attribute("width", ctx.view[0])("height", ctx.height);
    }
  },
  styles: [".timeline .brush-background{fill:#0000000d}.timeline .brush .selection{fill:#0000001a;stroke-width:1px;stroke:#888}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var Timeline = _Timeline;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Timeline, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-timeline]",
      template: `
    <svg:g class="timeline" [attr.transform]="transform">
      <svg:filter [attr.id]="filterId">
        <svg:feColorMatrix
          in="SourceGraphic"
          type="matrix"
          values="0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"
        />
      </svg:filter>
      <svg:g class="embedded-chart">
        <ng-content></ng-content>
      </svg:g>
      <svg:rect x="0" [attr.width]="view[0]" y="0" [attr.height]="height" class="brush-background" />
      <svg:g class="brush"></svg:g>
    </svg:g>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".timeline .brush-background{fill:#0000000d}.timeline .brush .selection{fill:#0000001a;stroke-width:1px;stroke:#888}.timeline .brush .handle{fill-opacity:0}.timeline .embedded-chart{opacity:.6}\n"]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    view: [{
      type: Input
    }],
    results: [{
      type: Input
    }],
    scheme: [{
      type: Input
    }],
    customColors: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    autoScale: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    onDomainChange: [{
      type: Output
    }]
  });
})();
var _AdvancedLegendComponent = class _AdvancedLegendComponent {
  constructor() {
    this.label = "Total";
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.legendItems = [];
    this.labelFormatting = (label) => label;
    this.percentageFormatting = (percentage) => percentage;
    this.defaultValueFormatting = (value2) => value2.toLocaleString();
  }
  ngOnChanges(changes) {
    this.update();
  }
  getTotal() {
    return this.data.map((d) => Number(d.value)).reduce((sum2, d) => sum2 + d, 0);
  }
  update() {
    this.total = this.getTotal();
    this.roundedTotal = this.total;
    this.legendItems = this.getLegendItems();
  }
  getLegendItems() {
    return this.data.map((d) => {
      const label = formatLabel(d.name);
      const value2 = d.value;
      const color2 = this.colors.getColor(label);
      const percentage = this.total > 0 ? value2 / this.total * 100 : 0;
      const formattedLabel = typeof this.labelFormatting === "function" ? this.labelFormatting(label) : label;
      return {
        _value: value2,
        data: d,
        value: value2,
        color: color2,
        label: formattedLabel,
        displayLabel: trimLabel(formattedLabel, 20),
        origialLabel: d.name,
        percentage: this.percentageFormatting ? this.percentageFormatting(percentage) : percentage.toLocaleString()
      };
    });
  }
  trackBy(index, item) {
    return item.label;
  }
};
_AdvancedLegendComponent.\u0275fac = function AdvancedLegendComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AdvancedLegendComponent)();
};
_AdvancedLegendComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AdvancedLegendComponent,
  selectors: [["ngx-charts-advanced-legend"]],
  inputs: {
    width: "width",
    data: "data",
    colors: "colors",
    label: "label",
    animations: "animations",
    valueFormatting: "valueFormatting",
    labelFormatting: "labelFormatting",
    percentageFormatting: "percentageFormatting"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  decls: 8,
  vars: 7,
  consts: [[1, "advanced-pie-legend"], ["class", "total-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "total-value", 4, "ngIf"], [1, "total-label"], [1, "legend-items-container"], [1, "legend-items"], ["tabindex", "-1", "class", "legend-item", 3, "mouseenter", "mouseleave", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-count-up", "", 1, "total-value", 3, "countTo", "valueFormatting"], [1, "total-value"], ["tabindex", "-1", 1, "legend-item", 3, "mouseenter", "mouseleave", "click"], [1, "item-color"], ["class", "item-value", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "item-value", 4, "ngIf"], [1, "item-label"], ["class", "item-percent", "ngx-charts-count-up", "", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "item-percent", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "item-value", 3, "countTo", "valueFormatting"], [1, "item-value"], ["ngx-charts-count-up", "", 1, "item-percent", 3, "countTo", "countSuffix"], [1, "item-percent"]],
  template: function AdvancedLegendComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275template(1, AdvancedLegendComponent_div_1_Template, 1, 2, "div", 1)(2, AdvancedLegendComponent_div_2_Template, 2, 1, "div", 2);
      \u0275\u0275elementStart(3, "div", 3);
      \u0275\u0275text(4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "div", 4)(6, "div", 5);
      \u0275\u0275template(7, AdvancedLegendComponent_div_7_Template, 8, 7, "div", 6);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx.width, "px");
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.animations);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.label, " ");
      \u0275\u0275advance(3);
      \u0275\u0275property("ngForOf", ctx.legendItems)("ngForTrackBy", ctx.trackBy);
    }
  },
  dependencies: [NgForOf, NgIf, CountUpDirective],
  styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translateY(-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{white-space:nowrap;overflow:auto}.advanced-pie-legend .legend-items-container .legend-items .legend-item{margin-right:20px;display:inline-block;cursor:pointer}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:none}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-top:-6px;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;opacity:.7;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;opacity:.7;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;width:4px;height:42px;float:left;margin-right:7px}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var AdvancedLegendComponent = _AdvancedLegendComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdvancedLegendComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-advanced-legend",
      template: `
    <div class="advanced-pie-legend" [style.width.px]="width">
      <div
        *ngIf="animations"
        class="total-value"
        ngx-charts-count-up
        [countTo]="roundedTotal"
        [valueFormatting]="valueFormatting"
      ></div>
      <div class="total-value" *ngIf="!animations">
        {{ valueFormatting ? valueFormatting(roundedTotal) : defaultValueFormatting(roundedTotal) }}
      </div>
      <div class="total-label">
        {{ label }}
      </div>
      <div class="legend-items-container">
        <div class="legend-items">
          <div
            *ngFor="let legendItem of legendItems; trackBy: trackBy"
            tabindex="-1"
            class="legend-item"
            (mouseenter)="activate.emit(legendItem.data)"
            (mouseleave)="deactivate.emit(legendItem.data)"
            (click)="select.emit(legendItem.data)"
          >
            <div class="item-color" [style.border-left-color]="legendItem.color"></div>
            <div
              *ngIf="animations"
              class="item-value"
              ngx-charts-count-up
              [countTo]="legendItem._value"
              [valueFormatting]="valueFormatting"
            ></div>
            <div *ngIf="!animations" class="item-value">
              {{ valueFormatting ? valueFormatting(legendItem.value) : defaultValueFormatting(legendItem.value) }}
            </div>
            <div class="item-label">{{ legendItem.displayLabel }}</div>
            <div
              *ngIf="animations"
              class="item-percent"
              ngx-charts-count-up
              [countTo]="legendItem.percentage"
              [countSuffix]="'%'"
            ></div>
            <div *ngIf="!animations" class="item-percent">{{ legendItem.percentage.toLocaleString() }}%</div>
          </div>
        </div>
      </div>
    </div>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".advanced-pie-legend{float:left;position:relative;top:50%;transform:translateY(-50%)}.advanced-pie-legend .total-value{font-size:36px}.advanced-pie-legend .total-label{font-size:24px;margin-bottom:19px}.advanced-pie-legend .legend-items-container{width:100%}.advanced-pie-legend .legend-items-container .legend-items{white-space:nowrap;overflow:auto}.advanced-pie-legend .legend-items-container .legend-items .legend-item{margin-right:20px;display:inline-block;cursor:pointer}.advanced-pie-legend .legend-items-container .legend-items .legend-item:focus{outline:none}.advanced-pie-legend .legend-items-container .legend-items .legend-item:hover{color:#000;-webkit-transition:.2s;-moz-transition:.2s;transition:.2s}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-value{font-size:24px;margin-top:-6px;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-label{font-size:14px;opacity:.7;margin-left:11px;margin-top:-6px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-percent{font-size:24px;opacity:.7;margin-left:11px}.advanced-pie-legend .legend-items-container .legend-items .legend-item .item-color{border-left:4px solid;width:4px;height:42px;float:left;margin-right:7px}\n"]
    }]
  }], null, {
    width: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    percentageFormatting: [{
      type: Input
    }]
  });
})();
var COMPONENTS = [AreaComponent, BaseChartComponent, CountUpDirective, TooltipArea, ChartComponent, LegendComponent, LegendEntryComponent, ScaleLegendComponent, CircleComponent, CircleSeriesComponent, GridPanelComponent, GridPanelSeriesComponent, SvgLinearGradientComponent, SvgRadialGradientComponent, Timeline, AdvancedLegendComponent];
var _ChartCommonModule = class _ChartCommonModule {
};
_ChartCommonModule.\u0275fac = function ChartCommonModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ChartCommonModule)();
};
_ChartCommonModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _ChartCommonModule
});
_ChartCommonModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [CommonModule, AxesModule, TooltipModule, CommonModule, AxesModule, TooltipModule]
});
var ChartCommonModule = _ChartCommonModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartCommonModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, AxesModule, TooltipModule],
      declarations: [...COMPONENTS, VisibilityObserver],
      exports: [CommonModule, AxesModule, TooltipModule, ...COMPONENTS, VisibilityObserver]
    }]
  }], null, null);
})();
function calculateViewDimensions({
  width,
  height,
  margins,
  showXAxis = false,
  showYAxis = false,
  xAxisHeight = 0,
  yAxisWidth = 0,
  showXLabel = false,
  showYLabel = false,
  showLegend = false,
  legendType = ScaleType.Ordinal,
  legendPosition = LegendPosition.Right,
  columns = 12
}) {
  let xOffset = margins[3];
  let chartWidth = width;
  let chartHeight = height - margins[0] - margins[2];
  if (showLegend && legendPosition === LegendPosition.Right) {
    if (legendType === ScaleType.Ordinal) {
      columns -= 2;
    } else {
      columns -= 1;
    }
  }
  chartWidth = chartWidth * columns / 12;
  chartWidth = chartWidth - margins[1] - margins[3];
  if (showXAxis) {
    chartHeight -= 5;
    chartHeight -= xAxisHeight;
    if (showXLabel) {
      const offset2 = 25 + 5;
      chartHeight -= offset2;
    }
  }
  if (showYAxis) {
    chartWidth -= 5;
    chartWidth -= yAxisWidth;
    xOffset += yAxisWidth;
    xOffset += 10;
    if (showYLabel) {
      const offset2 = 25 + 5;
      chartWidth -= offset2;
      xOffset += offset2;
    }
  }
  chartWidth = Math.max(0, chartWidth);
  chartHeight = Math.max(0, chartHeight);
  return {
    width: Math.floor(chartWidth),
    height: Math.floor(chartHeight),
    xOffset: Math.floor(xOffset)
  };
}
var colorSets = [{
  name: "vivid",
  selectable: true,
  group: ScaleType.Ordinal,
  domain: ["#647c8a", "#3f51b5", "#2196f3", "#00b862", "#afdf0a", "#a7b61a", "#f3e562", "#ff9800", "#ff5722", "#ff4514"]
}, {
  name: "natural",
  selectable: true,
  group: ScaleType.Ordinal,
  domain: ["#bf9d76", "#e99450", "#d89f59", "#f2dfa7", "#a5d7c6", "#7794b1", "#afafaf", "#707160", "#ba9383", "#d9d5c3"]
}, {
  name: "cool",
  selectable: true,
  group: ScaleType.Ordinal,
  domain: ["#a8385d", "#7aa3e5", "#a27ea8", "#aae3f5", "#adcded", "#a95963", "#8796c0", "#7ed3ed", "#50abcc", "#ad6886"]
}, {
  name: "fire",
  selectable: true,
  group: ScaleType.Ordinal,
  domain: ["#ff3d00", "#bf360c", "#ff8f00", "#ff6f00", "#ff5722", "#e65100", "#ffca28", "#ffab00"]
}, {
  name: "solar",
  selectable: true,
  group: ScaleType.Linear,
  domain: ["#fff8e1", "#ffecb3", "#ffe082", "#ffd54f", "#ffca28", "#ffc107", "#ffb300", "#ffa000", "#ff8f00", "#ff6f00"]
}, {
  name: "air",
  selectable: true,
  group: ScaleType.Linear,
  domain: ["#e1f5fe", "#b3e5fc", "#81d4fa", "#4fc3f7", "#29b6f6", "#03a9f4", "#039be5", "#0288d1", "#0277bd", "#01579b"]
}, {
  name: "aqua",
  selectable: true,
  group: ScaleType.Linear,
  domain: ["#e0f7fa", "#b2ebf2", "#80deea", "#4dd0e1", "#26c6da", "#00bcd4", "#00acc1", "#0097a7", "#00838f", "#006064"]
}, {
  name: "flame",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#A10A28", "#D3342D", "#EF6D49", "#FAAD67", "#FDDE90", "#DBED91", "#A9D770", "#6CBA67", "#2C9653", "#146738"]
}, {
  name: "ocean",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#1D68FB", "#33C0FC", "#4AFFFE", "#AFFFFF", "#FFFC63", "#FDBD2D", "#FC8A25", "#FA4F1E", "#FA141B", "#BA38D1"]
}, {
  name: "forest",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#55C22D", "#C1F33D", "#3CC099", "#AFFFFF", "#8CFC9D", "#76CFFA", "#BA60FB", "#EE6490", "#C42A1C", "#FC9F32"]
}, {
  name: "horizon",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#2597FB", "#65EBFD", "#99FDD0", "#FCEE4B", "#FEFCFA", "#FDD6E3", "#FCB1A8", "#EF6F7B", "#CB96E8", "#EFDEE0"]
}, {
  name: "neons",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#FF3333", "#FF33FF", "#CC33FF", "#0000FF", "#33CCFF", "#33FFFF", "#33FF66", "#CCFF33", "#FFCC00", "#FF6600"]
}, {
  name: "picnic",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#FAC51D", "#66BD6D", "#FAA026", "#29BB9C", "#E96B56", "#55ACD2", "#B7332F", "#2C83C9", "#9166B8", "#92E7E8"]
}, {
  name: "night",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#2B1B5A", "#501356", "#183356", "#28203F", "#391B3C", "#1E2B3C", "#120634", "#2D0432", "#051932", "#453080", "#75267D", "#2C507D", "#4B3880", "#752F7D", "#35547D"]
}, {
  name: "nightLights",
  selectable: false,
  group: ScaleType.Ordinal,
  domain: ["#4e31a5", "#9c25a7", "#3065ab", "#57468b", "#904497", "#46648b", "#32118d", "#a00fb3", "#1052a2", "#6e51bd", "#b63cc3", "#6c97cb", "#8671c1", "#b455be", "#7496c3"]
}];
var ColorHelper = class {
  constructor(scheme, type2, domain, customColors) {
    if (typeof scheme === "string") {
      scheme = colorSets.find((cs) => {
        return cs.name === scheme;
      });
    }
    this.colorDomain = scheme.domain;
    this.scaleType = type2;
    this.domain = domain;
    this.customColors = customColors;
    this.scale = this.generateColorScheme(scheme, type2, this.domain);
  }
  generateColorScheme(scheme, type2, domain) {
    if (typeof scheme === "string") {
      scheme = colorSets.find((cs) => {
        return cs.name === scheme;
      });
    }
    let colorScale;
    switch (type2) {
      case ScaleType.Quantile:
        colorScale = quantile2().range(scheme.domain).domain(domain);
        break;
      case ScaleType.Ordinal:
        colorScale = ordinal().range(scheme.domain).domain(domain);
        break;
      case ScaleType.Linear:
        {
          const colorDomain = [...scheme.domain];
          if (colorDomain.length === 1) {
            colorDomain.push(colorDomain[0]);
            this.colorDomain = colorDomain;
          }
          const points = range(0, 1, 1 / colorDomain.length);
          colorScale = linear2().range(colorDomain).domain(points);
        }
        break;
      default:
        break;
    }
    return colorScale;
  }
  getColor(value2) {
    if (value2 === void 0 || value2 === null) {
      throw new Error("Value can not be null");
    }
    if (this.scaleType === ScaleType.Linear) {
      const valueScale = linear2().domain(this.domain).range([0, 1]);
      return this.scale(valueScale(value2));
    } else {
      if (typeof this.customColors === "function") {
        return this.customColors(value2);
      }
      const formattedValue = value2.toString();
      let found;
      if (this.customColors && this.customColors.length > 0) {
        found = this.customColors.find((mapping) => {
          return mapping.name.toLowerCase() === formattedValue.toLowerCase();
        });
      }
      if (found) {
        return found.value;
      } else {
        return this.scale(value2);
      }
    }
  }
  getLinearGradientStops(value2, start2) {
    if (start2 === void 0) {
      start2 = this.domain[0];
    }
    const valueScale = linear2().domain(this.domain).range([0, 1]);
    const colorValueScale = band().domain(this.colorDomain).range([0, 1]);
    const endColor = this.getColor(value2);
    const startVal = valueScale(start2);
    const startColor = this.getColor(start2);
    const endVal = valueScale(value2);
    let i = 1;
    let currentVal = startVal;
    const stops = [];
    stops.push({
      color: startColor,
      offset: startVal,
      originalOffset: startVal,
      opacity: 1
    });
    while (currentVal < endVal && i < this.colorDomain.length) {
      const color2 = this.colorDomain[i];
      const offset2 = colorValueScale(color2);
      if (offset2 <= startVal) {
        i++;
        continue;
      }
      if (offset2.toFixed(4) >= (endVal - colorValueScale.bandwidth()).toFixed(4)) {
        break;
      }
      stops.push({
        color: color2,
        offset: offset2,
        opacity: 1
      });
      currentVal = offset2;
      i++;
    }
    if (stops[stops.length - 1].offset < 100) {
      stops.push({
        color: endColor,
        offset: endVal,
        opacity: 1
      });
    }
    if (endVal === startVal) {
      stops[0].offset = 0;
      stops[1].offset = 100;
    } else {
      if (stops[stops.length - 1].offset !== 100) {
        for (const s2 of stops) {
          s2.offset = (s2.offset - startVal) / (endVal - startVal) * 100;
        }
      }
    }
    return stops;
  }
};
function getUniqueXDomainValues(results) {
  const valueSet = /* @__PURE__ */ new Set();
  for (const result of results) {
    for (const d of result.series) {
      valueSet.add(d.name);
    }
  }
  return Array.from(valueSet);
}
function getScaleType(values, checkDateType = true) {
  if (checkDateType) {
    const allDates = values.every((value2) => value2 instanceof Date);
    if (allDates) {
      return ScaleType.Time;
    }
  }
  const allNumbers = values.every((value2) => typeof value2 === "number");
  if (allNumbers) {
    return ScaleType.Linear;
  }
  return ScaleType.Ordinal;
}
function sortLinear(data, property, direction = "asc") {
  return data.sort((a, b) => {
    if (direction === "asc") {
      return a[property] - b[property];
    } else {
      return b[property] - a[property];
    }
  });
}
function sortByDomain(data, property, direction = "asc", domain) {
  return data.sort((a, b) => {
    const aVal = a[property];
    const bVal = b[property];
    const aIdx = domain.indexOf(aVal);
    const bIdx = domain.indexOf(bVal);
    if (direction === "asc") {
      return aIdx - bIdx;
    } else {
      return bIdx - aIdx;
    }
  });
}
function sortByTime(data, property, direction = "asc") {
  return data.sort((a, b) => {
    const aDate = a[property].getTime();
    const bDate = b[property].getTime();
    if (direction === "asc") {
      if (aDate > bDate) return 1;
      if (bDate > aDate) return -1;
      return 0;
    } else {
      if (aDate > bDate) return -1;
      if (bDate > aDate) return 1;
      return 0;
    }
  });
}
var _AreaSeriesComponent = class _AreaSeriesComponent {
  constructor() {
    this.baseValue = "auto";
    this.stacked = false;
    this.normalized = false;
    this.animations = true;
    this.select = new EventEmitter();
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.updateGradient();
    let currentArea;
    let startingArea;
    const xProperty = (d) => {
      const label = d.name;
      return this.xScale(label);
    };
    if (this.stacked || this.normalized) {
      currentArea = area_default().x(xProperty).y0((d, i) => this.yScale(d.d0)).y1((d, i) => this.yScale(d.d1));
      startingArea = area_default().x(xProperty).y0((d) => this.yScale.range()[0]).y1((d) => this.yScale.range()[0]);
    } else {
      currentArea = area_default().x(xProperty).y0(() => this.baseValue === "auto" ? this.yScale.range()[0] : this.yScale(this.baseValue)).y1((d) => this.yScale(d.value));
      startingArea = area_default().x(xProperty).y0((d) => this.baseValue === "auto" ? this.yScale.range()[0] : this.yScale(this.baseValue)).y1((d) => this.baseValue === "auto" ? this.yScale.range()[0] : this.yScale(this.baseValue));
    }
    currentArea.curve(this.curve);
    startingArea.curve(this.curve);
    this.opacity = 0.8;
    let data = this.data.series;
    if (this.scaleType === ScaleType.Linear) {
      data = sortLinear(data, "name");
    } else if (this.scaleType === ScaleType.Time) {
      data = sortByTime(data, "name");
    } else {
      data = sortByDomain(data, "name", "asc", this.xScale.domain());
    }
    this.path = currentArea(data);
    this.startingPath = startingArea(data);
  }
  updateGradient() {
    if (this.colors.scaleType === ScaleType.Linear) {
      this.hasGradient = true;
      if (this.stacked || this.normalized) {
        const d0values = this.data.series.map((d) => d.d0);
        const d1values = this.data.series.map((d) => d.d1);
        const max6 = Math.max(...d1values);
        const min6 = Math.min(...d0values);
        this.gradientStops = this.colors.getLinearGradientStops(max6, min6);
      } else {
        const values = this.data.series.map((d) => d.value);
        const max6 = Math.max(...values);
        this.gradientStops = this.colors.getLinearGradientStops(max6);
      }
    } else {
      this.hasGradient = false;
      this.gradientStops = void 0;
    }
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item !== void 0;
  }
  isInactive(entry) {
    if (!this.activeEntries || this.activeEntries.length === 0) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item === void 0;
  }
};
_AreaSeriesComponent.\u0275fac = function AreaSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AreaSeriesComponent)();
};
_AreaSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AreaSeriesComponent,
  selectors: [["g", "ngx-charts-area-series", ""]],
  inputs: {
    data: "data",
    xScale: "xScale",
    yScale: "yScale",
    baseValue: "baseValue",
    colors: "colors",
    scaleType: "scaleType",
    stacked: "stacked",
    normalized: "normalized",
    gradient: "gradient",
    curve: "curve",
    activeEntries: "activeEntries",
    animations: "animations"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c21,
  decls: 1,
  vars: 12,
  consts: [["ngx-charts-area", "", 1, "area-series", 3, "data", "path", "fill", "stops", "startingPath", "opacity", "gradient", "animations"]],
  template: function AreaSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275element(0, "g", 0);
    }
    if (rf & 2) {
      \u0275\u0275classProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
      \u0275\u0275property("data", ctx.data)("path", ctx.path)("fill", ctx.colors.getColor(ctx.data.name))("stops", ctx.gradientStops)("startingPath", ctx.startingPath)("opacity", ctx.opacity)("gradient", ctx.gradient || ctx.hasGradient)("animations", ctx.animations);
    }
  },
  dependencies: [AreaComponent],
  encapsulation: 2,
  changeDetection: 0
});
var AreaSeriesComponent = _AreaSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-area-series]",
      template: `
    <svg:g
      ngx-charts-area
      class="area-series"
      [data]="data"
      [path]="path"
      [fill]="colors.getColor(data.name)"
      [stops]="gradientStops"
      [startingPath]="startingPath"
      [opacity]="opacity"
      [gradient]="gradient || hasGradient"
      [animations]="animations"
      [class.active]="isActive(data)"
      [class.inactive]="isInactive(data)"
    />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    baseValue: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    stacked: [{
      type: Input
    }],
    normalized: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
var _AreaChartComponent = class _AreaChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.xAxis = false;
    this.yAxis = false;
    this.baseValue = "auto";
    this.autoScale = false;
    this.timeline = false;
    this.showGridLines = true;
    this.curve = linear_default;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.tooltipDisabled = false;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.timelineHeight = 50;
    this.timelinePadding = 10;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.timeline) {
      this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
    }
    this.xDomain = this.getXDomain();
    if (this.filteredDomain) {
      this.xDomain = this.filteredDomain;
    }
    this.yDomain = this.getYDomain();
    this.seriesDomain = this.getSeriesDomain();
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
    this.yScale = this.getYScale(this.yDomain, this.dims.height);
    this.updateTimeline();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset}, ${this.margin[0]})`;
    this.clipPathId = "clip" + id2().toString();
    this.clipPath = `url(#${this.clipPathId})`;
  }
  updateTimeline() {
    if (this.timeline) {
      this.timelineWidth = this.dims.width;
      this.timelineXDomain = this.getXDomain();
      this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
      this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
      this.timelineTransform = `translate(${this.dims.xOffset}, ${-this.margin[2]})`;
    }
  }
  getXDomain() {
    let values = getUniqueXDomainValues(this.results);
    this.scaleType = getScaleType(values);
    let domain = [];
    if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
    }
    let min6;
    let max6;
    if (this.scaleType === ScaleType.Time || this.scaleType === ScaleType.Linear) {
      min6 = this.xScaleMin ? this.xScaleMin : Math.min(...values);
      max6 = this.xScaleMax ? this.xScaleMax : Math.max(...values);
    }
    if (this.scaleType === ScaleType.Time) {
      domain = [new Date(min6), new Date(max6)];
      this.xSet = [...values].sort((a, b) => {
        const aDate = a.getTime();
        const bDate = b.getTime();
        if (aDate > bDate) return 1;
        if (bDate > aDate) return -1;
        return 0;
      });
    } else if (this.scaleType === ScaleType.Linear) {
      domain = [min6, max6];
      this.xSet = [...values].sort((a, b) => a - b);
    } else {
      domain = values;
      this.xSet = values;
    }
    return domain;
  }
  getYDomain() {
    const domain = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (!domain.includes(d.value)) {
          domain.push(d.value);
        }
      }
    }
    const values = [...domain];
    if (!this.autoScale) {
      values.push(0);
    }
    if (this.baseValue !== "auto") {
      values.push(this.baseValue);
    }
    const min6 = this.yScaleMin ? this.yScaleMin : Math.min(...values);
    const max6 = this.yScaleMax ? this.yScaleMax : Math.max(...values);
    return [min6, max6];
  }
  getSeriesDomain() {
    return this.results.map((d) => d.name);
  }
  getXScale(domain, width) {
    let scale;
    if (this.scaleType === ScaleType.Time) {
      scale = time();
    } else if (this.scaleType === ScaleType.Linear) {
      scale = linear2();
    } else if (this.scaleType === ScaleType.Ordinal) {
      scale = point().padding(0.1);
    }
    scale.range([0, width]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getYScale(domain, height) {
    const scale = linear2().range([height, 0]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getScaleType(values) {
    let date2 = true;
    let num = true;
    for (const value2 of values) {
      if (isDate2(value2)) {
        date2 = false;
      }
      if (isNumber(value2)) {
        num = false;
      }
    }
    if (date2) {
      return ScaleType.Time;
    }
    if (num) {
      return ScaleType.Linear;
    }
    return ScaleType.Ordinal;
  }
  updateDomain(domain) {
    this.filteredDomain = domain;
    this.xDomain = this.filteredDomain;
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
  }
  updateHoveredVertical(item) {
    this.hoveredVertical = item.value;
    this.deactivateAll();
  }
  hideCircles() {
    this.hoveredVertical = null;
    this.deactivateAll();
  }
  onClick(data, series) {
    if (series) {
      data.series = series.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.seriesDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.seriesDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.yDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
};
_AreaChartComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275AreaChartComponent_BaseFactory;
  return function AreaChartComponent_Factory(__ngFactoryType__) {
    return (\u0275AreaChartComponent_BaseFactory || (\u0275AreaChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_AreaChartComponent)))(__ngFactoryType__ || _AreaChartComponent);
  };
})();
_AreaChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AreaChartComponent,
  selectors: [["ngx-charts-area-chart"]],
  contentQueries: function AreaChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
      \u0275\u0275contentQuery(dirIndex, _c232, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    }
  },
  hostBindings: function AreaChartComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseleave", function AreaChartComponent_mouseleave_HostBindingHandler() {
        return ctx.hideCircles();
      });
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    baseValue: "baseValue",
    autoScale: "autoScale",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    timeline: "timeline",
    gradient: "gradient",
    showGridLines: "showGridLines",
    curve: "curve",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    roundDomains: "roundDomains",
    tooltipDisabled: "tooltipDisabled",
    xScaleMin: "xScaleMin",
    xScaleMax: "xScaleMax",
    yScaleMin: "yScaleMin",
    yScaleMax: "yScaleMax",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 11,
  vars: 20,
  consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "activeEntries", "scaleType", "gradient", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "hover", "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "select", "activate", "deactivate", "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate"], ["ngx-charts-timeline", "", 3, "onDomainChange", "results", "view", "height", "scheme", "customColors", "legend", "scaleType"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "baseValue", "colors", "data", "scaleType", "gradient", "curve", "animations"]],
  template: function AreaChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelClick", function AreaChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      })("legendLabelActivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event);
      })("legendLabelDeactivate", function AreaChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "defs")(2, "clipPath");
      \u0275\u0275element(3, "rect");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(4, "g", 1);
      \u0275\u0275template(5, AreaChartComponent__svg_g_5_Template, 1, 11, "g", 2)(6, AreaChartComponent__svg_g_6_Template, 1, 10, "g", 3);
      \u0275\u0275elementStart(7, "g");
      \u0275\u0275template(8, AreaChartComponent__svg_g_8_Template, 2, 10, "g", 4)(9, AreaChartComponent__svg_g_9_Template, 3, 9, "g", 5);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(10, AreaChartComponent__svg_g_10_Template, 2, 13, "g", 6);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance(2);
      \u0275\u0275attribute("id", ctx.clipPathId);
      \u0275\u0275advance();
      \u0275\u0275attribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275attribute("clip-path", ctx.clipPath);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.tooltipDisabled);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, TooltipArea, ChartComponent, CircleSeriesComponent, Timeline, AreaSeriesComponent],
  styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var AreaChartComponent = _AreaChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-area-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:defs>
        <svg:clipPath [attr.id]="clipPathId">
          <svg:rect
            [attr.width]="dims.width + 10"
            [attr.height]="dims.height + 10"
            [attr.transform]="'translate(-5, -5)'"
          />
        </svg:clipPath>
      </svg:defs>
      <svg:g [attr.transform]="transform" class="area-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g [attr.clip-path]="clipPath">
          <svg:g *ngFor="let series of results; trackBy: trackBy">
            <svg:g
              ngx-charts-area-series
              [xScale]="xScale"
              [yScale]="yScale"
              [baseValue]="baseValue"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [scaleType]="scaleType"
              [gradient]="gradient"
              [curve]="curve"
              [animations]="animations"
            />
          </svg:g>

          <svg:g *ngIf="!tooltipDisabled" (mouseleave)="hideCircles()">
            <svg:g
              ngx-charts-tooltip-area
              [dims]="dims"
              [xSet]="xSet"
              [xScale]="xScale"
              [yScale]="yScale"
              [results]="results"
              [colors]="colors"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="seriesTooltipTemplate"
              (hover)="updateHoveredVertical($event)"
            />

            <svg:g *ngFor="let series of results">
              <svg:g
                ngx-charts-circle-series
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [activeEntries]="activeEntries"
                [data]="series"
                [scaleType]="scaleType"
                [visibleValue]="hoveredVertical"
                [tooltipDisabled]="tooltipDisabled"
                [tooltipTemplate]="tooltipTemplate"
                (select)="onClick($event, series)"
                (activate)="onActivate($event)"
                (deactivate)="onDeactivate($event)"
              />
            </svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
      <svg:g
        ngx-charts-timeline
        *ngIf="timeline && scaleType != 'ordinal'"
        [attr.transform]="timelineTransform"
        [results]="results"
        [view]="[timelineWidth, height]"
        [height]="timelineHeight"
        [scheme]="scheme"
        [customColors]="customColors"
        [legend]="legend"
        [scaleType]="scaleType"
        (onDomainChange)="updateDomain($event)"
      >
        <svg:g *ngFor="let series of results; trackBy: trackBy">
          <svg:g
            ngx-charts-area-series
            [xScale]="timelineXScale"
            [yScale]="timelineYScale"
            [baseValue]="baseValue"
            [colors]="colors"
            [data]="series"
            [scaleType]="scaleType"
            [gradient]="gradient"
            [curve]="curve"
            [animations]="animations"
          />
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    baseValue: [{
      type: Input
    }],
    autoScale: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    timeline: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    xScaleMin: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    yScaleMin: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    seriesTooltipTemplate: [{
      type: ContentChild,
      args: ["seriesTooltipTemplate"]
    }],
    hideCircles: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var _AreaChartNormalizedComponent = class _AreaChartNormalizedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.showXAxisLabel = false;
    this.showYAxisLabel = false;
    this.showGridLines = true;
    this.curve = linear_default;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.tooltipDisabled = false;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.yDomain = [0, 100];
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.seriesType = SeriesType;
    this.timelineHeight = 50;
    this.timelinePadding = 10;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.timeline) {
      this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
    }
    this.xDomain = this.getXDomain();
    if (this.filteredDomain) {
      this.xDomain = this.filteredDomain;
    }
    this.seriesDomain = this.getSeriesDomain();
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
    this.yScale = this.getYScale(this.yDomain, this.dims.height);
    for (let i = 0; i < this.xSet.length; i++) {
      const val = this.xSet[i];
      let d0 = 0;
      let total = 0;
      for (const group of this.results) {
        const d = group.series.find((item) => {
          let a = item.name;
          let b = val;
          if (this.scaleType === ScaleType.Time) {
            a = a.valueOf();
            b = b.valueOf();
          }
          return a === b;
        });
        if (d) {
          total += d.value;
        }
      }
      for (const group of this.results) {
        let d = group.series.find((item) => {
          let a = item.name;
          let b = val;
          if (this.scaleType === ScaleType.Time) {
            a = a.valueOf();
            b = b.valueOf();
          }
          return a === b;
        });
        if (d) {
          d.d0 = d0;
          d.d1 = d0 + d.value;
          d0 += d.value;
        } else {
          d = {
            name: val,
            value: 0,
            d0,
            d1: d0
          };
          group.series.push(d);
        }
        if (total > 0) {
          d.d0 = d.d0 * 100 / total;
          d.d1 = d.d1 * 100 / total;
        } else {
          d.d0 = 0;
          d.d1 = 0;
        }
      }
    }
    this.updateTimeline();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    this.clipPathId = "clip" + id2().toString();
    this.clipPath = `url(#${this.clipPathId})`;
  }
  updateTimeline() {
    if (this.timeline) {
      this.timelineWidth = this.dims.width;
      this.timelineXDomain = this.getXDomain();
      this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
      this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
      this.timelineTransform = `translate(${this.dims.xOffset}, ${-this.margin[2]})`;
    }
  }
  getXDomain() {
    let values = getUniqueXDomainValues(this.results);
    this.scaleType = getScaleType(values);
    let domain = [];
    if (this.scaleType === ScaleType.Time) {
      const min6 = Math.min(...values);
      const max6 = Math.max(...values);
      domain = [new Date(min6), new Date(max6)];
      this.xSet = [...values].sort((a, b) => {
        const aDate = a.getTime();
        const bDate = b.getTime();
        if (aDate > bDate) return 1;
        if (bDate > aDate) return -1;
        return 0;
      });
    } else if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
      const min6 = Math.min(...values);
      const max6 = Math.max(...values);
      domain = [min6, max6];
      this.xSet = [...values].sort((a, b) => a - b);
    } else {
      domain = values;
      this.xSet = values;
    }
    return domain;
  }
  getSeriesDomain() {
    return this.results.map((d) => d.name);
  }
  getXScale(domain, width) {
    let scale;
    if (this.scaleType === ScaleType.Time) {
      scale = time();
    } else if (this.scaleType === ScaleType.Linear) {
      scale = linear2();
    } else if (this.scaleType === ScaleType.Ordinal) {
      scale = point().padding(0.1);
    }
    scale.range([0, width]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getYScale(domain, height) {
    const scale = linear2().range([height, 0]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  updateDomain(domain) {
    this.filteredDomain = domain;
    this.xDomain = this.filteredDomain;
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
  }
  updateHoveredVertical(item) {
    this.hoveredVertical = item.value;
    this.deactivateAll();
  }
  hideCircles() {
    this.hoveredVertical = null;
    this.deactivateAll();
  }
  onClick(data, series) {
    if (series) {
      data.series = series.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.seriesDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.seriesDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.yDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
};
_AreaChartNormalizedComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275AreaChartNormalizedComponent_BaseFactory;
  return function AreaChartNormalizedComponent_Factory(__ngFactoryType__) {
    return (\u0275AreaChartNormalizedComponent_BaseFactory || (\u0275AreaChartNormalizedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_AreaChartNormalizedComponent)))(__ngFactoryType__ || _AreaChartNormalizedComponent);
  };
})();
_AreaChartNormalizedComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AreaChartNormalizedComponent,
  selectors: [["ngx-charts-area-chart-normalized"]],
  contentQueries: function AreaChartNormalizedComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
      \u0275\u0275contentQuery(dirIndex, _c232, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    }
  },
  hostBindings: function AreaChartNormalizedComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseleave", function AreaChartNormalizedComponent_mouseleave_HostBindingHandler() {
        return ctx.hideCircles();
      });
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    timeline: "timeline",
    gradient: "gradient",
    showGridLines: "showGridLines",
    curve: "curve",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    roundDomains: "roundDomains",
    tooltipDisabled: "tooltipDisabled",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 11,
  vars: 20,
  consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "activeEntries", "gradient", "normalized", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "hover", "dims", "xSet", "xScale", "yScale", "results", "colors", "showPercentage", "tooltipDisabled", "tooltipTemplate"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "select", "activate", "deactivate", "type", "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate"], ["ngx-charts-timeline", "", 3, "onDomainChange", "results", "view", "height", "scheme", "customColors", "legend", "scaleType"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "normalized", "curve", "animations"]],
  template: function AreaChartNormalizedComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelClick", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      })("legendLabelActivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event);
      })("legendLabelDeactivate", function AreaChartNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "defs")(2, "clipPath");
      \u0275\u0275element(3, "rect");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(4, "g", 1);
      \u0275\u0275template(5, AreaChartNormalizedComponent__svg_g_5_Template, 1, 11, "g", 2)(6, AreaChartNormalizedComponent__svg_g_6_Template, 1, 10, "g", 3);
      \u0275\u0275elementStart(7, "g");
      \u0275\u0275template(8, AreaChartNormalizedComponent__svg_g_8_Template, 2, 10, "g", 4)(9, AreaChartNormalizedComponent__svg_g_9_Template, 3, 10, "g", 5);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(10, AreaChartNormalizedComponent__svg_g_10_Template, 2, 13, "g", 6);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance(2);
      \u0275\u0275attribute("id", ctx.clipPathId);
      \u0275\u0275advance();
      \u0275\u0275attribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275attribute("clip-path", ctx.clipPath);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.tooltipDisabled);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, TooltipArea, ChartComponent, CircleSeriesComponent, Timeline, AreaSeriesComponent],
  styles: [_c25],
  encapsulation: 2,
  changeDetection: 0
});
var AreaChartNormalizedComponent = _AreaChartNormalizedComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaChartNormalizedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-area-chart-normalized",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:defs>
        <svg:clipPath [attr.id]="clipPathId">
          <svg:rect
            [attr.width]="dims.width + 10"
            [attr.height]="dims.height + 10"
            [attr.transform]="'translate(-5, -5)'"
          />
        </svg:clipPath>
      </svg:defs>
      <svg:g [attr.transform]="transform" class="area-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g [attr.clip-path]="clipPath">
          <svg:g *ngFor="let series of results; trackBy: trackBy">
            <svg:g
              ngx-charts-area-series
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [data]="series"
              [scaleType]="scaleType"
              [activeEntries]="activeEntries"
              [gradient]="gradient"
              [normalized]="true"
              [curve]="curve"
              [animations]="animations"
            />
          </svg:g>

          <svg:g *ngIf="!tooltipDisabled" (mouseleave)="hideCircles()">
            <svg:g
              ngx-charts-tooltip-area
              [dims]="dims"
              [xSet]="xSet"
              [xScale]="xScale"
              [yScale]="yScale"
              [results]="results"
              [colors]="colors"
              [showPercentage]="true"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="seriesTooltipTemplate"
              (hover)="updateHoveredVertical($event)"
            />

            <svg:g *ngFor="let series of results">
              <svg:g
                ngx-charts-circle-series
                [type]="seriesType.Stacked"
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [activeEntries]="activeEntries"
                [data]="series"
                [scaleType]="scaleType"
                [visibleValue]="hoveredVertical"
                [tooltipDisabled]="tooltipDisabled"
                [tooltipTemplate]="tooltipTemplate"
                (select)="onClick($event, series)"
                (activate)="onActivate($event)"
                (deactivate)="onDeactivate($event)"
              />
            </svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
      <svg:g
        ngx-charts-timeline
        *ngIf="timeline && scaleType != 'ordinal'"
        [attr.transform]="timelineTransform"
        [results]="results"
        [view]="[timelineWidth, height]"
        [height]="timelineHeight"
        [scheme]="scheme"
        [customColors]="customColors"
        [legend]="legend"
        [scaleType]="scaleType"
        (onDomainChange)="updateDomain($event)"
      >
        <svg:g *ngFor="let series of results; trackBy: trackBy">
          <svg:g
            ngx-charts-area-series
            [xScale]="timelineXScale"
            [yScale]="timelineYScale"
            [colors]="colors"
            [data]="series"
            [scaleType]="scaleType"
            [gradient]="gradient"
            [normalized]="true"
            [curve]="curve"
            [animations]="animations"
          />
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    timeline: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    seriesTooltipTemplate: [{
      type: ContentChild,
      args: ["seriesTooltipTemplate"]
    }],
    hideCircles: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var _AreaChartStackedComponent = class _AreaChartStackedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.xAxis = false;
    this.yAxis = false;
    this.timeline = false;
    this.showGridLines = true;
    this.curve = linear_default;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.tooltipDisabled = false;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.timelineHeight = 50;
    this.timelinePadding = 10;
    this.seriesType = SeriesType;
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.timeline) {
      this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
    }
    this.xDomain = this.getXDomain();
    if (this.filteredDomain) {
      this.xDomain = this.filteredDomain;
    }
    this.yDomain = this.getYDomain();
    this.seriesDomain = this.getSeriesDomain();
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
    this.yScale = this.getYScale(this.yDomain, this.dims.height);
    for (let i = 0; i < this.xSet.length; i++) {
      const val = this.xSet[i];
      let d0 = 0;
      for (const group of this.results) {
        let d = group.series.find((item) => {
          let a = item.name;
          let b = val;
          if (this.scaleType === ScaleType.Time) {
            a = a.valueOf();
            b = b.valueOf();
          }
          return a === b;
        });
        if (d) {
          d.d0 = d0;
          d.d1 = d0 + d.value;
          d0 += d.value;
        } else {
          d = {
            name: val,
            value: 0,
            d0,
            d1: d0
          };
          group.series.push(d);
        }
      }
    }
    this.updateTimeline();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    this.clipPathId = "clip" + id2().toString();
    this.clipPath = `url(#${this.clipPathId})`;
  }
  updateTimeline() {
    if (this.timeline) {
      this.timelineWidth = this.dims.width;
      this.timelineXDomain = this.getXDomain();
      this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
      this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
      this.timelineTransform = `translate(${this.dims.xOffset}, ${-this.margin[2]})`;
    }
  }
  getXDomain() {
    let values = getUniqueXDomainValues(this.results);
    this.scaleType = getScaleType(values);
    let domain = [];
    if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
    }
    let min6;
    let max6;
    if (this.scaleType === ScaleType.Time || this.scaleType === ScaleType.Linear) {
      min6 = this.xScaleMin ? this.xScaleMin : Math.min(...values);
      max6 = this.xScaleMax ? this.xScaleMax : Math.max(...values);
    }
    if (this.scaleType === ScaleType.Time) {
      domain = [new Date(min6), new Date(max6)];
      this.xSet = [...values].sort((a, b) => {
        const aDate = a.getTime();
        const bDate = b.getTime();
        if (aDate > bDate) return 1;
        if (bDate > aDate) return -1;
        return 0;
      });
    } else if (this.scaleType === ScaleType.Linear) {
      domain = [min6, max6];
      this.xSet = [...values].sort((a, b) => a - b);
    } else {
      domain = values;
      this.xSet = values;
    }
    return domain;
  }
  getYDomain() {
    const domain = [];
    for (let i = 0; i < this.xSet.length; i++) {
      const val = this.xSet[i];
      let sum2 = 0;
      for (const group of this.results) {
        const d = group.series.find((item) => {
          let a = item.name;
          let b = val;
          if (this.scaleType === ScaleType.Time) {
            a = a.valueOf();
            b = b.valueOf();
          }
          return a === b;
        });
        if (d) {
          sum2 += d.value;
        }
      }
      domain.push(sum2);
    }
    const min6 = this.yScaleMin ? this.yScaleMin : Math.min(0, ...domain);
    const max6 = this.yScaleMax ? this.yScaleMax : Math.max(...domain);
    return [min6, max6];
  }
  getSeriesDomain() {
    return this.results.map((d) => d.name);
  }
  getXScale(domain, width) {
    let scale;
    if (this.scaleType === ScaleType.Time) {
      scale = time();
    } else if (this.scaleType === ScaleType.Linear) {
      scale = linear2();
    } else if (this.scaleType === ScaleType.Ordinal) {
      scale = point().padding(0.1);
    }
    scale.range([0, width]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getYScale(domain, height) {
    const scale = linear2().range([height, 0]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  updateDomain(domain) {
    this.filteredDomain = domain;
    this.xDomain = this.filteredDomain;
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
  }
  updateHoveredVertical(item) {
    this.hoveredVertical = item.value;
    this.deactivateAll();
  }
  hideCircles() {
    this.hoveredVertical = null;
    this.deactivateAll();
  }
  onClick(data, series) {
    if (series) {
      data.series = series.name;
    }
    this.select.emit(data);
  }
  trackBy(index, item) {
    return `${item.name}`;
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.seriesDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.seriesDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.yDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
};
_AreaChartStackedComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275AreaChartStackedComponent_BaseFactory;
  return function AreaChartStackedComponent_Factory(__ngFactoryType__) {
    return (\u0275AreaChartStackedComponent_BaseFactory || (\u0275AreaChartStackedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_AreaChartStackedComponent)))(__ngFactoryType__ || _AreaChartStackedComponent);
  };
})();
_AreaChartStackedComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AreaChartStackedComponent,
  selectors: [["ngx-charts-area-chart-stacked"]],
  contentQueries: function AreaChartStackedComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
      \u0275\u0275contentQuery(dirIndex, _c232, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    }
  },
  hostBindings: function AreaChartStackedComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseleave", function AreaChartStackedComponent_mouseleave_HostBindingHandler() {
        return ctx.hideCircles();
      });
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    timeline: "timeline",
    gradient: "gradient",
    showGridLines: "showGridLines",
    curve: "curve",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    roundDomains: "roundDomains",
    tooltipDisabled: "tooltipDisabled",
    xScaleMin: "xScaleMin",
    xScaleMax: "xScaleMax",
    yScaleMin: "yScaleMin",
    yScaleMax: "yScaleMax",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 11,
  vars: 20,
  consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "area-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "legend", "scaleType", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "activeEntries", "stacked", "curve", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "hover", "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate"], ["ngx-charts-circle-series", "", 3, "select", "activate", "deactivate", "type", "xScale", "yScale", "colors", "activeEntries", "data", "scaleType", "visibleValue", "tooltipDisabled", "tooltipTemplate"], ["ngx-charts-timeline", "", 3, "onDomainChange", "results", "view", "height", "scheme", "customColors", "legend", "scaleType"], ["ngx-charts-area-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "gradient", "stacked", "curve", "animations"]],
  template: function AreaChartStackedComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelClick", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      })("legendLabelActivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event);
      })("legendLabelDeactivate", function AreaChartStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "defs")(2, "clipPath");
      \u0275\u0275element(3, "rect");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(4, "g", 1);
      \u0275\u0275template(5, AreaChartStackedComponent__svg_g_5_Template, 1, 11, "g", 2)(6, AreaChartStackedComponent__svg_g_6_Template, 1, 10, "g", 3);
      \u0275\u0275elementStart(7, "g");
      \u0275\u0275template(8, AreaChartStackedComponent__svg_g_8_Template, 2, 10, "g", 4)(9, AreaChartStackedComponent__svg_g_9_Template, 3, 10, "g", 5);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(10, AreaChartStackedComponent__svg_g_10_Template, 2, 13, "g", 6);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance(2);
      \u0275\u0275attribute("id", ctx.clipPathId);
      \u0275\u0275advance();
      \u0275\u0275attribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275attribute("clip-path", ctx.clipPath);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.tooltipDisabled);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, TooltipArea, ChartComponent, CircleSeriesComponent, Timeline, AreaSeriesComponent],
  styles: [_c25],
  encapsulation: 2,
  changeDetection: 0
});
var AreaChartStackedComponent = _AreaChartStackedComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaChartStackedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-area-chart-stacked",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:defs>
        <svg:clipPath [attr.id]="clipPathId">
          <svg:rect
            [attr.width]="dims.width + 10"
            [attr.height]="dims.height + 10"
            [attr.transform]="'translate(-5, -5)'"
          />
        </svg:clipPath>
      </svg:defs>
      <svg:g [attr.transform]="transform" class="area-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g [attr.clip-path]="clipPath">
          <svg:g *ngFor="let series of results; trackBy: trackBy">
            <svg:g
              ngx-charts-area-series
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [data]="series"
              [scaleType]="scaleType"
              [gradient]="gradient"
              [activeEntries]="activeEntries"
              [stacked]="true"
              [curve]="curve"
              [animations]="animations"
            />
          </svg:g>

          <svg:g *ngIf="!tooltipDisabled" (mouseleave)="hideCircles()">
            <svg:g
              ngx-charts-tooltip-area
              [dims]="dims"
              [xSet]="xSet"
              [xScale]="xScale"
              [yScale]="yScale"
              [results]="results"
              [colors]="colors"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="seriesTooltipTemplate"
              (hover)="updateHoveredVertical($event)"
            />

            <svg:g *ngFor="let series of results; trackBy: trackBy">
              <svg:g
                ngx-charts-circle-series
                [type]="seriesType.Stacked"
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [activeEntries]="activeEntries"
                [data]="series"
                [scaleType]="scaleType"
                [visibleValue]="hoveredVertical"
                [tooltipDisabled]="tooltipDisabled"
                [tooltipTemplate]="tooltipTemplate"
                (select)="onClick($event, series)"
                (activate)="onActivate($event)"
                (deactivate)="onDeactivate($event)"
              />
            </svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
      <svg:g
        ngx-charts-timeline
        *ngIf="timeline && scaleType != 'ordinal'"
        [attr.transform]="timelineTransform"
        [results]="results"
        [view]="[timelineWidth, height]"
        [height]="timelineHeight"
        [scheme]="scheme"
        [customColors]="customColors"
        [legend]="legend"
        [scaleType]="scaleType"
        (onDomainChange)="updateDomain($event)"
      >
        <svg:g *ngFor="let series of results; trackBy: trackBy">
          <svg:g
            ngx-charts-area-series
            [xScale]="timelineXScale"
            [yScale]="timelineYScale"
            [colors]="colors"
            [data]="series"
            [scaleType]="scaleType"
            [gradient]="gradient"
            [stacked]="true"
            [curve]="curve"
            [animations]="animations"
          />
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    timeline: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    xScaleMin: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    yScaleMin: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    seriesTooltipTemplate: [{
      type: ContentChild,
      args: ["seriesTooltipTemplate"]
    }],
    hideCircles: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var _AreaChartModule = class _AreaChartModule {
};
_AreaChartModule.\u0275fac = function AreaChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AreaChartModule)();
};
_AreaChartModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _AreaChartModule
});
_AreaChartModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule]
});
var AreaChartModule = _AreaChartModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AreaChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent],
      exports: [AreaChartComponent, AreaChartNormalizedComponent, AreaChartStackedComponent, AreaSeriesComponent]
    }]
  }], null, null);
})();
var _BarComponent = class _BarComponent {
  constructor(element) {
    this.roundEdges = true;
    this.gradient = false;
    this.offset = 0;
    this.isActive = false;
    this.animations = true;
    this.noBarWhenZero = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.hasGradient = false;
    this.hideBar = false;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    if (changes.roundEdges) {
      this.loadAnimation();
    }
    this.update();
  }
  update() {
    this.gradientId = "grad" + id2().toString();
    this.gradientFill = `url(#${this.gradientId})`;
    if (this.gradient || this.stops) {
      this.gradientStops = this.getGradient();
      this.hasGradient = true;
    } else {
      this.hasGradient = false;
    }
    this.updatePathEl();
    this.checkToHideBar();
  }
  loadAnimation() {
    this.path = this.getStartingPath();
    setTimeout(this.update.bind(this), 100);
  }
  updatePathEl() {
    const node = select_default2(this.element).select(".bar");
    const path3 = this.getPath();
    if (this.animations) {
      node.transition().duration(500).attr("d", path3);
    } else {
      node.attr("d", path3);
    }
  }
  getGradient() {
    if (this.stops) {
      return this.stops;
    }
    return [{
      offset: 0,
      color: this.fill,
      opacity: this.getStartOpacity()
    }, {
      offset: 100,
      color: this.fill,
      opacity: 1
    }];
  }
  getStartingPath() {
    if (!this.animations) {
      return this.getPath();
    }
    let radius = this.getRadius();
    let path3;
    if (this.roundEdges) {
      if (this.orientation === BarOrientation.Vertical) {
        radius = Math.min(this.height, radius);
        path3 = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
      } else if (this.orientation === BarOrientation.Horizontal) {
        radius = Math.min(this.width, radius);
        path3 = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
      }
    } else {
      if (this.orientation === BarOrientation.Vertical) {
        path3 = roundedRect(this.x, this.y + this.height, this.width, 1, 0, this.edges);
      } else if (this.orientation === BarOrientation.Horizontal) {
        path3 = roundedRect(this.x, this.y, 1, this.height, 0, this.edges);
      }
    }
    return path3;
  }
  getPath() {
    let radius = this.getRadius();
    let path3;
    if (this.roundEdges) {
      if (this.orientation === BarOrientation.Vertical) {
        radius = Math.min(this.height, radius);
        path3 = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
      } else if (this.orientation === BarOrientation.Horizontal) {
        radius = Math.min(this.width, radius);
        path3 = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
      }
    } else {
      path3 = roundedRect(this.x, this.y, this.width, this.height, radius, this.edges);
    }
    return path3;
  }
  getRadius() {
    let radius = 0;
    if (this.roundEdges && this.height > 5 && this.width > 5) {
      radius = Math.floor(Math.min(5, this.height / 2, this.width / 2));
    }
    return radius;
  }
  getStartOpacity() {
    if (this.roundEdges) {
      return 0.2;
    } else {
      return 0.5;
    }
  }
  get edges() {
    let edges = [false, false, false, false];
    if (this.roundEdges) {
      if (this.orientation === BarOrientation.Vertical) {
        if (this.data.value > 0) {
          edges = [true, true, false, false];
        } else {
          edges = [false, false, true, true];
        }
      } else if (this.orientation === BarOrientation.Horizontal) {
        if (this.data.value > 0) {
          edges = [false, true, false, true];
        } else {
          edges = [true, false, true, false];
        }
      }
    }
    return edges;
  }
  onMouseEnter() {
    this.activate.emit(this.data);
  }
  onMouseLeave() {
    this.deactivate.emit(this.data);
  }
  checkToHideBar() {
    this.hideBar = this.noBarWhenZero && (this.orientation === BarOrientation.Vertical && this.height === 0 || this.orientation === BarOrientation.Horizontal && this.width === 0);
  }
};
_BarComponent.\u0275fac = function BarComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BarComponent)(\u0275\u0275directiveInject(ElementRef));
};
_BarComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BarComponent,
  selectors: [["g", "ngx-charts-bar", ""]],
  hostBindings: function BarComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseenter", function BarComponent_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function BarComponent_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      });
    }
  },
  inputs: {
    fill: "fill",
    data: "data",
    width: "width",
    height: "height",
    x: "x",
    y: "y",
    orientation: "orientation",
    roundEdges: "roundEdges",
    gradient: "gradient",
    offset: "offset",
    isActive: "isActive",
    stops: "stops",
    animations: "animations",
    ariaLabel: "ariaLabel",
    noBarWhenZero: "noBarWhenZero"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c26,
  decls: 2,
  vars: 8,
  consts: [[4, "ngIf"], ["stroke", "none", "role", "img", "tabIndex", "-1", 1, "bar", 3, "click"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]],
  template: function BarComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, BarComponent__svg_defs_0_Template, 2, 3, "defs", 0);
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "path", 1);
      \u0275\u0275listener("click", function BarComponent_Template_path_click_1_listener() {
        return ctx.select.emit(ctx.data);
      });
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", ctx.hasGradient);
      \u0275\u0275advance();
      \u0275\u0275classProp("active", ctx.isActive)("hidden", ctx.hideBar);
      \u0275\u0275attribute("d", ctx.path)("aria-label", ctx.ariaLabel)("fill", ctx.hasGradient ? ctx.gradientFill : ctx.fill);
    }
  },
  dependencies: [NgIf, SvgLinearGradientComponent],
  encapsulation: 2,
  changeDetection: 0
});
var BarComponent = _BarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-bar]",
      template: `
    <svg:defs *ngIf="hasGradient">
      <svg:g ngx-charts-svg-linear-gradient [orientation]="orientation" [name]="gradientId" [stops]="gradientStops" />
    </svg:defs>
    <svg:path
      class="bar"
      stroke="none"
      role="img"
      tabIndex="-1"
      [class.active]="isActive"
      [class.hidden]="hideBar"
      [attr.d]="path"
      [attr.aria-label]="ariaLabel"
      [attr.fill]="hasGradient ? gradientFill : fill"
      (click)="select.emit(data)"
    />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    fill: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    stops: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var BarChartType;
(function(BarChartType2) {
  BarChartType2["Standard"] = "standard";
  BarChartType2["Normalized"] = "normalized";
  BarChartType2["Stacked"] = "stacked";
})(BarChartType || (BarChartType = {}));
var D0Types;
(function(D0Types2) {
  D0Types2["positive"] = "positive";
  D0Types2["negative"] = "negative";
})(D0Types || (D0Types = {}));
var _BarLabelComponent = class _BarLabelComponent {
  constructor(element) {
    this.dimensionsChanged = new EventEmitter();
    this.horizontalPadding = 2;
    this.verticalPadding = 5;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
  }
  getSize() {
    const h = this.element.getBoundingClientRect().height;
    const w2 = this.element.getBoundingClientRect().width;
    return {
      height: h,
      width: w2,
      negative: this.value < 0
    };
  }
  ngAfterViewInit() {
    this.dimensionsChanged.emit(this.getSize());
  }
  update() {
    if (this.valueFormatting) {
      this.formatedValue = this.valueFormatting(this.value);
    } else {
      this.formatedValue = formatLabel(this.value);
    }
    if (this.orientation === "horizontal") {
      this.x = this.barX + this.barWidth;
      if (this.value < 0) {
        this.x = this.x - this.horizontalPadding;
        this.textAnchor = "end";
      } else {
        this.x = this.x + this.horizontalPadding;
        this.textAnchor = "start";
      }
      this.y = this.barY + this.barHeight / 2;
    } else {
      this.x = this.barX + this.barWidth / 2;
      this.y = this.barY + this.barHeight;
      if (this.value < 0) {
        this.y = this.y + this.verticalPadding;
        this.textAnchor = "end";
      } else {
        this.y = this.y - this.verticalPadding;
        this.textAnchor = "start";
      }
      this.transform = `rotate(-45, ${this.x} , ${this.y})`;
    }
  }
};
_BarLabelComponent.\u0275fac = function BarLabelComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BarLabelComponent)(\u0275\u0275directiveInject(ElementRef));
};
_BarLabelComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BarLabelComponent,
  selectors: [["g", "ngx-charts-bar-label", ""]],
  inputs: {
    value: "value",
    valueFormatting: "valueFormatting",
    barX: "barX",
    barY: "barY",
    barWidth: "barWidth",
    barHeight: "barHeight",
    orientation: "orientation"
  },
  outputs: {
    dimensionsChanged: "dimensionsChanged"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c27,
  decls: 2,
  vars: 5,
  consts: [["alignment-baseline", "middle", 1, "textDataLabel"]],
  template: function BarLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "text", 0);
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275attribute("text-anchor", ctx.textAnchor)("transform", ctx.transform)("x", ctx.x)("y", ctx.y);
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.formatedValue, " ");
    }
  },
  styles: [".textDataLabel[_ngcontent-%COMP%]{font-size:11px}"],
  changeDetection: 0
});
var BarLabelComponent = _BarLabelComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarLabelComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-bar-label]",
      template: `
    <svg:text
      class="textDataLabel"
      alignment-baseline="middle"
      [attr.text-anchor]="textAnchor"
      [attr.transform]="transform"
      [attr.x]="x"
      [attr.y]="y"
    >
      {{ formatedValue }}
    </svg:text>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".textDataLabel{font-size:11px}\n"]
    }]
  }], () => [{
    type: ElementRef
  }], {
    value: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    barX: [{
      type: Input
    }],
    barY: [{
      type: Input
    }],
    barWidth: [{
      type: Input
    }],
    barHeight: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    dimensionsChanged: [{
      type: Output
    }]
  });
})();
var _SeriesHorizontal = class _SeriesHorizontal {
  constructor() {
    this.type = BarChartType.Standard;
    this.tooltipDisabled = false;
    this.animations = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.dataLabelWidthChanged = new EventEmitter();
    this.barsForDataLabels = [];
    this.barOrientation = BarOrientation;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.updateTooltipSettings();
    const d0 = {
      [D0Types.positive]: 0,
      [D0Types.negative]: 0
    };
    let d0Type;
    d0Type = D0Types.positive;
    let total;
    if (this.type === BarChartType.Normalized) {
      total = this.series.map((d) => d.value).reduce((sum2, d) => sum2 + d, 0);
    }
    const xScaleMin = Math.max(this.xScale.domain()[0], 0);
    this.bars = this.series.map((d) => {
      let value2 = d.value;
      const label = this.getLabel(d);
      const formattedLabel = formatLabel(label);
      const roundEdges = this.roundEdges;
      d0Type = value2 > 0 ? D0Types.positive : D0Types.negative;
      const bar = {
        value: value2,
        label,
        roundEdges,
        data: d,
        formattedLabel
      };
      bar.height = this.yScale.bandwidth();
      if (this.type === BarChartType.Standard) {
        bar.width = Math.abs(this.xScale(value2) - this.xScale(xScaleMin));
        if (value2 < 0) {
          bar.x = this.xScale(value2);
        } else {
          bar.x = this.xScale(xScaleMin);
        }
        bar.y = this.yScale(label);
      } else if (this.type === BarChartType.Stacked) {
        const offset0 = d0[d0Type];
        const offset1 = offset0 + value2;
        d0[d0Type] += value2;
        bar.width = this.xScale(offset1) - this.xScale(offset0);
        bar.x = this.xScale(offset0);
        bar.y = 0;
        bar.offset0 = offset0;
        bar.offset1 = offset1;
      } else if (this.type === BarChartType.Normalized) {
        let offset0 = d0[d0Type];
        let offset1 = offset0 + value2;
        d0[d0Type] += value2;
        if (total > 0) {
          offset0 = offset0 * 100 / total;
          offset1 = offset1 * 100 / total;
        } else {
          offset0 = 0;
          offset1 = 0;
        }
        bar.width = this.xScale(offset1) - this.xScale(offset0);
        bar.x = this.xScale(offset0);
        bar.y = 0;
        bar.offset0 = offset0;
        bar.offset1 = offset1;
        value2 = (offset1 - offset0).toFixed(2) + "%";
      }
      if (this.colors.scaleType === ScaleType.Ordinal) {
        bar.color = this.colors.getColor(label);
      } else {
        if (this.type === BarChartType.Standard) {
          bar.color = this.colors.getColor(value2);
          bar.gradientStops = this.colors.getLinearGradientStops(value2);
        } else {
          bar.color = this.colors.getColor(bar.offset1);
          bar.gradientStops = this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
        }
      }
      let tooltipLabel = formattedLabel;
      bar.ariaLabel = formattedLabel + " " + value2.toLocaleString();
      if (this.seriesName !== null && this.seriesName !== void 0) {
        tooltipLabel = `${this.seriesName} \u2022 ${formattedLabel}`;
        bar.data.series = this.seriesName;
        bar.ariaLabel = this.seriesName + " " + bar.ariaLabel;
      }
      bar.tooltipText = this.tooltipDisabled ? void 0 : `
        <span class="tooltip-label">${escapeLabel(tooltipLabel)}</span>
        <span class="tooltip-val">${this.dataLabelFormatting ? this.dataLabelFormatting(value2) : value2.toLocaleString()}</span>
      `;
      return bar;
    });
    this.updateDataLabels();
  }
  updateDataLabels() {
    if (this.type === BarChartType.Stacked) {
      this.barsForDataLabels = [];
      const section = {};
      section.series = this.seriesName;
      const totalPositive = this.series.map((d) => d.value).reduce((sum2, d) => d > 0 ? sum2 + d : sum2, 0);
      const totalNegative = this.series.map((d) => d.value).reduce((sum2, d) => d < 0 ? sum2 + d : sum2, 0);
      section.total = totalPositive + totalNegative;
      section.x = 0;
      section.y = 0;
      if (section.total > 0) {
        section.width = this.xScale(totalPositive);
      } else {
        section.width = this.xScale(totalNegative);
      }
      section.height = this.yScale.bandwidth();
      this.barsForDataLabels.push(section);
    } else {
      this.barsForDataLabels = this.series.map((d) => {
        const section = {};
        section.series = this.seriesName ?? d.label;
        section.total = d.value;
        section.x = this.xScale(0);
        section.y = this.yScale(d.label);
        section.width = this.xScale(section.total) - this.xScale(0);
        section.height = this.yScale.bandwidth();
        return section;
      });
    }
  }
  updateTooltipSettings() {
    this.tooltipPlacement = this.tooltipDisabled ? void 0 : PlacementTypes.Top;
    this.tooltipType = this.tooltipDisabled ? void 0 : StyleTypes.tooltip;
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((active) => {
      return entry.name === active.name && entry.value === active.value;
    });
    return item !== void 0;
  }
  getLabel(dataItem) {
    if (dataItem.label) {
      return dataItem.label;
    }
    return dataItem.name;
  }
  trackBy(index, bar) {
    return bar.label;
  }
  trackDataLabelBy(index, barLabel) {
    return index + "#" + barLabel.series + "#" + barLabel.total;
  }
  click(data) {
    this.select.emit(data);
  }
};
_SeriesHorizontal.\u0275fac = function SeriesHorizontal_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _SeriesHorizontal)();
};
_SeriesHorizontal.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SeriesHorizontal,
  selectors: [["g", "ngx-charts-series-horizontal", ""]],
  inputs: {
    dims: "dims",
    type: "type",
    series: "series",
    xScale: "xScale",
    yScale: "yScale",
    colors: "colors",
    tooltipDisabled: "tooltipDisabled",
    gradient: "gradient",
    activeEntries: "activeEntries",
    seriesName: "seriesName",
    tooltipTemplate: "tooltipTemplate",
    roundEdges: "roundEdges",
    animations: "animations",
    showDataLabel: "showDataLabel",
    dataLabelFormatting: "dataLabelFormatting",
    noBarWhenZero: "noBarWhenZero"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate",
    dataLabelWidthChanged: "dataLabelWidthChanged"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c28,
  decls: 2,
  vars: 3,
  consts: [["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], [4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "isActive", "ariaLabel", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "dimensionsChanged", "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation"]],
  template: function SeriesHorizontal_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, SeriesHorizontal__svg_g_0_Template, 1, 21, "g", 0)(1, SeriesHorizontal__svg_g_1_Template, 2, 2, "g", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.bars)("ngForTrackBy", ctx.trackBy);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showDataLabel);
    }
  },
  dependencies: [NgForOf, NgIf, TooltipDirective, BarComponent, BarLabelComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1
    }), animate(500, style({
      opacity: 0
    }))])])]
  },
  changeDetection: 0
});
var SeriesHorizontal = _SeriesHorizontal;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesHorizontal, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-series-horizontal]",
      template: `
    <svg:g
      ngx-charts-bar
      *ngFor="let bar of bars; trackBy: trackBy"
      [@animationState]="'active'"
      [width]="bar.width"
      [height]="bar.height"
      [x]="bar.x"
      [y]="bar.y"
      [fill]="bar.color"
      [stops]="bar.gradientStops"
      [data]="bar.data"
      [orientation]="barOrientation.Horizontal"
      [roundEdges]="bar.roundEdges"
      (select)="click($event)"
      [gradient]="gradient"
      [isActive]="isActive(bar.data)"
      [ariaLabel]="bar.ariaLabel"
      [animations]="animations"
      (activate)="activate.emit($event)"
      (deactivate)="deactivate.emit($event)"
      ngx-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="tooltipPlacement"
      [tooltipType]="tooltipType"
      [tooltipTitle]="tooltipTemplate ? undefined : bar.tooltipText"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="bar.data"
      [noBarWhenZero]="noBarWhenZero"
    ></svg:g>
    <svg:g *ngIf="showDataLabel">
      <svg:g
        ngx-charts-bar-label
        *ngFor="let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy"
        [barX]="b.x"
        [barY]="b.y"
        [barWidth]="b.width"
        [barHeight]="b.height"
        [value]="b.total"
        [valueFormatting]="dataLabelFormatting"
        [orientation]="barOrientation.Horizontal"
        (dimensionsChanged)="dataLabelWidthChanged.emit({ size: $event, index: i })"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])]
    }]
  }], null, {
    dims: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    series: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    seriesName: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    dataLabelWidthChanged: [{
      type: Output
    }]
  });
})();
var _BarHorizontalComponent = class _BarHorizontalComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.roundEdges = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxWidth = {
      negative: 0,
      positive: 0
    };
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxWidth = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getXScale() {
    this.xDomain = this.getXDomain();
    const scale = linear2().range([0, this.dims.width]).domain(this.xDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getYScale() {
    this.yDomain = this.getYDomain();
    const spacing = this.yDomain.length / (this.dims.height / this.barPadding + 1);
    return band().rangeRound([0, this.dims.height]).paddingInner(spacing).domain(this.yDomain);
  }
  getXDomain() {
    const values = this.results.map((d) => d.value);
    const min6 = this.xScaleMin ? Math.min(this.xScaleMin, ...values) : Math.min(0, ...values);
    const max6 = this.xScaleMax ? Math.max(this.xScaleMax, ...values) : Math.max(0, ...values);
    return [min6, max6];
  }
  getYDomain() {
    return this.results.map((d) => d.label);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.yDomain;
    } else {
      domain = this.xDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === "ordinal") {
      opts.domain = this.yDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.xDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onDataLabelMaxWidthChanged(event) {
    if (event.size.negative) {
      this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event.size.width);
    } else {
      this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event.size.width);
    }
    if (event.index === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  onActivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_BarHorizontalComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BarHorizontalComponent_BaseFactory;
  return function BarHorizontalComponent_Factory(__ngFactoryType__) {
    return (\u0275BarHorizontalComponent_BaseFactory || (\u0275BarHorizontalComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarHorizontalComponent)))(__ngFactoryType__ || _BarHorizontalComponent);
  };
})();
_BarHorizontalComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BarHorizontalComponent,
  selectors: [["ngx-charts-bar-horizontal"]],
  contentQueries: function BarHorizontalComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    tooltipDisabled: "tooltipDisabled",
    gradient: "gradient",
    showGridLines: "showGridLines",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    barPadding: "barPadding",
    roundDomains: "roundDomains",
    roundEdges: "roundEdges",
    xScaleMax: "xScaleMax",
    xScaleMin: "xScaleMin",
    showDataLabel: "showDataLabel",
    dataLabelFormatting: "dataLabelFormatting",
    noBarWhenZero: "noBarWhenZero",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 5,
  vars: 25,
  consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-horizontal", "", 3, "select", "activate", "deactivate", "dataLabelWidthChanged", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "activeEntries", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks"]],
  template: function BarHorizontalComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelClick", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      })("legendLabelActivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event, true);
      })("legendLabelDeactivate", function BarHorizontalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event, true);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275template(2, BarHorizontalComponent__svg_g_2_Template, 1, 11, "g", 2)(3, BarHorizontalComponent__svg_g_3_Template, 1, 10, "g", 3);
      \u0275\u0275elementStart(4, "g", 4);
      \u0275\u0275listener("select", function BarHorizontalComponent_Template_g_select_4_listener($event) {
        return ctx.onClick($event);
      })("activate", function BarHorizontalComponent_Template_g_activate_4_listener($event) {
        return ctx.onActivate($event);
      })("deactivate", function BarHorizontalComponent_Template_g_deactivate_4_listener($event) {
        return ctx.onDeactivate($event);
      })("dataLabelWidthChanged", function BarHorizontalComponent_Template_g_dataLabelWidthChanged_4_listener($event) {
        return ctx.onDataLabelMaxWidthChanged($event);
      });
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(22, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275property("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("noBarWhenZero", ctx.noBarWhenZero);
    }
  },
  dependencies: [NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesHorizontal],
  styles: [_c25],
  encapsulation: 2,
  changeDetection: 0
});
var BarHorizontalComponent = _BarHorizontalComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarHorizontalComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-horizontal",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event, true)"
      (legendLabelDeactivate)="onDeactivate($event, true)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [yAxisOffset]="dataLabelMaxWidth.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g
          ngx-charts-series-horizontal
          [xScale]="xScale"
          [yScale]="yScale"
          [colors]="colors"
          [series]="results"
          [dims]="dims"
          [gradient]="gradient"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [activeEntries]="activeEntries"
          [roundEdges]="roundEdges"
          [animations]="animations"
          [showDataLabel]="showDataLabel"
          [dataLabelFormatting]="dataLabelFormatting"
          [noBarWhenZero]="noBarWhenZero"
          (select)="onClick($event)"
          (activate)="onActivate($event)"
          (deactivate)="onDeactivate($event)"
          (dataLabelWidthChanged)="onDataLabelMaxWidthChanged($event)"
        ></svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    xScaleMin: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _BarHorizontal2DComponent = class _BarHorizontal2DComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.groupPadding = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.roundEdges = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxWidth = {
      negative: 0,
      positive: 0
    };
    this.isSSR = false;
    this.barOrientation = BarOrientation;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxWidth = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.valueDomain = this.getValueDomain();
    this.groupScale = this.getGroupScale();
    this.innerScale = this.getInnerScale();
    this.valueScale = this.getValueScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getGroupScale() {
    const spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
    return band().rangeRound([0, this.dims.height]).paddingInner(spacing).paddingOuter(spacing / 2).domain(this.groupDomain);
  }
  getInnerScale() {
    const height = this.groupScale.bandwidth();
    const spacing = this.innerDomain.length / (height / this.barPadding + 1);
    return band().rangeRound([0, height]).paddingInner(spacing).domain(this.innerDomain);
  }
  getValueScale() {
    const scale = linear2().range([0, this.dims.width]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getValueDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.value)) {
          domain.push(d.value);
        }
      }
    }
    const min6 = Math.min(0, ...domain);
    const max6 = this.xScaleMax ? Math.max(this.xScaleMax, ...domain) : Math.max(0, ...domain);
    return [min6, max6];
  }
  groupTransform(group) {
    return `translate(0, ${this.groupScale(group.label)})`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onDataLabelMaxWidthChanged(event, groupIndex) {
    if (event.size.negative) {
      this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event.size.width);
    } else {
      this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event.size.width);
    }
    if (groupIndex === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g2) => g2.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_BarHorizontal2DComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BarHorizontal2DComponent_BaseFactory;
  return function BarHorizontal2DComponent_Factory(__ngFactoryType__) {
    return (\u0275BarHorizontal2DComponent_BaseFactory || (\u0275BarHorizontal2DComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarHorizontal2DComponent)))(__ngFactoryType__ || _BarHorizontal2DComponent);
  };
})();
_BarHorizontal2DComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BarHorizontal2DComponent,
  selectors: [["ngx-charts-bar-horizontal-2d"]],
  contentQueries: function BarHorizontal2DComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    tooltipDisabled: "tooltipDisabled",
    gradient: "gradient",
    showGridLines: "showGridLines",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    groupPadding: "groupPadding",
    barPadding: "barPadding",
    roundDomains: "roundDomains",
    roundEdges: "roundEdges",
    xScaleMax: "xScaleMax",
    showDataLabel: "showDataLabel",
    dataLabelFormatting: "dataLabelFormatting",
    noBarWhenZero: "noBarWhenZero",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 7,
  vars: 18,
  consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", 3, "xScale", "yScale", "data", "dims", "orient"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-horizontal", "", 3, "select", "activate", "deactivate", "dataLabelWidthChanged", "xScale", "activeEntries", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero"]],
  template: function BarHorizontal2DComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelActivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event, void 0, true);
      })("legendLabelDeactivate", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event, void 0, true);
      })("legendLabelClick", function BarHorizontal2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275element(2, "g", 2);
      \u0275\u0275template(3, BarHorizontal2DComponent__svg_g_3_Template, 1, 11, "g", 3)(4, BarHorizontal2DComponent__svg_g_4_Template, 1, 10, "g", 4)(5, BarHorizontal2DComponent__svg_g_5_Template, 2, 2, "g", 5)(6, BarHorizontal2DComponent__svg_g_6_Template, 2, 2, "g", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(15, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("xScale", ctx.valueScale)("yScale", ctx.groupScale)("data", ctx.results)("dims", ctx.dims)("orient", ctx.barOrientation.Horizontal);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, GridPanelSeriesComponent, SeriesHorizontal],
  styles: [_c25],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1,
      transform: "*"
    }), animate(500, style({
      opacity: 0,
      transform: "scale(0)"
    }))])])]
  },
  changeDetection: 0
});
var BarHorizontal2DComponent = _BarHorizontal2DComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarHorizontal2DComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-horizontal-2d",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-grid-panel-series
          [xScale]="valueScale"
          [yScale]="groupScale"
          [data]="results"
          [dims]="dims"
          [orient]="barOrientation.Horizontal"
        ></svg:g>
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="valueScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="groupScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [yAxisOffset]="dataLabelMaxWidth.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>

        <svg:g *ngIf="!isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-horizontal
              [xScale]="valueScale"
              [activeEntries]="activeEntries"
              [yScale]="innerScale"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [roundEdges]="roundEdges"
              [animations]="animations"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelWidthChanged)="onDataLabelMaxWidthChanged($event, index)"
            />
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-horizontal
              [xScale]="valueScale"
              [activeEntries]="activeEntries"
              [yScale]="innerScale"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [roundEdges]="roundEdges"
              [animations]="animations"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelWidthChanged)="onDataLabelMaxWidthChanged($event, index)"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    groupPadding: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _BarHorizontalNormalizedComponent = class _BarHorizontalNormalizedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.valueDomain = [0, 100];
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.barChartType = BarChartType;
    this.isSSR = false;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getYScale() {
    const spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
    return band().rangeRound([0, this.dims.height]).paddingInner(spacing).domain(this.groupDomain);
  }
  getXScale() {
    const scale = linear2().range([0, this.dims.width]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  groupTransform(group) {
    return `translate(0, ${this.yScale(group.name)})`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g2) => g2.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_BarHorizontalNormalizedComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BarHorizontalNormalizedComponent_BaseFactory;
  return function BarHorizontalNormalizedComponent_Factory(__ngFactoryType__) {
    return (\u0275BarHorizontalNormalizedComponent_BaseFactory || (\u0275BarHorizontalNormalizedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarHorizontalNormalizedComponent)))(__ngFactoryType__ || _BarHorizontalNormalizedComponent);
  };
})();
_BarHorizontalNormalizedComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BarHorizontalNormalizedComponent,
  selectors: [["ngx-charts-bar-horizontal-normalized"]],
  contentQueries: function BarHorizontalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    tooltipDisabled: "tooltipDisabled",
    gradient: "gradient",
    showGridLines: "showGridLines",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    barPadding: "barPadding",
    roundDomains: "roundDomains",
    noBarWhenZero: "noBarWhenZero",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 6,
  vars: 13,
  consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-horizontal", "", 3, "select", "activate", "deactivate", "type", "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero"]],
  template: function BarHorizontalNormalizedComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelActivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event, void 0, true);
      })("legendLabelDeactivate", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event, void 0, true);
      })("legendLabelClick", function BarHorizontalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275template(2, BarHorizontalNormalizedComponent__svg_g_2_Template, 1, 11, "g", 2)(3, BarHorizontalNormalizedComponent__svg_g_3_Template, 1, 9, "g", 3)(4, BarHorizontalNormalizedComponent__svg_g_4_Template, 2, 2, "g", 4)(5, BarHorizontalNormalizedComponent__svg_g_5_Template, 2, 2, "g", 4);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(10, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesHorizontal],
  styles: [_c25],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1,
      transform: "*"
    }), animate(500, style({
      opacity: 0,
      transform: "scale(0)"
    }))])])]
  },
  changeDetection: 0
});
var BarHorizontalNormalizedComponent = _BarHorizontalNormalizedComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarHorizontalNormalizedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-horizontal-normalized",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g *ngIf="!isSSR">
          <svg:g
            *ngFor="let group of results; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-horizontal
              [type]="barChartType.Normalized"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              [noBarWhenZero]="noBarWhenZero"
            />
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g *ngFor="let group of results; trackBy: trackBy" [attr.transform]="groupTransform(group)">
            <svg:g
              ngx-charts-series-horizontal
              [type]="barChartType.Normalized"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              [noBarWhenZero]="noBarWhenZero"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _BarHorizontalStackedComponent = class _BarHorizontalStackedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxWidth = {
      negative: 0,
      positive: 0
    };
    this.barChartType = BarChartType;
    this.isSSR = false;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxWidth = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10, 20 + this.dataLabelMaxWidth.positive, 10, 20 + this.dataLabelMaxWidth.negative];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.valueDomain = this.getValueDomain();
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getValueDomain() {
    const domain = [];
    let smallest = 0;
    let biggest = 0;
    for (const group of this.results) {
      let smallestSum = 0;
      let biggestSum = 0;
      for (const d of group.series) {
        if (d.value < 0) {
          smallestSum += d.value;
        } else {
          biggestSum += d.value;
        }
        smallest = d.value < smallest ? d.value : smallest;
        biggest = d.value > biggest ? d.value : biggest;
      }
      domain.push(smallestSum);
      domain.push(biggestSum);
    }
    domain.push(smallest);
    domain.push(biggest);
    const min6 = Math.min(0, ...domain);
    const max6 = this.xScaleMax ? Math.max(this.xScaleMax, ...domain) : Math.max(...domain);
    return [min6, max6];
  }
  getYScale() {
    const spacing = this.groupDomain.length / (this.dims.height / this.barPadding + 1);
    return band().rangeRound([0, this.dims.height]).paddingInner(spacing).domain(this.groupDomain);
  }
  getXScale() {
    const scale = linear2().range([0, this.dims.width]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  groupTransform(group) {
    return `translate(0, ${this.yScale(group.name)})`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onDataLabelMaxWidthChanged(event, groupIndex) {
    if (event.size.negative) {
      this.dataLabelMaxWidth.negative = Math.max(this.dataLabelMaxWidth.negative, event.size.width);
    } else {
      this.dataLabelMaxWidth.positive = Math.max(this.dataLabelMaxWidth.positive, event.size.width);
    }
    if (groupIndex === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g2) => g2.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_BarHorizontalStackedComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BarHorizontalStackedComponent_BaseFactory;
  return function BarHorizontalStackedComponent_Factory(__ngFactoryType__) {
    return (\u0275BarHorizontalStackedComponent_BaseFactory || (\u0275BarHorizontalStackedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarHorizontalStackedComponent)))(__ngFactoryType__ || _BarHorizontalStackedComponent);
  };
})();
_BarHorizontalStackedComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BarHorizontalStackedComponent,
  selectors: [["ngx-charts-bar-horizontal-stacked"]],
  contentQueries: function BarHorizontalStackedComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    tooltipDisabled: "tooltipDisabled",
    gradient: "gradient",
    showGridLines: "showGridLines",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    barPadding: "barPadding",
    roundDomains: "roundDomains",
    xScaleMax: "xScaleMax",
    showDataLabel: "showDataLabel",
    dataLabelFormatting: "dataLabelFormatting",
    noBarWhenZero: "noBarWhenZero",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 6,
  vars: 13,
  consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "yAxisOffset", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-horizontal", "", 3, "select", "activate", "deactivate", "dataLabelWidthChanged", "type", "xScale", "yScale", "colors", "series", "activeEntries", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "showDataLabel", "dataLabelFormatting", "noBarWhenZero"]],
  template: function BarHorizontalStackedComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelActivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event, void 0, true);
      })("legendLabelDeactivate", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event, void 0, true);
      })("legendLabelClick", function BarHorizontalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275template(2, BarHorizontalStackedComponent__svg_g_2_Template, 1, 11, "g", 2)(3, BarHorizontalStackedComponent__svg_g_3_Template, 1, 10, "g", 3)(4, BarHorizontalStackedComponent__svg_g_4_Template, 2, 2, "g", 4)(5, BarHorizontalStackedComponent__svg_g_5_Template, 2, 2, "g", 4);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(10, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesHorizontal],
  styles: [_c25],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1,
      transform: "*"
    }), animate(500, style({
      opacity: 0,
      transform: "scale(0)"
    }))])])]
  },
  changeDetection: 0
});
var BarHorizontalStackedComponent = _BarHorizontalStackedComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarHorizontalStackedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-horizontal-stacked",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [yAxisOffset]="dataLabelMaxWidth.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g *ngIf="!isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-horizontal
              [type]="barChartType.Stacked"
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [series]="group.series"
              [activeEntries]="activeEntries"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelWidthChanged)="onDataLabelMaxWidthChanged($event, index)"
            />
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-horizontal
              [type]="barChartType.Stacked"
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [series]="group.series"
              [activeEntries]="activeEntries"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelWidthChanged)="onDataLabelMaxWidthChanged($event, index)"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _SeriesVerticalComponent = class _SeriesVerticalComponent {
  constructor(platformId) {
    this.platformId = platformId;
    this.type = BarChartType.Standard;
    this.tooltipDisabled = false;
    this.animations = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.dataLabelHeightChanged = new EventEmitter();
    this.barsForDataLabels = [];
    this.barOrientation = BarOrientation;
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.updateTooltipSettings();
    let width;
    if (this.series.length) {
      width = this.xScale.bandwidth();
    }
    width = Math.round(width);
    const yScaleMin = Math.max(this.yScale.domain()[0], 0);
    const d0 = {
      [D0Types.positive]: 0,
      [D0Types.negative]: 0
    };
    let d0Type = D0Types.positive;
    let total;
    if (this.type === BarChartType.Normalized) {
      total = this.series.map((d) => d.value).reduce((sum2, d) => sum2 + d, 0);
    }
    this.bars = this.series.map((d, index) => {
      let value2 = d.value;
      const label = this.getLabel(d);
      const formattedLabel = formatLabel(label);
      const roundEdges = this.roundEdges;
      d0Type = value2 > 0 ? D0Types.positive : D0Types.negative;
      const bar = {
        value: value2,
        label,
        roundEdges,
        data: d,
        width,
        formattedLabel,
        height: 0,
        x: 0,
        y: 0
      };
      if (this.type === BarChartType.Standard) {
        bar.height = Math.abs(this.yScale(value2) - this.yScale(yScaleMin));
        bar.x = this.xScale(label);
        if (value2 < 0) {
          bar.y = this.yScale(0);
        } else {
          bar.y = this.yScale(value2);
        }
      } else if (this.type === BarChartType.Stacked) {
        const offset0 = d0[d0Type];
        const offset1 = offset0 + value2;
        d0[d0Type] += value2;
        bar.height = this.yScale(offset0) - this.yScale(offset1);
        bar.x = 0;
        bar.y = this.yScale(offset1);
        bar.offset0 = offset0;
        bar.offset1 = offset1;
      } else if (this.type === BarChartType.Normalized) {
        let offset0 = d0[d0Type];
        let offset1 = offset0 + value2;
        d0[d0Type] += value2;
        if (total > 0) {
          offset0 = offset0 * 100 / total;
          offset1 = offset1 * 100 / total;
        } else {
          offset0 = 0;
          offset1 = 0;
        }
        bar.height = this.yScale(offset0) - this.yScale(offset1);
        bar.x = 0;
        bar.y = this.yScale(offset1);
        bar.offset0 = offset0;
        bar.offset1 = offset1;
        value2 = (offset1 - offset0).toFixed(2) + "%";
      }
      if (this.colors.scaleType === ScaleType.Ordinal) {
        bar.color = this.colors.getColor(label);
      } else {
        if (this.type === BarChartType.Standard) {
          bar.color = this.colors.getColor(value2);
          bar.gradientStops = this.colors.getLinearGradientStops(value2);
        } else {
          bar.color = this.colors.getColor(bar.offset1);
          bar.gradientStops = this.colors.getLinearGradientStops(bar.offset1, bar.offset0);
        }
      }
      let tooltipLabel = formattedLabel;
      bar.ariaLabel = formattedLabel + " " + value2.toLocaleString();
      if (this.seriesName !== null && this.seriesName !== void 0) {
        tooltipLabel = `${this.seriesName} \u2022 ${formattedLabel}`;
        bar.data.series = this.seriesName;
        bar.ariaLabel = this.seriesName + " " + bar.ariaLabel;
      }
      bar.tooltipText = this.tooltipDisabled ? void 0 : `
        <span class="tooltip-label">${escapeLabel(tooltipLabel)}</span>
        <span class="tooltip-val">${this.dataLabelFormatting ? this.dataLabelFormatting(value2) : value2.toLocaleString()}</span>
      `;
      return bar;
    });
    this.updateDataLabels();
  }
  updateDataLabels() {
    if (this.type === BarChartType.Stacked) {
      this.barsForDataLabels = [];
      const section = {};
      section.series = this.seriesName;
      const totalPositive = this.series.map((d) => d.value).reduce((sum2, d) => d > 0 ? sum2 + d : sum2, 0);
      const totalNegative = this.series.map((d) => d.value).reduce((sum2, d) => d < 0 ? sum2 + d : sum2, 0);
      section.total = totalPositive + totalNegative;
      section.x = 0;
      section.y = 0;
      if (section.total > 0) {
        section.height = this.yScale(totalPositive);
      } else {
        section.height = this.yScale(totalNegative);
      }
      section.width = this.xScale.bandwidth();
      this.barsForDataLabels.push(section);
    } else {
      this.barsForDataLabels = this.series.map((d) => {
        const section = {};
        section.series = this.seriesName ?? d.label;
        section.total = d.value;
        section.x = this.xScale(d.label);
        section.y = this.yScale(0);
        section.height = this.yScale(section.total) - this.yScale(0);
        section.width = this.xScale.bandwidth();
        return section;
      });
    }
  }
  updateTooltipSettings() {
    this.tooltipPlacement = this.tooltipDisabled ? void 0 : PlacementTypes.Top;
    this.tooltipType = this.tooltipDisabled ? void 0 : StyleTypes.tooltip;
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((active) => {
      return entry.name === active.name && entry.value === active.value;
    });
    return item !== void 0;
  }
  onClick(data) {
    this.select.emit(data);
  }
  getLabel(dataItem) {
    if (dataItem.label) {
      return dataItem.label;
    }
    return dataItem.name;
  }
  trackBy(index, bar) {
    return bar.label;
  }
  trackDataLabelBy(index, barLabel) {
    return index + "#" + barLabel.series + "#" + barLabel.total;
  }
};
_SeriesVerticalComponent.\u0275fac = function SeriesVerticalComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _SeriesVerticalComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
};
_SeriesVerticalComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SeriesVerticalComponent,
  selectors: [["g", "ngx-charts-series-vertical", ""]],
  inputs: {
    dims: "dims",
    type: "type",
    series: "series",
    xScale: "xScale",
    yScale: "yScale",
    colors: "colors",
    gradient: "gradient",
    activeEntries: "activeEntries",
    seriesName: "seriesName",
    tooltipDisabled: "tooltipDisabled",
    tooltipTemplate: "tooltipTemplate",
    roundEdges: "roundEdges",
    animations: "animations",
    showDataLabel: "showDataLabel",
    dataLabelFormatting: "dataLabelFormatting",
    noBarWhenZero: "noBarWhenZero"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate",
    dataLabelHeightChanged: "dataLabelHeightChanged"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c29,
  decls: 3,
  vars: 3,
  consts: [[4, "ngIf"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "width", "height", "x", "y", "fill", "stops", "data", "orientation", "roundEdges", "gradient", "ariaLabel", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "noBarWhenZero", "animations"], ["ngx-charts-bar-label", "", 3, "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation", "dimensionsChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bar-label", "", 3, "dimensionsChanged", "barX", "barY", "barWidth", "barHeight", "value", "valueFormatting", "orientation"]],
  template: function SeriesVerticalComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, SeriesVerticalComponent__svg_g_0_Template, 2, 2, "g", 0)(1, SeriesVerticalComponent__svg_g_1_Template, 2, 2, "g", 0)(2, SeriesVerticalComponent__svg_g_2_Template, 2, 2, "g", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showDataLabel);
    }
  },
  dependencies: [NgForOf, NgIf, TooltipDirective, BarComponent, BarLabelComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1
    }), animate(500, style({
      opacity: 0
    }))])])]
  },
  changeDetection: 0
});
var SeriesVerticalComponent = _SeriesVerticalComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesVerticalComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-series-vertical]",
      template: `
    <svg:g *ngIf="!isSSR">
      <svg:g
        ngx-charts-bar
        *ngFor="let bar of bars; trackBy: trackBy"
        [@animationState]="'active'"
        [@.disabled]="!animations"
        [width]="bar.width"
        [height]="bar.height"
        [x]="bar.x"
        [y]="bar.y"
        [fill]="bar.color"
        [stops]="bar.gradientStops"
        [data]="bar.data"
        [orientation]="barOrientation.Vertical"
        [roundEdges]="bar.roundEdges"
        [gradient]="gradient"
        [ariaLabel]="bar.ariaLabel"
        [isActive]="isActive(bar.data)"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="tooltipPlacement"
        [tooltipType]="tooltipType"
        [tooltipTitle]="tooltipTemplate ? undefined : bar.tooltipText"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="bar.data"
        [noBarWhenZero]="noBarWhenZero"
        [animations]="animations"
      ></svg:g>
    </svg:g>
    <svg:g *ngIf="isSSR">
      <svg:g
        ngx-charts-bar
        *ngFor="let bar of bars; trackBy: trackBy"
        [width]="bar.width"
        [height]="bar.height"
        [x]="bar.x"
        [y]="bar.y"
        [fill]="bar.color"
        [stops]="bar.gradientStops"
        [data]="bar.data"
        [orientation]="barOrientation.Vertical"
        [roundEdges]="bar.roundEdges"
        [gradient]="gradient"
        [ariaLabel]="bar.ariaLabel"
        [isActive]="isActive(bar.data)"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="tooltipPlacement"
        [tooltipType]="tooltipType"
        [tooltipTitle]="tooltipTemplate ? undefined : bar.tooltipText"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="bar.data"
        [noBarWhenZero]="noBarWhenZero"
        [animations]="animations"
      ></svg:g>
    </svg:g>
    <svg:g *ngIf="showDataLabel">
      <svg:g
        ngx-charts-bar-label
        *ngFor="let b of barsForDataLabels; let i = index; trackBy: trackDataLabelBy"
        [barX]="b.x"
        [barY]="b.y"
        [barWidth]="b.width"
        [barHeight]="b.height"
        [value]="b.total"
        [valueFormatting]="dataLabelFormatting"
        [orientation]="barOrientation.Vertical"
        (dimensionsChanged)="dataLabelHeightChanged.emit({ size: $event, index: i })"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    dims: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    series: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    seriesName: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    dataLabelHeightChanged: [{
      type: Output
    }]
  });
})();
var _BarVerticalComponent = class _BarVerticalComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.roundEdges = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxHeight = {
      negative: 0,
      positive: 0
    };
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxHeight = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    if (this.showDataLabel) {
      this.dims.height -= this.dataLabelMaxHeight.negative;
    }
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0] + this.dataLabelMaxHeight.negative})`;
  }
  getXScale() {
    this.xDomain = this.getXDomain();
    const spacing = this.xDomain.length / (this.dims.width / this.barPadding + 1);
    return band().range([0, this.dims.width]).paddingInner(spacing).domain(this.xDomain);
  }
  getYScale() {
    this.yDomain = this.getYDomain();
    const scale = linear2().range([this.dims.height, 0]).domain(this.yDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getXDomain() {
    return this.results.map((d) => d.label);
  }
  getYDomain() {
    const values = this.results.map((d) => d.value);
    let min6 = this.yScaleMin ? Math.min(this.yScaleMin, ...values) : Math.min(0, ...values);
    if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
      min6 = Math.min(min6, ...this.yAxisTicks);
    }
    let max6 = this.yScaleMax ? Math.max(this.yScaleMax, ...values) : Math.max(0, ...values);
    if (this.yAxisTicks && !this.yAxisTicks.some(isNaN)) {
      max6 = Math.max(max6, ...this.yAxisTicks);
    }
    return [min6, max6];
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.xDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.xDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.yDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onDataLabelMaxHeightChanged(event) {
    if (event.size.negative) {
      this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
    } else {
      this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
    }
    if (event.index === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  onActivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_BarVerticalComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BarVerticalComponent_BaseFactory;
  return function BarVerticalComponent_Factory(__ngFactoryType__) {
    return (\u0275BarVerticalComponent_BaseFactory || (\u0275BarVerticalComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarVerticalComponent)))(__ngFactoryType__ || _BarVerticalComponent);
  };
})();
_BarVerticalComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BarVerticalComponent,
  selectors: [["ngx-charts-bar-vertical"]],
  contentQueries: function BarVerticalComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    tooltipDisabled: "tooltipDisabled",
    gradient: "gradient",
    showGridLines: "showGridLines",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    barPadding: "barPadding",
    roundDomains: "roundDomains",
    roundEdges: "roundEdges",
    yScaleMax: "yScaleMax",
    yScaleMin: "yScaleMin",
    showDataLabel: "showDataLabel",
    dataLabelFormatting: "dataLabelFormatting",
    noBarWhenZero: "noBarWhenZero",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 5,
  vars: 25,
  consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-series-vertical", "", 3, "activate", "deactivate", "select", "dataLabelHeightChanged", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "activeEntries", "roundEdges", "animations", "noBarWhenZero"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"]],
  template: function BarVerticalComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelClick", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      })("legendLabelActivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event, true);
      })("legendLabelDeactivate", function BarVerticalComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event, true);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275template(2, BarVerticalComponent__svg_g_2_Template, 1, 12, "g", 2)(3, BarVerticalComponent__svg_g_3_Template, 1, 10, "g", 3);
      \u0275\u0275elementStart(4, "g", 4);
      \u0275\u0275listener("activate", function BarVerticalComponent_Template_g_activate_4_listener($event) {
        return ctx.onActivate($event);
      })("deactivate", function BarVerticalComponent_Template_g_deactivate_4_listener($event) {
        return ctx.onDeactivate($event);
      })("select", function BarVerticalComponent_Template_g_select_4_listener($event) {
        return ctx.onClick($event);
      })("dataLabelHeightChanged", function BarVerticalComponent_Template_g_dataLabelHeightChanged_4_listener($event) {
        return ctx.onDataLabelMaxHeightChanged($event);
      });
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(22, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275property("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("series", ctx.results)("dims", ctx.dims)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("showDataLabel", ctx.showDataLabel)("dataLabelFormatting", ctx.dataLabelFormatting)("activeEntries", ctx.activeEntries)("roundEdges", ctx.roundEdges)("animations", ctx.animations)("noBarWhenZero", ctx.noBarWhenZero);
    }
  },
  dependencies: [NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesVerticalComponent],
  styles: [_c25],
  encapsulation: 2,
  changeDetection: 0
});
var BarVerticalComponent = _BarVerticalComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarVerticalComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-vertical",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event, true)"
      (legendLabelDeactivate)="onDeactivate($event, true)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [xAxisOffset]="dataLabelMaxHeight.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g
          ngx-charts-series-vertical
          [xScale]="xScale"
          [yScale]="yScale"
          [colors]="colors"
          [series]="results"
          [dims]="dims"
          [gradient]="gradient"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [showDataLabel]="showDataLabel"
          [dataLabelFormatting]="dataLabelFormatting"
          [activeEntries]="activeEntries"
          [roundEdges]="roundEdges"
          [animations]="animations"
          [noBarWhenZero]="noBarWhenZero"
          (activate)="onActivate($event)"
          (deactivate)="onDeactivate($event)"
          (select)="onClick($event)"
          (dataLabelHeightChanged)="onDataLabelMaxHeightChanged($event)"
        ></svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    yScaleMin: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _BarVertical2DComponent = class _BarVertical2DComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.scaleType = ScaleType.Ordinal;
    this.showGridLines = true;
    this.activeEntries = [];
    this.schemeType = ScaleType.Ordinal;
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.groupPadding = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.roundEdges = true;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxHeight = {
      negative: 0,
      positive: 0
    };
    this.isSSR = false;
    this.barOrientation = BarOrientation;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxHeight = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.showDataLabel) {
      this.dims.height -= this.dataLabelMaxHeight.negative;
    }
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.valueDomain = this.getValueDomain();
    this.groupScale = this.getGroupScale();
    this.innerScale = this.getInnerScale();
    this.valueScale = this.getValueScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0] + this.dataLabelMaxHeight.negative})`;
  }
  onDataLabelMaxHeightChanged(event, groupIndex) {
    if (event.size.negative) {
      this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
    } else {
      this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
    }
    if (groupIndex === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  getGroupScale() {
    const spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
    return band().rangeRound([0, this.dims.width]).paddingInner(spacing).paddingOuter(spacing / 2).domain(this.groupDomain);
  }
  getInnerScale() {
    const width = this.groupScale.bandwidth();
    const spacing = this.innerDomain.length / (width / this.barPadding + 1);
    return band().rangeRound([0, width]).paddingInner(spacing).domain(this.innerDomain);
  }
  getValueScale() {
    const scale = linear2().range([this.dims.height, 0]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getValueDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.value)) {
          domain.push(d.value);
        }
      }
    }
    const min6 = Math.min(0, ...domain);
    const max6 = this.yScaleMax ? Math.max(this.yScaleMax, ...domain) : Math.max(0, ...domain);
    return [min6, max6];
  }
  groupTransform(group) {
    return `translate(${this.groupScale(group.label)}, 0)`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g2) => g2.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_BarVertical2DComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BarVertical2DComponent_BaseFactory;
  return function BarVertical2DComponent_Factory(__ngFactoryType__) {
    return (\u0275BarVertical2DComponent_BaseFactory || (\u0275BarVertical2DComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarVertical2DComponent)))(__ngFactoryType__ || _BarVertical2DComponent);
  };
})();
_BarVertical2DComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BarVertical2DComponent,
  selectors: [["ngx-charts-bar-vertical-2d"]],
  contentQueries: function BarVertical2DComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    tooltipDisabled: "tooltipDisabled",
    scaleType: "scaleType",
    gradient: "gradient",
    showGridLines: "showGridLines",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    groupPadding: "groupPadding",
    barPadding: "barPadding",
    roundDomains: "roundDomains",
    roundEdges: "roundEdges",
    yScaleMax: "yScaleMax",
    showDataLabel: "showDataLabel",
    dataLabelFormatting: "dataLabelFormatting",
    noBarWhenZero: "noBarWhenZero",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 7,
  vars: 18,
  consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-grid-panel-series", "", 3, "xScale", "yScale", "data", "dims", "orient"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-series-vertical", "", 3, "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero", "select", "activate", "deactivate", "dataLabelHeightChanged", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-vertical", "", 3, "select", "activate", "deactivate", "dataLabelHeightChanged", "activeEntries", "xScale", "yScale", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "roundEdges", "animations", "noBarWhenZero"]],
  template: function BarVertical2DComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelActivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event, void 0, true);
      })("legendLabelDeactivate", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event, void 0, true);
      })("legendLabelClick", function BarVertical2DComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275element(2, "g", 2);
      \u0275\u0275template(3, BarVertical2DComponent__svg_g_3_Template, 1, 11, "g", 3)(4, BarVertical2DComponent__svg_g_4_Template, 1, 10, "g", 4)(5, BarVertical2DComponent__svg_g_5_Template, 2, 2, "g", 5)(6, BarVertical2DComponent__svg_g_6_Template, 2, 2, "g", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(15, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("xScale", ctx.groupScale)("yScale", ctx.valueScale)("data", ctx.results)("dims", ctx.dims)("orient", ctx.barOrientation.Vertical);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, GridPanelSeriesComponent, SeriesVerticalComponent],
  styles: [_c25],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1,
      transform: "*"
    }), animate(500, style({
      opacity: 0,
      transform: "scale(0)"
    }))])])]
  },
  changeDetection: 0
});
var BarVertical2DComponent = _BarVertical2DComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarVertical2DComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-vertical-2d",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-grid-panel-series
          [xScale]="groupScale"
          [yScale]="valueScale"
          [data]="results"
          [dims]="dims"
          [orient]="barOrientation.Vertical"
        ></svg:g>
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="groupScale"
          [dims]="dims"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [xAxisOffset]="dataLabelMaxHeight.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="valueScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g *ngIf="!isSSR">
          <svg:g
            ngx-charts-series-vertical
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
            [activeEntries]="activeEntries"
            [xScale]="innerScale"
            [yScale]="valueScale"
            [colors]="colors"
            [series]="group.series"
            [dims]="dims"
            [gradient]="gradient"
            [tooltipDisabled]="tooltipDisabled"
            [tooltipTemplate]="tooltipTemplate"
            [showDataLabel]="showDataLabel"
            [dataLabelFormatting]="dataLabelFormatting"
            [seriesName]="group.name"
            [roundEdges]="roundEdges"
            [animations]="animations"
            [noBarWhenZero]="noBarWhenZero"
            (select)="onClick($event, group)"
            (activate)="onActivate($event, group)"
            (deactivate)="onDeactivate($event, group)"
            (dataLabelHeightChanged)="onDataLabelMaxHeightChanged($event, index)"
          ></svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g
            ngx-charts-series-vertical
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [attr.transform]="groupTransform(group)"
            [activeEntries]="activeEntries"
            [xScale]="innerScale"
            [yScale]="valueScale"
            [colors]="colors"
            [series]="group.series"
            [dims]="dims"
            [gradient]="gradient"
            [tooltipDisabled]="tooltipDisabled"
            [tooltipTemplate]="tooltipTemplate"
            [showDataLabel]="showDataLabel"
            [dataLabelFormatting]="dataLabelFormatting"
            [seriesName]="group.name"
            [roundEdges]="roundEdges"
            [animations]="animations"
            [noBarWhenZero]="noBarWhenZero"
            (select)="onClick($event, group)"
            (activate)="onActivate($event, group)"
            (deactivate)="onDeactivate($event, group)"
            (dataLabelHeightChanged)="onDataLabelMaxHeightChanged($event, index)"
          ></svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    groupPadding: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _BarVerticalNormalizedComponent = class _BarVerticalNormalizedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.schemeType = ScaleType.Ordinal;
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.valueDomain = [0, 100];
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.isSSR = false;
    this.barChartType = BarChartType;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getXScale() {
    const spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
    return band().rangeRound([0, this.dims.width]).paddingInner(spacing).domain(this.groupDomain);
  }
  getYScale() {
    const scale = linear2().range([this.dims.height, 0]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  groupTransform(group) {
    return `translate(${this.xScale(group.name)}, 0)`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g2) => g2.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_BarVerticalNormalizedComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BarVerticalNormalizedComponent_BaseFactory;
  return function BarVerticalNormalizedComponent_Factory(__ngFactoryType__) {
    return (\u0275BarVerticalNormalizedComponent_BaseFactory || (\u0275BarVerticalNormalizedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarVerticalNormalizedComponent)))(__ngFactoryType__ || _BarVerticalNormalizedComponent);
  };
})();
_BarVerticalNormalizedComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BarVerticalNormalizedComponent,
  selectors: [["ngx-charts-bar-vertical-normalized"]],
  contentQueries: function BarVerticalNormalizedComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    tooltipDisabled: "tooltipDisabled",
    gradient: "gradient",
    showGridLines: "showGridLines",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    barPadding: "barPadding",
    roundDomains: "roundDomains",
    noBarWhenZero: "noBarWhenZero",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 6,
  vars: 13,
  consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-vertical", "", 3, "select", "activate", "deactivate", "type", "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "seriesName", "animations", "noBarWhenZero"]],
  template: function BarVerticalNormalizedComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelActivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event, void 0, true);
      })("legendLabelDeactivate", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event, void 0, true);
      })("legendLabelClick", function BarVerticalNormalizedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275template(2, BarVerticalNormalizedComponent__svg_g_2_Template, 1, 10, "g", 2)(3, BarVerticalNormalizedComponent__svg_g_3_Template, 1, 10, "g", 3)(4, BarVerticalNormalizedComponent__svg_g_4_Template, 2, 2, "g", 4)(5, BarVerticalNormalizedComponent__svg_g_5_Template, 2, 2, "g", 4);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(10, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesVerticalComponent],
  styles: [_c25],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1,
      transform: "*"
    }), animate(500, style({
      opacity: 0,
      transform: "scale(0)"
    }))])])]
  },
  changeDetection: 0
});
var BarVerticalNormalizedComponent = _BarVerticalNormalizedComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarVerticalNormalizedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-vertical-normalized",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g *ngIf="!isSSR">
          <svg:g
            *ngFor="let group of results; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-vertical
              [type]="barChartType.Normalized"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
            ></svg:g>
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g *ngFor="let group of results; trackBy: trackBy" [attr.transform]="groupTransform(group)">
            <svg:g
              ngx-charts-series-vertical
              [type]="barChartType.Normalized"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [seriesName]="group.name"
              [animations]="animations"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
            ></svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _BarVerticalStackedComponent = class _BarVerticalStackedComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.tooltipDisabled = false;
    this.showGridLines = true;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.barPadding = 8;
    this.roundDomains = false;
    this.showDataLabel = false;
    this.noBarWhenZero = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.dataLabelMaxHeight = {
      negative: 0,
      positive: 0
    };
    this.isSSR = false;
    this.barChartType = BarChartType;
    this.trackBy = (index, item) => {
      return item.name;
    };
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    if (!this.showDataLabel) {
      this.dataLabelMaxHeight = {
        negative: 0,
        positive: 0
      };
    }
    this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.showDataLabel) {
      this.dims.height -= this.dataLabelMaxHeight.negative;
    }
    this.formatDates();
    this.groupDomain = this.getGroupDomain();
    this.innerDomain = this.getInnerDomain();
    this.valueDomain = this.getValueDomain();
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0] + this.dataLabelMaxHeight.negative})`;
  }
  getGroupDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.label)) {
        domain.push(group.label);
      }
    }
    return domain;
  }
  getInnerDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.label)) {
          domain.push(d.label);
        }
      }
    }
    return domain;
  }
  getValueDomain() {
    const domain = [];
    let smallest = 0;
    let biggest = 0;
    for (const group of this.results) {
      let smallestSum = 0;
      let biggestSum = 0;
      for (const d of group.series) {
        if (d.value < 0) {
          smallestSum += d.value;
        } else {
          biggestSum += d.value;
        }
        smallest = d.value < smallest ? d.value : smallest;
        biggest = d.value > biggest ? d.value : biggest;
      }
      domain.push(smallestSum);
      domain.push(biggestSum);
    }
    domain.push(smallest);
    domain.push(biggest);
    const min6 = Math.min(0, ...domain);
    const max6 = this.yScaleMax ? Math.max(this.yScaleMax, ...domain) : Math.max(...domain);
    return [min6, max6];
  }
  getXScale() {
    const spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
    return band().rangeRound([0, this.dims.width]).paddingInner(spacing).domain(this.groupDomain);
  }
  getYScale() {
    const scale = linear2().range([this.dims.height, 0]).domain(this.valueDomain);
    return this.roundDomains ? scale.nice() : scale;
  }
  onDataLabelMaxHeightChanged(event, groupIndex) {
    if (event.size.negative) {
      this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
    } else {
      this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
    }
    if (groupIndex === this.results.length - 1) {
      setTimeout(() => this.update());
    }
  }
  groupTransform(group) {
    return `translate(${this.xScale(group.name) || 0}, 0)`;
  }
  onClick(data, group) {
    if (group) {
      data.series = group.name;
    }
    this.select.emit(data);
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.innerDomain;
    } else {
      domain = this.valueDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.innerDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.valueDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g2) => g2.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_BarVerticalStackedComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BarVerticalStackedComponent_BaseFactory;
  return function BarVerticalStackedComponent_Factory(__ngFactoryType__) {
    return (\u0275BarVerticalStackedComponent_BaseFactory || (\u0275BarVerticalStackedComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BarVerticalStackedComponent)))(__ngFactoryType__ || _BarVerticalStackedComponent);
  };
})();
_BarVerticalStackedComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BarVerticalStackedComponent,
  selectors: [["ngx-charts-bar-vertical-stacked"]],
  contentQueries: function BarVerticalStackedComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    tooltipDisabled: "tooltipDisabled",
    gradient: "gradient",
    showGridLines: "showGridLines",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    barPadding: "barPadding",
    roundDomains: "roundDomains",
    yScaleMax: "yScaleMax",
    showDataLabel: "showDataLabel",
    dataLabelFormatting: "dataLabelFormatting",
    noBarWhenZero: "noBarWhenZero",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 6,
  vars: 13,
  consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "bar-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "xAxisOffset", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-series-vertical", "", 3, "select", "activate", "deactivate", "dataLabelHeightChanged", "type", "xScale", "yScale", "activeEntries", "colors", "series", "dims", "gradient", "tooltipDisabled", "tooltipTemplate", "showDataLabel", "dataLabelFormatting", "seriesName", "animations", "noBarWhenZero"]],
  template: function BarVerticalStackedComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelActivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event, void 0, true);
      })("legendLabelDeactivate", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event, void 0, true);
      })("legendLabelClick", function BarVerticalStackedComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275template(2, BarVerticalStackedComponent__svg_g_2_Template, 1, 11, "g", 2)(3, BarVerticalStackedComponent__svg_g_3_Template, 1, 10, "g", 3)(4, BarVerticalStackedComponent__svg_g_4_Template, 2, 2, "g", 4)(5, BarVerticalStackedComponent__svg_g_5_Template, 2, 2, "g", 4);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(10, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, SeriesVerticalComponent],
  styles: [_c25],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1,
      transform: "*"
    }), animate(500, style({
      opacity: 0,
      transform: "scale(0)"
    }))])])]
  },
  changeDetection: 0
});
var BarVerticalStackedComponent = _BarVerticalStackedComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarVerticalStackedComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bar-vertical-stacked",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, undefined, true)"
      (legendLabelDeactivate)="onDeactivate($event, undefined, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="bar-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [xAxisOffset]="dataLabelMaxHeight.negative"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g *ngIf="!isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [@animationState]="'active'"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-vertical
              [type]="barChartType.Stacked"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [seriesName]="group.name"
              [animations]="animations"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelHeightChanged)="onDataLabelMaxHeightChanged($event, index)"
            ></svg:g>
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR">
          <svg:g
            *ngFor="let group of results; let index = index; trackBy: trackBy"
            [attr.transform]="groupTransform(group)"
          >
            <svg:g
              ngx-charts-series-vertical
              [type]="barChartType.Stacked"
              [xScale]="xScale"
              [yScale]="yScale"
              [activeEntries]="activeEntries"
              [colors]="colors"
              [series]="group.series"
              [dims]="dims"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [showDataLabel]="showDataLabel"
              [dataLabelFormatting]="dataLabelFormatting"
              [seriesName]="group.name"
              [animations]="animations"
              [noBarWhenZero]="noBarWhenZero"
              (select)="onClick($event, group)"
              (activate)="onActivate($event, group)"
              (deactivate)="onDeactivate($event, group)"
              (dataLabelHeightChanged)="onDataLabelMaxHeightChanged($event, index)"
            ></svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1,
        transform: "*"
      }), animate(500, style({
        opacity: 0,
        transform: "scale(0)"
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    barPadding: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    showDataLabel: [{
      type: Input
    }],
    dataLabelFormatting: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _BarChartModule = class _BarChartModule {
};
_BarChartModule.\u0275fac = function BarChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BarChartModule)();
};
_BarChartModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _BarChartModule
});
_BarChartModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule]
});
var BarChartModule = _BarChartModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BarChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, BarLabelComponent, SeriesHorizontal, SeriesVerticalComponent],
      exports: [BarComponent, BarHorizontalComponent, BarHorizontal2DComponent, BarHorizontalNormalizedComponent, BarHorizontalStackedComponent, BarVerticalComponent, BarVertical2DComponent, BarVerticalNormalizedComponent, BarVerticalStackedComponent, BarLabelComponent, SeriesHorizontal, SeriesVerticalComponent]
    }]
  }], null, null);
})();
function clonePoint(original) {
  if (!original) {
    return original;
  }
  return {
    x: original.x,
    y: original.y
  };
}
function cloneVector2d(original) {
  if (!original) {
    return original;
  }
  return {
    v1: clonePoint(original.v1),
    v2: clonePoint(original.v2)
  };
}
function cloneLineCoordinates(original) {
  if (!original) {
    return original;
  }
  return [cloneVector2d(original[0]), cloneVector2d(original[1]), cloneVector2d(original[2]), cloneVector2d(original[3])];
}
var _BoxComponent = class _BoxComponent {
  constructor(element, cd) {
    this.cd = cd;
    this.roundEdges = true;
    this.gradient = false;
    this.offset = 0;
    this.isActive = false;
    this.animations = true;
    this.noBarWhenZero = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.BarOrientation = BarOrientation;
    this.initialized = false;
    this.hasGradient = false;
    this.hideBar = false;
    this.nativeElm = element.nativeElement;
  }
  ngOnChanges(changes) {
    if (!this.initialized) {
      this.loadAnimation();
      this.initialized = true;
    } else {
      this.update();
    }
  }
  update() {
    this.boxStrokeWidth = Math.max(this.strokeWidth, 1);
    this.whiskerStrokeWidth = Math.max(this.strokeWidth / 2, 1);
    this.medianLineWidth = 1.5 * this.strokeWidth;
    this.gradientId = "grad" + id2().toString();
    this.gradientFill = `url(#${this.gradientId})`;
    if (this.gradient) {
      this.gradientStops = this.getGradient();
      this.hasGradient = true;
    } else {
      this.hasGradient = false;
    }
    this.updateLineEl();
    this.updatePathEl();
    this.checkToHideBar();
    this.maskLineId = "mask" + id2().toString();
    this.maskLine = `url(#${this.maskLineId})`;
    if (this.cd) {
      this.cd.markForCheck();
    }
  }
  loadAnimation() {
    this.boxPath = this.oldPath = this.getStartingPath();
    this.oldLineCoordinates = this.getStartingLineCoordinates();
    setTimeout(this.update.bind(this), 100);
  }
  updatePathEl() {
    const nodeBar = select_default2(this.nativeElm).selectAll(".bar");
    const path3 = this.getPath();
    if (this.animations) {
      nodeBar.attr("d", this.oldPath).transition().ease(sinInOut).duration(500).attrTween("d", this.pathTween(path3, 4));
    } else {
      nodeBar.attr("d", path3);
    }
    this.oldPath = path3;
  }
  updateLineEl() {
    const lineEl = select_default2(this.nativeElm).selectAll(".bar-line");
    const lineCoordinates = this.lineCoordinates;
    const oldLineCoordinates = this.oldLineCoordinates;
    if (this.animations) {
      lineEl.attr("x1", (_, index) => oldLineCoordinates[index].v1.x).attr("y1", (_, index) => oldLineCoordinates[index].v1.y).attr("x2", (_, index) => oldLineCoordinates[index].v2.x).attr("y2", (_, index) => oldLineCoordinates[index].v2.y).transition().ease(sinInOut).duration(500).attr("x1", (_, index) => lineCoordinates[index].v1.x).attr("y1", (_, index) => lineCoordinates[index].v1.y).attr("x2", (_, index) => lineCoordinates[index].v2.x).attr("y2", (_, index) => lineCoordinates[index].v2.y);
    } else {
      lineEl.attr("x1", (_, index) => lineCoordinates[index].v1.x).attr("y1", (_, index) => lineCoordinates[index].v1.y).attr("x2", (_, index) => lineCoordinates[index].v2.x).attr("y2", (_, index) => lineCoordinates[index].v2.y);
    }
    this.oldLineCoordinates = [...lineCoordinates];
  }
  /**
   * See [D3 Selections](https://www.d3indepth.com/selections/)
   * @param d The joined data.
   * @param index The index of the element within the selection
   * @param node The node element (Line).
   */
  lineTween(attr, d, index, node) {
    const nodeLineEl = node[index];
    return nodeLineEl[attr].baseVal.value;
  }
  // TODO: Refactor into another .ts file if https://github.com/swimlane/ngx-charts/pull/1179 gets merged.
  pathTween(d1, precision) {
    return function() {
      const path0 = this;
      const path1 = this.cloneNode();
      path1.setAttribute("d", d1);
      const n0 = path0?.getTotalLength();
      const n1 = path1?.getTotalLength();
      const distances = [0];
      let i = 0;
      const dt = precision / Math.max(n0, n1);
      while (i < 1) {
        distances.push(i);
        i += dt;
      }
      distances.push(1);
      const points = distances.map((t2) => {
        const p0 = path0.getPointAtLength(t2 * n0);
        const p1 = path1.getPointAtLength(t2 * n1);
        return value_default([p0.x, p0.y], [p1.x, p1.y]);
      });
      return (t2) => {
        return t2 < 1 ? "M" + points.map((p2) => p2(t2)).join("L") : d1;
      };
    };
  }
  getStartingPath() {
    if (!this.animations) {
      return this.getPath();
    }
    const radius = this.roundEdges ? 1 : 0;
    const {
      x: x4,
      y: y3
    } = this.lineCoordinates[2].v1;
    return roundedRect(x4 - this.width, y3 - 1, this.width, 2, radius, this.edges);
  }
  getPath() {
    const radius = this.getRadius();
    let path3 = "";
    path3 = roundedRect(this.x, this.y, this.width, this.height, Math.min(this.height, radius), this.edges);
    return path3;
  }
  getStartingLineCoordinates() {
    if (!this.animations) {
      return [...this.lineCoordinates];
    }
    const lineCoordinates = cloneLineCoordinates(this.lineCoordinates);
    lineCoordinates[1].v1.y = lineCoordinates[1].v2.y = lineCoordinates[3].v1.y = lineCoordinates[3].v2.y = lineCoordinates[0].v1.y = lineCoordinates[0].v2.y = lineCoordinates[2].v1.y;
    return lineCoordinates;
  }
  getRadius() {
    let radius = 0;
    if (this.roundEdges && this.height > 5 && this.width > 5) {
      radius = Math.floor(Math.min(5, this.height / 2, this.width / 2));
    }
    return radius;
  }
  getGradient() {
    return [{
      offset: 0,
      color: this.fill,
      opacity: this.getStartOpacity()
    }, {
      offset: 100,
      color: this.fill,
      opacity: 1
    }];
  }
  getStartOpacity() {
    if (this.roundEdges) {
      return 0.2;
    } else {
      return 0.5;
    }
  }
  get edges() {
    let edges = [false, false, false, false];
    if (this.roundEdges) {
      edges = [true, true, true, true];
    }
    return edges;
  }
  onMouseEnter() {
    this.activate.emit(this.data);
  }
  onMouseLeave() {
    this.deactivate.emit(this.data);
  }
  checkToHideBar() {
    this.hideBar = this.noBarWhenZero && this.height === 0;
  }
};
_BoxComponent.\u0275fac = function BoxComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BoxComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef));
};
_BoxComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BoxComponent,
  selectors: [["g", "ngx-charts-box", ""]],
  hostBindings: function BoxComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseenter", function BoxComponent_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function BoxComponent_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      });
    }
  },
  inputs: {
    strokeColor: "strokeColor",
    strokeWidth: "strokeWidth",
    fill: "fill",
    data: "data",
    width: "width",
    height: "height",
    x: "x",
    y: "y",
    lineCoordinates: "lineCoordinates",
    roundEdges: "roundEdges",
    gradient: "gradient",
    gradientStops: "gradientStops",
    offset: "offset",
    isActive: "isActive",
    animations: "animations",
    ariaLabel: "ariaLabel",
    noBarWhenZero: "noBarWhenZero"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c30,
  decls: 9,
  vars: 13,
  consts: [["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops", 4, "ngIf"], ["height", "100%", "width", "100%", "fill", "white", "fill-opacity", "1"], ["fill", "black", "fill-opacity", "1", 1, "bar"], ["role", "img", "tabIndex", "-1", 1, "bar", 3, "click"], ["class", "bar-line", "fill", "none", 3, "hidden", 4, "ngFor", "ngForOf"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"], ["fill", "none", 1, "bar-line"]],
  template: function BoxComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "defs");
      \u0275\u0275template(1, BoxComponent__svg_g_1_Template, 1, 3, "g", 0);
      \u0275\u0275elementStart(2, "mask")(3, "g");
      \u0275\u0275element(4, "rect", 1)(5, "path", 2);
      \u0275\u0275elementEnd()()();
      \u0275\u0275elementStart(6, "g")(7, "path", 3);
      \u0275\u0275listener("click", function BoxComponent_Template_path_click_7_listener() {
        return ctx.select.emit(ctx.data);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(8, BoxComponent__svg_line_8_Template, 1, 9, "line", 4);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.hasGradient);
      \u0275\u0275advance();
      \u0275\u0275attribute("id", ctx.maskLineId);
      \u0275\u0275advance(3);
      \u0275\u0275attribute("d", ctx.boxPath);
      \u0275\u0275advance(2);
      \u0275\u0275classProp("active", ctx.isActive)("hidden", ctx.hideBar);
      \u0275\u0275attribute("d", ctx.boxPath)("stroke", ctx.strokeColor)("stroke-width", ctx.boxStrokeWidth)("aria-label", ctx.ariaLabel)("fill", ctx.hasGradient ? ctx.gradientFill : ctx.fill);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.lineCoordinates);
    }
  },
  dependencies: [NgForOf, NgIf, SvgLinearGradientComponent],
  encapsulation: 2,
  changeDetection: 0
});
var BoxComponent = _BoxComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BoxComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-box]",
      template: `
    <svg:defs>
      <svg:g
        *ngIf="hasGradient"
        ngx-charts-svg-linear-gradient
        [orientation]="BarOrientation.Vertical"
        [name]="gradientId"
        [stops]="gradientStops"
      />
      <svg:mask [attr.id]="maskLineId">
        <svg:g>
          <rect height="100%" width="100%" fill="white" fill-opacity="1" />
          <path class="bar" [attr.d]="boxPath" fill="black" fill-opacity="1" />
        </svg:g>
      </svg:mask>
    </svg:defs>
    <svg:g>
      <svg:path
        class="bar"
        role="img"
        tabIndex="-1"
        [class.active]="isActive"
        [class.hidden]="hideBar"
        [attr.d]="boxPath"
        [attr.stroke]="strokeColor"
        [attr.stroke-width]="boxStrokeWidth"
        [attr.aria-label]="ariaLabel"
        [attr.fill]="hasGradient ? gradientFill : fill"
        (click)="select.emit(data)"
      />
      <svg:line
        *ngFor="let line of lineCoordinates; let i = index"
        class="bar-line"
        [class.hidden]="hideBar"
        [attr.x1]="line.v1.x"
        [attr.y1]="line.v1.y"
        [attr.x2]="line.v2.x"
        [attr.y2]="line.v2.y"
        [attr.stroke]="strokeColor"
        [attr.stroke-width]="i === 2 ? medianLineWidth : whiskerStrokeWidth"
        [attr.mask]="i ? undefined : maskLine"
        fill="none"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    strokeColor: [{
      type: Input
    }],
    strokeWidth: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }],
    lineCoordinates: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    gradientStops: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    noBarWhenZero: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var _BoxSeriesComponent = class _BoxSeriesComponent {
  constructor() {
    this.animations = true;
    this.tooltipDisabled = false;
    this.gradient = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
  }
  ngOnChanges(changes) {
    this.update();
  }
  onClick(data) {
    this.select.emit(data);
  }
  update() {
    this.updateTooltipSettings();
    const width = this.series && this.series.series.length ? Math.round(this.xScale.bandwidth()) : null;
    const seriesName = this.series.name;
    this.counts = this.series.series;
    const mappedCounts = this.counts.map((serie) => Number(serie.value));
    this.whiskers = [min3(mappedCounts), max3(mappedCounts)];
    const groupCounts = this.counts.map((item) => item.value).sort((a, b) => Number(a) - Number(b));
    this.quartiles = this.getBoxQuantiles(groupCounts);
    this.lineCoordinates = this.getLinesCoordinates(seriesName.toString(), this.whiskers, this.quartiles, width);
    const value2 = this.quartiles[1];
    const formattedLabel = formatLabel(seriesName);
    const box = {
      value: value2,
      data: this.counts,
      label: seriesName,
      formattedLabel,
      width,
      height: 0,
      x: 0,
      y: 0,
      roundEdges: this.roundEdges,
      quartiles: this.quartiles,
      lineCoordinates: this.lineCoordinates
    };
    box.height = Math.abs(this.yScale(this.quartiles[0]) - this.yScale(this.quartiles[2]));
    box.x = this.xScale(seriesName.toString());
    box.y = this.yScale(this.quartiles[2]);
    box.ariaLabel = formattedLabel + " - Median: " + value2.toLocaleString();
    if (this.colors.scaleType === ScaleType.Ordinal) {
      box.color = this.colors.getColor(seriesName);
    } else {
      box.color = this.colors.getColor(this.quartiles[1]);
      box.gradientStops = this.colors.getLinearGradientStops(this.quartiles[0], this.quartiles[2]);
    }
    const tooltipLabel = formattedLabel;
    const formattedTooltipLabel = `
    <span class="tooltip-label">${escapeLabel(tooltipLabel)}</span>
    <span class="tooltip-val">
      \u2022 Q1: ${this.quartiles[0]} \u2022 Q2: ${this.quartiles[1]} \u2022 Q3: ${this.quartiles[2]}<br>
      \u2022 Min: ${this.whiskers[0]} \u2022 Max: ${this.whiskers[1]}
    </span>`;
    box.tooltipText = this.tooltipDisabled ? void 0 : formattedTooltipLabel;
    this.tooltipTitle = this.tooltipDisabled ? void 0 : box.tooltipText;
    this.box = box;
  }
  getBoxQuantiles(inputData) {
    return [quantile(inputData, 0.25), quantile(inputData, 0.5), quantile(inputData, 0.75)];
  }
  getLinesCoordinates(seriesName, whiskers, quartiles, barWidth) {
    const commonX = this.xScale(seriesName);
    const offsetX = commonX + barWidth / 2;
    const medianLineWidth = Math.max(barWidth + 4 * this.strokeWidth, 1);
    const whiskerLineWidth = Math.max(barWidth / 3, 1);
    const whiskerZero = this.yScale(whiskers[0]);
    const whiskerOne = this.yScale(whiskers[1]);
    const median = this.yScale(quartiles[1]);
    const topLine = {
      v1: {
        x: offsetX + whiskerLineWidth / 2,
        y: whiskerZero
      },
      v2: {
        x: offsetX - whiskerLineWidth / 2,
        y: whiskerZero
      }
    };
    const medianLine = {
      v1: {
        x: offsetX + medianLineWidth / 2,
        y: median
      },
      v2: {
        x: offsetX - medianLineWidth / 2,
        y: median
      }
    };
    const bottomLine = {
      v1: {
        x: offsetX + whiskerLineWidth / 2,
        y: whiskerOne
      },
      v2: {
        x: offsetX - whiskerLineWidth / 2,
        y: whiskerOne
      }
    };
    const verticalLine = {
      v1: {
        x: offsetX,
        y: whiskerZero
      },
      v2: {
        x: offsetX,
        y: whiskerOne
      }
    };
    return [verticalLine, topLine, medianLine, bottomLine];
  }
  updateTooltipSettings() {
    if (this.tooltipDisabled) {
      this.tooltipPlacement = void 0;
      this.tooltipType = void 0;
    } else {
      if (!this.tooltipPlacement) {
        this.tooltipPlacement = PlacementTypes.Top;
      }
      if (!this.tooltipType) {
        this.tooltipType = StyleTypes.tooltip;
      }
    }
  }
};
_BoxSeriesComponent.\u0275fac = function BoxSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BoxSeriesComponent)();
};
_BoxSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BoxSeriesComponent,
  selectors: [["g", "ngx-charts-box-series", ""]],
  inputs: {
    dims: "dims",
    series: "series",
    xScale: "xScale",
    yScale: "yScale",
    colors: "colors",
    animations: "animations",
    strokeColor: "strokeColor",
    strokeWidth: "strokeWidth",
    tooltipDisabled: "tooltipDisabled",
    tooltipTemplate: "tooltipTemplate",
    tooltipPlacement: "tooltipPlacement",
    tooltipType: "tooltipType",
    roundEdges: "roundEdges",
    gradient: "gradient"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c31,
  decls: 1,
  vars: 22,
  consts: [["ngx-charts-box", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "width", "height", "x", "y", "roundEdges", "fill", "gradientStops", "strokeColor", "strokeWidth", "data", "lineCoordinates", "gradient", "ariaLabel", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "animations"]],
  template: function BoxSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g", 0);
      \u0275\u0275listener("select", function BoxSeriesComponent_Template_g_select_0_listener($event) {
        return ctx.onClick($event);
      })("activate", function BoxSeriesComponent_Template_g_activate_0_listener($event) {
        return ctx.activate.emit($event);
      })("deactivate", function BoxSeriesComponent_Template_g_deactivate_0_listener($event) {
        return ctx.deactivate.emit($event);
      });
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("@animationState", "active")("@.disabled", !ctx.animations)("width", ctx.box.width)("height", ctx.box.height)("x", ctx.box.x)("y", ctx.box.y)("roundEdges", ctx.box.roundEdges)("fill", ctx.box.color)("gradientStops", ctx.box.gradientStops)("strokeColor", ctx.strokeColor)("strokeWidth", ctx.strokeWidth)("data", ctx.box.data)("lineCoordinates", ctx.box.lineCoordinates)("gradient", ctx.gradient)("ariaLabel", ctx.box.ariaLabel)("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", ctx.tooltipPlacement)("tooltipType", ctx.tooltipType)("tooltipTitle", ctx.tooltipTitle)("tooltipTemplate", ctx.tooltipTemplate)("tooltipContext", ctx.box.data)("animations", ctx.animations);
    }
  },
  dependencies: [TooltipDirective, BoxComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1
    }), animate(500, style({
      opacity: 0
    }))])])]
  },
  changeDetection: 0
});
var BoxSeriesComponent = _BoxSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BoxSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-box-series]",
      template: `
    <svg:g
      ngx-charts-box
      [@animationState]="'active'"
      [@.disabled]="!animations"
      [width]="box.width"
      [height]="box.height"
      [x]="box.x"
      [y]="box.y"
      [roundEdges]="box.roundEdges"
      [fill]="box.color"
      [gradientStops]="box.gradientStops"
      [strokeColor]="strokeColor"
      [strokeWidth]="strokeWidth"
      [data]="box.data"
      [lineCoordinates]="box.lineCoordinates"
      [gradient]="gradient"
      [ariaLabel]="box.ariaLabel"
      (select)="onClick($event)"
      (activate)="activate.emit($event)"
      (deactivate)="deactivate.emit($event)"
      ngx-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="tooltipPlacement"
      [tooltipType]="tooltipType"
      [tooltipTitle]="tooltipTitle"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="box.data"
      [animations]="animations"
    ></svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])]
    }]
  }], null, {
    dims: [{
      type: Input
    }],
    series: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    strokeColor: [{
      type: Input
    }],
    strokeWidth: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    tooltipPlacement: [{
      type: Input
    }],
    tooltipType: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var _BoxChartComponent = class _BoxChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendPosition = LegendPosition.Right;
    this.legendTitle = "Legend";
    this.showGridLines = true;
    this.xAxis = true;
    this.yAxis = true;
    this.showXAxisLabel = true;
    this.showYAxisLabel = true;
    this.roundDomains = false;
    this.roundEdges = true;
    this.strokeColor = "#FFFFFF";
    this.strokeWidth = 2;
    this.tooltipDisabled = false;
    this.wrapTicks = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
  }
  trackBy(index, item) {
    return item.name;
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendPosition: this.legendPosition
    });
    this.xDomain = this.getXDomain();
    this.yDomain = this.getYDomain();
    this.seriesDomain = this.getSeriesDomain();
    this.setScales();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  setColors() {
    let domain = [];
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.seriesDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  setScales() {
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
    this.yScale = this.getYScale(this.yDomain, this.dims.height);
  }
  getXScale(domain, width) {
    const scale = band().domain(domain.map((d) => d.toString())).rangeRound([0, width]).padding(0.5);
    return scale;
  }
  getYScale(domain, height) {
    const scale = linear2().domain(domain).range([height, 0]);
    return this.roundDomains ? scale.nice() : scale;
  }
  getUniqueBoxChartXDomainValues(results) {
    const valueSet = /* @__PURE__ */ new Set();
    for (const result of results) {
      valueSet.add(result.name);
    }
    return Array.from(valueSet);
  }
  getXDomain() {
    let domain = [];
    const values = this.getUniqueBoxChartXDomainValues(this.results);
    let min6;
    let max6;
    if (typeof values[0] === "string") {
      domain = values.map((val) => val.toString());
    } else if (typeof values[0] === "number") {
      const mappedValues = values.map((v) => Number(v));
      min6 = Math.min(...mappedValues);
      max6 = Math.max(...mappedValues);
      domain = [min6, max6];
    } else {
      const mappedValues = values.map((v) => Number(new Date(v)));
      min6 = Math.min(...mappedValues);
      max6 = Math.max(...mappedValues);
      domain = [new Date(min6), new Date(max6)];
    }
    return domain;
  }
  getYDomain() {
    const domain = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (domain.indexOf(d.value) < 0) {
          domain.push(d.value);
        }
      }
    }
    const values = [...domain];
    const mappedValues = values.map((v) => Number(v));
    const min6 = Math.min(...mappedValues);
    const max6 = Math.max(...mappedValues);
    return [min6, max6];
  }
  getSeriesDomain() {
    return this.results.map((d) => `${d.name}`);
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onClick(data) {
    this.select.emit(data);
  }
  onActivate(data) {
    this.activate.emit(data);
  }
  onDeactivate(data) {
    this.deactivate.emit(data);
  }
  getLegendOptions() {
    const legendOpts = {
      scaleType: this.schemeType,
      colors: this.colors,
      domain: [],
      position: this.legendPosition,
      title: this.legendTitle
    };
    if (this.schemeType === ScaleType.Ordinal) {
      legendOpts.domain = this.xDomain;
      legendOpts.colors = this.colors;
    } else {
      legendOpts.domain = this.yDomain;
      legendOpts.colors = this.colors.scale;
    }
    return legendOpts;
  }
};
_BoxChartComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BoxChartComponent_BaseFactory;
  return function BoxChartComponent_Factory(__ngFactoryType__) {
    return (\u0275BoxChartComponent_BaseFactory || (\u0275BoxChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BoxChartComponent)))(__ngFactoryType__ || _BoxChartComponent);
  };
})();
_BoxChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BoxChartComponent,
  selectors: [["ngx-charts-box-chart"]],
  contentQueries: function BoxChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendPosition: "legendPosition",
    legendTitle: "legendTitle",
    legendOptionsConfig: "legendOptionsConfig",
    showGridLines: "showGridLines",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    roundDomains: "roundDomains",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    roundEdges: "roundEdges",
    strokeColor: "strokeColor",
    strokeWidth: "strokeWidth",
    tooltipDisabled: "tooltipDisabled",
    gradient: "gradient",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 6,
  vars: 23,
  consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "animations"], [1, "box-chart", "chart"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "showGridLines", "dims", "xScale", "showLabel", "labelText", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "showGridLines", "dims", "yScale", "showLabel", "labelText", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-box-series", "", 3, "activate", "deactivate", "select", "xScale", "yScale", "colors", "roundEdges", "strokeColor", "strokeWidth", "tooltipDisabled", "tooltipTemplate", "series", "dims", "animations", "gradient"]],
  template: function BoxChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelClick", function BoxChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      })("legendLabelActivate", function BoxChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event);
      })("legendLabelDeactivate", function BoxChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1)(2, "g", 2);
      \u0275\u0275listener("dimensionsChanged", function BoxChartComponent_Template_g_dimensionsChanged_2_listener($event) {
        return ctx.updateXAxisHeight($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "g", 3);
      \u0275\u0275listener("dimensionsChanged", function BoxChartComponent_Template_g_dimensionsChanged_3_listener($event) {
        return ctx.updateYAxisWidth($event);
      });
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(4, "g");
      \u0275\u0275template(5, BoxChartComponent__svg_g_5_Template, 2, 12, "g", 4);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(20, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("showGridLines", ctx.showGridLines)("dims", ctx.dims)("xScale", ctx.xScale)("showLabel", ctx.showXAxisLabel)("labelText", ctx.xAxisLabel)("wrapTicks", ctx.wrapTicks);
      \u0275\u0275advance();
      \u0275\u0275property("showGridLines", ctx.showGridLines)("dims", ctx.dims)("yScale", ctx.yScale)("showLabel", ctx.showYAxisLabel)("labelText", ctx.yAxisLabel)("wrapTicks", ctx.wrapTicks);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.results)("ngForTrackBy", ctx.trackBy);
    }
  },
  dependencies: [NgForOf, XAxisComponent, YAxisComponent, ChartComponent, BoxSeriesComponent],
  styles: [_c25],
  encapsulation: 2,
  changeDetection: 0
});
var BoxChartComponent = _BoxChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BoxChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-box-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:g [attr.transform]="transform" class="box-chart chart">
        <svg:g
          ngx-charts-x-axis
          [showGridLines]="showGridLines"
          [dims]="dims"
          [xScale]="xScale"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        />
        <svg:g
          ngx-charts-y-axis
          [showGridLines]="showGridLines"
          [dims]="dims"
          [yScale]="yScale"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        />
      </svg:g>
      <svg:g [attr.transform]="transform">
        <svg:g *ngFor="let result of results; trackBy: trackBy">
          <svg:g
            ngx-charts-box-series
            [xScale]="xScale"
            [yScale]="yScale"
            [colors]="colors"
            [roundEdges]="roundEdges"
            [strokeColor]="strokeColor"
            [strokeWidth]="strokeWidth"
            [tooltipDisabled]="tooltipDisabled"
            [tooltipTemplate]="tooltipTemplate"
            [series]="result"
            [dims]="dims"
            [animations]="animations"
            [gradient]="gradient"
            (activate)="onActivate($event)"
            (deactivate)="onDeactivate($event)"
            (select)="onClick($event)"
          />
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendOptionsConfig: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    roundEdges: [{
      type: Input
    }],
    strokeColor: [{
      type: Input
    }],
    strokeWidth: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate", {
        static: false
      }]
    }]
  });
})();
var _BoxChartModule = class _BoxChartModule {
};
_BoxChartModule.\u0275fac = function BoxChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BoxChartModule)();
};
_BoxChartModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _BoxChartModule
});
_BoxChartModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule]
});
var BoxChartModule = _BoxChartModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BoxChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [BoxChartComponent, BoxSeriesComponent, BoxComponent],
      exports: [BoxChartComponent, BoxSeriesComponent, BoxComponent]
    }]
  }], null, null);
})();
function getDomain(values, scaleType, autoScale, minVal, maxVal) {
  let domain = [];
  if (scaleType === ScaleType.Linear) {
    values = values.map((v) => Number(v));
    if (!autoScale) {
      values.push(0);
    }
  }
  if (scaleType === ScaleType.Time || scaleType === ScaleType.Linear) {
    const min6 = minVal || minVal === 0 ? minVal : Math.min(...values);
    const max6 = maxVal ? maxVal : Math.max(...values);
    domain = [min6, max6];
  } else {
    domain = values;
  }
  return domain;
}
function getScale2(domain, range2, scaleType, roundDomains) {
  switch (scaleType) {
    case ScaleType.Time:
      return time().range(range2).domain(domain);
    case ScaleType.Linear: {
      const scale = linear2().range(range2).domain(domain);
      if (roundDomains) {
        return scale.nice();
      }
      return scale;
    }
    case ScaleType.Ordinal:
      return point().range([range2[0], range2[1]]).domain(domain.map((r2) => r2.toString()));
    default:
      return void 0;
  }
}
var _BubbleSeriesComponent = class _BubbleSeriesComponent {
  constructor(platformId) {
    this.platformId = platformId;
    this.tooltipDisabled = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.circles = this.getCircles();
  }
  getCircles() {
    const seriesName = this.data.name;
    return this.data.series.map((d, i) => {
      if (typeof d.y !== "undefined" && typeof d.x !== "undefined") {
        const y3 = d.y;
        const x4 = d.x;
        const r2 = d.r;
        const radius = this.rScale(r2 || 1);
        const tooltipLabel = formatLabel(d.name);
        const cx = this.xScaleType === ScaleType.Linear ? this.xScale(Number(x4)) : this.xScale(x4);
        const cy = this.yScaleType === ScaleType.Linear ? this.yScale(Number(y3)) : this.yScale(y3);
        const color2 = this.colors.scaleType === ScaleType.Linear ? this.colors.getColor(r2) : this.colors.getColor(seriesName);
        const isActive = !this.activeEntries.length ? true : this.isActive({
          name: seriesName
        });
        const opacity = isActive ? 1 : 0.3;
        const data = Object.assign({}, d, {
          series: seriesName,
          name: d.name,
          value: d.y,
          x: d.x,
          radius: d.r
        });
        return {
          data,
          x: x4,
          y: y3,
          r: r2,
          classNames: [`circle-data-${i}`],
          value: y3,
          label: x4,
          cx,
          cy,
          radius,
          tooltipLabel,
          color: color2,
          opacity,
          seriesName,
          isActive,
          transform: `translate(${cx},${cy})`
        };
      }
    }).filter((circle) => circle !== void 0);
  }
  getTooltipText(circle) {
    const hasRadius = typeof circle.r !== "undefined";
    const hasTooltipLabel = circle.tooltipLabel && circle.tooltipLabel.length;
    const hasSeriesName = circle.seriesName && circle.seriesName.length;
    const radiusValue = hasRadius ? formatLabel(circle.r) : "";
    const xAxisLabel = this.xAxisLabel && this.xAxisLabel !== "" ? `${this.xAxisLabel}:` : "";
    const yAxisLabel = this.yAxisLabel && this.yAxisLabel !== "" ? `${this.yAxisLabel}:` : "";
    const x4 = formatLabel(circle.x);
    const y3 = formatLabel(circle.y);
    const name = hasSeriesName && hasTooltipLabel ? `${circle.seriesName} \u2022 ${circle.tooltipLabel}` : circle.seriesName + circle.tooltipLabel;
    const tooltipTitle = hasSeriesName || hasTooltipLabel ? `<span class="tooltip-label">${escapeLabel(name)}</span>` : "";
    return `
      ${tooltipTitle}
      <span class="tooltip-label">
        <label>${escapeLabel(xAxisLabel)}</label> ${escapeLabel(x4)}<br />
        <label>${escapeLabel(yAxisLabel)}</label> ${escapeLabel(y3)}
      </span>
      <span class="tooltip-val">
        ${escapeLabel(radiusValue)}
      </span>
    `;
  }
  onClick(data) {
    this.select.emit(data);
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item !== void 0;
  }
  isVisible(circle) {
    if (this.activeEntries.length > 0) {
      return this.isActive({
        name: circle.seriesName
      });
    }
    return circle.opacity !== 0;
  }
  activateCircle(circle) {
    circle.barVisible = true;
    this.activate.emit({
      name: this.data.name
    });
  }
  deactivateCircle(circle) {
    circle.barVisible = false;
    this.deactivate.emit({
      name: this.data.name
    });
  }
  trackBy(index, circle) {
    return `${circle.data.series} ${circle.data.name}`;
  }
};
_BubbleSeriesComponent.\u0275fac = function BubbleSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BubbleSeriesComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
};
_BubbleSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BubbleSeriesComponent,
  selectors: [["g", "ngx-charts-bubble-series", ""]],
  inputs: {
    data: "data",
    xScale: "xScale",
    yScale: "yScale",
    rScale: "rScale",
    xScaleType: "xScaleType",
    yScaleType: "yScaleType",
    colors: "colors",
    visibleValue: "visibleValue",
    activeEntries: "activeEntries",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    tooltipDisabled: "tooltipDisabled",
    tooltipTemplate: "tooltipTemplate"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c322,
  decls: 1,
  vars: 2,
  consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-circle", "", "class", "circle", "ngx-tooltip", "", 3, "cx", "cy", "r", "fill", "opacity", "active", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngIf"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "select", "activate", "deactivate", "cx", "cy", "r", "fill", "pointerEvents", "data", "classNames", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"]],
  template: function BubbleSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, BubbleSeriesComponent__svg_g_0_Template, 4, 3, "g", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.circles)("ngForTrackBy", ctx.trackBy);
    }
  },
  dependencies: [NgForOf, NgIf, TooltipDirective, CircleComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":enter", [style({
      opacity: 0,
      transform: "scale(0)"
    }), animate(250, style({
      opacity: 1,
      transform: "scale(1)"
    }))])])]
  },
  changeDetection: 0
});
var BubbleSeriesComponent = _BubbleSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BubbleSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-bubble-series]",
      template: `
    <svg:g *ngFor="let circle of circles; trackBy: trackBy">
      <svg:g [attr.transform]="circle.transform">
        <svg:g
          *ngIf="!isSSR"
          ngx-charts-circle
          [@animationState]="'active'"
          class="circle"
          [cx]="0"
          [cy]="0"
          [r]="circle.radius"
          [fill]="circle.color"
          [style.opacity]="circle.opacity"
          [class.active]="circle.isActive"
          [pointerEvents]="'all'"
          [data]="circle.value"
          [classNames]="circle.classNames"
          (select)="onClick(circle.data)"
          (activate)="activateCircle(circle)"
          (deactivate)="deactivateCircle(circle)"
          ngx-tooltip
          [tooltipDisabled]="tooltipDisabled"
          [tooltipPlacement]="placementTypes.Top"
          [tooltipType]="styleTypes.tooltip"
          [tooltipTitle]="tooltipTemplate ? undefined : getTooltipText(circle)"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipContext]="circle.data"
        />
        <svg:g
          *ngIf="isSSR"
          ngx-charts-circle
          class="circle"
          [cx]="0"
          [cy]="0"
          [r]="circle.radius"
          [fill]="circle.color"
          [style.opacity]="circle.opacity"
          [class.active]="circle.isActive"
          [pointerEvents]="'all'"
          [data]="circle.value"
          [classNames]="circle.classNames"
          (select)="onClick(circle.data)"
          (activate)="activateCircle(circle)"
          (deactivate)="deactivateCircle(circle)"
          ngx-tooltip
          [tooltipDisabled]="tooltipDisabled"
          [tooltipPlacement]="placementTypes.Top"
          [tooltipType]="styleTypes.tooltip"
          [tooltipTitle]="tooltipTemplate ? undefined : getTooltipText(circle)"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipContext]="circle.data"
        />
      </svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":enter", [style({
        opacity: 0,
        transform: "scale(0)"
      }), animate(250, style({
        opacity: 1,
        transform: "scale(1)"
      }))])])]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    data: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    rScale: [{
      type: Input
    }],
    xScaleType: [{
      type: Input
    }],
    yScaleType: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    visibleValue: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var _BubbleChartComponent = class _BubbleChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.showGridLines = true;
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.xAxis = true;
    this.yAxis = true;
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.maxRadius = 10;
    this.minRadius = 3;
    this.schemeType = ScaleType.Ordinal;
    this.tooltipDisabled = false;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.scaleType = ScaleType.Linear;
    this.margin = [10, 20, 10, 20];
    this.bubblePadding = [0, 0, 0, 0];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.activeEntries = [];
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    this.seriesDomain = this.results.map((d) => d.name);
    this.rDomain = this.getRDomain();
    this.xDomain = this.getXDomain();
    this.yDomain = this.getYDomain();
    this.transform = `translate(${this.dims.xOffset},${this.margin[0]})`;
    const colorDomain = this.schemeType === ScaleType.Ordinal ? this.seriesDomain : this.rDomain;
    this.colors = new ColorHelper(this.scheme, this.schemeType, colorDomain, this.customColors);
    this.data = this.results;
    this.minRadius = Math.max(this.minRadius, 1);
    this.maxRadius = Math.max(this.maxRadius, 1);
    this.rScale = this.getRScale(this.rDomain, [this.minRadius, this.maxRadius]);
    this.bubblePadding = [0, 0, 0, 0];
    this.setScales();
    this.bubblePadding = this.getBubblePadding();
    this.setScales();
    this.legendOptions = this.getLegendOptions();
    this.clipPathId = "clip" + id2().toString();
    this.clipPath = `url(#${this.clipPathId})`;
  }
  hideCircles() {
    this.deactivateAll();
  }
  onClick(data, series) {
    if (series) {
      data.series = series.name;
    }
    this.select.emit(data);
  }
  getBubblePadding() {
    let yMin = 0;
    let xMin = 0;
    let yMax = this.dims.height;
    let xMax = this.dims.width;
    for (const s2 of this.data) {
      for (const d of s2.series) {
        const r2 = this.rScale(d.r);
        const cx = this.xScaleType === ScaleType.Linear ? this.xScale(Number(d.x)) : this.xScale(d.x);
        const cy = this.yScaleType === ScaleType.Linear ? this.yScale(Number(d.y)) : this.yScale(d.y);
        xMin = Math.max(r2 - cx, xMin);
        yMin = Math.max(r2 - cy, yMin);
        yMax = Math.max(cy + r2, yMax);
        xMax = Math.max(cx + r2, xMax);
      }
    }
    xMax = Math.max(xMax - this.dims.width, 0);
    yMax = Math.max(yMax - this.dims.height, 0);
    return [yMin, xMax, yMax, xMin];
  }
  setScales() {
    let width = this.dims.width;
    if (this.xScaleMin === void 0 && this.xScaleMax === void 0) {
      width = width - this.bubblePadding[1];
    }
    let height = this.dims.height;
    if (this.yScaleMin === void 0 && this.yScaleMax === void 0) {
      height = height - this.bubblePadding[2];
    }
    this.xScale = this.getXScale(this.xDomain, width);
    this.yScale = this.getYScale(this.yDomain, height);
  }
  getYScale(domain, height) {
    return getScale2(domain, [height, this.bubblePadding[0]], this.yScaleType, this.roundDomains);
  }
  getXScale(domain, width) {
    return getScale2(domain, [this.bubblePadding[3], width], this.xScaleType, this.roundDomains);
  }
  getRScale(domain, range2) {
    const scale = linear2().range(range2).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      position: this.legendPosition,
      title: void 0
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.seriesDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.rDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  getXDomain() {
    const values = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (!values.includes(d.x)) {
          values.push(d.x);
        }
      }
    }
    this.xScaleType = getScaleType(values);
    return getDomain(values, this.xScaleType, this.autoScale, this.xScaleMin, this.xScaleMax);
  }
  getYDomain() {
    const values = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (!values.includes(d.y)) {
          values.push(d.y);
        }
      }
    }
    this.yScaleType = getScaleType(values);
    return getDomain(values, this.yScaleType, this.autoScale, this.yScaleMin, this.yScaleMax);
  }
  getRDomain() {
    let min6 = Infinity;
    let max6 = -Infinity;
    for (const results of this.results) {
      for (const d of results.series) {
        const value2 = Number(d.r) || 1;
        min6 = Math.min(min6, value2);
        max6 = Math.max(max6, value2);
      }
    }
    return [min6, max6];
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
  trackBy(index, item) {
    return `${item.name}`;
  }
};
_BubbleChartComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275BubbleChartComponent_BaseFactory;
  return function BubbleChartComponent_Factory(__ngFactoryType__) {
    return (\u0275BubbleChartComponent_BaseFactory || (\u0275BubbleChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_BubbleChartComponent)))(__ngFactoryType__ || _BubbleChartComponent);
  };
})();
_BubbleChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _BubbleChartComponent,
  selectors: [["ngx-charts-bubble-chart"]],
  contentQueries: function BubbleChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  hostBindings: function BubbleChartComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseleave", function BubbleChartComponent_mouseleave_HostBindingHandler() {
        return ctx.hideCircles();
      });
    }
  },
  inputs: {
    showGridLines: "showGridLines",
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    roundDomains: "roundDomains",
    maxRadius: "maxRadius",
    minRadius: "minRadius",
    autoScale: "autoScale",
    schemeType: "schemeType",
    tooltipDisabled: "tooltipDisabled",
    xScaleMin: "xScaleMin",
    xScaleMax: "xScaleMax",
    yScaleMin: "yScaleMin",
    yScaleMax: "yScaleMax",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 10,
  vars: 19,
  consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "activeEntries", "legendOptions", "animations"], [1, "bubble-chart", "chart"], ["ngx-charts-x-axis", "", 3, "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["x", "0", "y", "0", 1, "bubble-chart-area", 2, "fill", "rgb(255, 0, 0)", "opacity", "0", "cursor", "'auto'", 3, "mouseenter"], [4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "showGridLines", "dims", "xScale", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "showGridLines", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-bubble-series", "", 3, "select", "activate", "deactivate", "xScale", "yScale", "rScale", "xScaleType", "yScaleType", "xAxisLabel", "yAxisLabel", "colors", "data", "activeEntries", "tooltipDisabled", "tooltipTemplate"]],
  template: function BubbleChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelClick", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      })("legendLabelActivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event);
      })("legendLabelDeactivate", function BubbleChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "defs")(2, "clipPath");
      \u0275\u0275element(3, "rect");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(4, "g", 1);
      \u0275\u0275template(5, BubbleChartComponent__svg_g_5_Template, 1, 11, "g", 2)(6, BubbleChartComponent__svg_g_6_Template, 1, 10, "g", 3);
      \u0275\u0275elementStart(7, "rect", 4);
      \u0275\u0275listener("mouseenter", function BubbleChartComponent_Template_rect_mouseenter_7_listener() {
        return ctx.deactivateAll();
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(8, BubbleChartComponent__svg_g_8_Template, 2, 3, "g", 5)(9, BubbleChartComponent__svg_g_9_Template, 2, 3, "g", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(16, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("activeEntries", ctx.activeEntries)("legendOptions", ctx.legendOptions)("animations", ctx.animations);
      \u0275\u0275advance(2);
      \u0275\u0275attribute("id", ctx.clipPathId);
      \u0275\u0275advance();
      \u0275\u0275attribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275attribute("width", ctx.dims.width)("height", ctx.dims.height);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, BubbleSeriesComponent],
  styles: [_c25],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1
    }), animate(500, style({
      opacity: 0
    }))])])]
  },
  changeDetection: 0
});
var BubbleChartComponent = _BubbleChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BubbleChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-bubble-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [activeEntries]="activeEntries"
      [legendOptions]="legendOptions"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:defs>
        <svg:clipPath [attr.id]="clipPathId">
          <svg:rect
            [attr.width]="dims.width + 10"
            [attr.height]="dims.height + 10"
            [attr.transform]="'translate(-5, -5)'"
          />
        </svg:clipPath>
      </svg:defs>
      <svg:g [attr.transform]="transform" class="bubble-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [showGridLines]="showGridLines"
          [dims]="dims"
          [xScale]="xScale"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        />
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [showGridLines]="showGridLines"
          [yScale]="yScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        />
        <svg:rect
          class="bubble-chart-area"
          x="0"
          y="0"
          [attr.width]="dims.width"
          [attr.height]="dims.height"
          style="fill: rgb(255, 0, 0); opacity: 0; cursor: 'auto';"
          (mouseenter)="deactivateAll()"
        />
        <svg:g *ngIf="!isSSR" [attr.clip-path]="clipPath">
          <svg:g *ngFor="let series of data; trackBy: trackBy" [@animationState]="'active'">
            <svg:g
              ngx-charts-bubble-series
              [xScale]="xScale"
              [yScale]="yScale"
              [rScale]="rScale"
              [xScaleType]="xScaleType"
              [yScaleType]="yScaleType"
              [xAxisLabel]="xAxisLabel"
              [yAxisLabel]="yAxisLabel"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              (select)="onClick($event, series)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
            />
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR" [attr.clip-path]="clipPath">
          <svg:g *ngFor="let series of data; trackBy: trackBy">
            <svg:g
              ngx-charts-bubble-series
              [xScale]="xScale"
              [yScale]="yScale"
              [rScale]="rScale"
              [xScaleType]="xScaleType"
              [yScaleType]="yScaleType"
              [xAxisLabel]="xAxisLabel"
              [yAxisLabel]="yAxisLabel"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              (select)="onClick($event, series)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    showGridLines: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    maxRadius: [{
      type: Input
    }],
    minRadius: [{
      type: Input
    }],
    autoScale: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    xScaleMin: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    yScaleMin: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    hideCircles: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var _BubbleChartModule = class _BubbleChartModule {
};
_BubbleChartModule.\u0275fac = function BubbleChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BubbleChartModule)();
};
_BubbleChartModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _BubbleChartModule
});
_BubbleChartModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule]
});
var BubbleChartModule = _BubbleChartModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BubbleChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [BubbleChartComponent, BubbleSeriesComponent],
      exports: [BubbleChartComponent, BubbleSeriesComponent]
    }]
  }], null, null);
})();
var _HeatMapCellComponent = class _HeatMapCellComponent {
  constructor(element) {
    this.gradient = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.barOrientation = BarOrientation;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.transform = `translate(${this.x} , ${this.y})`;
    this.startOpacity = 0.3;
    this.gradientId = "grad" + id2().toString();
    this.gradientUrl = `url(#${this.gradientId})`;
    this.gradientStops = this.getGradientStops();
    if (this.animations) {
      this.loadAnimation();
    }
  }
  getGradientStops() {
    return [{
      offset: 0,
      color: this.fill,
      opacity: this.startOpacity
    }, {
      offset: 100,
      color: this.fill,
      opacity: 1
    }];
  }
  loadAnimation() {
    const node = select_default2(this.element).select(".cell");
    node.attr("opacity", 0);
    this.animateToCurrentForm();
  }
  animateToCurrentForm() {
    const node = select_default2(this.element).select(".cell");
    node.transition().duration(750).attr("opacity", 1);
  }
  onClick() {
    this.select.emit(this.data);
  }
  onMouseEnter() {
    this.activate.emit(this.data);
  }
  onMouseLeave() {
    this.deactivate.emit(this.data);
  }
};
_HeatMapCellComponent.\u0275fac = function HeatMapCellComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _HeatMapCellComponent)(\u0275\u0275directiveInject(ElementRef));
};
_HeatMapCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _HeatMapCellComponent,
  selectors: [["g", "ngx-charts-heat-map-cell", ""]],
  hostBindings: function HeatMapCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseenter", function HeatMapCellComponent_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function HeatMapCellComponent_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      });
    }
  },
  inputs: {
    fill: "fill",
    x: "x",
    y: "y",
    width: "width",
    height: "height",
    data: "data",
    gradient: "gradient",
    animations: "animations"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c332,
  decls: 3,
  vars: 5,
  consts: [[1, "cell"], [4, "ngIf"], ["rx", "3", 1, "cell", 3, "click"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"]],
  template: function HeatMapCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g", 0);
      \u0275\u0275template(1, HeatMapCellComponent__svg_defs_1_Template, 2, 3, "defs", 1);
      \u0275\u0275elementStart(2, "rect", 2);
      \u0275\u0275listener("click", function HeatMapCellComponent_Template_rect_click_2_listener() {
        return ctx.onClick();
      });
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.gradient);
      \u0275\u0275advance();
      \u0275\u0275attribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height);
    }
  },
  dependencies: [NgIf, SvgLinearGradientComponent],
  encapsulation: 2,
  changeDetection: 0
});
var HeatMapCellComponent = _HeatMapCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeatMapCellComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-heat-map-cell]",
      template: `
    <svg:g [attr.transform]="transform" class="cell">
      <defs *ngIf="gradient">
        <svg:g
          ngx-charts-svg-linear-gradient
          [orientation]="barOrientation.Vertical"
          [name]="gradientId"
          [stops]="gradientStops"
        />
      </defs>
      <svg:rect
        [attr.fill]="gradient ? gradientUrl : fill"
        rx="3"
        [attr.width]="width"
        [attr.height]="height"
        class="cell"
        (click)="onClick()"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    fill: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var _HeatCellSeriesComponent = class _HeatCellSeriesComponent {
  constructor() {
    this.tooltipDisabled = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
  }
  ngOnInit() {
    if (!this.tooltipText) {
      this.tooltipText = this.getTooltipText;
    }
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.cells = this.getCells();
  }
  getCells() {
    const cells = [];
    this.data.map((row) => {
      row.series.map((cell) => {
        const value2 = cell.value;
        cell.series = row.name;
        cells.push({
          row,
          cell,
          x: this.xScale(row.name),
          y: this.yScale(cell.name),
          width: this.xScale.bandwidth(),
          height: this.yScale.bandwidth(),
          fill: this.colors.getColor(value2),
          data: value2,
          label: formatLabel(cell.name),
          series: row.name
        });
      });
    });
    return cells;
  }
  getTooltipText({
    label,
    data,
    series
  }) {
    return `
      <span class="tooltip-label">${escapeLabel(series)} \u2022 ${escapeLabel(label)}</span>
      <span class="tooltip-val">${data.toLocaleString()}</span>
    `;
  }
  trackBy(index, item) {
    return item.label;
  }
  onClick(data) {
    this.select.emit(data);
  }
};
_HeatCellSeriesComponent.\u0275fac = function HeatCellSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _HeatCellSeriesComponent)();
};
_HeatCellSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _HeatCellSeriesComponent,
  selectors: [["g", "ngx-charts-heat-map-cell-series", ""]],
  inputs: {
    data: "data",
    colors: "colors",
    xScale: "xScale",
    yScale: "yScale",
    gradient: "gradient",
    tooltipDisabled: "tooltipDisabled",
    tooltipText: "tooltipText",
    tooltipTemplate: "tooltipTemplate",
    animations: "animations"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c34,
  decls: 1,
  vars: 2,
  consts: [["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-heat-map-cell", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "x", "y", "width", "height", "fill", "data", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"]],
  template: function HeatCellSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, HeatCellSeriesComponent__svg_g_0_Template, 1, 18, "g", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
    }
  },
  dependencies: [NgForOf, TooltipDirective, HeatMapCellComponent],
  encapsulation: 2,
  changeDetection: 0
});
var HeatCellSeriesComponent = _HeatCellSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeatCellSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-heat-map-cell-series]",
      template: `
    <svg:g
      ngx-charts-heat-map-cell
      *ngFor="let c of cells; trackBy: trackBy"
      [x]="c.x"
      [y]="c.y"
      [width]="c.width"
      [height]="c.height"
      [fill]="c.fill"
      [data]="c.data"
      (select)="onClick(c.cell)"
      (activate)="activate.emit(c.cell)"
      (deactivate)="deactivate.emit(c.cell)"
      [gradient]="gradient"
      [animations]="animations"
      ngx-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="placementTypes.Top"
      [tooltipType]="styleTypes.tooltip"
      [tooltipTitle]="tooltipTemplate ? undefined : tooltipText(c)"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="{ series: c.series, name: c.label, value: c.data }"
    ></svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var _HeatMapComponent = class _HeatMapComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.innerPadding = 8;
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.tooltipDisabled = false;
    this.activeEntries = [];
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.scaleType = ScaleType.Linear;
  }
  update() {
    super.update();
    this.formatDates();
    this.xDomain = this.getXDomain();
    this.yDomain = this.getYDomain();
    this.valueDomain = this.getValueDomain();
    this.scaleType = getScaleType(this.valueDomain, false);
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.scaleType,
      legendPosition: this.legendPosition
    });
    if (this.scaleType === ScaleType.Linear) {
      let min6 = this.min;
      let max6 = this.max;
      if (!this.min) {
        min6 = Math.min(0, ...this.valueDomain);
      }
      if (!this.max) {
        max6 = Math.max(...this.valueDomain);
      }
      this.valueDomain = [min6, max6];
    }
    this.xScale = this.getXScale();
    this.yScale = this.getYScale();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    this.rects = this.getRects();
  }
  getXDomain() {
    const domain = [];
    for (const group of this.results) {
      if (!domain.includes(group.name)) {
        domain.push(group.name);
      }
    }
    return domain;
  }
  getYDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.name)) {
          domain.push(d.name);
        }
      }
    }
    return domain;
  }
  getValueDomain() {
    const domain = [];
    for (const group of this.results) {
      for (const d of group.series) {
        if (!domain.includes(d.value)) {
          domain.push(d.value);
        }
      }
    }
    return domain;
  }
  /**
   * Converts the input to gap paddingInner in fraction
   * Supports the following inputs:
   *    Numbers: 8
   *    Strings: "8", "8px", "8%"
   *    Arrays: [8,2], "8,2", "[8,2]"
   *    Mixed: [8,"2%"], ["8px","2%"], "8,2%", "[8,2%]"
   *
   * @memberOf HeatMapComponent
   */
  getDimension(value2, index = 0, N, L2) {
    if (typeof value2 === "string") {
      value2 = value2.replace("[", "").replace("]", "").replace("px", "").replace("'", "");
      if (value2.includes(",")) {
        value2 = value2.split(",");
      }
    }
    if (Array.isArray(value2) && typeof index === "number") {
      return this.getDimension(value2[index], null, N, L2);
    }
    if (typeof value2 === "string" && value2.includes("%")) {
      return +value2.replace("%", "") / 100;
    }
    return N / (L2 / +value2 + 1);
  }
  getXScale() {
    const f = this.getDimension(this.innerPadding, 0, this.xDomain.length, this.dims.width);
    return band().rangeRound([0, this.dims.width]).domain(this.xDomain).paddingInner(f);
  }
  getYScale() {
    const f = this.getDimension(this.innerPadding, 1, this.yDomain.length, this.dims.height);
    return band().rangeRound([this.dims.height, 0]).domain(this.yDomain).paddingInner(f);
  }
  getRects() {
    const rects = [];
    this.xDomain.map((xVal) => {
      this.yDomain.map((yVal) => {
        rects.push({
          x: this.xScale(xVal),
          y: this.yScale(yVal),
          rx: 3,
          width: this.xScale.bandwidth(),
          height: this.yScale.bandwidth(),
          fill: "rgba(200,200,200,0.03)"
        });
      });
    });
    return rects;
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, this.scaleType, this.valueDomain);
  }
  getLegendOptions() {
    return {
      scaleType: this.scaleType,
      domain: this.valueDomain,
      colors: this.scaleType === ScaleType.Ordinal ? this.colors : this.colors.scale,
      title: this.scaleType === ScaleType.Ordinal ? this.legendTitle : void 0,
      position: this.legendPosition
    };
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    const items = this.results.map((g2) => g2.series).flat().filter((i) => {
      if (fromLegend) {
        return i.label === item.name;
      } else {
        return i.name === item.name && i.series === item.series;
      }
    });
    this.activeEntries = [...items];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(event, group, fromLegend = false) {
    const item = Object.assign({}, event);
    if (group) {
      item.series = group.name;
    }
    this.activeEntries = this.activeEntries.filter((i) => {
      if (fromLegend) {
        return i.label !== item.name;
      } else {
        return !(i.name === item.name && i.series === item.series);
      }
    });
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_HeatMapComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275HeatMapComponent_BaseFactory;
  return function HeatMapComponent_Factory(__ngFactoryType__) {
    return (\u0275HeatMapComponent_BaseFactory || (\u0275HeatMapComponent_BaseFactory = \u0275\u0275getInheritedFactory(_HeatMapComponent)))(__ngFactoryType__ || _HeatMapComponent);
  };
})();
_HeatMapComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _HeatMapComponent,
  selectors: [["ngx-charts-heat-map"]],
  contentQueries: function HeatMapComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    gradient: "gradient",
    innerPadding: "innerPadding",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    tooltipDisabled: "tooltipDisabled",
    tooltipText: "tooltipText",
    min: "min",
    max: "max",
    activeEntries: "activeEntries",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 6,
  vars: 20,
  consts: [[3, "legendLabelClick", "view", "showLegend", "animations", "legendOptions"], [1, "heat-map", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngFor", "ngForOf"], ["ngx-charts-heat-map-cell-series", "", 3, "select", "activate", "deactivate", "xScale", "yScale", "colors", "data", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"]],
  template: function HeatMapComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelClick", function HeatMapComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275template(2, HeatMapComponent__svg_g_2_Template, 1, 10, "g", 2)(3, HeatMapComponent__svg_g_3_Template, 1, 9, "g", 3)(4, HeatMapComponent__svg_rect_4_Template, 1, 6, "rect", 4);
      \u0275\u0275elementStart(5, "g", 5);
      \u0275\u0275listener("select", function HeatMapComponent_Template_g_select_5_listener($event) {
        return ctx.onClick($event);
      })("activate", function HeatMapComponent_Template_g_activate_5_listener($event) {
        return ctx.onActivate($event, void 0);
      })("deactivate", function HeatMapComponent_Template_g_deactivate_5_listener($event) {
        return ctx.onDeactivate($event, void 0);
      });
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("animations", ctx.animations)("legendOptions", ctx.legendOptions);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.rects);
      \u0275\u0275advance();
      \u0275\u0275property("xScale", ctx.xScale)("yScale", ctx.yScale)("colors", ctx.colors)("data", ctx.results)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, ChartComponent, HeatCellSeriesComponent],
  styles: [_c25],
  encapsulation: 2,
  changeDetection: 0
});
var HeatMapComponent = _HeatMapComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeatMapComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-heat-map",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [animations]="animations"
      [legendOptions]="legendOptions"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="transform" class="heat-map chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:rect
          *ngFor="let rect of rects"
          [attr.x]="rect.x"
          [attr.y]="rect.y"
          [attr.rx]="rect.rx"
          [attr.width]="rect.width"
          [attr.height]="rect.height"
          [attr.fill]="rect.fill"
        />
        <svg:g
          ngx-charts-heat-map-cell-series
          [xScale]="xScale"
          [yScale]="yScale"
          [colors]="colors"
          [data]="results"
          [gradient]="gradient"
          [animations]="animations"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipText]="tooltipText"
          (select)="onClick($event)"
          (activate)="onActivate($event, undefined)"
          (deactivate)="onDeactivate($event, undefined)"
        />
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    innerPadding: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _HeatMapModule = class _HeatMapModule {
};
_HeatMapModule.\u0275fac = function HeatMapModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _HeatMapModule)();
};
_HeatMapModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _HeatMapModule
});
_HeatMapModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule]
});
var HeatMapModule = _HeatMapModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeatMapModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [HeatMapCellComponent, HeatCellSeriesComponent, HeatMapComponent],
      exports: [HeatMapCellComponent, HeatCellSeriesComponent, HeatMapComponent]
    }]
  }], null, null);
})();
var _LineComponent = class _LineComponent {
  constructor(element, platformId) {
    this.element = element;
    this.platformId = platformId;
    this.fill = "none";
    this.animations = true;
    this.initialized = false;
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  ngOnChanges(changes) {
    if (!this.initialized) {
      this.initialized = true;
      this.initialPath = this.path;
    } else {
      this.updatePathEl();
    }
  }
  updatePathEl() {
    const node = select_default2(this.element.nativeElement).select(".line");
    if (this.animations) {
      node.transition().duration(750).attr("d", this.path);
    } else {
      node.attr("d", this.path);
    }
  }
};
_LineComponent.\u0275fac = function LineComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _LineComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(PLATFORM_ID));
};
_LineComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LineComponent,
  selectors: [["g", "ngx-charts-line", ""]],
  inputs: {
    path: "path",
    stroke: "stroke",
    data: "data",
    fill: "fill",
    animations: "animations"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c36,
  decls: 2,
  vars: 2,
  consts: [[4, "ngIf"], ["stroke-width", "1.5px", 1, "line"]],
  template: function LineComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, LineComponent__svg_g_0_Template, 2, 4, "g", 0)(1, LineComponent__svg_g_1_Template, 2, 3, "g", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":enter", [style({
      strokeDasharray: 2e3,
      strokeDashoffset: 2e3
    }), animate(1e3, style({
      strokeDashoffset: 0
    }))])])]
  },
  changeDetection: 0
});
var LineComponent = _LineComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LineComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-line]",
      template: `
    <svg:g *ngIf="!isSSR">
      <svg:path
        [@animationState]="'active'"
        class="line"
        [attr.d]="initialPath"
        [attr.fill]="fill"
        [attr.stroke]="stroke"
        stroke-width="1.5px"
      />
    </svg:g>
    <svg:g *ngIf="isSSR">
      <svg:path class="line" [attr.d]="initialPath" [attr.fill]="fill" [attr.stroke]="stroke" stroke-width="1.5px" />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":enter", [style({
        strokeDasharray: 2e3,
        strokeDashoffset: 2e3
      }), animate(1e3, style({
        strokeDashoffset: 0
      }))])])]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    path: [{
      type: Input
    }],
    stroke: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    animations: [{
      type: Input
    }]
  });
})();
var _LineSeriesComponent = class _LineSeriesComponent {
  constructor() {
    this.animations = true;
    this.barOrientation = BarOrientation;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.updateGradients();
    const data = this.sortData(this.data.series);
    const lineGen = this.getLineGenerator();
    this.path = lineGen(data) || "";
    const areaGen = this.getAreaGenerator();
    this.areaPath = areaGen(data) || "";
    if (this.hasRange) {
      const range2 = this.getRangeGenerator();
      this.outerPath = range2(data) || "";
    }
    if (this.hasGradient) {
      this.stroke = this.gradientUrl;
      const values = this.data.series.map((d) => d.value);
      const max6 = Math.max(...values);
      const min6 = Math.min(...values);
      if (max6 === min6) {
        this.stroke = this.colors.getColor(max6);
      }
    } else {
      this.stroke = this.colors.getColor(this.data.name);
    }
  }
  getLineGenerator() {
    return line_default().x((d) => {
      const label = d.name;
      let value2;
      if (this.scaleType === ScaleType.Time) {
        value2 = this.xScale(label);
      } else if (this.scaleType === ScaleType.Linear) {
        value2 = this.xScale(Number(label));
      } else {
        value2 = this.xScale(label);
      }
      return value2;
    }).y((d) => this.yScale(d.value)).curve(this.curve);
  }
  getRangeGenerator() {
    return area_default().x((d) => {
      const label = d.name;
      let value2;
      if (this.scaleType === ScaleType.Time) {
        value2 = this.xScale(label);
      } else if (this.scaleType === ScaleType.Linear) {
        value2 = this.xScale(Number(label));
      } else {
        value2 = this.xScale(label);
      }
      return value2;
    }).y0((d) => this.yScale(typeof d.min === "number" ? d.min : d.value)).y1((d) => this.yScale(typeof d.max === "number" ? d.max : d.value)).curve(this.curve);
  }
  getAreaGenerator() {
    const xProperty = (d) => {
      const label = d.name;
      return this.xScale(label);
    };
    return area_default().x(xProperty).y0(() => this.yScale.range()[0]).y1((d) => this.yScale(d.value)).curve(this.curve);
  }
  sortData(data) {
    if (this.scaleType === ScaleType.Linear) {
      data = sortLinear(data, "name");
    } else if (this.scaleType === ScaleType.Time) {
      data = sortByTime(data, "name");
    } else {
      data = sortByDomain(data, "name", "asc", this.xScale.domain());
    }
    return data;
  }
  updateGradients() {
    if (this.colors.scaleType === ScaleType.Linear) {
      this.hasGradient = true;
      this.gradientId = "grad" + id2().toString();
      this.gradientUrl = `url(#${this.gradientId})`;
      const values = this.data.series.map((d) => d.value);
      const max6 = Math.max(...values);
      const min6 = Math.min(...values);
      this.gradientStops = this.colors.getLinearGradientStops(max6, min6);
      this.areaGradientStops = this.colors.getLinearGradientStops(max6);
    } else {
      this.hasGradient = false;
      this.gradientStops = void 0;
      this.areaGradientStops = void 0;
    }
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item !== void 0;
  }
  isInactive(entry) {
    if (!this.activeEntries || this.activeEntries.length === 0) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item === void 0;
  }
};
_LineSeriesComponent.\u0275fac = function LineSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _LineSeriesComponent)();
};
_LineSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LineSeriesComponent,
  selectors: [["g", "ngx-charts-line-series", ""]],
  inputs: {
    data: "data",
    xScale: "xScale",
    yScale: "yScale",
    colors: "colors",
    scaleType: "scaleType",
    curve: "curve",
    activeEntries: "activeEntries",
    rangeFillOpacity: "rangeFillOpacity",
    hasRange: "hasRange",
    animations: "animations"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c37,
  decls: 6,
  vars: 22,
  consts: [["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops", 4, "ngIf"], ["ngx-charts-area", "", 1, "line-highlight", 3, "data", "path", "fill", "opacity", "startOpacity", "gradient", "stops", "animations"], ["ngx-charts-line", "", 1, "line-series", 3, "data", "path", "stroke", "animations"], ["ngx-charts-area", "", "class", "line-series-range", 3, "data", "path", "fill", "active", "inactive", "opacity", "animations", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"], ["ngx-charts-area", "", 1, "line-series-range", 3, "data", "path", "fill", "opacity", "animations"]],
  template: function LineSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g")(1, "defs");
      \u0275\u0275template(2, LineSeriesComponent__svg_g_2_Template, 1, 3, "g", 0);
      \u0275\u0275elementEnd();
      \u0275\u0275element(3, "g", 1)(4, "g", 2);
      \u0275\u0275template(5, LineSeriesComponent__svg_g_5_Template, 1, 9, "g", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.hasGradient);
      \u0275\u0275advance();
      \u0275\u0275classProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
      \u0275\u0275property("data", ctx.data)("path", ctx.areaPath)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.colors.getColor(ctx.data.name))("opacity", 0.25)("startOpacity", 0)("gradient", true)("stops", ctx.areaGradientStops)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275classProp("active", ctx.isActive(ctx.data))("inactive", ctx.isInactive(ctx.data));
      \u0275\u0275property("data", ctx.data)("path", ctx.path)("stroke", ctx.stroke)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.hasRange);
    }
  },
  dependencies: [NgIf, AreaComponent, SvgLinearGradientComponent, LineComponent],
  encapsulation: 2,
  changeDetection: 0
});
var LineSeriesComponent = _LineSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LineSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-line-series]",
      template: `
    <svg:g>
      <defs>
        <svg:g
          ngx-charts-svg-linear-gradient
          *ngIf="hasGradient"
          [orientation]="barOrientation.Vertical"
          [name]="gradientId"
          [stops]="gradientStops"
        />
      </defs>
      <svg:g
        ngx-charts-area
        class="line-highlight"
        [data]="data"
        [path]="areaPath"
        [fill]="hasGradient ? gradientUrl : colors.getColor(data.name)"
        [opacity]="0.25"
        [startOpacity]="0"
        [gradient]="true"
        [stops]="areaGradientStops"
        [class.active]="isActive(data)"
        [class.inactive]="isInactive(data)"
        [animations]="animations"
      />
      <svg:g
        ngx-charts-line
        class="line-series"
        [data]="data"
        [path]="path"
        [stroke]="stroke"
        [animations]="animations"
        [class.active]="isActive(data)"
        [class.inactive]="isInactive(data)"
      />
      <svg:g
        ngx-charts-area
        *ngIf="hasRange"
        class="line-series-range"
        [data]="data"
        [path]="outerPath"
        [fill]="hasGradient ? gradientUrl : colors.getColor(data.name)"
        [class.active]="isActive(data)"
        [class.inactive]="isInactive(data)"
        [opacity]="rangeFillOpacity"
        [animations]="animations"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    rangeFillOpacity: [{
      type: Input
    }],
    hasRange: [{
      type: Input
    }],
    animations: [{
      type: Input
    }]
  });
})();
var _LineChartComponent = class _LineChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.showGridLines = true;
    this.curve = linear_default;
    this.activeEntries = [];
    this.trimXAxisTicks = true;
    this.trimYAxisTicks = true;
    this.rotateXAxisTicks = true;
    this.maxXAxisTickLength = 16;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.tooltipDisabled = false;
    this.showRefLines = false;
    this.showRefLabels = true;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.timelineHeight = 50;
    this.timelinePadding = 10;
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    if (this.timeline) {
      this.dims.height -= this.timelineHeight + this.margin[2] + this.timelinePadding;
    }
    this.xDomain = this.getXDomain();
    if (this.filteredDomain) {
      this.xDomain = this.filteredDomain;
    }
    this.yDomain = this.getYDomain();
    this.seriesDomain = this.getSeriesDomain();
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
    this.yScale = this.getYScale(this.yDomain, this.dims.height);
    this.updateTimeline();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    this.clipPathId = "clip" + id2().toString();
    this.clipPath = `url(#${this.clipPathId})`;
  }
  updateTimeline() {
    if (this.timeline) {
      this.timelineWidth = this.dims.width;
      this.timelineXDomain = this.getXDomain();
      this.timelineXScale = this.getXScale(this.timelineXDomain, this.timelineWidth);
      this.timelineYScale = this.getYScale(this.yDomain, this.timelineHeight);
      this.timelineTransform = `translate(${this.dims.xOffset}, ${-this.margin[2]})`;
    }
  }
  getXDomain() {
    let values = getUniqueXDomainValues(this.results);
    this.scaleType = getScaleType(values);
    let domain = [];
    if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
    }
    let min6;
    let max6;
    if (this.scaleType === ScaleType.Time || this.scaleType === ScaleType.Linear) {
      min6 = this.xScaleMin ? this.xScaleMin : Math.min(...values);
      max6 = this.xScaleMax ? this.xScaleMax : Math.max(...values);
    }
    if (this.scaleType === ScaleType.Time) {
      domain = [new Date(min6), new Date(max6)];
      this.xSet = [...values].sort((a, b) => {
        const aDate = a.getTime();
        const bDate = b.getTime();
        if (aDate > bDate) return 1;
        if (bDate > aDate) return -1;
        return 0;
      });
    } else if (this.scaleType === ScaleType.Linear) {
      domain = [min6, max6];
      this.xSet = [...values].sort((a, b) => a - b);
    } else {
      domain = values;
      this.xSet = values;
    }
    return domain;
  }
  getYDomain() {
    const domain = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (domain.indexOf(d.value) < 0) {
          domain.push(d.value);
        }
        if (d.min !== void 0) {
          this.hasRange = true;
          if (domain.indexOf(d.min) < 0) {
            domain.push(d.min);
          }
        }
        if (d.max !== void 0) {
          this.hasRange = true;
          if (domain.indexOf(d.max) < 0) {
            domain.push(d.max);
          }
        }
      }
    }
    const values = [...domain];
    if (!this.autoScale) {
      values.push(0);
    }
    const min6 = this.yScaleMin ? this.yScaleMin : Math.min(...values);
    const max6 = this.yScaleMax ? this.yScaleMax : Math.max(...values);
    return [min6, max6];
  }
  getSeriesDomain() {
    return this.results.map((d) => d.name);
  }
  getXScale(domain, width) {
    let scale;
    if (this.scaleType === ScaleType.Time) {
      scale = time().range([0, width]).domain(domain);
    } else if (this.scaleType === ScaleType.Linear) {
      scale = linear2().range([0, width]).domain(domain);
      if (this.roundDomains) {
        scale = scale.nice();
      }
    } else if (this.scaleType === ScaleType.Ordinal) {
      scale = point().range([0, width]).padding(0.1).domain(domain);
    }
    return scale;
  }
  getYScale(domain, height) {
    const scale = linear2().range([height, 0]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  updateDomain(domain) {
    this.filteredDomain = domain;
    this.xDomain = this.filteredDomain;
    this.xScale = this.getXScale(this.xDomain, this.dims.width);
  }
  updateHoveredVertical(item) {
    this.hoveredVertical = item.value;
    this.deactivateAll();
  }
  hideCircles() {
    this.hoveredVertical = null;
    this.deactivateAll();
  }
  onClick(data) {
    this.select.emit(data);
  }
  trackBy(index, item) {
    return `${item.name}`;
  }
  setColors() {
    let domain;
    if (this.schemeType === ScaleType.Ordinal) {
      domain = this.seriesDomain;
    } else {
      domain = this.yDomain;
    }
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    const opts = {
      scaleType: this.schemeType,
      colors: void 0,
      domain: [],
      title: void 0,
      position: this.legendPosition
    };
    if (opts.scaleType === ScaleType.Ordinal) {
      opts.domain = this.seriesDomain;
      opts.colors = this.colors;
      opts.title = this.legendTitle;
    } else {
      opts.domain = this.yDomain;
      opts.colors = this.colors.scale;
    }
    return opts;
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    this.deactivateAll();
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
};
_LineChartComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275LineChartComponent_BaseFactory;
  return function LineChartComponent_Factory(__ngFactoryType__) {
    return (\u0275LineChartComponent_BaseFactory || (\u0275LineChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_LineChartComponent)))(__ngFactoryType__ || _LineChartComponent);
  };
})();
_LineChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LineChartComponent,
  selectors: [["ngx-charts-line-chart"]],
  contentQueries: function LineChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
      \u0275\u0275contentQuery(dirIndex, _c232, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    }
  },
  hostBindings: function LineChartComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("mouseleave", function LineChartComponent_mouseleave_HostBindingHandler() {
        return ctx.hideCircles();
      });
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    autoScale: "autoScale",
    timeline: "timeline",
    gradient: "gradient",
    showGridLines: "showGridLines",
    curve: "curve",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    rangeFillOpacity: "rangeFillOpacity",
    trimXAxisTicks: "trimXAxisTicks",
    trimYAxisTicks: "trimYAxisTicks",
    rotateXAxisTicks: "rotateXAxisTicks",
    maxXAxisTickLength: "maxXAxisTickLength",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    xAxisTicks: "xAxisTicks",
    yAxisTicks: "yAxisTicks",
    roundDomains: "roundDomains",
    tooltipDisabled: "tooltipDisabled",
    showRefLines: "showRefLines",
    referenceLines: "referenceLines",
    showRefLabels: "showRefLabels",
    xScaleMin: "xScaleMin",
    xScaleMax: "xScaleMax",
    yScaleMin: "yScaleMin",
    yScaleMax: "yScaleMax",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 12,
  vars: 20,
  consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "line-chart", "chart"], ["ngx-charts-x-axis", "", 3, "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "wrapTicks", "dimensionsChanged", 4, "ngIf"], [4, "ngIf"], [3, "mouseleave", 4, "ngIf"], ["ngx-charts-timeline", "", 3, "results", "view", "height", "scheme", "customColors", "scaleType", "legend", "onDomainChange", 4, "ngIf"], ["ngx-charts-x-axis", "", 3, "dimensionsChanged", "xScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "rotateTicks", "maxTickLength", "tickFormatting", "ticks", "wrapTicks"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "referenceLines", "showRefLines", "showRefLabels", "wrapTicks"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "hasRange", "animations"], [3, "mouseleave"], ["ngx-charts-tooltip-area", "", 3, "hover", "dims", "xSet", "xScale", "yScale", "results", "colors", "tooltipDisabled", "tooltipTemplate"], [4, "ngFor", "ngForOf"], ["ngx-charts-circle-series", "", 3, "select", "activate", "deactivate", "xScale", "yScale", "colors", "data", "scaleType", "visibleValue", "activeEntries", "tooltipDisabled", "tooltipTemplate"], ["ngx-charts-timeline", "", 3, "onDomainChange", "results", "view", "height", "scheme", "customColors", "scaleType", "legend"], ["ngx-charts-line-series", "", 3, "xScale", "yScale", "colors", "data", "scaleType", "curve", "hasRange", "animations"]],
  template: function LineChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelClick", function LineChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      })("legendLabelActivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event);
      })("legendLabelDeactivate", function LineChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "defs")(2, "clipPath");
      \u0275\u0275element(3, "rect");
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(4, "g", 1);
      \u0275\u0275template(5, LineChartComponent__svg_g_5_Template, 1, 11, "g", 2)(6, LineChartComponent__svg_g_6_Template, 1, 13, "g", 3);
      \u0275\u0275elementStart(7, "g");
      \u0275\u0275template(8, LineChartComponent__svg_g_8_Template, 2, 2, "g", 4)(9, LineChartComponent__svg_g_9_Template, 2, 2, "g", 4)(10, LineChartComponent__svg_g_10_Template, 3, 9, "g", 5);
      \u0275\u0275elementEnd()();
      \u0275\u0275template(11, LineChartComponent__svg_g_11_Template, 2, 13, "g", 6);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance(2);
      \u0275\u0275attribute("id", ctx.clipPathId);
      \u0275\u0275advance();
      \u0275\u0275attribute("width", ctx.dims.width + 10)("height", ctx.dims.height + 10)("transform", "translate(-5, -5)");
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275attribute("clip-path", ctx.clipPath);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.tooltipDisabled);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.timeline && ctx.scaleType != "ordinal");
    }
  },
  dependencies: [NgForOf, NgIf, XAxisComponent, YAxisComponent, TooltipArea, ChartComponent, CircleSeriesComponent, Timeline, LineSeriesComponent],
  styles: [_c25],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1
    }), animate(500, style({
      opacity: 0
    }))])])]
  },
  changeDetection: 0
});
var LineChartComponent = _LineChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LineChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-line-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:defs>
        <svg:clipPath [attr.id]="clipPathId">
          <svg:rect
            [attr.width]="dims.width + 10"
            [attr.height]="dims.height + 10"
            [attr.transform]="'translate(-5, -5)'"
          />
        </svg:clipPath>
      </svg:defs>
      <svg:g [attr.transform]="transform" class="line-chart chart">
        <svg:g
          ngx-charts-x-axis
          *ngIf="xAxis"
          [xScale]="xScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showXAxisLabel"
          [labelText]="xAxisLabel"
          [trimTicks]="trimXAxisTicks"
          [rotateTicks]="rotateXAxisTicks"
          [maxTickLength]="maxXAxisTickLength"
          [tickFormatting]="xAxisTickFormatting"
          [ticks]="xAxisTicks"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateXAxisHeight($event)"
        ></svg:g>
        <svg:g
          ngx-charts-y-axis
          *ngIf="yAxis"
          [yScale]="yScale"
          [dims]="dims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [ticks]="yAxisTicks"
          [referenceLines]="referenceLines"
          [showRefLines]="showRefLines"
          [showRefLabels]="showRefLabels"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g [attr.clip-path]="clipPath">
          <svg:g *ngIf="!isSSR">
            <svg:g *ngFor="let series of results; trackBy: trackBy" [@animationState]="'active'">
              <svg:g
                ngx-charts-line-series
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [data]="series"
                [activeEntries]="activeEntries"
                [scaleType]="scaleType"
                [curve]="curve"
                [rangeFillOpacity]="rangeFillOpacity"
                [hasRange]="hasRange"
                [animations]="animations"
              />
            </svg:g>
          </svg:g>
          <svg:g *ngIf="isSSR">
            <svg:g *ngFor="let series of results; trackBy: trackBy">
              <svg:g
                ngx-charts-line-series
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [data]="series"
                [activeEntries]="activeEntries"
                [scaleType]="scaleType"
                [curve]="curve"
                [rangeFillOpacity]="rangeFillOpacity"
                [hasRange]="hasRange"
                [animations]="animations"
              />
            </svg:g>
          </svg:g>

          <svg:g *ngIf="!tooltipDisabled" (mouseleave)="hideCircles()">
            <svg:g
              ngx-charts-tooltip-area
              [dims]="dims"
              [xSet]="xSet"
              [xScale]="xScale"
              [yScale]="yScale"
              [results]="results"
              [colors]="colors"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="seriesTooltipTemplate"
              (hover)="updateHoveredVertical($event)"
            />

            <svg:g *ngFor="let series of results">
              <svg:g
                ngx-charts-circle-series
                [xScale]="xScale"
                [yScale]="yScale"
                [colors]="colors"
                [data]="series"
                [scaleType]="scaleType"
                [visibleValue]="hoveredVertical"
                [activeEntries]="activeEntries"
                [tooltipDisabled]="tooltipDisabled"
                [tooltipTemplate]="tooltipTemplate"
                (select)="onClick($event)"
                (activate)="onActivate($event)"
                (deactivate)="onDeactivate($event)"
              />
            </svg:g>
          </svg:g>
        </svg:g>
      </svg:g>
      <svg:g
        ngx-charts-timeline
        *ngIf="timeline && scaleType != 'ordinal'"
        [attr.transform]="timelineTransform"
        [results]="results"
        [view]="[timelineWidth, height]"
        [height]="timelineHeight"
        [scheme]="scheme"
        [customColors]="customColors"
        [scaleType]="scaleType"
        [legend]="legend"
        (onDomainChange)="updateDomain($event)"
      >
        <svg:g *ngFor="let series of results; trackBy: trackBy">
          <svg:g
            ngx-charts-line-series
            [xScale]="timelineXScale"
            [yScale]="timelineYScale"
            [colors]="colors"
            [data]="series"
            [scaleType]="scaleType"
            [curve]="curve"
            [hasRange]="hasRange"
            [animations]="animations"
          />
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    autoScale: [{
      type: Input
    }],
    timeline: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    rangeFillOpacity: [{
      type: Input
    }],
    trimXAxisTicks: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    rotateXAxisTicks: [{
      type: Input
    }],
    maxXAxisTickLength: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    xAxisTicks: [{
      type: Input
    }],
    yAxisTicks: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    showRefLines: [{
      type: Input
    }],
    referenceLines: [{
      type: Input
    }],
    showRefLabels: [{
      type: Input
    }],
    xScaleMin: [{
      type: Input
    }],
    xScaleMax: [{
      type: Input
    }],
    yScaleMin: [{
      type: Input
    }],
    yScaleMax: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    seriesTooltipTemplate: [{
      type: ContentChild,
      args: ["seriesTooltipTemplate"]
    }],
    hideCircles: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var _LineChartModule = class _LineChartModule {
};
_LineChartModule.\u0275fac = function LineChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _LineChartModule)();
};
_LineChartModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _LineChartModule
});
_LineChartModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule]
});
var LineChartModule = _LineChartModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LineChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [LineComponent, LineChartComponent, LineSeriesComponent],
      exports: [LineComponent, LineChartComponent, LineSeriesComponent]
    }]
  }], null, null);
})();
var _PieLabelComponent = class _PieLabelComponent {
  constructor(platformId) {
    this.platformId = platformId;
    this.animations = true;
    this.labelTrim = true;
    this.labelTrimSize = 10;
    this.trimLabel = trimLabel;
  }
  ngOnChanges(changes) {
    this.setTransforms();
    this.update();
  }
  setTransforms() {
    if (isPlatformServer(this.platformId)) {
      this.styleTransform = `translate3d(${this.textX}px,${this.textY}px, 0)`;
      this.attrTransform = `translate(${this.textX},${this.textY})`;
      this.textTransition = !this.animations ? null : "transform 0.75s";
    } else {
      const isIE = /(edge|msie|trident)/i.test(navigator.userAgent);
      this.styleTransform = isIE ? null : `translate3d(${this.textX}px,${this.textY}px, 0)`;
      this.attrTransform = !isIE ? null : `translate(${this.textX},${this.textY})`;
      this.textTransition = isIE || !this.animations ? null : "transform 0.75s";
    }
  }
  update() {
    let startRadius = this.radius;
    if (this.explodeSlices) {
      startRadius = this.radius * this.value / this.max;
    }
    const innerArc = arc_default().innerRadius(startRadius).outerRadius(startRadius);
    const innerPos = innerArc.centroid(this.data);
    let scale = this.data.pos[1] / innerPos[1];
    if (this.data.pos[1] === 0 || innerPos[1] === 0) {
      scale = 1;
    }
    const outerPos = [scale * innerPos[0], scale * innerPos[1]];
    this.line = `M${innerPos}L${outerPos}L${this.data.pos}`;
  }
  get textX() {
    return this.data.pos[0];
  }
  get textY() {
    return this.data.pos[1];
  }
  textAnchor() {
    return this.midAngle(this.data) < Math.PI ? TextAnchor.Start : TextAnchor.End;
  }
  midAngle(d) {
    return d.startAngle + (d.endAngle - d.startAngle) / 2;
  }
};
_PieLabelComponent.\u0275fac = function PieLabelComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PieLabelComponent)(\u0275\u0275directiveInject(PLATFORM_ID));
};
_PieLabelComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PieLabelComponent,
  selectors: [["g", "ngx-charts-pie-label", ""]],
  inputs: {
    data: "data",
    radius: "radius",
    label: "label",
    color: "color",
    max: "max",
    value: "value",
    explodeSlices: "explodeSlices",
    animations: "animations",
    labelTrim: "labelTrim",
    labelTrimSize: "labelTrimSize"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c38,
  decls: 6,
  vars: 17,
  consts: [["dy", ".35em", 1, "pie-label"], ["fill", "none", 1, "pie-label-line", "line"]],
  template: function PieLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "title");
      \u0275\u0275text(1);
      \u0275\u0275elementEnd();
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(2, "g")(3, "text", 0);
      \u0275\u0275text(4);
      \u0275\u0275elementEnd()();
      \u0275\u0275element(5, "path", 1);
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275textInterpolate(ctx.label);
      \u0275\u0275advance();
      \u0275\u0275styleProp("transform", ctx.styleTransform)("transition", ctx.textTransition);
      \u0275\u0275attribute("transform", ctx.attrTransform);
      \u0275\u0275advance();
      \u0275\u0275styleProp("text-anchor", ctx.textAnchor())("shape-rendering", "crispEdges");
      \u0275\u0275classProp("animation", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ctx.labelTrim ? ctx.trimLabel(ctx.label, ctx.labelTrimSize) : ctx.label, " ");
      \u0275\u0275advance();
      \u0275\u0275classProp("animation", ctx.animations);
      \u0275\u0275attribute("d", ctx.line)("stroke", ctx.color);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var PieLabelComponent = _PieLabelComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieLabelComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-pie-label]",
      template: `
    <title>{{ label }}</title>
    <svg:g [attr.transform]="attrTransform" [style.transform]="styleTransform" [style.transition]="textTransition">
      <svg:text
        class="pie-label"
        [class.animation]="animations"
        dy=".35em"
        [style.textAnchor]="textAnchor()"
        [style.shapeRendering]="'crispEdges'"
      >
        {{ labelTrim ? trimLabel(label, labelTrimSize) : label }}
      </svg:text>
    </svg:g>
    <svg:path
      [attr.d]="line"
      [attr.stroke]="color"
      fill="none"
      class="pie-label-line line"
      [class.animation]="animations"
    ></svg:path>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    data: [{
      type: Input
    }],
    radius: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    explodeSlices: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    labelTrim: [{
      type: Input
    }],
    labelTrimSize: [{
      type: Input
    }]
  });
})();
var _PolarSeriesComponent = class _PolarSeriesComponent {
  constructor() {
    this.tooltipDisabled = false;
    this.gradient = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.circleRadius = 3;
    this.barOrientation = BarOrientation;
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.updateGradients();
    const line = this.getLineGenerator();
    const data = this.sortData(this.data.series);
    const seriesName = this.data.name;
    const linearScaleType = this.colors.scaleType === ScaleType.Linear;
    const min6 = this.yScale.domain()[0];
    this.seriesColor = this.colors.getColor(linearScaleType ? min6 : seriesName);
    this.path = line(data) || "";
    this.circles = data.map((d) => {
      const a = this.getAngle(d);
      const r2 = this.getRadius(d);
      const value2 = d.value;
      const color2 = this.colors.getColor(linearScaleType ? Math.abs(value2) : seriesName);
      const cData = Object.assign({}, d, {
        series: seriesName,
        value: value2,
        name: d.name
      });
      return {
        data: cData,
        cx: r2 * Math.sin(a),
        cy: -r2 * Math.cos(a),
        value: value2,
        color: color2,
        label: d.name
      };
    });
    this.active = this.isActive(this.data);
    this.inactive = this.isInactive(this.data);
    this.tooltipText = this.tooltipText || ((c) => this.defaultTooltipText(c));
  }
  getAngle(d) {
    const label = d.name;
    if (this.scaleType === ScaleType.Time) {
      return this.xScale(label);
    } else if (this.scaleType === ScaleType.Linear) {
      return this.xScale(Number(label));
    }
    return this.xScale(label);
  }
  getRadius(d) {
    return this.yScale(d.value);
  }
  getLineGenerator() {
    return lineRadial_default().angle((d) => this.getAngle(d)).radius((d) => this.getRadius(d)).curve(this.curve);
  }
  sortData(data) {
    if (this.scaleType === ScaleType.Linear) {
      return sortLinear(data, "name");
    } else if (this.scaleType === ScaleType.Time) {
      return sortByTime(data, "name");
    }
    return sortByDomain(data, "name", "asc", this.xScale.domain());
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item !== void 0;
  }
  isInactive(entry) {
    if (!this.activeEntries || this.activeEntries.length === 0) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name;
    });
    return item === void 0;
  }
  defaultTooltipText({
    label,
    value: value2
  }) {
    return `
      <span class="tooltip-label">${escapeLabel(this.data.name)} \u2022 ${escapeLabel(label)}</span>
      <span class="tooltip-val">${value2.toLocaleString()}</span>
    `;
  }
  updateGradients() {
    this.hasGradient = this.gradient || this.colors.scaleType === ScaleType.Linear;
    if (!this.hasGradient) {
      return;
    }
    this.gradientId = "grad" + id2().toString();
    this.gradientUrl = `url(#${this.gradientId})`;
    if (this.colors.scaleType === ScaleType.Linear) {
      const values = this.data.series.map((d) => d.value);
      const max6 = Math.max(...values);
      const min6 = Math.min(...values);
      this.gradientStops = this.colors.getLinearGradientStops(max6, min6);
    } else {
      this.gradientStops = void 0;
    }
  }
};
_PolarSeriesComponent.\u0275fac = function PolarSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PolarSeriesComponent)();
};
_PolarSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PolarSeriesComponent,
  selectors: [["g", "ngx-charts-polar-series", ""]],
  inputs: {
    name: "name",
    data: "data",
    xScale: "xScale",
    yScale: "yScale",
    colors: "colors",
    scaleType: "scaleType",
    curve: "curve",
    activeEntries: "activeEntries",
    rangeFillOpacity: "rangeFillOpacity",
    tooltipDisabled: "tooltipDisabled",
    tooltipText: "tooltipText",
    gradient: "gradient",
    tooltipTemplate: "tooltipTemplate",
    animations: "animations"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c39,
  decls: 5,
  vars: 11,
  consts: [[1, "polar-charts-series"], ["ngx-charts-svg-radial-gradient", "", 3, "color", "name", "startOpacity", "endOpacity", "stops", 4, "ngIf"], ["ngx-charts-line", "", 1, "polar-series-path", 3, "path", "stroke", "fill", "animations"], ["ngx-charts-circle", "", "class", "circle", "ngx-tooltip", "", 3, "cx", "cy", "r", "fill", "opacity", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", "activate", "deactivate", 4, "ngFor", "ngForOf"], ["ngx-charts-svg-radial-gradient", "", 3, "color", "name", "startOpacity", "endOpacity", "stops"], ["ngx-charts-circle", "", "ngx-tooltip", "", 1, "circle", 3, "select", "activate", "deactivate", "cx", "cy", "r", "fill", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"]],
  template: function PolarSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g", 0)(1, "defs");
      \u0275\u0275template(2, PolarSeriesComponent__svg_g_2_Template, 1, 5, "g", 1);
      \u0275\u0275elementEnd();
      \u0275\u0275element(3, "g", 2);
      \u0275\u0275template(4, PolarSeriesComponent__svg_g_4_Template, 1, 12, "g", 3);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275property("ngIf", ctx.hasGradient);
      \u0275\u0275advance();
      \u0275\u0275classProp("active", ctx.active)("inactive", ctx.inactive);
      \u0275\u0275property("path", ctx.path)("stroke", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("fill", ctx.hasGradient ? ctx.gradientUrl : ctx.seriesColor)("animations", ctx.animations);
      \u0275\u0275attribute("fill-opacity", ctx.rangeFillOpacity);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.circles);
    }
  },
  dependencies: [NgForOf, NgIf, TooltipDirective, CircleComponent, SvgRadialGradientComponent, LineComponent],
  encapsulation: 2,
  changeDetection: 0
});
var PolarSeriesComponent = _PolarSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PolarSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-polar-series]",
      template: `
    <svg:g class="polar-charts-series">
      <defs>
        <svg:g
          ngx-charts-svg-radial-gradient
          *ngIf="hasGradient"
          [color]="seriesColor"
          [name]="gradientId"
          [startOpacity]="0.25"
          [endOpacity]="1"
          [stops]="gradientStops"
        />
      </defs>
      <svg:g
        ngx-charts-line
        class="polar-series-path"
        [path]="path"
        [stroke]="hasGradient ? gradientUrl : seriesColor"
        [class.active]="active"
        [class.inactive]="inactive"
        [attr.fill-opacity]="rangeFillOpacity"
        [fill]="hasGradient ? gradientUrl : seriesColor"
        [animations]="animations"
      />
      <svg:g
        ngx-charts-circle
        *ngFor="let circle of circles"
        class="circle"
        [cx]="circle.cx"
        [cy]="circle.cy"
        [r]="circleRadius"
        [fill]="circle.color"
        [style.opacity]="inactive ? 0.2 : 1"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="placementTypes.Top"
        [tooltipType]="styleTypes.tooltip"
        [tooltipTitle]="tooltipTemplate ? undefined : tooltipText(circle)"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="circle.data"
        (select)="select.emit(circle.data)"
        (activate)="activate.emit({ name: circle.data.series })"
        (deactivate)="deactivate.emit({ name: circle.data.series })"
      ></svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    name: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    xScale: [{
      type: Input
    }],
    yScale: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    scaleType: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    rangeFillOpacity: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var twoPI = 2 * Math.PI;
var _PolarChartComponent = class _PolarChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.showGridLines = true;
    this.curve = cardinalClosed_default;
    this.activeEntries = [];
    this.rangeFillOpacity = 0.15;
    this.trimYAxisTicks = true;
    this.maxYAxisTickLength = 16;
    this.roundDomains = false;
    this.tooltipDisabled = false;
    this.showSeriesOnHover = true;
    this.gradient = false;
    this.yAxisMinScale = 0;
    this.labelTrim = true;
    this.labelTrimSize = 10;
    this.wrapTicks = false;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 20, 10, 20];
    this.xAxisHeight = 0;
    this.yAxisWidth = 0;
    this.orientation = Orientation;
    this.isSSR = false;
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.isSSR = true;
    }
  }
  update() {
    super.update();
    this.setDims();
    this.setScales();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    this.setTicks();
  }
  setDims() {
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showXAxis: this.xAxis,
      showYAxis: this.yAxis,
      xAxisHeight: this.xAxisHeight,
      yAxisWidth: this.yAxisWidth,
      showXLabel: this.showXAxisLabel,
      showYLabel: this.showYAxisLabel,
      showLegend: this.legend,
      legendType: this.schemeType,
      legendPosition: this.legendPosition
    });
    const halfWidth = Math.floor(this.dims.width / 2);
    const halfHeight = Math.floor(this.dims.height / 2);
    const outerRadius = this.outerRadius = Math.min(halfHeight / 1.5, halfWidth / 1.5);
    const yOffset = Math.max(0, halfHeight - outerRadius);
    this.yAxisDims = __spreadProps(__spreadValues({}, this.dims), {
      width: halfWidth
    });
    this.transform = `translate(${this.dims.xOffset}, ${this.margin[0]})`;
    this.transformYAxis = `translate(0, ${yOffset})`;
    this.labelOffset = this.dims.height + 40;
    this.transformPlot = `translate(${halfWidth}, ${halfHeight})`;
  }
  setScales() {
    const xValues = this.getXValues();
    this.scaleType = getScaleType(xValues);
    this.xDomain = this.filteredDomain || this.getXDomain(xValues);
    this.yDomain = this.getYDomain();
    this.seriesDomain = this.getSeriesDomain();
    this.xScale = this.getXScale(this.xDomain, twoPI);
    this.yScale = this.getYScale(this.yDomain, this.outerRadius);
    this.yAxisScale = this.getYScale(this.yDomain.reverse(), this.outerRadius);
  }
  setTicks() {
    let tickFormat2;
    if (this.xAxisTickFormatting) {
      tickFormat2 = this.xAxisTickFormatting;
    } else if (this.xScale.tickFormat) {
      tickFormat2 = this.xScale.tickFormat.apply(this.xScale, [5]);
    } else {
      tickFormat2 = (d) => {
        if (isDate2(d)) {
          return d.toLocaleDateString();
        }
        return d.toLocaleString();
      };
    }
    const outerRadius = this.outerRadius;
    const s2 = 1.1;
    this.thetaTicks = this.xDomain.map((d) => {
      const startAngle = this.xScale(d);
      const dd = s2 * outerRadius * (startAngle > Math.PI ? -1 : 1);
      const label = tickFormat2(d);
      const startPos = [outerRadius * Math.sin(startAngle), -outerRadius * Math.cos(startAngle)];
      const pos = [dd, s2 * startPos[1]];
      return {
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle: startAngle,
        value: outerRadius,
        label,
        startPos,
        pos
      };
    });
    const minDistance = 10;
    for (let i = 0; i < this.thetaTicks.length - 1; i++) {
      const a = this.thetaTicks[i];
      for (let j = i + 1; j < this.thetaTicks.length; j++) {
        const b = this.thetaTicks[j];
        if (b.pos[0] * a.pos[0] > 0) {
          const o2 = minDistance - Math.abs(b.pos[1] - a.pos[1]);
          if (o2 > 0) {
            b.pos[1] += Math.sign(b.pos[0]) * o2;
          }
        }
      }
    }
    this.radiusTicks = this.yAxisScale.ticks(Math.floor(this.dims.height / 50)).map((d) => this.yScale(d));
  }
  getXValues() {
    const values = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (!values.includes(d.name)) {
          values.push(d.name);
        }
      }
    }
    return values;
  }
  getXDomain(values = this.getXValues()) {
    if (this.scaleType === ScaleType.Time) {
      const min6 = Math.min(...values);
      const max6 = Math.max(...values);
      return [min6, max6];
    } else if (this.scaleType === ScaleType.Linear) {
      values = values.map((v) => Number(v));
      const min6 = Math.min(...values);
      const max6 = Math.max(...values);
      return [min6, max6];
    }
    return values;
  }
  getYValues() {
    const domain = [];
    for (const results of this.results) {
      for (const d of results.series) {
        if (domain.indexOf(d.value) < 0) {
          domain.push(d.value);
        }
        if (d.min !== void 0) {
          if (domain.indexOf(d.min) < 0) {
            domain.push(d.min);
          }
        }
        if (d.max !== void 0) {
          if (domain.indexOf(d.max) < 0) {
            domain.push(d.max);
          }
        }
      }
    }
    return domain;
  }
  getYDomain(domain = this.getYValues()) {
    let min6 = Math.min(...domain);
    const max6 = Math.max(this.yAxisMinScale, ...domain);
    min6 = Math.max(0, min6);
    if (!this.autoScale) {
      min6 = Math.min(0, min6);
    }
    return [min6, max6];
  }
  getSeriesDomain() {
    return this.results.map((d) => d.name);
  }
  getXScale(domain, width) {
    switch (this.scaleType) {
      case ScaleType.Time:
        return time().range([0, width]).domain(domain);
      case ScaleType.Linear: {
        const scale = linear2().range([0, width]).domain(domain);
        return this.roundDomains ? scale.nice() : scale;
      }
      default:
        return point().range([0, width - twoPI / domain.length]).padding(0).domain(domain);
    }
  }
  getYScale(domain, height) {
    const scale = linear2().range([0, height]).domain(domain);
    return this.roundDomains ? scale.nice() : scale;
  }
  onClick(data, series) {
    if (series) {
      data.series = series.name;
    }
    this.select.emit(data);
  }
  setColors() {
    const domain = this.schemeType === ScaleType.Ordinal ? this.seriesDomain : this.yDomain.reverse();
    this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
  }
  getLegendOptions() {
    if (this.schemeType === ScaleType.Ordinal) {
      return {
        scaleType: this.schemeType,
        colors: this.colors,
        domain: this.seriesDomain,
        title: this.legendTitle,
        position: this.legendPosition
      };
    }
    return {
      scaleType: this.schemeType,
      colors: this.colors.scale,
      domain: this.yDomain,
      title: void 0,
      position: this.legendPosition
    };
  }
  updateYAxisWidth({
    width
  }) {
    this.yAxisWidth = width;
    this.update();
  }
  updateXAxisHeight({
    height
  }) {
    this.xAxisHeight = height;
    this.update();
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = this.showSeriesOnHover ? [item, ...this.activeEntries] : this.activeEntries;
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  deactivateAll() {
    this.activeEntries = [...this.activeEntries];
    for (const entry of this.activeEntries) {
      this.deactivate.emit({
        value: entry,
        entries: []
      });
    }
    this.activeEntries = [];
  }
  trackBy(index, item) {
    return `${item.name}`;
  }
};
_PolarChartComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275PolarChartComponent_BaseFactory;
  return function PolarChartComponent_Factory(__ngFactoryType__) {
    return (\u0275PolarChartComponent_BaseFactory || (\u0275PolarChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_PolarChartComponent)))(__ngFactoryType__ || _PolarChartComponent);
  };
})();
_PolarChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PolarChartComponent,
  selectors: [["ngx-charts-polar-chart"]],
  contentQueries: function PolarChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    xAxis: "xAxis",
    yAxis: "yAxis",
    showXAxisLabel: "showXAxisLabel",
    showYAxisLabel: "showYAxisLabel",
    xAxisLabel: "xAxisLabel",
    yAxisLabel: "yAxisLabel",
    autoScale: "autoScale",
    showGridLines: "showGridLines",
    curve: "curve",
    activeEntries: "activeEntries",
    schemeType: "schemeType",
    rangeFillOpacity: "rangeFillOpacity",
    trimYAxisTicks: "trimYAxisTicks",
    maxYAxisTickLength: "maxYAxisTickLength",
    xAxisTickFormatting: "xAxisTickFormatting",
    yAxisTickFormatting: "yAxisTickFormatting",
    roundDomains: "roundDomains",
    tooltipDisabled: "tooltipDisabled",
    showSeriesOnHover: "showSeriesOnHover",
    gradient: "gradient",
    yAxisMinScale: "yAxisMinScale",
    labelTrim: "labelTrim",
    labelTrimSize: "labelTrimSize",
    wrapTicks: "wrapTicks"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 10,
  vars: 17,
  consts: [[3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "polar-chart", "chart"], ["cx", "0", "cy", "0", 1, "polar-chart-background"], [4, "ngIf"], ["ngx-charts-y-axis", "", 3, "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "wrapTicks", "dimensionsChanged", 4, "ngIf"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width", 4, "ngIf"], ["class", "gridline-path radial-gridline-path", "cx", "0", "cy", "0", 4, "ngFor", "ngForOf"], ["cx", "0", "cy", "0", 1, "gridline-path", "radial-gridline-path"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize", 4, "ngFor", "ngForOf"], ["ngx-charts-pie-label", "", 3, "data", "radius", "label", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize"], ["ngx-charts-y-axis", "", 3, "dimensionsChanged", "yScale", "dims", "showGridLines", "showLabel", "labelText", "trimTicks", "maxTickLength", "tickFormatting", "wrapTicks"], ["ngx-charts-axis-label", "", 3, "label", "offset", "orient", "height", "width"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-polar-series", "", 3, "select", "activate", "deactivate", "gradient", "xScale", "yScale", "colors", "data", "activeEntries", "scaleType", "curve", "rangeFillOpacity", "animations", "tooltipDisabled", "tooltipTemplate"]],
  template: function PolarChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelClick", function PolarChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      })("legendLabelActivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event);
      })("legendLabelDeactivate", function PolarChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1)(2, "g");
      \u0275\u0275element(3, "circle", 2);
      \u0275\u0275template(4, PolarChartComponent__svg_g_4_Template, 2, 1, "g", 3)(5, PolarChartComponent__svg_g_5_Template, 2, 1, "g", 3);
      \u0275\u0275elementEnd();
      \u0275\u0275template(6, PolarChartComponent__svg_g_6_Template, 1, 10, "g", 4)(7, PolarChartComponent__svg_g_7_Template, 1, 5, "g", 5)(8, PolarChartComponent__svg_g_8_Template, 2, 3, "g", 3)(9, PolarChartComponent__svg_g_9_Template, 2, 3, "g", 3);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(14, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transformPlot);
      \u0275\u0275advance();
      \u0275\u0275attribute("r", ctx.outerRadius);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showGridLines);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.yAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.xAxis && ctx.showXAxisLabel);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", !ctx.isSSR);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.isSSR);
    }
  },
  dependencies: [NgForOf, NgIf, AxisLabelComponent, YAxisComponent, ChartComponent, PieLabelComponent, PolarSeriesComponent],
  styles: [_c25, ".pie-label{font-size:11px}.pie-label.animation{animation:.75s ease-in fadeIn}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d .75s}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}\n", ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area,.polar-series-path{pointer-events:none}\n"],
  encapsulation: 2,
  data: {
    animation: [trigger("animationState", [transition(":leave", [style({
      opacity: 1
    }), animate(500, style({
      opacity: 0
    }))])])]
  },
  changeDetection: 0
});
var PolarChartComponent = _PolarChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PolarChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-polar-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:g class="polar-chart chart" [attr.transform]="transform">
        <svg:g [attr.transform]="transformPlot">
          <svg:circle class="polar-chart-background" cx="0" cy="0" [attr.r]="this.outerRadius" />
          <svg:g *ngIf="showGridLines">
            <svg:circle
              *ngFor="let r of radiusTicks"
              class="gridline-path radial-gridline-path"
              cx="0"
              cy="0"
              [attr.r]="r"
            />
          </svg:g>
          <svg:g *ngIf="xAxis">
            <svg:g
              ngx-charts-pie-label
              *ngFor="let tick of thetaTicks"
              [data]="tick"
              [radius]="outerRadius"
              [label]="tick.label"
              [max]="outerRadius"
              [value]="showGridLines ? 1 : outerRadius"
              [explodeSlices]="true"
              [animations]="animations"
              [labelTrim]="labelTrim"
              [labelTrimSize]="labelTrimSize"
            ></svg:g>
          </svg:g>
        </svg:g>
        <svg:g
          ngx-charts-y-axis
          [attr.transform]="transformYAxis"
          *ngIf="yAxis"
          [yScale]="yAxisScale"
          [dims]="yAxisDims"
          [showGridLines]="showGridLines"
          [showLabel]="showYAxisLabel"
          [labelText]="yAxisLabel"
          [trimTicks]="trimYAxisTicks"
          [maxTickLength]="maxYAxisTickLength"
          [tickFormatting]="yAxisTickFormatting"
          [wrapTicks]="wrapTicks"
          (dimensionsChanged)="updateYAxisWidth($event)"
        ></svg:g>
        <svg:g
          ngx-charts-axis-label
          *ngIf="xAxis && showXAxisLabel"
          [label]="xAxisLabel"
          [offset]="labelOffset"
          [orient]="orientation.Bottom"
          [height]="dims.height"
          [width]="dims.width"
        ></svg:g>
        <svg:g *ngIf="!isSSR" [attr.transform]="transformPlot">
          <svg:g *ngFor="let series of results; trackBy: trackBy" [@animationState]="'active'">
            <svg:g
              ngx-charts-polar-series
              [gradient]="gradient"
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [scaleType]="scaleType"
              [curve]="curve"
              [rangeFillOpacity]="rangeFillOpacity"
              [animations]="animations"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              (select)="onClick($event)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
            />
          </svg:g>
        </svg:g>
        <svg:g *ngIf="isSSR" [attr.transform]="transformPlot">
          <svg:g *ngFor="let series of results; trackBy: trackBy">
            <svg:g
              ngx-charts-polar-series
              [gradient]="gradient"
              [xScale]="xScale"
              [yScale]="yScale"
              [colors]="colors"
              [data]="series"
              [activeEntries]="activeEntries"
              [scaleType]="scaleType"
              [curve]="curve"
              [rangeFillOpacity]="rangeFillOpacity"
              [animations]="animations"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              (select)="onClick($event)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
            />
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [trigger("animationState", [transition(":leave", [style({
        opacity: 1
      }), animate(500, style({
        opacity: 0
      }))])])],
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".pie-label{font-size:11px}.pie-label.animation{animation:.75s ease-in fadeIn}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d .75s}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}\n", ".polar-chart .polar-chart-background{fill:none}.polar-chart .radial-gridline-path{stroke-dasharray:10 10;fill:none}.polar-chart .pie-label-line{stroke:#2f3646}.polar-charts-series .polar-series-area,.polar-series-path{pointer-events:none}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    showXAxisLabel: [{
      type: Input
    }],
    showYAxisLabel: [{
      type: Input
    }],
    xAxisLabel: [{
      type: Input
    }],
    yAxisLabel: [{
      type: Input
    }],
    autoScale: [{
      type: Input
    }],
    showGridLines: [{
      type: Input
    }],
    curve: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    schemeType: [{
      type: Input
    }],
    rangeFillOpacity: [{
      type: Input
    }],
    trimYAxisTicks: [{
      type: Input
    }],
    maxYAxisTickLength: [{
      type: Input
    }],
    xAxisTickFormatting: [{
      type: Input
    }],
    yAxisTickFormatting: [{
      type: Input
    }],
    roundDomains: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    showSeriesOnHover: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    yAxisMinScale: [{
      type: Input
    }],
    labelTrim: [{
      type: Input
    }],
    labelTrimSize: [{
      type: Input
    }],
    wrapTicks: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _PieArcComponent = class _PieArcComponent {
  constructor(element) {
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.cornerRadius = 0;
    this.explodeSlices = false;
    this.gradient = false;
    this.animate = true;
    this.pointerEvents = true;
    this.isActive = false;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.dblclick = new EventEmitter();
    this.barOrientation = BarOrientation;
    this.initialized = false;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
  }
  getGradient() {
    return this.gradient ? this.gradientFill : this.fill;
  }
  getPointerEvents() {
    return this.pointerEvents ? "auto" : "none";
  }
  update() {
    const calc = this.calculateArc();
    this.startOpacity = 0.5;
    this.radialGradientId = "linearGrad" + id2().toString();
    this.gradientFill = `url(#${this.radialGradientId})`;
    if (this.animate) {
      if (this.initialized) {
        this.updateAnimation();
      } else {
        this.loadAnimation();
        this.initialized = true;
      }
    } else {
      this.path = calc.startAngle(this.startAngle).endAngle(this.endAngle)();
    }
  }
  calculateArc() {
    let outerRadius = this.outerRadius;
    if (this.explodeSlices && this.innerRadius === 0) {
      outerRadius = this.outerRadius * this.value / this.max;
    }
    return arc_default().innerRadius(this.innerRadius).outerRadius(outerRadius).cornerRadius(this.cornerRadius);
  }
  loadAnimation() {
    const node = select_default2(this.element).selectAll(".arc").data([{
      startAngle: this.startAngle,
      endAngle: this.endAngle
    }]);
    const calc = this.calculateArc();
    node.transition().attrTween("d", function(d) {
      this._current = this._current || d;
      const copyOfD = Object.assign({}, d);
      copyOfD.endAngle = copyOfD.startAngle;
      const interpolater = value_default(copyOfD, copyOfD);
      this._current = interpolater(0);
      return function(t2) {
        return calc(interpolater(t2));
      };
    }).transition().duration(750).attrTween("d", function(d) {
      this._current = this._current || d;
      const interpolater = value_default(this._current, d);
      this._current = interpolater(0);
      return function(t2) {
        return calc(interpolater(t2));
      };
    });
  }
  updateAnimation() {
    const node = select_default2(this.element).selectAll(".arc").data([{
      startAngle: this.startAngle,
      endAngle: this.endAngle
    }]);
    const calc = this.calculateArc();
    node.transition().duration(750).attrTween("d", function(d) {
      this._current = this._current || d;
      const interpolater = value_default(this._current, d);
      this._current = interpolater(0);
      return function(t2) {
        return calc(interpolater(t2));
      };
    });
  }
  onClick() {
    clearTimeout(this._timeout);
    this._timeout = setTimeout(() => this.select.emit(this.data), 200);
  }
  onDblClick(event) {
    event.preventDefault();
    event.stopPropagation();
    clearTimeout(this._timeout);
    this.dblclick.emit({
      data: this.data,
      nativeEvent: event
    });
  }
};
_PieArcComponent.\u0275fac = function PieArcComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PieArcComponent)(\u0275\u0275directiveInject(ElementRef));
};
_PieArcComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PieArcComponent,
  selectors: [["g", "ngx-charts-pie-arc", ""]],
  inputs: {
    fill: "fill",
    startAngle: "startAngle",
    endAngle: "endAngle",
    innerRadius: "innerRadius",
    outerRadius: "outerRadius",
    cornerRadius: "cornerRadius",
    value: "value",
    max: "max",
    data: "data",
    explodeSlices: "explodeSlices",
    gradient: "gradient",
    animate: "animate",
    pointerEvents: "pointerEvents",
    isActive: "isActive"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate",
    dblclick: "dblclick"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c40,
  decls: 3,
  vars: 7,
  consts: [[1, "arc-group"], [4, "ngIf"], [1, "arc", 3, "click", "dblclick", "mouseenter", "mouseleave"], ["ngx-charts-svg-radial-gradient", "", 3, "color", "name", "startOpacity"]],
  template: function PieArcComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g", 0);
      \u0275\u0275template(1, PieArcComponent__svg_defs_1_Template, 2, 3, "defs", 1);
      \u0275\u0275elementStart(2, "path", 2);
      \u0275\u0275listener("click", function PieArcComponent_Template_path_click_2_listener() {
        return ctx.onClick();
      })("dblclick", function PieArcComponent_Template_path_dblclick_2_listener($event) {
        return ctx.onDblClick($event);
      })("mouseenter", function PieArcComponent_Template_path_mouseenter_2_listener() {
        return ctx.activate.emit(ctx.data);
      })("mouseleave", function PieArcComponent_Template_path_mouseleave_2_listener() {
        return ctx.deactivate.emit(ctx.data);
      });
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.gradient);
      \u0275\u0275advance();
      \u0275\u0275styleProp("pointer-events", ctx.getPointerEvents());
      \u0275\u0275classProp("active", ctx.isActive);
      \u0275\u0275attribute("d", ctx.path)("fill", ctx.getGradient());
    }
  },
  dependencies: [NgIf, SvgRadialGradientComponent],
  encapsulation: 2,
  changeDetection: 0
});
var PieArcComponent = _PieArcComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieArcComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-pie-arc]",
      template: `
    <svg:g class="arc-group">
      <svg:defs *ngIf="gradient">
        <svg:g ngx-charts-svg-radial-gradient [color]="fill" [name]="radialGradientId" [startOpacity]="startOpacity" />
      </svg:defs>
      <svg:path
        [attr.d]="path"
        class="arc"
        [class.active]="isActive"
        [attr.fill]="getGradient()"
        (click)="onClick()"
        (dblclick)="onDblClick($event)"
        (mouseenter)="activate.emit(data)"
        (mouseleave)="deactivate.emit(data)"
        [style.pointer-events]="getPointerEvents()"
      />
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    fill: [{
      type: Input
    }],
    startAngle: [{
      type: Input
    }],
    endAngle: [{
      type: Input
    }],
    innerRadius: [{
      type: Input
    }],
    outerRadius: [{
      type: Input
    }],
    cornerRadius: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    explodeSlices: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    pointerEvents: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    dblclick: [{
      type: Output
    }]
  });
})();
var _PieSeriesComponent = class _PieSeriesComponent {
  constructor() {
    this.series = [];
    this.innerRadius = 60;
    this.outerRadius = 80;
    this.trimLabels = true;
    this.maxLabelLength = 10;
    this.tooltipDisabled = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.dblclick = new EventEmitter();
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    const pieGenerator = pie_default().value((d) => d.value).sort(null);
    const arcData = pieGenerator(this.series);
    this.max = max3(arcData, (d) => {
      return d.value;
    });
    this.data = this.calculateLabelPositions(arcData);
    this.tooltipText = this.tooltipText || this.defaultTooltipText;
  }
  midAngle(d) {
    return d.startAngle + (d.endAngle - d.startAngle) / 2;
  }
  outerArc() {
    const factor = 1.5;
    return arc_default().innerRadius(this.outerRadius * factor).outerRadius(this.outerRadius * factor);
  }
  calculateLabelPositions(pieData) {
    const factor = 1.5;
    const minDistance = 10;
    const labelPositions = pieData;
    labelPositions.forEach((d) => {
      d.pos = this.outerArc().centroid(d);
      d.pos[0] = factor * this.outerRadius * (this.midAngle(d) < Math.PI ? 1 : -1);
    });
    for (let i = 0; i < labelPositions.length - 1; i++) {
      const a = labelPositions[i];
      if (!this.labelVisible(a)) {
        continue;
      }
      for (let j = i + 1; j < labelPositions.length; j++) {
        const b = labelPositions[j];
        if (!this.labelVisible(b)) {
          continue;
        }
        if (b.pos[0] * a.pos[0] > 0) {
          const o2 = minDistance - Math.abs(b.pos[1] - a.pos[1]);
          if (o2 > 0) {
            b.pos[1] += Math.sign(b.pos[0]) * o2;
          }
        }
      }
    }
    return labelPositions;
  }
  labelVisible(myArc) {
    return this.showLabels && myArc.endAngle - myArc.startAngle > Math.PI / 30;
  }
  getTooltipTitle(a) {
    return this.tooltipTemplate ? void 0 : this.tooltipText(a);
  }
  labelText(myArc) {
    if (this.labelFormatting) {
      return this.labelFormatting(myArc.data.name);
    }
    return this.label(myArc);
  }
  label(myArc) {
    return formatLabel(myArc.data.name);
  }
  defaultTooltipText(myArc) {
    const label = this.label(myArc);
    const val = formatLabel(myArc.data.value);
    return `
      <span class="tooltip-label">${escapeLabel(label)}</span>
      <span class="tooltip-val">${val}</span>
    `;
  }
  color(myArc) {
    return this.colors.getColor(this.label(myArc));
  }
  trackBy(index, item) {
    return item.data.name;
  }
  onClick(data) {
    this.select.emit(data);
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name && entry.series === d.series;
    });
    return item !== void 0;
  }
};
_PieSeriesComponent.\u0275fac = function PieSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PieSeriesComponent)();
};
_PieSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PieSeriesComponent,
  selectors: [["g", "ngx-charts-pie-series", ""]],
  inputs: {
    colors: "colors",
    series: "series",
    dims: "dims",
    innerRadius: "innerRadius",
    outerRadius: "outerRadius",
    explodeSlices: "explodeSlices",
    showLabels: "showLabels",
    gradient: "gradient",
    activeEntries: "activeEntries",
    labelFormatting: "labelFormatting",
    trimLabels: "trimLabels",
    maxLabelLength: "maxLabelLength",
    tooltipText: "tooltipText",
    tooltipDisabled: "tooltipDisabled",
    tooltipTemplate: "tooltipTemplate",
    animations: "animations"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate",
    dblclick: "dblclick"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c41,
  decls: 1,
  vars: 2,
  consts: [[4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations", 4, "ngIf"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "dblclick", "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "gradient", "data", "max", "explodeSlices", "isActive", "animate", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"], ["ngx-charts-pie-label", "", 3, "data", "radius", "color", "label", "labelTrim", "labelTrimSize", "max", "value", "explodeSlices", "animations"]],
  template: function PieSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, PieSeriesComponent__svg_g_0_Template, 3, 19, "g", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
    }
  },
  dependencies: [NgForOf, NgIf, TooltipDirective, PieLabelComponent, PieArcComponent],
  encapsulation: 2,
  changeDetection: 0
});
var PieSeriesComponent = _PieSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-pie-series]",
      template: `
    <svg:g *ngFor="let arc of data; trackBy: trackBy">
      <svg:g
        ngx-charts-pie-label
        *ngIf="labelVisible(arc)"
        [data]="arc"
        [radius]="outerRadius"
        [color]="color(arc)"
        [label]="labelText(arc)"
        [labelTrim]="trimLabels"
        [labelTrimSize]="maxLabelLength"
        [max]="max"
        [value]="arc.value"
        [explodeSlices]="explodeSlices"
        [animations]="animations"
      ></svg:g>
      <svg:g
        ngx-charts-pie-arc
        [startAngle]="arc.startAngle"
        [endAngle]="arc.endAngle"
        [innerRadius]="innerRadius"
        [outerRadius]="outerRadius"
        [fill]="color(arc)"
        [value]="arc.data.value"
        [gradient]="gradient"
        [data]="arc.data"
        [max]="max"
        [explodeSlices]="explodeSlices"
        [isActive]="isActive(arc.data)"
        [animate]="animations"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
        (dblclick)="dblclick.emit($event)"
        ngx-tooltip
        [tooltipDisabled]="tooltipDisabled"
        [tooltipPlacement]="placementTypes.Top"
        [tooltipType]="styleTypes.tooltip"
        [tooltipTitle]="getTooltipTitle(arc)"
        [tooltipTemplate]="tooltipTemplate"
        [tooltipContext]="arc.data"
      ></svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    colors: [{
      type: Input
    }],
    series: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    innerRadius: [{
      type: Input
    }],
    outerRadius: [{
      type: Input
    }],
    explodeSlices: [{
      type: Input
    }],
    showLabels: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    trimLabels: [{
      type: Input
    }],
    maxLabelLength: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    dblclick: [{
      type: Output
    }]
  });
})();
var _AdvancedPieChartComponent = class _AdvancedPieChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.activeEntries = [];
    this.tooltipDisabled = false;
    this.label = "Total";
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [20, 20, 20, 20];
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width * 4 / 12,
      height: this.height,
      margins: this.margin
    });
    this.formatDates();
    this.domain = this.getDomain();
    this.setColors();
    const xOffset = this.dims.width / 2;
    const yOffset = this.margin[0] + this.dims.height / 2;
    this.legendWidth = this.width - this.dims.width - this.margin[1];
    this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2.5;
    this.innerRadius = this.outerRadius * 0.75;
    this.transform = `translate(${xOffset} , ${yOffset})`;
  }
  getDomain() {
    return this.results.map((d) => d.label);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
  onActivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_AdvancedPieChartComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275AdvancedPieChartComponent_BaseFactory;
  return function AdvancedPieChartComponent_Factory(__ngFactoryType__) {
    return (\u0275AdvancedPieChartComponent_BaseFactory || (\u0275AdvancedPieChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_AdvancedPieChartComponent)))(__ngFactoryType__ || _AdvancedPieChartComponent);
  };
})();
_AdvancedPieChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _AdvancedPieChartComponent,
  selectors: [["ngx-charts-advanced-pie-chart"]],
  contentQueries: function AdvancedPieChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    gradient: "gradient",
    activeEntries: "activeEntries",
    tooltipDisabled: "tooltipDisabled",
    tooltipText: "tooltipText",
    label: "label",
    valueFormatting: "valueFormatting",
    nameFormatting: "nameFormatting",
    percentageFormatting: "percentageFormatting"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 7,
  vars: 37,
  consts: [[1, "advanced-pie", "chart"], [3, "view", "showLegend", "animations"], [1, "pie", "chart"], ["ngx-charts-pie-series", "", 3, "select", "activate", "deactivate", "colors", "series", "innerRadius", "activeEntries", "outerRadius", "gradient", "tooltipDisabled", "tooltipTemplate", "tooltipText", "animations"], [1, "advanced-pie-legend-wrapper"], [3, "select", "activate", "deactivate", "data", "colors", "width", "label", "animations", "valueFormatting", "labelFormatting", "percentageFormatting"]],
  template: function AdvancedPieChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div")(1, "div", 0)(2, "ngx-charts-chart", 1);
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(3, "g", 2)(4, "g", 3);
      \u0275\u0275listener("select", function AdvancedPieChartComponent_Template_g_select_4_listener($event) {
        return ctx.onClick($event);
      })("activate", function AdvancedPieChartComponent_Template_g_activate_4_listener($event) {
        return ctx.onActivate($event);
      })("deactivate", function AdvancedPieChartComponent_Template_g_deactivate_4_listener($event) {
        return ctx.onDeactivate($event);
      });
      \u0275\u0275elementEnd()()()();
      \u0275\u0275namespaceHTML();
      \u0275\u0275elementStart(5, "div", 4)(6, "ngx-charts-advanced-legend", 5);
      \u0275\u0275listener("select", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_select_6_listener($event) {
        return ctx.onClick($event);
      })("activate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_activate_6_listener($event) {
        return ctx.onActivate($event, true);
      })("deactivate", function AdvancedPieChartComponent_Template_ngx_charts_advanced_legend_deactivate_6_listener($event) {
        return ctx.onDeactivate($event, true);
      });
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275styleProp("width", ctx.width, "px")("height", ctx.height, "px");
      \u0275\u0275advance();
      \u0275\u0275styleProp("width", ctx.dims.width, "px")("height", ctx.dims.height, "px");
      \u0275\u0275advance();
      \u0275\u0275property("view", \u0275\u0275pureFunction2(34, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("colors", ctx.colors)("series", ctx.results)("innerRadius", ctx.innerRadius)("activeEntries", ctx.activeEntries)("outerRadius", ctx.outerRadius)("gradient", ctx.gradient)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275styleProp("width", ctx.width - ctx.dims.width, "px")("height", ctx.height, "px");
      \u0275\u0275advance();
      \u0275\u0275property("data", ctx.results)("colors", ctx.colors)("width", ctx.width - ctx.dims.width - ctx.margin[1])("label", ctx.label)("animations", ctx.animations)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.nameFormatting)("percentageFormatting", ctx.percentageFormatting);
    }
  },
  dependencies: [ChartComponent, AdvancedLegendComponent, PieSeriesComponent],
  styles: [_c25, ".advanced-pie{display:inline-block;float:left}.advanced-pie-legend-wrapper{display:inline-block}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var AdvancedPieChartComponent = _AdvancedPieChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdvancedPieChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-advanced-pie-chart",
      template: `
    <div [style.width.px]="width" [style.height.px]="height">
      <div class="advanced-pie chart" [style.width.px]="dims.width" [style.height.px]="dims.height">
        <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
          <svg:g [attr.transform]="transform" class="pie chart">
            <svg:g
              ngx-charts-pie-series
              [colors]="colors"
              [series]="results"
              [innerRadius]="innerRadius"
              [activeEntries]="activeEntries"
              [outerRadius]="outerRadius"
              [gradient]="gradient"
              [tooltipDisabled]="tooltipDisabled"
              [tooltipTemplate]="tooltipTemplate"
              [tooltipText]="tooltipText"
              (select)="onClick($event)"
              (activate)="onActivate($event)"
              (deactivate)="onDeactivate($event)"
              [animations]="animations"
            ></svg:g>
          </svg:g>
        </ngx-charts-chart>
      </div>
      <div class="advanced-pie-legend-wrapper" [style.width.px]="width - dims.width" [style.height.px]="height">
        <ngx-charts-advanced-legend
          [data]="results"
          [colors]="colors"
          [width]="width - dims.width - margin[1]"
          [label]="label"
          [animations]="animations"
          [valueFormatting]="valueFormatting"
          [labelFormatting]="nameFormatting"
          [percentageFormatting]="percentageFormatting"
          (select)="onClick($event)"
          (activate)="onActivate($event, true)"
          (deactivate)="onDeactivate($event, true)"
        >
        </ngx-charts-advanced-legend>
      </div>
    </div>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".advanced-pie{display:inline-block;float:left}.advanced-pie-legend-wrapper{display:inline-block}\n"]
    }]
  }], null, {
    gradient: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    valueFormatting: [{
      type: Input
    }],
    nameFormatting: [{
      type: Input
    }],
    percentageFormatting: [{
      type: Input
    }]
  });
})();
var _PieChartComponent = class _PieChartComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.labels = false;
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.explodeSlices = false;
    this.doughnut = false;
    this.arcWidth = 0.25;
    this.activeEntries = [];
    this.tooltipDisabled = false;
    this.trimLabels = true;
    this.maxLabelLength = 10;
    this.dblclick = new EventEmitter();
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
  }
  update() {
    super.update();
    if (this.labels && this.hasNoOptionalMarginsSet()) {
      this.margins = [30, 80, 30, 80];
    } else if (!this.labels && this.hasNoOptionalMarginsSet()) {
      this.margins = [20, 20, 20, 20];
    }
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margins,
      showLegend: this.legend,
      legendPosition: this.legendPosition
    });
    this.formatDates();
    const xOffset = this.margins[3] + this.dims.width / 2;
    const yOffset = this.margins[0] + this.dims.height / 2;
    this.translation = `translate(${xOffset}, ${yOffset})`;
    this.outerRadius = Math.min(this.dims.width, this.dims.height);
    if (this.labels) {
      this.outerRadius /= 3;
    } else {
      this.outerRadius /= 2;
    }
    this.innerRadius = 0;
    if (this.doughnut) {
      this.innerRadius = this.outerRadius * (1 - this.arcWidth);
    }
    this.domain = this.getDomain();
    this.data = this.results.sort((a, b) => {
      return this.domain.indexOf(a.name) - this.domain.indexOf(b.name);
    });
    this.setColors();
    this.legendOptions = this.getLegendOptions();
  }
  getDomain() {
    return this.results.map((d) => d.label);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
  getLegendOptions() {
    return {
      scaleType: ScaleType.Ordinal,
      domain: this.domain,
      colors: this.colors,
      title: this.legendTitle,
      position: this.legendPosition
    };
  }
  onActivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  hasNoOptionalMarginsSet() {
    return !this.margins || this.margins.length <= 0;
  }
};
_PieChartComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275PieChartComponent_BaseFactory;
  return function PieChartComponent_Factory(__ngFactoryType__) {
    return (\u0275PieChartComponent_BaseFactory || (\u0275PieChartComponent_BaseFactory = \u0275\u0275getInheritedFactory(_PieChartComponent)))(__ngFactoryType__ || _PieChartComponent);
  };
})();
_PieChartComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PieChartComponent,
  selectors: [["ngx-charts-pie-chart"]],
  contentQueries: function PieChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    labels: "labels",
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    explodeSlices: "explodeSlices",
    doughnut: "doughnut",
    arcWidth: "arcWidth",
    gradient: "gradient",
    activeEntries: "activeEntries",
    tooltipDisabled: "tooltipDisabled",
    labelFormatting: "labelFormatting",
    trimLabels: "trimLabels",
    maxLabelLength: "maxLabelLength",
    tooltipText: "tooltipText",
    margins: "margins"
  },
  outputs: {
    dblclick: "dblclick",
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 3,
  vars: 24,
  consts: [[3, "legendLabelActivate", "legendLabelDeactivate", "legendLabelClick", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "pie-chart", "chart"], ["ngx-charts-pie-series", "", 3, "dblclick", "select", "activate", "deactivate", "colors", "series", "showLabels", "labelFormatting", "trimLabels", "maxLabelLength", "activeEntries", "innerRadius", "outerRadius", "explodeSlices", "gradient", "animations", "tooltipDisabled", "tooltipTemplate", "tooltipText"]],
  template: function PieChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275listener("legendLabelActivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event, true);
      })("legendLabelDeactivate", function PieChartComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event, true);
      })("legendLabelClick", function PieChartComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1)(2, "g", 2);
      \u0275\u0275listener("dblclick", function PieChartComponent_Template_g_dblclick_2_listener($event) {
        return ctx.dblclick.emit($event);
      })("select", function PieChartComponent_Template_g_select_2_listener($event) {
        return ctx.onClick($event);
      })("activate", function PieChartComponent_Template_g_activate_2_listener($event) {
        return ctx.onActivate($event);
      })("deactivate", function PieChartComponent_Template_g_deactivate_2_listener($event) {
        return ctx.onDeactivate($event);
      });
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(21, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.translation);
      \u0275\u0275advance();
      \u0275\u0275property("colors", ctx.colors)("series", ctx.data)("showLabels", ctx.labels)("labelFormatting", ctx.labelFormatting)("trimLabels", ctx.trimLabels)("maxLabelLength", ctx.maxLabelLength)("activeEntries", ctx.activeEntries)("innerRadius", ctx.innerRadius)("outerRadius", ctx.outerRadius)("explodeSlices", ctx.explodeSlices)("gradient", ctx.gradient)("animations", ctx.animations)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("tooltipText", ctx.tooltipText);
    }
  },
  dependencies: [ChartComponent, PieSeriesComponent],
  styles: [_c25, _c422],
  encapsulation: 2,
  changeDetection: 0
});
var PieChartComponent = _PieChartComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieChartComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-pie-chart",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event, true)"
      (legendLabelDeactivate)="onDeactivate($event, true)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="translation" class="pie-chart chart">
        <svg:g
          ngx-charts-pie-series
          [colors]="colors"
          [series]="data"
          [showLabels]="labels"
          [labelFormatting]="labelFormatting"
          [trimLabels]="trimLabels"
          [maxLabelLength]="maxLabelLength"
          [activeEntries]="activeEntries"
          [innerRadius]="innerRadius"
          [outerRadius]="outerRadius"
          [explodeSlices]="explodeSlices"
          [gradient]="gradient"
          [animations]="animations"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipText]="tooltipText"
          (dblclick)="dblclick.emit($event)"
          (select)="onClick($event)"
          (activate)="onActivate($event)"
          (deactivate)="onDeactivate($event)"
        />
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".pie-label{font-size:11px}.pie-label.animation{animation:.75s ease-in fadeIn}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d .75s}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}\n"]
    }]
  }], null, {
    labels: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    explodeSlices: [{
      type: Input
    }],
    doughnut: [{
      type: Input
    }],
    arcWidth: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    trimLabels: [{
      type: Input
    }],
    maxLabelLength: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    dblclick: [{
      type: Output
    }],
    margins: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
function gridSize(dims, len, minWidth) {
  let rows = 1;
  let cols = len;
  const width = dims.width;
  if (width > minWidth) {
    while (width / cols < minWidth) {
      rows += 1;
      cols = Math.ceil(len / rows);
    }
  }
  return [cols, rows];
}
function gridLayout(dims, data, minWidth, designatedTotal) {
  const xScale = band();
  const yScale = band();
  const width = dims.width;
  const height = dims.height;
  const [columns, rows] = gridSize(dims, data.length, minWidth);
  const xDomain = [];
  const yDomain = [];
  for (let i = 0; i < rows; i++) {
    yDomain.push(i);
  }
  for (let i = 0; i < columns; i++) {
    xDomain.push(i);
  }
  xScale.domain(xDomain);
  yScale.domain(yDomain);
  xScale.rangeRound([0, width], 0.1);
  yScale.rangeRound([0, height], 0.1);
  const res = [];
  const total = designatedTotal ? designatedTotal : getTotal(data);
  const cardWidth = xScale.bandwidth();
  const cardHeight = yScale.bandwidth();
  for (let i = 0; i < data.length; i++) {
    res[i] = {};
    res[i].data = {
      name: data[i] ? data[i].name : "",
      value: data[i] ? data[i].value : void 0,
      extra: data[i] ? data[i].extra : void 0,
      label: data[i] ? data[i].label : ""
    };
    res[i].x = xScale(i % columns);
    res[i].y = yScale(Math.floor(i / columns));
    res[i].width = cardWidth;
    res[i].height = cardHeight;
    res[i].data.percent = total > 0 ? res[i].data.value / total : 0;
    res[i].data.total = total;
  }
  return res;
}
function getTotal(results) {
  return results.map((d) => d ? d.value : 0).reduce((sum2, val) => sum2 + val, 0);
}
var _PieGridSeriesComponent = class _PieGridSeriesComponent {
  constructor(element) {
    this.innerRadius = 70;
    this.outerRadius = 80;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.layout = pie_default().value((d) => d.data.value).sort(null);
    this.arcs = this.getArcs();
  }
  getArcs() {
    return this.layout(this.data).map((arc, index) => {
      const label = arc.data.data.name;
      const other = arc.data.data.other;
      if (index === 0) {
        arc.startAngle = 0;
      }
      const color2 = this.colors(label);
      return {
        data: arc.data.data,
        class: "arc arc" + index,
        fill: color2,
        startAngle: other ? 0 : arc.startAngle,
        endAngle: arc.endAngle,
        animate: this.animations && !other,
        pointerEvents: !other
      };
    });
  }
  onClick(data) {
    this.select.emit(this.data[0].data);
  }
  trackBy(index, item) {
    return item.data.name;
  }
  label(arc) {
    return arc.data.name;
  }
  color(arc) {
    return this.colors(this.label(arc));
  }
};
_PieGridSeriesComponent.\u0275fac = function PieGridSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PieGridSeriesComponent)(\u0275\u0275directiveInject(ElementRef));
};
_PieGridSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PieGridSeriesComponent,
  selectors: [["g", "ngx-charts-pie-grid-series", ""]],
  inputs: {
    colors: "colors",
    data: "data",
    innerRadius: "innerRadius",
    outerRadius: "outerRadius",
    animations: "animations"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c43,
  decls: 2,
  vars: 2,
  consts: [[1, "pie-grid-arcs"], ["ngx-charts-pie-arc", "", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate", "select", "activate", "deactivate", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-pie-arc", "", 3, "select", "activate", "deactivate", "startAngle", "endAngle", "innerRadius", "outerRadius", "fill", "value", "data", "gradient", "pointerEvents", "animate"]],
  template: function PieGridSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g", 0);
      \u0275\u0275template(1, PieGridSeriesComponent__svg_g_1_Template, 1, 11, "g", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
    }
  },
  dependencies: [NgForOf, PieArcComponent],
  encapsulation: 2,
  changeDetection: 0
});
var PieGridSeriesComponent = _PieGridSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieGridSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-pie-grid-series]",
      template: `
    <svg:g class="pie-grid-arcs">
      <svg:g
        ngx-charts-pie-arc
        *ngFor="let arc of arcs; trackBy: trackBy"
        [attr.class]="arc.class"
        [startAngle]="arc.startAngle"
        [endAngle]="arc.endAngle"
        [innerRadius]="innerRadius"
        [outerRadius]="outerRadius"
        [fill]="color(arc)"
        [value]="arc.data.value"
        [data]="arc.data"
        [gradient]="false"
        [pointerEvents]="arc.pointerEvents"
        [animate]="arc.animate"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
      ></svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    colors: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    innerRadius: [{
      type: Input
    }],
    outerRadius: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var _PieGridComponent = class _PieGridComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.tooltipDisabled = false;
    this.label = "Total";
    this.minWidth = 150;
    this.activeEntries = [];
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [20, 20, 20, 20];
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin
    });
    this.formatDates();
    this.domain = this.getDomain();
    this.data = gridLayout(this.dims, this.results, this.minWidth, this.designatedTotal);
    this.transform = `translate(${this.margin[3]} , ${this.margin[0]})`;
    this.series = this.getSeries();
    this.setColors();
    this.tooltipText = this.tooltipText || this.defaultTooltipText;
  }
  defaultTooltipText({
    data
  }) {
    const label = trimLabel(formatLabel(data.name));
    const val = data.value.toLocaleString();
    return `
      <span class="tooltip-label">${label}</span>
      <span class="tooltip-val">${val}</span>
    `;
  }
  getDomain() {
    return this.results.map((d) => d.label);
  }
  getSeries() {
    const total = this.designatedTotal ? this.designatedTotal : this.getTotal();
    return this.data.map((d) => {
      const baselineLabelHeight = 20;
      const padding = 10;
      const name = d.data.name;
      const label = formatLabel(name);
      const value2 = d.data.value;
      const radius = min3([d.width - padding, d.height - baselineLabelHeight]) / 2 - 5;
      const innerRadius = radius * 0.9;
      let count3 = 0;
      const colors = () => {
        count3 += 1;
        if (count3 === 1) {
          return "rgba(100,100,100,0.3)";
        } else {
          return this.colorScale.getColor(label);
        }
      };
      const xPos = d.x + (d.width - padding) / 2;
      const yPos = d.y + (d.height - baselineLabelHeight) / 2;
      return {
        transform: `translate(${xPos}, ${yPos})`,
        colors,
        innerRadius,
        outerRadius: radius,
        name,
        label: trimLabel(label),
        total: value2,
        value: value2,
        percent: format(".1%")(d.data.percent),
        data: [d, {
          data: {
            other: true,
            value: total - value2,
            name: d.data.name
          }
        }]
      };
    });
  }
  getTotal() {
    return this.results.map((d) => d.value).reduce((sum2, d) => sum2 + d, 0);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colorScale = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
  onActivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item, fromLegend = false) {
    item = this.results.find((d) => {
      if (fromLegend) {
        return d.label === item.name;
      } else {
        return d.name === item.name;
      }
    });
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value && d.series === item.series;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
};
_PieGridComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275PieGridComponent_BaseFactory;
  return function PieGridComponent_Factory(__ngFactoryType__) {
    return (\u0275PieGridComponent_BaseFactory || (\u0275PieGridComponent_BaseFactory = \u0275\u0275getInheritedFactory(_PieGridComponent)))(__ngFactoryType__ || _PieGridComponent);
  };
})();
_PieGridComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _PieGridComponent,
  selectors: [["ngx-charts-pie-grid"]],
  contentQueries: function PieGridComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    designatedTotal: "designatedTotal",
    tooltipDisabled: "tooltipDisabled",
    tooltipText: "tooltipText",
    label: "label",
    minWidth: "minWidth",
    activeEntries: "activeEntries"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 3,
  vars: 8,
  consts: [[3, "view", "showLegend", "animations"], [1, "pie-grid", "chart"], ["class", "pie-grid-item", 4, "ngFor", "ngForOf"], [1, "pie-grid-item"], ["ngx-charts-pie-grid-series", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "colors", "data", "innerRadius", "outerRadius", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 3, "countTo", "countSuffix", 4, "ngIf"], ["class", "label percent-label", "dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 4, "ngIf"], ["dy", "0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 3, "countTo", "countPrefix", 4, "ngIf"], ["class", "label", "dy", "1.23em", "x", "0", "text-anchor", "middle", 4, "ngIf"], ["dy", "-0.5em", "x", "0", "y", "5", "ngx-charts-count-up", "", "text-anchor", "middle", 1, "label", "percent-label", 3, "countTo", "countSuffix"], ["dy", "-0.5em", "x", "0", "y", "5", "text-anchor", "middle", 1, "label", "percent-label"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", "ngx-charts-count-up", "", 1, "label", 3, "countTo", "countPrefix"], ["dy", "1.23em", "x", "0", "text-anchor", "middle", 1, "label"]],
  template: function PieGridComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275template(2, PieGridComponent__svg_g_2_Template, 8, 19, "g", 2);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(5, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.series);
    }
  },
  dependencies: [NgForOf, NgIf, TooltipDirective, CountUpDirective, ChartComponent, PieGridSeriesComponent],
  styles: [_c25, ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var PieGridComponent = _PieGridComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieGridComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-pie-grid",
      template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g [attr.transform]="transform" class="pie-grid chart">
        <svg:g *ngFor="let series of series" class="pie-grid-item" [attr.transform]="series.transform">
          <svg:g
            ngx-charts-pie-grid-series
            [colors]="series.colors"
            [data]="series.data"
            [innerRadius]="series.innerRadius"
            [outerRadius]="series.outerRadius"
            [animations]="animations"
            (select)="onClick($event)"
            ngx-tooltip
            [tooltipDisabled]="tooltipDisabled"
            [tooltipPlacement]="placementTypes.Top"
            [tooltipType]="styleTypes.tooltip"
            [tooltipTitle]="tooltipTemplate ? undefined : tooltipText({ data: series })"
            [tooltipTemplate]="tooltipTemplate"
            [tooltipContext]="series.data[0].data"
            (activate)="onActivate($event)"
            (deactivate)="onDeactivate($event)"
          />
          <svg:text
            *ngIf="animations"
            class="label percent-label"
            dy="-0.5em"
            x="0"
            y="5"
            ngx-charts-count-up
            [countTo]="series.percent"
            [countSuffix]="'%'"
            text-anchor="middle"
          ></svg:text>
          <svg:text *ngIf="!animations" class="label percent-label" dy="-0.5em" x="0" y="5" text-anchor="middle">
            {{ series.percent.toLocaleString() }}
          </svg:text>
          <svg:text class="label" dy="0.5em" x="0" y="5" text-anchor="middle">
            {{ series.label }}
          </svg:text>
          <svg:text
            *ngIf="animations"
            class="label"
            dy="1.23em"
            x="0"
            [attr.y]="series.outerRadius"
            text-anchor="middle"
            ngx-charts-count-up
            [countTo]="series.total"
            [countPrefix]="label + ': '"
          ></svg:text>
          <svg:text
            *ngIf="!animations"
            class="label"
            dy="1.23em"
            x="0"
            [attr.y]="series.outerRadius"
            text-anchor="middle"
          >
            {{ label }}: {{ series.total.toLocaleString() }}
          </svg:text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".pie-grid .arc1{opacity:.4}.pie-grid .percent-label{font-size:16px;font-weight:400}\n"]
    }]
  }], null, {
    designatedTotal: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipText: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    minWidth: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _PieChartModule = class _PieChartModule {
};
_PieChartModule.\u0275fac = function PieChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PieChartModule)();
};
_PieChartModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PieChartModule
});
_PieChartModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule]
});
var PieChartModule = _PieChartModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PieChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [AdvancedPieChartComponent, PieLabelComponent, PieArcComponent, PieChartComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent],
      exports: [AdvancedPieChartComponent, PieLabelComponent, PieArcComponent, PieChartComponent, PieGridComponent, PieGridSeriesComponent, PieSeriesComponent]
    }]
  }], null, null);
})();
var _PolarChartModule = class _PolarChartModule {
};
_PolarChartModule.\u0275fac = function PolarChartModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PolarChartModule)();
};
_PolarChartModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _PolarChartModule
});
_PolarChartModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule, PieChartModule, LineChartModule]
});
var PolarChartModule = _PolarChartModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PolarChartModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule, PieChartModule, LineChartModule],
      declarations: [PolarChartComponent, PolarSeriesComponent],
      exports: [PolarChartComponent, PolarSeriesComponent]
    }]
  }], null, null);
})();
function calculateTextWidth(fontFamilyKey, text2, defaultWidth = 8) {
  return text2.split("").reduce((acc, curr) => {
    const width = fontFamilyKey[curr] || defaultWidth;
    return acc + width;
  }, 0);
}
var VERDANA_FONT_WIDTHS_16_PX = {
  "0": 10,
  "1": 10,
  "2": 10,
  "3": 10,
  "4": 10,
  "5": 10,
  "6": 10,
  "7": 10,
  "8": 10,
  "9": 10,
  A: 11,
  B: 11,
  C: 11,
  D: 12,
  E: 10,
  F: 9,
  G: 12,
  H: 12,
  I: 7,
  J: 7,
  K: 11,
  L: 9,
  M: 13,
  N: 12,
  O: 13,
  P: 10,
  Q: 13,
  R: 11,
  S: 11,
  T: 10,
  U: 12,
  V: 11,
  W: 16,
  X: 11,
  Y: 10,
  Z: 11,
  a: 10,
  b: 10,
  c: 8,
  d: 10,
  e: 10,
  f: 6,
  g: 10,
  h: 10,
  i: 4,
  j: 6,
  k: 9,
  l: 4,
  m: 16,
  n: 10,
  o: 10,
  p: 10,
  q: 10,
  r: 7,
  s: 8,
  t: 6,
  u: 10,
  v: 9,
  w: 13,
  x: 9,
  y: 9,
  z: 8,
  "!": 6,
  "@": 16,
  "#": 13,
  $: 10,
  "%": 17,
  "^": 13,
  "&": 12,
  "*": 10,
  "(": 7,
  ")": 7,
  _: 10,
  "-": 7,
  "+": 13,
  "=": 13,
  ",": 6,
  ".": 6,
  "/": 7,
  "'": 4,
  ":": 7,
  "|": 7,
  "?": 9,
  ";": 7,
  "<": 13,
  ">": 13
};
var _CardComponent = class _CardComponent {
  constructor(element, cd, zone, platformId) {
    this.cd = cd;
    this.zone = zone;
    this.platformId = platformId;
    this.animations = true;
    this.select = new EventEmitter();
    this.value = "";
    this.textFontSize = 12;
    this.textTransform = "";
    this.initialized = false;
    this.bandHeight = 10;
    this.textPadding = [10, 20, 5, 20];
    this.labelFontSize = 15;
    this.element = element.nativeElement;
  }
  ngOnChanges(changes) {
    this.update();
  }
  ngOnInit() {
    if (isPlatformServer(this.platformId)) {
      this.scaleTextSSR();
    }
  }
  ngOnDestroy() {
    if (isPlatformBrowser(this.platformId)) {
      cancelAnimationFrame(this.animationReq);
    }
  }
  update() {
    this.zone.run(() => {
      const hasValue = this.data && typeof this.data.value !== "undefined";
      const valueFormatting = this.valueFormatting || ((card) => card.value.toLocaleString());
      const labelFormatting = this.labelFormatting || ((card) => escapeLabel(trimLabel(card.label, 55)));
      this.transform = `translate(${this.x} , ${this.y})`;
      this.textWidth = Math.max(0, this.width) - this.textPadding[1] - this.textPadding[3];
      this.cardWidth = Math.max(0, this.width);
      this.cardHeight = Math.max(0, this.height);
      this.label = this.label ? this.label : this.data.name;
      const cardData = {
        label: this.label,
        data: this.data,
        value: this.data.value
      };
      this.formattedLabel = labelFormatting(cardData);
      this.transformBand = `translate(0 , ${this.cardHeight - this.bandHeight})`;
      const value2 = hasValue ? valueFormatting(cardData) : "";
      this.value = this.paddedValue(value2);
      this.setPadding();
      this.bandPath = roundedRect(0, 0, this.cardWidth, this.bandHeight, 3, [false, false, true, true]);
      setTimeout(() => {
        if (isPlatformBrowser(this.platformId)) {
          this.scaleText();
        }
        this.value = value2;
        if (hasValue && !this.initialized) {
          setTimeout(() => this.startCount(), 20);
        }
      }, 8);
    });
  }
  paddedValue(value2) {
    if (this.medianSize && this.medianSize > value2.length) {
      value2 += "\u2007".repeat(this.medianSize - value2.length);
    }
    return value2;
  }
  startCount() {
    if (!this.initialized && this.animations) {
      cancelAnimationFrame(this.animationReq);
      const val = this.data.value;
      const decs = decimalChecker(val);
      const valueFormatting = this.valueFormatting || ((card) => card.value.toLocaleString());
      const callback = ({
        value: value2,
        finished
      }) => {
        this.zone.run(() => {
          value2 = finished ? val : value2;
          this.value = valueFormatting({
            label: this.label,
            data: this.data,
            value: value2
          });
          if (!finished) {
            this.value = this.paddedValue(this.value);
          }
          this.cd.markForCheck();
        });
      };
      this.animationReq = count2(0, val, decs, 1, callback);
      this.initialized = true;
    }
  }
  scaleText() {
    this.zone.run(() => {
      const {
        width,
        height
      } = this.textEl.nativeElement.getBoundingClientRect();
      if (width === 0 || height === 0) {
        return;
      }
      const textPadding = this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8;
      const availableWidth = this.cardWidth - 2 * textPadding;
      const availableHeight = this.cardHeight / 3;
      const resizeScale = Math.min(availableWidth / width, availableHeight / height);
      this.textFontSize = Math.floor(this.textFontSize * resizeScale);
      this.labelFontSize = Math.min(this.textFontSize, 15);
      this.setPadding();
      this.cd.markForCheck();
    });
  }
  scaleTextSSR() {
    const width = calculateTextWidth(VERDANA_FONT_WIDTHS_16_PX, this.value, 10);
    const height = 18;
    const textPadding = this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8;
    const availableWidth = this.cardWidth - 2 * textPadding;
    const availableHeight = this.cardHeight / 3;
    const resizeScale = Math.min(availableWidth / width, availableHeight / height);
    this.textFontSize = Math.floor(this.textFontSize * resizeScale);
    this.labelFontSize = Math.min(this.textFontSize, 15);
    this.setPadding();
  }
  setPadding() {
    this.textPadding[1] = this.textPadding[3] = this.cardWidth / 8;
    const padding = this.cardHeight / 2;
    this.textPadding[0] = padding - this.textFontSize - this.labelFontSize / 2;
    this.textPadding[2] = padding - this.labelFontSize;
  }
  onClick() {
    this.select.emit(this.data);
  }
};
_CardComponent.\u0275fac = function CardComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CardComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ChangeDetectorRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(PLATFORM_ID));
};
_CardComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CardComponent,
  selectors: [["g", "ngx-charts-card", ""]],
  viewQuery: function CardComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c45, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.textEl = _t.first);
    }
  },
  inputs: {
    color: "color",
    bandColor: "bandColor",
    textColor: "textColor",
    x: "x",
    y: "y",
    width: "width",
    height: "height",
    label: "label",
    data: "data",
    medianSize: "medianSize",
    valueFormatting: "valueFormatting",
    labelFormatting: "labelFormatting",
    animations: "animations"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c46,
  decls: 10,
  vars: 25,
  consts: [["textEl", ""], [1, "cell", 3, "click"], ["rx", "3", "ry", "3", 1, "card"], ["class", "card-band", "stroke", "none", 4, "ngIf"], ["x", "5", "alignment-baseline", "hanging", 1, "trimmed-label"], [3, "innerHTML"], ["text-anchor", "start", "alignment-baseline", "hanging", 1, "value-text"], ["stroke", "none", 1, "card-band"]],
  template: function CardComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g", 1);
      \u0275\u0275listener("click", function CardComponent_Template_g_click_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onClick());
      });
      \u0275\u0275element(1, "rect", 2);
      \u0275\u0275template(2, CardComponent__svg_path_2_Template, 1, 3, "path", 3);
      \u0275\u0275elementStart(3, "title");
      \u0275\u0275text(4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "foreignObject", 4);
      \u0275\u0275namespaceHTML();
      \u0275\u0275element(6, "p", 5);
      \u0275\u0275elementEnd();
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(7, "text", 6, 0);
      \u0275\u0275text(9);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275styleProp("fill", ctx.color);
      \u0275\u0275attribute("width", ctx.cardWidth)("height", ctx.cardHeight);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.bandColor && ctx.bandColor !== ctx.color);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate(ctx.label);
      \u0275\u0275advance();
      \u0275\u0275attribute("x", ctx.textPadding[3])("y", ctx.cardHeight - ctx.textPadding[2])("width", ctx.textWidth)("height", ctx.labelFontSize + ctx.textPadding[2]);
      \u0275\u0275advance();
      \u0275\u0275styleProp("color", ctx.textColor)("font-size", ctx.labelFontSize, "px")("line-height", ctx.labelFontSize, "px");
      \u0275\u0275property("innerHTML", ctx.formattedLabel, \u0275\u0275sanitizeHtml);
      \u0275\u0275advance();
      \u0275\u0275styleProp("fill", ctx.textColor)("font-size", ctx.textFontSize, "pt");
      \u0275\u0275attribute("x", ctx.textPadding[3])("y", ctx.textPadding[0]);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.value, " ");
    }
  },
  dependencies: [NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var CardComponent = _CardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-card]",
      template: `
    <svg:g [attr.transform]="transform" class="cell" (click)="onClick()">
      <svg:rect class="card" [style.fill]="color" [attr.width]="cardWidth" [attr.height]="cardHeight" rx="3" ry="3" />
      <svg:path
        *ngIf="bandColor && bandColor !== color"
        class="card-band"
        [attr.fill]="bandColor"
        [attr.transform]="transformBand"
        stroke="none"
        [attr.d]="bandPath"
      />
      <title>{{ label }}</title>
      <svg:foreignObject
        class="trimmed-label"
        x="5"
        [attr.x]="textPadding[3]"
        [attr.y]="cardHeight - textPadding[2]"
        [attr.width]="textWidth"
        [attr.height]="labelFontSize + textPadding[2]"
        alignment-baseline="hanging"
      >
        <xhtml:p
          [style.color]="textColor"
          [style.fontSize.px]="labelFontSize"
          [style.lineHeight.px]="labelFontSize"
          [innerHTML]="formattedLabel"
        >
        </xhtml:p>
      </svg:foreignObject>
      <svg:text
        #textEl
        class="value-text"
        [attr.x]="textPadding[3]"
        [attr.y]="textPadding[0]"
        [style.fill]="textColor"
        text-anchor="start"
        alignment-baseline="hanging"
        [style.font-size.pt]="textFontSize"
      >
        {{ value }}
      </svg:text>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], {
    color: [{
      type: Input
    }],
    bandColor: [{
      type: Input
    }],
    textColor: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    medianSize: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    textEl: [{
      type: ViewChild,
      args: ["textEl", {
        static: false
      }]
    }]
  });
})();
function invertColor(value2) {
  const color2 = rgb(value2);
  const {
    r: r2,
    g: g2,
    b,
    opacity
  } = color2;
  if (opacity === 0) {
    return color2.toString();
  }
  const yiq = (r2 * 299 + g2 * 587 + b * 114) / 1e3;
  const depth = yiq >= 128 ? -0.8 : 0.8;
  return shadeRGBColor(color2, depth);
}
function shadeRGBColor({
  r: r2,
  g: g2,
  b
}, percent) {
  const t2 = percent < 0 ? 0 : 255;
  const p2 = percent < 0 ? percent * -1 : percent;
  r2 = Math.round((t2 - r2) * p2) + r2;
  g2 = Math.round((t2 - g2) * p2) + g2;
  b = Math.round((t2 - b) * p2) + b;
  return `rgb(${r2}, ${g2}, ${b})`;
}
var _CardSeriesComponent = class _CardSeriesComponent {
  constructor() {
    this.innerPadding = 15;
    this.emptyColor = "rgba(0, 0, 0, 0)";
    this.animations = true;
    this.select = new EventEmitter();
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    if (this.data.length > 2) {
      const valueFormatting = this.valueFormatting || ((card) => card.value.toLocaleString());
      const sortedLengths = this.data.map((d) => {
        const hasValue = d && d.data && typeof d.data.value !== "undefined" && d.data.value !== null;
        return hasValue ? valueFormatting({
          data: d.data,
          label: d ? d.data.name : "",
          value: d && d.data ? d.data.value : ""
        }).length : 0;
      }).sort((a, b) => b - a);
      const idx = Math.ceil(this.data.length / 2);
      this.medianSize = sortedLengths[idx];
    }
    const cards = this.getCards();
    this.cards = cards.filter((d) => d.data.value !== null);
    this.emptySlots = cards.filter((d) => d.data.value === null);
  }
  getCards() {
    const yPadding = typeof this.innerPadding === "number" ? this.innerPadding : this.innerPadding[0] + this.innerPadding[2];
    const xPadding = typeof this.innerPadding === "number" ? this.innerPadding : this.innerPadding[1] + this.innerPadding[3];
    return this.data.map((d, index) => {
      let label = d.data.name;
      if (label && label.constructor.name === "Date") {
        label = label.toLocaleDateString();
      } else {
        label = label ? label.toLocaleString() : label;
      }
      const value2 = d.data.value;
      const valueColor = label ? this.colors.getColor(label) : this.emptyColor;
      const color2 = this.cardColor || valueColor || "#000";
      return {
        x: d.x,
        y: d.y,
        width: d.width - xPadding,
        height: d.height - yPadding,
        color: color2,
        bandColor: this.bandColor || valueColor,
        textColor: this.textColor || invertColor(color2),
        label,
        data: d.data,
        tooltipText: `${label}: ${value2}`
      };
    });
  }
  trackBy(index, card) {
    return card.label;
  }
  onClick(data) {
    this.select.emit(data);
  }
};
_CardSeriesComponent.\u0275fac = function CardSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CardSeriesComponent)();
};
_CardSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _CardSeriesComponent,
  selectors: [["g", "ngx-charts-card-series", ""]],
  inputs: {
    data: "data",
    dims: "dims",
    colors: "colors",
    innerPadding: "innerPadding",
    cardColor: "cardColor",
    bandColor: "bandColor",
    emptyColor: "emptyColor",
    textColor: "textColor",
    valueFormatting: "valueFormatting",
    labelFormatting: "labelFormatting",
    animations: "animations"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c47,
  decls: 2,
  vars: 4,
  consts: [["class", "card-empty", "rx", "3", "ry", "3", 3, "fill", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-card", "", 3, "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["rx", "3", "ry", "3", 1, "card-empty"], ["ngx-charts-card", "", 3, "select", "x", "y", "width", "height", "color", "bandColor", "textColor", "data", "label", "medianSize", "valueFormatting", "labelFormatting", "animations"]],
  template: function CardSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, CardSeriesComponent__svg_rect_0_Template, 1, 6, "rect", 0)(1, CardSeriesComponent__svg_g_1_Template, 1, 13, "g", 1);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.emptySlots)("ngForTrackBy", ctx.trackBy);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.cards)("ngForTrackBy", ctx.trackBy);
    }
  },
  dependencies: [NgForOf, CardComponent],
  encapsulation: 2,
  changeDetection: 0
});
var CardSeriesComponent = _CardSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CardSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-card-series]",
      template: `
    <svg:rect
      *ngFor="let c of emptySlots; trackBy: trackBy"
      class="card-empty"
      [attr.x]="c.x"
      [attr.y]="c.y"
      [style.fill]="emptyColor"
      [attr.width]="c.width"
      [attr.height]="c.height"
      rx="3"
      ry="3"
    />
    <svg:g
      ngx-charts-card
      *ngFor="let c of cards; trackBy: trackBy"
      [x]="c.x"
      [y]="c.y"
      [width]="c.width"
      [height]="c.height"
      [color]="c.color"
      [bandColor]="c.bandColor"
      [textColor]="c.textColor"
      [data]="c.data"
      [label]="c.label"
      [medianSize]="medianSize"
      [valueFormatting]="valueFormatting"
      [labelFormatting]="labelFormatting"
      [animations]="animations"
      (select)="onClick($event)"
    />
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    innerPadding: [{
      type: Input
    }],
    cardColor: [{
      type: Input
    }],
    bandColor: [{
      type: Input
    }],
    emptyColor: [{
      type: Input
    }],
    textColor: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
var _NumberCardComponent = class _NumberCardComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.emptyColor = "rgba(0, 0, 0, 0)";
    this.innerPadding = 15;
    this.margin = [10, 10, 10, 10];
  }
  get clickable() {
    return !!this.select.observers.length;
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin
    });
    this.formatDates();
    this.domain = this.getDomain();
    this.setColors();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
    const size2 = gridSize(this.dims, this.results.length, 150);
    const N = size2[0] * size2[1];
    const data = this.results.slice();
    while (data.length < N) {
      data.push({
        value: null
      });
    }
    this.data = gridLayout(this.dims, data, 150, this.designatedTotal);
  }
  getDomain() {
    return this.results.map((d) => d.label);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
};
_NumberCardComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275NumberCardComponent_BaseFactory;
  return function NumberCardComponent_Factory(__ngFactoryType__) {
    return (\u0275NumberCardComponent_BaseFactory || (\u0275NumberCardComponent_BaseFactory = \u0275\u0275getInheritedFactory(_NumberCardComponent)))(__ngFactoryType__ || _NumberCardComponent);
  };
})();
_NumberCardComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _NumberCardComponent,
  selectors: [["ngx-charts-number-card"]],
  inputs: {
    cardColor: "cardColor",
    bandColor: "bandColor",
    emptyColor: "emptyColor",
    innerPadding: "innerPadding",
    textColor: "textColor",
    valueFormatting: "valueFormatting",
    labelFormatting: "labelFormatting",
    designatedTotal: "designatedTotal"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 3,
  vars: 20,
  consts: [[3, "view", "showLegend", "animations"], [1, "number-card", "chart"], ["ngx-charts-card-series", "", 3, "select", "colors", "cardColor", "bandColor", "textColor", "emptyColor", "data", "dims", "innerPadding", "valueFormatting", "labelFormatting", "animations"]],
  template: function NumberCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1)(2, "g", 2);
      \u0275\u0275listener("select", function NumberCardComponent_Template_g_select_2_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(17, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275classProp("clickable", ctx.clickable);
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("colors", ctx.colors)("cardColor", ctx.cardColor)("bandColor", ctx.bandColor)("textColor", ctx.textColor)("emptyColor", ctx.emptyColor)("data", ctx.data)("dims", ctx.dims)("innerPadding", ctx.innerPadding)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("animations", ctx.animations);
    }
  },
  dependencies: [ChartComponent, CardSeriesComponent],
  styles: [_c25, "ngx-charts-number-card .cell .trimmed-label{font-size:12px;pointer-events:none;overflow:hidden;text-align:left;line-height:1em}ngx-charts-number-card .cell .trimmed-label p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;padding:0;margin:0}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var NumberCardComponent = _NumberCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberCardComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-number-card",
      template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g [attr.transform]="transform" class="number-card chart" [class.clickable]="clickable">
        <svg:g
          ngx-charts-card-series
          [colors]="colors"
          [cardColor]="cardColor"
          [bandColor]="bandColor"
          [textColor]="textColor"
          [emptyColor]="emptyColor"
          [data]="data"
          [dims]="dims"
          [innerPadding]="innerPadding"
          [valueFormatting]="valueFormatting"
          [labelFormatting]="labelFormatting"
          [animations]="animations"
          (select)="onClick($event)"
        />
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", "ngx-charts-number-card .cell .trimmed-label{font-size:12px;pointer-events:none;overflow:hidden;text-align:left;line-height:1em}ngx-charts-number-card .cell .trimmed-label p{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;width:100%;padding:0;margin:0}ngx-charts-number-card .cell .value-text{pointer-events:none}ngx-charts-number-card .number-card.clickable .cell .card,ngx-charts-number-card .number-card.clickable .cell .card-band{cursor:pointer}\n"]
    }]
  }], null, {
    cardColor: [{
      type: Input
    }],
    bandColor: [{
      type: Input
    }],
    emptyColor: [{
      type: Input
    }],
    innerPadding: [{
      type: Input
    }],
    textColor: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    designatedTotal: [{
      type: Input
    }]
  });
})();
var _NumberCardModule = class _NumberCardModule {
};
_NumberCardModule.\u0275fac = function NumberCardModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NumberCardModule)();
};
_NumberCardModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NumberCardModule
});
_NumberCardModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule]
});
var NumberCardModule = _NumberCardModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberCardModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [CardComponent, CardSeriesComponent, NumberCardComponent],
      exports: [CardComponent, CardSeriesComponent, NumberCardComponent]
    }]
  }], null, null);
})();
var _TreeMapCellComponent = class _TreeMapCellComponent {
  constructor(element) {
    this.gradient = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.initialized = false;
    this.orientation = BarOrientation;
    this.element = element.nativeElement;
  }
  ngOnChanges() {
    this.update();
    this.valueFormatting = this.valueFormatting || ((value2) => value2.toLocaleString());
    const labelFormatting = this.labelFormatting || ((cell) => escapeLabel(trimLabel(cell.label, 55)));
    const cellData = {
      data: this.data,
      label: this.label,
      value: this.value
    };
    this.formattedValue = this.valueFormatting(cellData.value);
    this.formattedLabel = labelFormatting(cellData);
    this.gradientId = "grad" + id2().toString();
    this.gradientUrl = `url(#${this.gradientId})`;
    this.gradientStops = this.getGradientStops();
  }
  update() {
    if (this.initialized) {
      this.animateToCurrentForm();
    } else {
      if (this.animations) {
        this.loadAnimation();
      }
      this.initialized = true;
    }
  }
  loadAnimation() {
    const node = select_default2(this.element).select(".cell");
    node.attr("opacity", 0).attr("x", this.x).attr("y", this.y);
    this.animateToCurrentForm();
  }
  getTextColor() {
    return invertColor(this.fill);
  }
  animateToCurrentForm() {
    const node = select_default2(this.element).select(".cell");
    if (this.animations) {
      node.transition().duration(750).attr("opacity", 1).attr("x", this.x).attr("y", this.y).attr("width", this.width).attr("height", this.height);
    } else {
      node.attr("opacity", 1).attr("x", this.x).attr("y", this.y).attr("width", this.width).attr("height", this.height);
    }
  }
  onClick() {
    this.select.emit(this.data);
  }
  getGradientStops() {
    return [{
      offset: 0,
      color: this.fill,
      opacity: 0.3
    }, {
      offset: 100,
      color: this.fill,
      opacity: 1
    }];
  }
};
_TreeMapCellComponent.\u0275fac = function TreeMapCellComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TreeMapCellComponent)(\u0275\u0275directiveInject(ElementRef));
};
_TreeMapCellComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TreeMapCellComponent,
  selectors: [["g", "ngx-charts-tree-map-cell", ""]],
  inputs: {
    data: "data",
    fill: "fill",
    x: "x",
    y: "y",
    width: "width",
    height: "height",
    label: "label",
    value: "value",
    valueFormatting: "valueFormatting",
    labelFormatting: "labelFormatting",
    gradient: "gradient",
    animations: "animations"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c48,
  decls: 4,
  vars: 7,
  consts: [[4, "ngIf"], [1, "cell", 3, "click"], ["class", "treemap-label", 3, "pointer-events", 4, "ngIf"], ["ngx-charts-svg-linear-gradient", "", 3, "orientation", "name", "stops"], [1, "treemap-label"], [1, "treemap-label", 3, "innerHTML"], ["class", "treemap-val", "ngx-charts-count-up", "", 3, "countTo", "valueFormatting", 4, "ngIf"], ["class", "treemap-val", 4, "ngIf"], ["ngx-charts-count-up", "", 1, "treemap-val", 3, "countTo", "valueFormatting"], [1, "treemap-val"]],
  template: function TreeMapCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g");
      \u0275\u0275template(1, TreeMapCellComponent__svg_defs_1_Template, 2, 3, "defs", 0);
      \u0275\u0275elementStart(2, "rect", 1);
      \u0275\u0275listener("click", function TreeMapCellComponent_Template_rect_click_2_listener() {
        return ctx.onClick();
      });
      \u0275\u0275elementEnd();
      \u0275\u0275template(3, TreeMapCellComponent__svg_foreignObject_3_Template, 6, 15, "foreignObject", 2);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.gradient);
      \u0275\u0275advance();
      \u0275\u0275attribute("fill", ctx.gradient ? ctx.gradientUrl : ctx.fill)("width", ctx.width)("height", ctx.height)("x", ctx.x)("y", ctx.y);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.width >= 70 && ctx.height >= 35);
    }
  },
  dependencies: [NgIf, CountUpDirective, SvgLinearGradientComponent],
  encapsulation: 2,
  changeDetection: 0
});
var TreeMapCellComponent = _TreeMapCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeMapCellComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-tree-map-cell]",
      template: `
    <svg:g>
      <defs *ngIf="gradient">
        <svg:g
          ngx-charts-svg-linear-gradient
          [orientation]="orientation.Vertical"
          [name]="gradientId"
          [stops]="gradientStops"
        />
      </defs>
      <svg:rect
        [attr.fill]="gradient ? gradientUrl : fill"
        [attr.width]="width"
        [attr.height]="height"
        [attr.x]="x"
        [attr.y]="y"
        class="cell"
        (click)="onClick()"
      />
      <svg:foreignObject
        *ngIf="width >= 70 && height >= 35"
        [attr.x]="x"
        [attr.y]="y"
        [attr.width]="width"
        [attr.height]="height"
        class="treemap-label"
        [style.pointer-events]="'none'"
      >
        <xhtml:p [style.color]="getTextColor()" [style.height]="height + 'px'" [style.width]="width + 'px'">
          <xhtml:span class="treemap-label" [innerHTML]="formattedLabel"> </xhtml:span>
          <xhtml:br />
          <xhtml:span
            *ngIf="animations"
            class="treemap-val"
            ngx-charts-count-up
            [countTo]="value"
            [valueFormatting]="valueFormatting"
          >
          </xhtml:span>
          <xhtml:span *ngIf="!animations" class="treemap-val">
            {{ formattedValue }}
          </xhtml:span>
        </xhtml:p>
      </svg:foreignObject>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }], {
    data: [{
      type: Input
    }],
    fill: [{
      type: Input
    }],
    x: [{
      type: Input
    }],
    y: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
var _TreeMapCellSeriesComponent = class _TreeMapCellSeriesComponent {
  constructor() {
    this.gradient = false;
    this.tooltipDisabled = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.styleTypes = StyleTypes;
    this.placementTypes = PlacementTypes;
  }
  ngOnChanges(changes) {
    this.cells = this.getCells();
  }
  getCells() {
    return this.data.children.filter((d) => {
      return d.depth === 1;
    }).map((d, index) => {
      const label = d.id;
      return {
        data: d.data,
        x: d.x0,
        y: d.y0,
        width: d.x1 - d.x0,
        height: d.y1 - d.y0,
        fill: this.colors.getColor(label),
        label,
        value: d.value
      };
    });
  }
  getTooltipText({
    label,
    value: value2
  }) {
    return `
      <span class="tooltip-label">${escapeLabel(label)}</span>
      <span class="tooltip-val">${value2.toLocaleString()}</span>
    `;
  }
  onClick(data) {
    this.select.emit(data);
  }
  trackBy(index, item) {
    return item.label;
  }
};
_TreeMapCellSeriesComponent.\u0275fac = function TreeMapCellSeriesComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TreeMapCellSeriesComponent)();
};
_TreeMapCellSeriesComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TreeMapCellSeriesComponent,
  selectors: [["g", "ngx-charts-tree-map-cell-series", ""]],
  inputs: {
    data: "data",
    dims: "dims",
    colors: "colors",
    valueFormatting: "valueFormatting",
    labelFormatting: "labelFormatting",
    gradient: "gradient",
    tooltipDisabled: "tooltipDisabled",
    tooltipTemplate: "tooltipTemplate",
    animations: "animations"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c49,
  decls: 1,
  vars: 2,
  consts: [["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "data", "x", "y", "width", "height", "fill", "label", "value", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext", "select", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-tree-map-cell", "", "ngx-tooltip", "", 3, "select", "data", "x", "y", "width", "height", "fill", "label", "value", "valueFormatting", "labelFormatting", "gradient", "animations", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"]],
  template: function TreeMapCellSeriesComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275template(0, TreeMapCellSeriesComponent__svg_g_0_Template, 1, 18, "g", 0);
    }
    if (rf & 2) {
      \u0275\u0275property("ngForOf", ctx.cells)("ngForTrackBy", ctx.trackBy);
    }
  },
  dependencies: [NgForOf, TooltipDirective, TreeMapCellComponent],
  encapsulation: 2,
  changeDetection: 0
});
var TreeMapCellSeriesComponent = _TreeMapCellSeriesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeMapCellSeriesComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-tree-map-cell-series]",
      template: `
    <svg:g
      ngx-charts-tree-map-cell
      *ngFor="let c of cells; trackBy: trackBy"
      [data]="c.data"
      [x]="c.x"
      [y]="c.y"
      [width]="c.width"
      [height]="c.height"
      [fill]="c.fill"
      [label]="c.label"
      [value]="c.value"
      [valueFormatting]="valueFormatting"
      [labelFormatting]="labelFormatting"
      [gradient]="gradient"
      [animations]="animations"
      (select)="onClick($event)"
      ngx-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="placementTypes.Top"
      [tooltipType]="styleTypes.tooltip"
      [tooltipTitle]="tooltipTemplate ? undefined : getTooltipText(c)"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="c.data"
    ></svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    dims: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }]
  });
})();
var _TreeMapComponent = class _TreeMapComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.tooltipDisabled = false;
    this.gradient = false;
    this.select = new EventEmitter();
    this.margin = [10, 10, 10, 10];
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin
    });
    this.domain = this.getDomain();
    this.treemap = treemap_default().size([this.dims.width, this.dims.height]);
    const rootNode = {
      name: "root",
      value: 0,
      isRoot: true
    };
    const root3 = stratify_default().id((d) => {
      let label = d.name;
      if (label.constructor.name === "Date") {
        label = label.toLocaleDateString();
      } else {
        label = label.toLocaleString();
      }
      return label;
    }).parentId((d) => d.isRoot ? null : "root")([rootNode, ...this.results]).sum((d) => d.value);
    this.data = this.treemap(root3);
    this.setColors();
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getDomain() {
    return this.results.map((d) => d.name);
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
};
_TreeMapComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275TreeMapComponent_BaseFactory;
  return function TreeMapComponent_Factory(__ngFactoryType__) {
    return (\u0275TreeMapComponent_BaseFactory || (\u0275TreeMapComponent_BaseFactory = \u0275\u0275getInheritedFactory(_TreeMapComponent)))(__ngFactoryType__ || _TreeMapComponent);
  };
})();
_TreeMapComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _TreeMapComponent,
  selectors: [["ngx-charts-tree-map"]],
  contentQueries: function TreeMapComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    results: "results",
    tooltipDisabled: "tooltipDisabled",
    valueFormatting: "valueFormatting",
    labelFormatting: "labelFormatting",
    gradient: "gradient"
  },
  outputs: {
    select: "select"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 3,
  vars: 16,
  consts: [[3, "view", "showLegend", "animations"], [1, "tree-map", "chart"], ["ngx-charts-tree-map-cell-series", "", 3, "select", "colors", "data", "dims", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "labelFormatting", "gradient", "animations"]],
  template: function TreeMapComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1)(2, "g", 2);
      \u0275\u0275listener("select", function TreeMapComponent_Template_g_select_2_listener($event) {
        return ctx.onClick($event);
      });
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(13, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("colors", ctx.colors)("data", ctx.data)("dims", ctx.dims)("tooltipDisabled", ctx.tooltipDisabled)("tooltipTemplate", ctx.tooltipTemplate)("valueFormatting", ctx.valueFormatting)("labelFormatting", ctx.labelFormatting)("gradient", ctx.gradient)("animations", ctx.animations);
    }
  },
  dependencies: [ChartComponent, TreeMapCellSeriesComponent],
  styles: [".tree-map .treemap-val{font-size:1.3em;padding-top:5px;display:inline-block}.tree-map .treemap-label p{display:table-cell;text-align:center;line-height:1.2em;vertical-align:middle}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var TreeMapComponent = _TreeMapComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeMapComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-tree-map",
      template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations">
      <svg:g [attr.transform]="transform" class="tree-map chart">
        <svg:g
          ngx-charts-tree-map-cell-series
          [colors]="colors"
          [data]="data"
          [dims]="dims"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [valueFormatting]="valueFormatting"
          [labelFormatting]="labelFormatting"
          [gradient]="gradient"
          [animations]="animations"
          (select)="onClick($event)"
        />
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".tree-map .treemap-val{font-size:1.3em;padding-top:5px;display:inline-block}.tree-map .treemap-label p{display:table-cell;text-align:center;line-height:1.2em;vertical-align:middle}\n"]
    }]
  }], null, {
    results: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _TreeMapModule = class _TreeMapModule {
};
_TreeMapModule.\u0275fac = function TreeMapModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _TreeMapModule)();
};
_TreeMapModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _TreeMapModule
});
_TreeMapModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule]
});
var TreeMapModule = _TreeMapModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeMapModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [TreeMapCellComponent, TreeMapCellSeriesComponent, TreeMapComponent],
      exports: [TreeMapCellComponent, TreeMapCellSeriesComponent, TreeMapComponent]
    }]
  }], null, null);
})();
var ElementType;
(function(ElementType2) {
  ElementType2["Value"] = "value";
  ElementType2["Units"] = "units";
})(ElementType || (ElementType = {}));
var _LinearGaugeComponent = class _LinearGaugeComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.min = 0;
    this.max = 100;
    this.value = 0;
    this.margin = [10, 20, 10, 20];
    this.valueResizeScale = 1;
    this.unitsResizeScale = 1;
    this.valueTextTransform = "";
    this.valueTranslate = "";
    this.unitsTextTransform = "";
    this.unitsTranslate = "";
    this.barOrientation = BarOrientation;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    setTimeout(() => {
      this.scaleText(ElementType.Value);
      this.scaleText(ElementType.Units);
    });
  }
  update() {
    super.update();
    this.hasPreviousValue = this.previousValue !== void 0;
    this.max = Math.max(this.max, this.value);
    this.min = Math.min(this.min, this.value);
    if (this.hasPreviousValue) {
      this.max = Math.max(this.max, this.previousValue);
      this.min = Math.min(this.min, this.previousValue);
    }
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin
    });
    this.valueDomain = this.getValueDomain();
    this.valueScale = this.getValueScale();
    this.displayValue = this.getDisplayValue();
    this.setColors();
    const xOffset = this.margin[3] + this.dims.width / 2;
    const yOffset = this.margin[0] + this.dims.height / 2;
    this.transform = `translate(${xOffset}, ${yOffset})`;
    this.transformLine = `translate(${this.margin[3] + this.valueScale(this.previousValue)}, ${yOffset})`;
    this.valueTranslate = `translate(0, -15)`;
    this.unitsTranslate = `translate(0, 15)`;
    if (isPlatformServer(this.platformId)) {
      this.scaleTextSSR("value");
      this.scaleTextSSR("units");
    } else {
      setTimeout(() => this.scaleText(ElementType.Value), 50);
      setTimeout(() => this.scaleText(ElementType.Units), 50);
    }
  }
  getValueDomain() {
    return [this.min, this.max];
  }
  getValueScale() {
    return linear2().range([0, this.dims.width]).domain(this.valueDomain);
  }
  getDisplayValue() {
    if (this.valueFormatting) {
      return this.valueFormatting(this.value);
    }
    return this.value.toLocaleString();
  }
  scaleText(element, repeat = true) {
    let el;
    let resizeScale;
    if (element === ElementType.Value) {
      el = this.valueTextEl;
      resizeScale = this.valueResizeScale;
    } else {
      el = this.unitsTextEl;
      resizeScale = this.unitsResizeScale;
    }
    const {
      width,
      height
    } = el.nativeElement.getBoundingClientRect();
    if (width === 0 || height === 0) return;
    const oldScale = resizeScale;
    const availableWidth = this.dims.width;
    const availableHeight = Math.max(this.dims.height / 2 - 15, 0);
    const resizeScaleWidth = Math.floor(availableWidth / (width / resizeScale) * 100) / 100;
    const resizeScaleHeight = Math.floor(availableHeight / (height / resizeScale) * 100) / 100;
    resizeScale = Math.min(resizeScaleHeight, resizeScaleWidth);
    if (resizeScale !== oldScale) {
      if (element === ElementType.Value) {
        this.valueResizeScale = resizeScale;
        this.valueTextTransform = `scale(${resizeScale}, ${resizeScale})`;
      } else {
        this.unitsResizeScale = resizeScale;
        this.unitsTextTransform = `scale(${resizeScale}, ${resizeScale})`;
      }
      this.cd.markForCheck();
      if (repeat && isPlatformBrowser(this.platformId)) {
        setTimeout(() => {
          this.scaleText(element, false);
        }, 50);
      }
    }
  }
  scaleTextSSR(element) {
    let resizeScale = 1;
    const value2 = element === "value" ? this.displayValue : this.units;
    const width = calculateTextWidth(VERDANA_FONT_WIDTHS_16_PX, value2, 10);
    const height = 25;
    const availableWidth = this.dims.width;
    const availableHeight = Math.max(this.dims.height / 2 - 15, 0);
    const resizeScaleWidth = Math.floor(availableWidth / (width / resizeScale) * 100) / 100;
    const resizeScaleHeight = Math.floor(availableHeight / (height / resizeScale) * 100) / 100;
    resizeScale = Math.min(resizeScaleHeight, resizeScaleWidth);
    if (element === "value") {
      this.valueResizeScale = resizeScale;
      this.valueTextTransform = `scale(${resizeScale}, ${resizeScale})`;
    } else {
      this.unitsResizeScale = resizeScale;
      this.unitsTextTransform = `scale(${resizeScale}, ${resizeScale})`;
    }
    this.cd.markForCheck();
  }
  onClick() {
    this.select.emit({
      name: "Value",
      value: this.value
    });
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, [this.value], this.customColors);
  }
};
_LinearGaugeComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275LinearGaugeComponent_BaseFactory;
  return function LinearGaugeComponent_Factory(__ngFactoryType__) {
    return (\u0275LinearGaugeComponent_BaseFactory || (\u0275LinearGaugeComponent_BaseFactory = \u0275\u0275getInheritedFactory(_LinearGaugeComponent)))(__ngFactoryType__ || _LinearGaugeComponent);
  };
})();
_LinearGaugeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _LinearGaugeComponent,
  selectors: [["ngx-charts-linear-gauge"]],
  viewQuery: function LinearGaugeComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c50, 5);
      \u0275\u0275viewQuery(_c51, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.valueTextEl = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.unitsTextEl = _t.first);
    }
  },
  inputs: {
    min: "min",
    max: "max",
    value: "value",
    units: "units",
    previousValue: "previousValue",
    valueFormatting: "valueFormatting"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 15,
  vars: 38,
  consts: [["valueTextEl", ""], ["unitsTextEl", ""], [3, "click", "view", "showLegend", "animations"], [1, "linear-gauge", "chart"], ["ngx-charts-bar", "", 1, "background-bar", 3, "width", "height", "x", "y", "data", "orientation", "roundEdges", "animations"], ["ngx-charts-bar", "", 3, "width", "height", "x", "y", "fill", "data", "orientation", "roundEdges", "animations"], ["x1", "0", "y1", "5", "x2", "0", "y2", "15", 4, "ngIf"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15", 4, "ngIf"], ["alignment-baseline", "after-edge", 1, "value"], ["alignment-baseline", "before-edge", 1, "units"], ["x1", "0", "y1", "5", "x2", "0", "y2", "15"], ["x1", "0", "y1", "-5", "x2", "0", "y2", "-15"]],
  template: function LinearGaugeComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "ngx-charts-chart", 2);
      \u0275\u0275listener("click", function LinearGaugeComponent_Template_ngx_charts_chart_click_0_listener() {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.onClick());
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 3);
      \u0275\u0275element(2, "g", 4)(3, "g", 5);
      \u0275\u0275template(4, LinearGaugeComponent__svg_line_4_Template, 1, 2, "line", 6)(5, LinearGaugeComponent__svg_line_5_Template, 1, 2, "line", 7);
      \u0275\u0275elementStart(6, "g")(7, "g")(8, "text", 8, 0);
      \u0275\u0275text(10);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(11, "g")(12, "text", 9, 1);
      \u0275\u0275text(14);
      \u0275\u0275elementEnd()()()()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(33, _c24, ctx.width, ctx.height))("showLegend", false)("animations", ctx.animations);
      \u0275\u0275advance(2);
      \u0275\u0275property("width", ctx.dims.width)("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("data", \u0275\u0275pureFunction0(36, _c522))("orientation", ctx.barOrientation.Horizontal)("roundEdges", true)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275property("width", ctx.valueScale(ctx.value))("height", 3)("x", ctx.margin[3])("y", ctx.dims.height / 2 + ctx.margin[0] - 2)("fill", ctx.colors.getColor(ctx.units))("data", \u0275\u0275pureFunction0(37, _c522))("orientation", ctx.barOrientation.Horizontal)("roundEdges", true)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.hasPreviousValue);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.hasPreviousValue);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.valueTranslate);
      \u0275\u0275advance();
      \u0275\u0275styleProp("text-anchor", "middle");
      \u0275\u0275attribute("transform", ctx.valueTextTransform);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.displayValue, " ");
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.unitsTranslate);
      \u0275\u0275advance();
      \u0275\u0275styleProp("text-anchor", "middle");
      \u0275\u0275attribute("transform", ctx.unitsTextTransform);
      \u0275\u0275advance(2);
      \u0275\u0275textInterpolate1(" ", ctx.units, " ");
    }
  },
  dependencies: [NgIf, ChartComponent, BarComponent],
  styles: [_c25, ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:#0000000d}.linear-gauge .units{fill:#666}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var LinearGaugeComponent = _LinearGaugeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LinearGaugeComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-linear-gauge",
      template: `
    <ngx-charts-chart [view]="[width, height]" [showLegend]="false" [animations]="animations" (click)="onClick()">
      <svg:g class="linear-gauge chart">
        <svg:g
          ngx-charts-bar
          class="background-bar"
          [width]="dims.width"
          [height]="3"
          [x]="margin[3]"
          [y]="dims.height / 2 + margin[0] - 2"
          [data]="{}"
          [orientation]="barOrientation.Horizontal"
          [roundEdges]="true"
          [animations]="animations"
        ></svg:g>
        <svg:g
          ngx-charts-bar
          [width]="valueScale(value)"
          [height]="3"
          [x]="margin[3]"
          [y]="dims.height / 2 + margin[0] - 2"
          [fill]="colors.getColor(units)"
          [data]="{}"
          [orientation]="barOrientation.Horizontal"
          [roundEdges]="true"
          [animations]="animations"
        ></svg:g>

        <svg:line
          *ngIf="hasPreviousValue"
          [attr.transform]="transformLine"
          x1="0"
          y1="5"
          x2="0"
          y2="15"
          [attr.stroke]="colors.getColor(units)"
        />

        <svg:line
          *ngIf="hasPreviousValue"
          [attr.transform]="transformLine"
          x1="0"
          y1="-5"
          x2="0"
          y2="-15"
          [attr.stroke]="colors.getColor(units)"
        />

        <svg:g [attr.transform]="transform">
          <svg:g [attr.transform]="valueTranslate">
            <svg:text
              #valueTextEl
              class="value"
              [style.textAnchor]="'middle'"
              [attr.transform]="valueTextTransform"
              alignment-baseline="after-edge"
            >
              {{ displayValue }}
            </svg:text>
          </svg:g>

          <svg:g [attr.transform]="unitsTranslate">
            <svg:text
              #unitsTextEl
              class="units"
              [style.textAnchor]="'middle'"
              [attr.transform]="unitsTextTransform"
              alignment-baseline="before-edge"
            >
              {{ units }}
            </svg:text>
          </svg:g>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".linear-gauge{cursor:pointer}.linear-gauge .background-bar path{fill:#0000000d}.linear-gauge .units{fill:#666}\n"]
    }]
  }], null, {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    units: [{
      type: Input
    }],
    previousValue: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    valueTextEl: [{
      type: ViewChild,
      args: ["valueTextEl"]
    }],
    unitsTextEl: [{
      type: ViewChild,
      args: ["unitsTextEl"]
    }]
  });
})();
var _GaugeArcComponent = class _GaugeArcComponent {
  constructor() {
    this.isActive = false;
    this.tooltipDisabled = false;
    this.animations = true;
    this.select = new EventEmitter();
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.placementTypes = PlacementTypes;
    this.styleTypes = StyleTypes;
  }
  tooltipText(arc) {
    const label = formatLabel(arc.data.name);
    let val;
    if (this.valueFormatting) {
      val = this.valueFormatting(arc.data.value);
    } else {
      val = formatLabel(arc.data.value);
    }
    return `
      <span class="tooltip-label">${escapeLabel(label)}</span>
      <span class="tooltip-val">${val}</span>
    `;
  }
};
_GaugeArcComponent.\u0275fac = function GaugeArcComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GaugeArcComponent)();
};
_GaugeArcComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _GaugeArcComponent,
  selectors: [["g", "ngx-charts-gauge-arc", ""]],
  inputs: {
    backgroundArc: "backgroundArc",
    valueArc: "valueArc",
    cornerRadius: "cornerRadius",
    colors: "colors",
    isActive: "isActive",
    tooltipDisabled: "tooltipDisabled",
    valueFormatting: "valueFormatting",
    tooltipTemplate: "tooltipTemplate",
    animations: "animations"
  },
  outputs: {
    select: "select",
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  attrs: _c53,
  decls: 2,
  vars: 23,
  consts: [["ngx-charts-pie-arc", "", 1, "background-arc", 3, "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "data", "animate", "pointerEvents"], ["ngx-charts-pie-arc", "", "ngx-tooltip", "", 3, "select", "activate", "deactivate", "startAngle", "endAngle", "innerRadius", "outerRadius", "cornerRadius", "fill", "data", "animate", "isActive", "tooltipDisabled", "tooltipPlacement", "tooltipType", "tooltipTitle", "tooltipTemplate", "tooltipContext"]],
  template: function GaugeArcComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275element(0, "g", 0);
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275listener("select", function GaugeArcComponent_Template_g_select_1_listener($event) {
        return ctx.select.emit($event);
      })("activate", function GaugeArcComponent_Template_g_activate_1_listener($event) {
        return ctx.activate.emit($event);
      })("deactivate", function GaugeArcComponent_Template_g_deactivate_1_listener($event) {
        return ctx.deactivate.emit($event);
      });
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("startAngle", 0)("endAngle", ctx.backgroundArc.endAngle)("innerRadius", ctx.backgroundArc.innerRadius)("outerRadius", ctx.backgroundArc.outerRadius)("cornerRadius", ctx.cornerRadius)("data", ctx.backgroundArc.data)("animate", false)("pointerEvents", false);
      \u0275\u0275advance();
      \u0275\u0275property("startAngle", 0)("endAngle", ctx.valueArc.endAngle)("innerRadius", ctx.valueArc.innerRadius)("outerRadius", ctx.valueArc.outerRadius)("cornerRadius", ctx.cornerRadius)("fill", ctx.colors.getColor(ctx.valueArc.data.name))("data", ctx.valueArc.data)("animate", ctx.animations)("isActive", ctx.isActive)("tooltipDisabled", ctx.tooltipDisabled)("tooltipPlacement", ctx.placementTypes.Top)("tooltipType", ctx.styleTypes.tooltip)("tooltipTitle", ctx.tooltipTemplate ? void 0 : ctx.tooltipText(ctx.valueArc))("tooltipTemplate", ctx.tooltipTemplate)("tooltipContext", ctx.valueArc.data);
    }
  },
  dependencies: [TooltipDirective, PieArcComponent],
  encapsulation: 2,
  changeDetection: 0
});
var GaugeArcComponent = _GaugeArcComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GaugeArcComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-gauge-arc]",
      template: `
    <svg:g
      ngx-charts-pie-arc
      class="background-arc"
      [startAngle]="0"
      [endAngle]="backgroundArc.endAngle"
      [innerRadius]="backgroundArc.innerRadius"
      [outerRadius]="backgroundArc.outerRadius"
      [cornerRadius]="cornerRadius"
      [data]="backgroundArc.data"
      [animate]="false"
      [pointerEvents]="false"
    ></svg:g>
    <svg:g
      ngx-charts-pie-arc
      [startAngle]="0"
      [endAngle]="valueArc.endAngle"
      [innerRadius]="valueArc.innerRadius"
      [outerRadius]="valueArc.outerRadius"
      [cornerRadius]="cornerRadius"
      [fill]="colors.getColor(valueArc.data.name)"
      [data]="valueArc.data"
      [animate]="animations"
      [isActive]="isActive"
      (select)="select.emit($event)"
      (activate)="activate.emit($event)"
      (deactivate)="deactivate.emit($event)"
      ngx-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="placementTypes.Top"
      [tooltipType]="styleTypes.tooltip"
      [tooltipTitle]="tooltipTemplate ? undefined : tooltipText(valueArc)"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="valueArc.data"
    ></svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    backgroundArc: [{
      type: Input
    }],
    valueArc: [{
      type: Input
    }],
    cornerRadius: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    tooltipTemplate: [{
      type: Input
    }],
    animations: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }]
  });
})();
var _GaugeAxisComponent = class _GaugeAxisComponent {
  constructor() {
    this.rotate = "";
  }
  ngOnChanges(changes) {
    this.update();
  }
  update() {
    this.rotationAngle = -90 + this.startAngle;
    this.rotate = `rotate(${this.rotationAngle})`;
    this.ticks = this.getTicks();
  }
  getTicks() {
    const bigTickSegment = this.angleSpan / this.bigSegments;
    const smallTickSegment = bigTickSegment / this.smallSegments;
    const tickLength = 20;
    const ticks2 = {
      big: [],
      small: []
    };
    const startDistance = this.radius + 10;
    const textDist = startDistance + tickLength + 10;
    for (let i = 0; i <= this.bigSegments; i++) {
      const angleDeg = i * bigTickSegment;
      const angle = angleDeg * Math.PI / 180;
      const textAnchor = this.getTextAnchor(angleDeg);
      let skip = false;
      if (i === 0 && this.angleSpan === 360) {
        skip = true;
      }
      if (!skip) {
        let text2 = Number.parseFloat(this.valueScale.invert(angleDeg).toString()).toLocaleString();
        if (this.tickFormatting) {
          text2 = this.tickFormatting(text2);
        }
        ticks2.big.push({
          line: this.getTickPath(startDistance, tickLength, angle),
          textAnchor,
          text: text2,
          textTransform: `
            translate(${textDist * Math.cos(angle)}, ${textDist * Math.sin(angle)}) rotate(${-this.rotationAngle})
          `
        });
      }
      if (i === this.bigSegments) {
        continue;
      }
      for (let j = 1; j <= this.smallSegments; j++) {
        const smallAngleDeg = angleDeg + j * smallTickSegment;
        const smallAngle = smallAngleDeg * Math.PI / 180;
        ticks2.small.push({
          line: this.getTickPath(startDistance, tickLength / 2, smallAngle)
        });
      }
    }
    return ticks2;
  }
  getTextAnchor(angle) {
    angle = (this.startAngle + angle) % 360;
    let textAnchor = TextAnchor.Middle;
    if (angle > 45 && angle <= 135) {
      textAnchor = TextAnchor.Start;
    } else if (angle > 225 && angle <= 315) {
      textAnchor = TextAnchor.End;
    }
    return textAnchor;
  }
  getTickPath(startDistance, tickLength, angle) {
    const y1 = startDistance * Math.sin(angle);
    const y22 = (startDistance + tickLength) * Math.sin(angle);
    const x1 = startDistance * Math.cos(angle);
    const x22 = (startDistance + tickLength) * Math.cos(angle);
    const points = [{
      x: x1,
      y: y1
    }, {
      x: x22,
      y: y22
    }];
    const lineGenerator = line_default().x((d) => d.x).y((d) => d.y);
    return lineGenerator(points);
  }
};
_GaugeAxisComponent.\u0275fac = function GaugeAxisComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GaugeAxisComponent)();
};
_GaugeAxisComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _GaugeAxisComponent,
  selectors: [["g", "ngx-charts-gauge-axis", ""]],
  inputs: {
    bigSegments: "bigSegments",
    smallSegments: "smallSegments",
    min: "min",
    max: "max",
    angleSpan: "angleSpan",
    startAngle: "startAngle",
    radius: "radius",
    valueScale: "valueScale",
    tickFormatting: "tickFormatting"
  },
  standalone: false,
  features: [\u0275\u0275NgOnChangesFeature],
  attrs: _c54,
  decls: 4,
  vars: 4,
  consts: [["class", "gauge-tick gauge-tick-large", 4, "ngFor", "ngForOf"], ["class", "gauge-tick gauge-tick-small", 4, "ngFor", "ngForOf"], [1, "gauge-tick", "gauge-tick-large"], ["alignment-baseline", "central"], [1, "gauge-tick", "gauge-tick-small"]],
  template: function GaugeAxisComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(0, "g");
      \u0275\u0275template(1, GaugeAxisComponent__svg_g_1_Template, 2, 1, "g", 0)(2, GaugeAxisComponent__svg_g_2_Template, 3, 4, "g", 0)(3, GaugeAxisComponent__svg_g_3_Template, 2, 1, "g", 1);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275attribute("transform", ctx.rotate);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.ticks.big);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.ticks.big);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.ticks.small);
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2,
  changeDetection: 0
});
var GaugeAxisComponent = _GaugeAxisComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GaugeAxisComponent, [{
    type: Component,
    args: [{
      selector: "g[ngx-charts-gauge-axis]",
      template: `
    <svg:g [attr.transform]="rotate">
      <svg:g *ngFor="let tick of ticks.big" class="gauge-tick gauge-tick-large">
        <svg:path [attr.d]="tick.line" />
      </svg:g>
      <svg:g *ngFor="let tick of ticks.big" class="gauge-tick gauge-tick-large">
        <svg:text
          [style.textAnchor]="tick.textAnchor"
          [attr.transform]="tick.textTransform"
          alignment-baseline="central"
        >
          {{ tick.text }}
        </svg:text>
      </svg:g>
      <svg:g *ngFor="let tick of ticks.small" class="gauge-tick gauge-tick-small">
        <svg:path [attr.d]="tick.line" />
      </svg:g>
    </svg:g>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    bigSegments: [{
      type: Input
    }],
    smallSegments: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    angleSpan: [{
      type: Input
    }],
    startAngle: [{
      type: Input
    }],
    radius: [{
      type: Input
    }],
    valueScale: [{
      type: Input
    }],
    tickFormatting: [{
      type: Input
    }]
  });
})();
var _GaugeComponent = class _GaugeComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.legend = false;
    this.legendTitle = "Legend";
    this.legendPosition = LegendPosition.Right;
    this.min = 0;
    this.max = 100;
    this.bigSegments = 10;
    this.smallSegments = 5;
    this.showAxis = true;
    this.startAngle = -120;
    this.angleSpan = 240;
    this.activeEntries = [];
    this.tooltipDisabled = false;
    this.showText = true;
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.resizeScale = 1;
    this.rotation = "";
    this.textTransform = "scale(1, 1)";
    this.cornerRadius = 10;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    setTimeout(() => this.scaleText());
  }
  update() {
    super.update();
    if (!this.showAxis) {
      if (!this.margin) {
        this.margin = [10, 20, 10, 20];
      }
    } else {
      if (!this.margin) {
        this.margin = [60, 100, 60, 100];
      }
    }
    if (this.startAngle < 0) {
      this.startAngle = this.startAngle % 360 + 360;
    }
    this.angleSpan = Math.min(this.angleSpan, 360);
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      showLegend: this.legend,
      legendPosition: this.legendPosition
    });
    this.domain = this.getDomain();
    this.valueDomain = this.getValueDomain();
    this.valueScale = this.getValueScale();
    this.displayValue = this.getDisplayValue();
    this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2;
    this.arcs = this.getArcs();
    this.setColors();
    this.legendOptions = this.getLegendOptions();
    const xOffset = this.margin[3] + this.dims.width / 2;
    const yOffset = this.margin[0] + this.dims.height / 2;
    this.transform = `translate(${xOffset}, ${yOffset})`;
    this.rotation = `rotate(${this.startAngle})`;
    setTimeout(() => this.scaleText(), 50);
  }
  getArcs() {
    const arcs = [];
    const availableRadius = this.outerRadius * 0.7;
    const radiusPerArc = Math.min(availableRadius / this.results.length, 10);
    const arcWidth = radiusPerArc * 0.7;
    this.textRadius = this.outerRadius - this.results.length * radiusPerArc;
    this.cornerRadius = Math.floor(arcWidth / 2);
    let i = 0;
    for (const d of this.results) {
      const outerRadius = this.outerRadius - i * radiusPerArc;
      const innerRadius = outerRadius - arcWidth;
      const backgroundArc = {
        endAngle: this.angleSpan * Math.PI / 180,
        innerRadius,
        outerRadius,
        data: {
          value: this.max,
          name: d.name
        }
      };
      const valueArc = {
        endAngle: Math.min(this.valueScale(d.value), this.angleSpan) * Math.PI / 180,
        innerRadius,
        outerRadius,
        data: {
          value: d.value,
          name: d.name
        }
      };
      const arc = {
        backgroundArc,
        valueArc
      };
      arcs.push(arc);
      i++;
    }
    return arcs;
  }
  getDomain() {
    return this.results.map((d) => d.name);
  }
  getValueDomain() {
    const values = this.results.map((d) => d.value);
    const dataMin = Math.min(...values);
    const dataMax = Math.max(...values);
    if (this.min !== void 0) {
      this.min = Math.min(this.min, dataMin);
    } else {
      this.min = dataMin;
    }
    if (this.max !== void 0) {
      this.max = Math.max(this.max, dataMax);
    } else {
      this.max = dataMax;
    }
    return [this.min, this.max];
  }
  getValueScale() {
    return linear2().range([0, this.angleSpan]).nice().domain(this.valueDomain);
  }
  getDisplayValue() {
    const value2 = this.results.map((d) => d.value).reduce((a, b) => a + b, 0);
    if (this.textValue && 0 !== this.textValue.length) {
      return this.textValue.toLocaleString();
    }
    if (this.valueFormatting) {
      return this.valueFormatting(value2);
    }
    return value2.toLocaleString();
  }
  scaleText(repeat = true) {
    if (!this.showText) {
      return;
    }
    const {
      width
    } = this.textEl.nativeElement.getBoundingClientRect();
    const oldScale = this.resizeScale;
    if (width === 0) {
      this.resizeScale = 1;
    } else {
      const availableSpace = this.textRadius;
      this.resizeScale = Math.floor(availableSpace / (width / this.resizeScale) * 100) / 100;
    }
    if (this.resizeScale !== oldScale) {
      this.textTransform = `scale(${this.resizeScale}, ${this.resizeScale})`;
      this.cd.markForCheck();
      if (repeat) {
        setTimeout(() => this.scaleText(false), 50);
      }
    }
  }
  onClick(data) {
    this.select.emit(data);
  }
  getLegendOptions() {
    return {
      scaleType: ScaleType.Ordinal,
      colors: this.colors,
      domain: this.domain,
      title: this.legendTitle,
      position: this.legendPosition
    };
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
  }
  onActivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    if (idx > -1) {
      return;
    }
    this.activeEntries = [item, ...this.activeEntries];
    this.activate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  onDeactivate(item) {
    const idx = this.activeEntries.findIndex((d) => {
      return d.name === item.name && d.value === item.value;
    });
    this.activeEntries.splice(idx, 1);
    this.activeEntries = [...this.activeEntries];
    this.deactivate.emit({
      value: item,
      entries: this.activeEntries
    });
  }
  isActive(entry) {
    if (!this.activeEntries) return false;
    const item = this.activeEntries.find((d) => {
      return entry.name === d.name && entry.series === d.series;
    });
    return item !== void 0;
  }
  trackBy(index, item) {
    return item.valueArc.data.name;
  }
};
_GaugeComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275GaugeComponent_BaseFactory;
  return function GaugeComponent_Factory(__ngFactoryType__) {
    return (\u0275GaugeComponent_BaseFactory || (\u0275GaugeComponent_BaseFactory = \u0275\u0275getInheritedFactory(_GaugeComponent)))(__ngFactoryType__ || _GaugeComponent);
  };
})();
_GaugeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _GaugeComponent,
  selectors: [["ngx-charts-gauge"]],
  contentQueries: function GaugeComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  viewQuery: function GaugeComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c45, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.textEl = _t.first);
    }
  },
  inputs: {
    legend: "legend",
    legendTitle: "legendTitle",
    legendPosition: "legendPosition",
    min: "min",
    max: "max",
    textValue: "textValue",
    units: "units",
    bigSegments: "bigSegments",
    smallSegments: "smallSegments",
    results: "results",
    showAxis: "showAxis",
    startAngle: "startAngle",
    angleSpan: "angleSpan",
    activeEntries: "activeEntries",
    axisTickFormatting: "axisTickFormatting",
    tooltipDisabled: "tooltipDisabled",
    valueFormatting: "valueFormatting",
    showText: "showText",
    margin: "margin"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 5,
  vars: 13,
  consts: [["textEl", ""], [3, "legendLabelClick", "legendLabelActivate", "legendLabelDeactivate", "view", "showLegend", "legendOptions", "activeEntries", "animations"], [1, "gauge", "chart"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting", 4, "ngIf"], ["alignment-baseline", "central", 3, "textAnchor", 4, "ngIf"], ["ngx-charts-gauge-arc", "", 3, "select", "activate", "deactivate", "backgroundArc", "valueArc", "cornerRadius", "colors", "isActive", "tooltipDisabled", "tooltipTemplate", "valueFormatting", "animations"], ["ngx-charts-gauge-axis", "", 3, "bigSegments", "smallSegments", "min", "max", "radius", "angleSpan", "valueScale", "startAngle", "tickFormatting"], ["alignment-baseline", "central"], ["x", "0", "dy", "0"], ["x", "0", "dy", "1.2em"]],
  template: function GaugeComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 1);
      \u0275\u0275listener("legendLabelClick", function GaugeComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {
        return ctx.onClick($event);
      })("legendLabelActivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {
        return ctx.onActivate($event);
      })("legendLabelDeactivate", function GaugeComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {
        return ctx.onDeactivate($event);
      });
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 2);
      \u0275\u0275template(2, GaugeComponent__svg_g_2_Template, 2, 10, "g", 3)(3, GaugeComponent__svg_g_3_Template, 1, 9, "g", 4)(4, GaugeComponent__svg_text_4_Template, 6, 5, "text", 5);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(10, _c24, ctx.width, ctx.height))("showLegend", ctx.legend)("legendOptions", ctx.legendOptions)("activeEntries", ctx.activeEntries)("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.arcs)("ngForTrackBy", ctx.trackBy);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showAxis);
      \u0275\u0275advance();
      \u0275\u0275property("ngIf", ctx.showText);
    }
  },
  dependencies: [NgForOf, NgIf, ChartComponent, GaugeArcComponent, GaugeAxisComponent],
  styles: [_c25, ".gauge .background-arc path{fill:#0000000d}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{font-size:12px;fill:#666;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}\n"],
  encapsulation: 2,
  changeDetection: 0
});
var GaugeComponent = _GaugeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GaugeComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-gauge",
      template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelClick)="onClick($event)"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
    >
      <svg:g [attr.transform]="transform" class="gauge chart">
        <svg:g *ngFor="let arc of arcs; trackBy: trackBy" [attr.transform]="rotation">
          <svg:g
            ngx-charts-gauge-arc
            [backgroundArc]="arc.backgroundArc"
            [valueArc]="arc.valueArc"
            [cornerRadius]="cornerRadius"
            [colors]="colors"
            [isActive]="isActive(arc.valueArc.data)"
            [tooltipDisabled]="tooltipDisabled"
            [tooltipTemplate]="tooltipTemplate"
            [valueFormatting]="valueFormatting"
            [animations]="animations"
            (select)="onClick($event)"
            (activate)="onActivate($event)"
            (deactivate)="onDeactivate($event)"
          ></svg:g>
        </svg:g>

        <svg:g
          ngx-charts-gauge-axis
          *ngIf="showAxis"
          [bigSegments]="bigSegments"
          [smallSegments]="smallSegments"
          [min]="min"
          [max]="max"
          [radius]="outerRadius"
          [angleSpan]="angleSpan"
          [valueScale]="valueScale"
          [startAngle]="startAngle"
          [tickFormatting]="axisTickFormatting"
        ></svg:g>

        <svg:text
          #textEl
          *ngIf="showText"
          [style.textAnchor]="'middle'"
          [attr.transform]="textTransform"
          alignment-baseline="central"
        >
          <tspan x="0" dy="0">{{ displayValue }}</tspan>
          <tspan x="0" dy="1.2em">{{ units }}</tspan>
        </svg:text>
      </svg:g>
    </ngx-charts-chart>
  `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n", ".gauge .background-arc path{fill:#0000000d}.gauge .gauge-tick path{stroke:#666}.gauge .gauge-tick text{font-size:12px;fill:#666;font-weight:700}.gauge .gauge-tick-large path{stroke-width:2px}.gauge .gauge-tick-small path{stroke-width:1px}\n"]
    }]
  }], null, {
    legend: [{
      type: Input
    }],
    legendTitle: [{
      type: Input
    }],
    legendPosition: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    textValue: [{
      type: Input
    }],
    units: [{
      type: Input
    }],
    bigSegments: [{
      type: Input
    }],
    smallSegments: [{
      type: Input
    }],
    results: [{
      type: Input
    }],
    showAxis: [{
      type: Input
    }],
    startAngle: [{
      type: Input
    }],
    angleSpan: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    axisTickFormatting: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    valueFormatting: [{
      type: Input
    }],
    showText: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }],
    textEl: [{
      type: ViewChild,
      args: ["textEl"]
    }]
  });
})();
var _GaugeModule = class _GaugeModule {
};
_GaugeModule.\u0275fac = function GaugeModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GaugeModule)();
};
_GaugeModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _GaugeModule
});
_GaugeModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule, PieChartModule, BarChartModule]
});
var GaugeModule = _GaugeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GaugeModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule, PieChartModule, BarChartModule],
      declarations: [LinearGaugeComponent, GaugeComponent, GaugeArcComponent, GaugeAxisComponent],
      exports: [LinearGaugeComponent, GaugeComponent, GaugeArcComponent, GaugeAxisComponent]
    }]
  }], null, null);
})();
function ngxChartsPolyfills() {
  if (typeof SVGElement !== "undefined" && typeof SVGElement.prototype.contains === "undefined") {
    SVGElement.prototype.contains = HTMLDivElement.prototype.contains;
  }
}
var _SankeyComponent = class _SankeyComponent extends BaseChartComponent {
  constructor() {
    super(...arguments);
    this.showLabels = true;
    this.tooltipDisabled = false;
    this.activeEntries = [];
    this.activate = new EventEmitter();
    this.deactivate = new EventEmitter();
    this.margin = [10, 10, 10, 10];
    this.scaleType = ScaleType.Ordinal;
    this.styleTypes = StyleTypes;
  }
  update() {
    super.update();
    this.dims = calculateViewDimensions({
      width: this.width,
      height: this.height,
      margins: this.margin,
      legendType: this.scaleType
    });
    const linkDefs = this.results;
    const nodeDefs = Array.from(new Set(linkDefs.flatMap((l) => [l.source, l.target])), (name) => ({
      name,
      value: linkDefs.filter((l) => l.source === name).reduce((acc, l) => acc + l.value, 0)
    }));
    const sankeyGenerator = Sankey().nodeId((d) => d.name).nodeAlign(left).nodeWidth(15).nodePadding(10).extent([[1, 5], [this.dims.width - 1, this.dims.height - 5]]);
    const data = sankeyGenerator({
      nodes: nodeDefs.map((d) => Object.assign({}, d)),
      links: linkDefs.map((d) => Object.assign({}, d))
    });
    this.valueDomain = this.getValueDomain(data.nodes);
    this.setColors();
    this.nodeRects = data.nodes.map((node) => {
      const rect = {
        x: node.x0,
        y: node.y0,
        height: node.y1 - node.y0,
        width: node.x1 - node.x0,
        fill: this.colors.getColor(node.name),
        tooltip: this.getNodeTooltipText(node),
        rx: 5,
        data: {
          name: node.name,
          value: node.value
        },
        transform: "",
        label: this.labelFormatting ? this.labelFormatting(node.name) : node.name,
        labelAnchor: TextAnchor.Start
      };
      rect.labelAnchor = this.getTextAnchor(node);
      rect.transform = `translate(${rect.x},${rect.y})`;
      return rect;
    });
    this.linkPaths = data.links.map((link2) => {
      const gradientId = "mask" + id2().toString();
      const linkPath = {
        path: sankeyLinkHorizontal_default()(link2),
        strokeWidth: Math.max(1, link2.width),
        tooltip: this.getLinkTooltipText(link2.source, link2.target, link2.value),
        id: gradientId,
        gradientFill: `url(#${gradientId})`,
        source: link2.source,
        target: link2.target,
        startColor: this.colors.getColor(link2.source.name),
        endColor: this.colors.getColor(link2.target.name),
        data: {
          source: link2.source.name,
          target: link2.target.name,
          value: link2.value
        }
      };
      return linkPath;
    });
    this.transform = `translate(${this.dims.xOffset} , ${this.margin[0]})`;
  }
  getNodeTooltipText(node) {
    return `
      <span class="tooltip-label">${escapeLabel(node.name)}</span>
      <span class="tooltip-val">${node.value.toLocaleString()}</span>
    `;
  }
  getLinkTooltipText(sourceNode, targetNode, value2) {
    return `
      <span class="tooltip-label">${escapeLabel(sourceNode.name)} \u2022 ${escapeLabel(targetNode.name)}</span>
      <span class="tooltip-val">${value2.toLocaleString()} (${(value2 / sourceNode.value).toLocaleString(void 0, {
      style: "percent",
      maximumFractionDigits: 2
    })})</span>
    `;
  }
  getTextAnchor(node) {
    if (node.layer === 0) {
      return TextAnchor.Start;
    } else {
      return TextAnchor.End;
    }
  }
  onClick(data) {
    this.select.emit(data);
  }
  setColors() {
    this.colors = new ColorHelper(this.scheme, this.scaleType, this.valueDomain);
  }
  getValueDomain(nodes) {
    return nodes.map((n) => n.name);
  }
};
_SankeyComponent.\u0275fac = /* @__PURE__ */ (() => {
  let \u0275SankeyComponent_BaseFactory;
  return function SankeyComponent_Factory(__ngFactoryType__) {
    return (\u0275SankeyComponent_BaseFactory || (\u0275SankeyComponent_BaseFactory = \u0275\u0275getInheritedFactory(_SankeyComponent)))(__ngFactoryType__ || _SankeyComponent);
  };
})();
_SankeyComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
  type: _SankeyComponent,
  selectors: [["ngx-charts-sankey"]],
  contentQueries: function SankeyComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      \u0275\u0275contentQuery(dirIndex, _c222, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tooltipTemplate = _t.first);
    }
  },
  inputs: {
    showLabels: "showLabels",
    gradient: "gradient",
    tooltipDisabled: "tooltipDisabled",
    activeEntries: "activeEntries",
    labelFormatting: "labelFormatting"
  },
  outputs: {
    activate: "activate",
    deactivate: "deactivate"
  },
  standalone: false,
  features: [\u0275\u0275InheritDefinitionFeature],
  decls: 5,
  vars: 9,
  consts: [[3, "view", "animations"], [1, "sankey", "chart"], ["class", "link", "ngx-tooltip", "", 3, "tooltipDisabled", "tooltipType", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext", 4, "ngFor", "ngForOf"], ["class", "node", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf"], ["ngx-tooltip", "", 1, "link", 3, "tooltipDisabled", "tooltipType", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext"], ["gradientUnits", "userSpaceOnUse"], ["offset", "0%"], ["offset", "100%"], ["stroke-opacity", "0.5", "fill", "none", 3, "click", "mouseenter"], [1, "node"], ["ngx-tooltip", "", 3, "click", "mouseenter", "tooltipDisabled", "tooltipType", "tooltipPlacement", "tooltipTitle", "tooltipTemplate", "tooltipContext"], ["class", "label", "dy", "0.35em", 4, "ngIf"], ["dy", "0.35em", 1, "label"]],
  template: function SankeyComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "ngx-charts-chart", 0);
      \u0275\u0275namespaceSVG();
      \u0275\u0275elementStart(1, "g", 1);
      \u0275\u0275template(2, SankeyComponent__svg_g_2_Template, 6, 14, "g", 2)(3, SankeyComponent__svg_g_3_Template, 2, 12, "g", 3)(4, SankeyComponent__svg_g_4_Template, 2, 2, "g", 4);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275property("view", \u0275\u0275pureFunction2(6, _c24, ctx.width, ctx.height))("animations", ctx.animations);
      \u0275\u0275advance();
      \u0275\u0275attribute("transform", ctx.transform);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.linkPaths);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.nodeRects);
      \u0275\u0275advance();
      \u0275\u0275property("ngForOf", ctx.nodeRects);
    }
  },
  dependencies: [NgForOf, NgIf, TooltipDirective, ChartComponent],
  styles: [_c25],
  encapsulation: 2,
  changeDetection: 0
});
var SankeyComponent = _SankeyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyComponent, [{
    type: Component,
    args: [{
      selector: "ngx-charts-sankey",
      template: `
    <ngx-charts-chart [view]="[width, height]" [animations]="animations">
      <svg:g [attr.transform]="transform" class="sankey chart">
        <svg:g
          *ngFor="let link of linkPaths"
          class="link"
          ngx-tooltip
          [tooltipDisabled]="tooltipDisabled"
          [tooltipType]="styleTypes.tooltip"
          [tooltipPlacement]="'top'"
          [tooltipTitle]="tooltipTemplate ? undefined : link.tooltip"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipContext]="link.data"
        >
          <svg:defs>
            <svg:linearGradient
              [attr.id]="link.id"
              gradientUnits="userSpaceOnUse"
              [attr.x1]="link.source.x1"
              [attr.x2]="link.target.x0"
            >
              <svg:stop offset="0%" [attr.stop-color]="link.startColor"></svg:stop>
              <svg:stop offset="100%" [attr.stop-color]="link.endColor"></svg:stop>
            </svg:linearGradient>
          </svg:defs>
          <svg:path
            [attr.d]="link.path"
            [attr.stroke]="link.gradientFill"
            [attr.stroke-width]="link.strokeWidth"
            stroke-opacity="0.5"
            fill="none"
            (click)="select.emit(link.data)"
            (mouseenter)="activate.emit(link.data)"
          ></svg:path>
        </svg:g>

        <svg:g *ngFor="let rect of nodeRects" [attr.transform]="rect.transform" class="node">
          <svg:rect
            [attr.x]="0"
            [attr.y]="0"
            [attr.width]="rect.width"
            [attr.height]="rect.height"
            [attr.fill]="rect.fill"
            ngx-tooltip
            [tooltipDisabled]="tooltipDisabled"
            [tooltipType]="styleTypes.tooltip"
            [tooltipPlacement]="'top'"
            [tooltipTitle]="tooltipTemplate ? undefined : rect.tooltip"
            [tooltipTemplate]="tooltipTemplate"
            [tooltipContext]="rect.data"
            (click)="select.emit(rect.data)"
            (mouseenter)="activate.emit(rect.data)"
          ></svg:rect>
        </svg:g>

        <svg:g *ngFor="let rect of nodeRects" [attr.transform]="rect.transform">
          <svg:text
            *ngIf="showLabels && rect.height > 15"
            class="label"
            [attr.x]="rect.width + 5"
            [attr.y]="rect.height / 2"
            [attr.text-anchor]="rect.labelAnchor"
            dy="0.35em"
            [attr.dx]="rect.labelAnchor === 'end' ? -25 : 0"
          >
            {{ rect.label }}
          </svg:text>
        </svg:g>
      </svg:g>
    </ngx-charts-chart>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      styles: [".ngx-charts-outer{animation:chartFadeIn linear .6s}@keyframes chartFadeIn{0%{opacity:0}20%{opacity:0}to{opacity:1}}.ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .cell,.ngx-charts .bar,.ngx-charts .node,.ngx-charts .link,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .node.active,.ngx-charts .node:hover,.ngx-charts .link.active,.ngx-charts .link:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .node:focus,.ngx-charts .link:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .node.hidden,.ngx-charts .link.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:400}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}\n"]
    }]
  }], null, {
    showLabels: [{
      type: Input
    }],
    gradient: [{
      type: Input
    }],
    tooltipDisabled: [{
      type: Input
    }],
    activeEntries: [{
      type: Input
    }],
    labelFormatting: [{
      type: Input
    }],
    activate: [{
      type: Output
    }],
    deactivate: [{
      type: Output
    }],
    tooltipTemplate: [{
      type: ContentChild,
      args: ["tooltipTemplate"]
    }]
  });
})();
var _SankeyModule = class _SankeyModule {
};
_SankeyModule.\u0275fac = function SankeyModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _SankeyModule)();
};
_SankeyModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _SankeyModule
});
_SankeyModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule]
});
var SankeyModule = _SankeyModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyModule, [{
    type: NgModule,
    args: [{
      imports: [ChartCommonModule],
      declarations: [SankeyComponent],
      exports: [SankeyComponent]
    }]
  }], null, null);
})();
var _NgxChartsModule = class _NgxChartsModule {
  constructor() {
    ngxChartsPolyfills();
  }
};
_NgxChartsModule.\u0275fac = function NgxChartsModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _NgxChartsModule)();
};
_NgxChartsModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
  type: _NgxChartsModule
});
_NgxChartsModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
  imports: [ChartCommonModule, AreaChartModule, BarChartModule, BoxChartModule, BubbleChartModule, HeatMapModule, SankeyModule, LineChartModule, PolarChartModule, NumberCardModule, PieChartModule, TreeMapModule, GaugeModule]
});
var NgxChartsModule = _NgxChartsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxChartsModule, [{
    type: NgModule,
    args: [{
      exports: [ChartCommonModule, AreaChartModule, BarChartModule, BoxChartModule, BubbleChartModule, HeatMapModule, SankeyModule, LineChartModule, PolarChartModule, NumberCardModule, PieChartModule, TreeMapModule, GaugeModule]
    }]
  }], () => [], null);
})();

// src/app/graph-home/graph-home.component.ts
var _c014 = () => [1e3, 400];
var _GraphHomeComponent = class _GraphHomeComponent {
  constructor(statisticsService, spinner, toastr) {
    this.statisticsService = statisticsService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.errorDto = new ErrorDto();
    this.destroy$ = new Subject();
    this.view = [700, 300];
    this.colorScheme = {
      domain: ["#5AA454", "#E44D25", "#CFC0BB", "#7aa3e5", "#a8385d", "#aae3f5"]
    };
    this.orderStatuses = [];
    this.categoryToProductCount = [];
    this.orderPriceTotalPerDay = [];
    this.single = [
      {
        "name": "Users",
        "value": 50
      },
      {
        "name": "Orders",
        "value": 37e3
      },
      {
        "name": "Categories",
        "value": 72
      },
      {
        "name": "Products",
        "value": 5e3
      },
      {
        "name": "Messages",
        "value": 15
      },
      {
        "name": "Total revenue",
        "value": 1e5
      }
    ];
  }
  ngOnInit() {
    this.loadGraphs();
  }
  loadGraphs() {
    this.spinner.show().then((r2) => r2);
    this.statisticsService.getOrderPieStatus(this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (orderPieResponse) => {
        this.spinner.hide().then((r2) => r2);
        this.orderStatuses = orderPieResponse.map((responseItem) => new GraphPieVo(responseItem.status, responseItem.total));
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " load categories failed", "Stats"));
      }
    });
    this.statisticsService.getCategoryToProductCount(this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (categoryProductCountResponse) => {
        this.spinner.hide().then((r2) => r2);
        this.categoryToProductCount = categoryProductCountResponse.map((responseItem) => new GraphPieVo(responseItem.name, responseItem.total));
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " load categories failed", "Stats"));
      }
    });
    this.statisticsService.getOrderTotalPerDay(this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (orderTotalPerDayResponse) => {
        this.spinner.hide().then((r2) => r2);
        let orderPriceTotalPerDay = orderTotalPerDayResponse.map((responseItem) => new GraphLineVo(responseItem.status, responseItem.totalPrice));
        this.orderPriceTotalPerDay = [new MultiVo(orderPriceTotalPerDay)];
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " load categories failed", "Stats"));
      }
    });
  }
  onSelect(event) {
    console.log(event);
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_GraphHomeComponent.\u0275fac = function GraphHomeComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GraphHomeComponent)(\u0275\u0275directiveInject(StatisticsService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_GraphHomeComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GraphHomeComponent, selectors: [["app-graph-home"]], standalone: false, decls: 24, vars: 29, consts: [["id", "accordionForGraphs", 1, "accordion"], [1, "accordion-item"], ["id", "headingOne", 1, "accordion-header"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#collapseOne", "aria-expanded", "true", "aria-controls", "collapseOne", 1, "accordion-button"], ["id", "collapseOne", "aria-labelledby", "headingOne", "data-bs-parent", "#accordionExample", 1, "accordion-collapse", "collapse", "show"], [1, "accordion-body"], [3, "view", "results", "xAxisLabel", "legendTitle", "yAxisLabel", "legend", "showXAxisLabel", "showYAxisLabel", "xAxis", "yAxis", "gradient"], ["id", "headingTwo", 1, "accordion-header"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#collapseTwo", "aria-expanded", "false", "aria-controls", "collapseTwo", 1, "accordion-button", "collapsed"], ["id", "collapseTwo", "aria-labelledby", "headingTwo", "data-bs-parent", "#accordionExample", 1, "accordion-collapse", "collapse"], [3, "select", "view", "results", "cardColor"], ["id", "headingThree", 1, "accordion-header"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#collapseThree", "aria-expanded", "false", "aria-controls", "collapseThree", 1, "accordion-button", "collapsed"], ["id", "collapseThree", "aria-labelledby", "headingThree", "data-bs-parent", "#accordionExample", 1, "accordion-collapse", "collapse"], [1, "row"], [1, "col", 3, "view", "results", "gradient"], [1, "col", 3, "view", "legend", "legendTitle", "showXAxisLabel", "showYAxisLabel", "xAxis", "yAxis", "xAxisLabel", "yAxisLabel", "timeline", "results"]], template: function GraphHomeComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "h2", 2)(3, "button", 3);
    \u0275\u0275text(4, " Categories ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "div", 4)(6, "div", 5);
    \u0275\u0275element(7, "ngx-charts-bar-vertical", 6);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(8, "div", 1)(9, "h2", 7)(10, "button", 8);
    \u0275\u0275text(11, " Eshop overview ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(12, "div", 9)(13, "div", 5)(14, "ngx-charts-number-card", 10);
    \u0275\u0275listener("select", function GraphHomeComponent_Template_ngx_charts_number_card_select_14_listener($event) {
      return ctx.onSelect($event);
    });
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(15, "div", 1)(16, "h2", 11)(17, "button", 12);
    \u0275\u0275text(18, " Orders ");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(19, "div", 13)(20, "div", 5)(21, "div", 14);
    \u0275\u0275element(22, "ngx-charts-advanced-pie-chart", 15)(23, "ngx-charts-line-chart", 16);
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(7);
    \u0275\u0275property("view", \u0275\u0275pureFunction0(28, _c014))("results", ctx.categoryToProductCount)("xAxisLabel", "Categories")("legendTitle", "Categories")("yAxisLabel", "Products count")("legend", true)("showXAxisLabel", true)("showYAxisLabel", true)("xAxis", true)("yAxis", true)("gradient", true);
    \u0275\u0275advance(7);
    \u0275\u0275property("view", ctx.view)("results", ctx.single)("cardColor", "#232837");
    \u0275\u0275advance(8);
    \u0275\u0275property("view", ctx.view)("results", ctx.orderStatuses)("gradient", true);
    \u0275\u0275advance();
    \u0275\u0275property("view", ctx.view)("legend", true)("legendTitle", "Order price(day)")("showXAxisLabel", true)("showYAxisLabel", true)("xAxis", true)("yAxis", true)("xAxisLabel", "Date")("yAxisLabel", "Price total")("timeline", true)("results", ctx.orderPriceTotalPerDay);
  }
}, dependencies: [BarVerticalComponent, LineChartComponent, NumberCardComponent, AdvancedPieChartComponent], encapsulation: 2 });
var GraphHomeComponent = _GraphHomeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GraphHomeComponent, { className: "GraphHomeComponent", filePath: "src/app/graph-home/graph-home.component.ts", lineNumber: 16 });
})();
var MultiVo = class {
  constructor(series) {
    this.name = "Default";
    this.series = series;
  }
};

// src/app/service/order.service.ts
var _OrderService = class _OrderService extends BaseService {
  constructor(httpClient) {
    super();
    this.httpClient = httpClient;
    this.orderEndpoint = AppConstants.baseUrl + "/api/orders";
    this.orderFilterEndpoint = this.orderEndpoint + "/filter";
  }
  deleteOrder(orderId, errorDto) {
    const accountUrl = this.addParamIntoUrl(this.orderEndpoint, orderId);
    return this.httpClient.delete(accountUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  getOrderDetail(orderId, errorDto) {
    const orderResponseUrl = this.addParamIntoUrl(this.orderEndpoint, orderId);
    return this.httpClient.get(orderResponseUrl, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  listOrders(page, errorDto) {
    let paramsData = new HttpParams().set("pageNumber", String(page)).set("pageSize", "10").set("sortBy", "STATUS");
    if (page != null) {
      paramsData = paramsData.set("pageNumber", page);
    }
    return this.httpClient.get(this.orderFilterEndpoint, {
      headers: AppConstants.acceptJson,
      params: paramsData
    }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
};
_OrderService.\u0275fac = function OrderService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _OrderService)(\u0275\u0275inject(HttpClient));
};
_OrderService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _OrderService, factory: _OrderService.\u0275fac, providedIn: "root" });
var OrderService = _OrderService;

// src/app/shared/price.pipe.ts
var _PricePipe = class _PricePipe {
  transform(money, ...args) {
    return `${money.amount} ${money.currencyCode}`;
  }
};
_PricePipe.\u0275fac = function PricePipe_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PricePipe)();
};
_PricePipe.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({ name: "pricePipe", type: _PricePipe, pure: true, standalone: false });
var PricePipe = _PricePipe;

// src/app/order/order-list/order-list.component.ts
var _c015 = (a0) => ["/orders/view/", a0];
function OrderListComponent_div_7_div_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 9)(1, "div", 7);
    \u0275\u0275text(2);
    \u0275\u0275elementStart(3, "span", 10);
    \u0275\u0275element(4, "fa-icon", 11);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "div", 7)(6, "span", 12);
    \u0275\u0275text(7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(8, "div", 7);
    \u0275\u0275text(9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "div", 7);
    \u0275\u0275text(11);
    \u0275\u0275pipe(12, "pricePipe");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "div", 7);
    \u0275\u0275text(14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "div", 7)(16, "button", 13);
    \u0275\u0275listener("click", function OrderListComponent_div_7_div_14_Template_button_click_16_listener() {
      const order_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.removeOrder(order_r3.orderId));
    });
    \u0275\u0275element(17, "fa-icon", 14);
    \u0275\u0275text(18, " Delete ");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const order_r3 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", order_r3.orderId, " ");
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(10, _c015, order_r3.orderId));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r3.faEye);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(order_r3.status);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(order_r3.owner);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(12, 8, order_r3.totalPrice));
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate((order_r3.orderItems == null ? null : order_r3.orderItems.length) || 0);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx_r3.faTrash);
  }
}
function OrderListComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "div", 6)(2, "div", 7);
    \u0275\u0275text(3, "Order ID");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 7);
    \u0275\u0275text(5, "Status");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 7);
    \u0275\u0275text(7, "Owner");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 7);
    \u0275\u0275text(9, "Total Price");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "div", 7);
    \u0275\u0275text(11, "Items Count");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "div", 7);
    \u0275\u0275text(13, "Actions");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(14, OrderListComponent_div_7_div_14_Template, 19, 12, "div", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance(14);
    \u0275\u0275property("ngForOf", ctx_r3.orders);
  }
}
function OrderListComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275text(1, " No orders found. ");
    \u0275\u0275elementEnd();
  }
}
var _OrderListComponent = class _OrderListComponent {
  constructor(orderService, spinner, toastr) {
    this.orderService = orderService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.faTrash = faTrash;
    this.faEdit = faEdit;
    this.faEye = faEye;
    this.orders = [];
    this.errorDto = new ErrorDto();
    this.info = null;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.loadOrders();
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  loadOrders() {
    this.spinner.show("orderListSpinner");
    this.orderService.listOrders(0, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.orders = response.data;
        this.spinner.hide("orderListSpinner").then(() => {
          this.toastr.info(`${response.data.length} orders reloaded`, "Order List");
        });
      },
      error: () => {
        this.orders = [];
        this.spinner.hide("orderListSpinner").then(() => {
          this.toastr.error(`${this.errorDto.httpStatus} - Failed to load orders`, "Order List");
        });
      }
    });
  }
  removeOrder(orderId) {
    const confirmation = confirm(`Are you sure you want to delete order with ID ${orderId}?`);
    if (!confirmation) {
      return;
    }
    this.spinner.show();
    this.orderService.deleteOrder(orderId.toString(), this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.info = `Order ID ${orderId} deleted successfully.`;
        this.spinner.hide().then(() => {
          this.toastr.success(`Order ID ${orderId} deleted successfully`, "Order List");
          setTimeout(() => this.info = null, AppConstants.toastSuccessDelay);
          this.loadOrders();
        });
      },
      error: () => {
        this.spinner.hide().then(() => {
          this.toastr.error(`${this.errorDto.httpStatus} - Failed to delete order`, "Order List");
        });
      }
    });
  }
};
_OrderListComponent.\u0275fac = function OrderListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _OrderListComponent)(\u0275\u0275directiveInject(OrderService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_OrderListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _OrderListComponent, selectors: [["app-order-list"]], standalone: false, decls: 10, vars: 2, consts: [["noOrders", ""], [1, "container", "mt-3"], [1, "d-flex", "justify-content-between", "align-items-center", "mb-3"], [1, "btn", "btn-primary", 3, "click"], ["name", "orderListSpinner", "type", "ball-spin-clockwise"], [4, "ngIf", "ngIfElse"], [1, "order-header", "row", "g-3", "text-white", "bg-dark"], [1, "col"], ["class", "order-item row g-3 text-white", 4, "ngFor", "ngForOf"], [1, "order-item", "row", "g-3", "text-white"], ["routerLinkActive", "active", 1, "d-inline-block", "m-2", "text-white", "pointer", 3, "routerLink"], [1, "mx-2", 3, "icon"], [1, "badge", "bg-info", "text-dark"], [1, "btn", "btn-danger", "btn-sm", 3, "click"], [3, "icon"], [1, "alert", "alert-warning", "mt-3", "text-center"]], template: function OrderListComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1)(1, "div", 2)(2, "h2");
    \u0275\u0275text(3, "Order List");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "button", 3);
    \u0275\u0275listener("click", function OrderListComponent_Template_button_click_4_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.loadOrders());
    });
    \u0275\u0275text(5, "Reload Orders");
    \u0275\u0275elementEnd()();
    \u0275\u0275element(6, "ngx-spinner", 4);
    \u0275\u0275template(7, OrderListComponent_div_7_Template, 15, 1, "div", 5)(8, OrderListComponent_ng_template_8_Template, 2, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const noOrders_r5 = \u0275\u0275reference(9);
    \u0275\u0275advance(7);
    \u0275\u0275property("ngIf", ctx.orders.length > 0)("ngIfElse", noOrders_r5);
  }
}, dependencies: [NgForOf, NgIf, FaIconComponent, RouterLink, NgxSpinnerComponent, PricePipe], encapsulation: 2 });
var OrderListComponent = _OrderListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(OrderListComponent, { className: "OrderListComponent", filePath: "src/app/order/order-list/order-list.component.ts", lineNumber: 17 });
})();

// src/app/model/order/order-detail-output-dto.ts
var OrderDetailOutputDto = class {
};
var CurrencyType;
(function(CurrencyType2) {
  CurrencyType2[CurrencyType2["CZK"] = 0] = "CZK";
  CurrencyType2[CurrencyType2["EUR"] = 1] = "EUR";
})(CurrencyType || (CurrencyType = {}));
var OrderStatusType;
(function(OrderStatusType2) {
  OrderStatusType2[OrderStatusType2["CREATED"] = 0] = "CREATED";
  OrderStatusType2[OrderStatusType2["PROCESSING"] = 1] = "PROCESSING";
  OrderStatusType2[OrderStatusType2["SHIPPED"] = 2] = "SHIPPED";
  OrderStatusType2[OrderStatusType2["FINISHED"] = 3] = "FINISHED";
})(OrderStatusType || (OrderStatusType = {}));
var PaymentType;
(function(PaymentType2) {
  PaymentType2[PaymentType2["BANK_TRANSFER"] = 0] = "BANK_TRANSFER";
  PaymentType2[PaymentType2["CASH"] = 1] = "CASH";
  PaymentType2[PaymentType2["CREDIT_CARD"] = 2] = "CREDIT_CARD";
  PaymentType2[PaymentType2["CASH_ON_DELIVERY"] = 3] = "CASH_ON_DELIVERY";
})(PaymentType || (PaymentType = {}));

// src/app/model/audit/audit.ts
var Audit = class {
};

// src/app/model/order/address-detail-base-dto.ts
var AddressDetailBaseDto = class {
};

// src/app/order/address-view/address-view.component.ts
var _AddressViewComponent = class _AddressViewComponent {
  constructor() {
    this.address = new AddressDetailBaseDto();
    this.type = "Fakturacni";
  }
};
_AddressViewComponent.\u0275fac = function AddressViewComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AddressViewComponent)();
};
_AddressViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AddressViewComponent, selectors: [["app-address-view"]], inputs: { address: "address", type: "type" }, standalone: false, decls: 33, vars: 10, consts: [[1, "order-address", "col-4", "content", "text-start"], [1, "row"], [1, "col-3"]], template: function AddressViewComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h3");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 1)(4, "div", 2);
    \u0275\u0275text(5, "Name:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 2);
    \u0275\u0275text(7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(8, "div", 1)(9, "div", 2);
    \u0275\u0275text(10, "Street");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "div", 2);
    \u0275\u0275text(12);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "div", 1)(14, "div", 2);
    \u0275\u0275text(15, "City");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "div", 2);
    \u0275\u0275text(17);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "div", 1)(19, "div", 2);
    \u0275\u0275text(20, "Country");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "div", 2);
    \u0275\u0275text(22);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(23, "div", 1)(24, "div", 2);
    \u0275\u0275text(25, "Note:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(26, "div", 2);
    \u0275\u0275text(27);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(28, "div", 1)(29, "div", 2);
    \u0275\u0275text(30, "Phone:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(31, "div", 2);
    \u0275\u0275text(32);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("", ctx.type, " address");
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate2("", ctx.address.firstName, " ", ctx.address.lastName, "");
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate2("", ctx.address.street, " ", ctx.address.streetNumber, "");
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate2("", ctx.address.zipCode, " ", ctx.address.city, "");
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx.address.country);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx.address.note);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx.address.phone);
  }
}, encapsulation: 2 });
var AddressViewComponent = _AddressViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AddressViewComponent, { className: "AddressViewComponent", filePath: "src/app/order/address-view/address-view.component.ts", lineNumber: 9 });
})();

// src/app/order/order-view/order-view.component.ts
var _c016 = (a0) => ["/products/view/", a0];
function OrderViewComponent_div_44_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14)(1, "div", 7)(2, "span", 15);
    \u0275\u0275element(3, "fa-icon", 16);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "div", 6);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "div", 6);
    \u0275\u0275text(8);
    \u0275\u0275pipe(9, "pricePipe");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const orderItem_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(7, _c016, orderItem_r1.productUrl));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r1.faView);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", orderItem_r1.name, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("", orderItem_r1.count, " ks");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(9, 5, orderItem_r1.price));
  }
}
var _OrderViewComponent = class _OrderViewComponent {
  constructor(orderService, spinner, actRoute, toastr) {
    this.orderService = orderService;
    this.spinner = spinner;
    this.actRoute = actRoute;
    this.toastr = toastr;
    this.errorDto = new ErrorDto();
    this.destroy$ = new Subject();
    this.faView = AppConstants.iconEye;
    this.actualOrder = new OrderDetailOutputDto();
    this.actualAudit = new Audit();
    this.faArrowLeft = faArrowLeft;
  }
  ngOnInit() {
    this.spinner.show().then((r2) => r2);
    this.actRoute.paramMap.subscribe((params) => {
      this.selectedOrderId = params.get("orderId");
    });
    this.orderService.getOrderDetail(this.selectedOrderId, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (orderResponse) => {
        this.spinner.hide().then(() => this.toastr.info("OrderId " + this.selectedOrderId + " loaded", "Order"));
        this.actualOrder = orderResponse.data;
        this.actualAudit = orderResponse.audit;
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto + " failed", "Order"));
        this.actualOrder = new OrderDetailOutputDto();
        this.actualAudit = new Audit();
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_OrderViewComponent.\u0275fac = function OrderViewComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _OrderViewComponent)(\u0275\u0275directiveInject(OrderService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(ToastrService));
};
_OrderViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _OrderViewComponent, selectors: [["app-order-view"]], standalone: false, decls: 51, vars: 13, consts: [["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "box"], [1, "row"], [1, "col-10"], [1, "box-part"], [1, "content", "col-6", "text-start"], [1, "col-3"], [1, "col-4"], ["class", "text-start row", 4, "ngFor", "ngForOf"], ["type", "Billing", 3, "address"], ["type", "Shipping", 3, "address"], [3, "errorDto"], ["type", "button", "appBackButton", "", 1, "btn", "btn-danger"], [3, "icon"], [1, "text-start", "row"], ["routerLinkActive", "active", 1, "pointer", "d-inline-block", "text-white", "text-break", 3, "routerLink"], [1, "me-2", 3, "icon"]], template: function OrderViewComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "ngx-spinner", 0);
    \u0275\u0275elementStart(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "h2");
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "div", 5)(8, "div", 2)(9, "div", 6);
    \u0275\u0275text(10, "Total price");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "div", 6);
    \u0275\u0275text(12);
    \u0275\u0275pipe(13, "pricePipe");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "div", 2)(15, "div", 6);
    \u0275\u0275text(16, "Status");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "div", 6);
    \u0275\u0275text(18);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(19, "div", 2)(20, "div", 6);
    \u0275\u0275text(21, "Payment type");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "div", 6);
    \u0275\u0275text(23);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(24, "div", 2)(25, "div", 6);
    \u0275\u0275text(26, "Note");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(27, "div", 6);
    \u0275\u0275text(28);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(29, "div", 2)(30, "div", 6);
    \u0275\u0275text(31, "Owner");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(32, "div", 6);
    \u0275\u0275text(33);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(34, "div", 5)(35, "h2");
    \u0275\u0275text(36, "Order Items");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(37, "div", 2)(38, "div", 7);
    \u0275\u0275text(39, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(40, "div", 6);
    \u0275\u0275text(41, "Count");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(42, "div", 6);
    \u0275\u0275text(43, "Price Total");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(44, OrderViewComponent_div_44_Template, 10, 9, "div", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275element(45, "app-address-view", 9)(46, "app-address-view", 10)(47, "app-error", 11);
    \u0275\u0275elementStart(48, "button", 12);
    \u0275\u0275element(49, "fa-icon", 13);
    \u0275\u0275text(50, "\xA0Back ");
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate1("Order detail (id = ", ctx.actualOrder.orderId, ")");
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(13, 11, ctx.actualOrder.totalPrice));
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx.actualOrder.status);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx.actualOrder.paymentType);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx.actualOrder.note);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(ctx.actualOrder.owner);
    \u0275\u0275advance(11);
    \u0275\u0275property("ngForOf", ctx.actualOrder.orderItems);
    \u0275\u0275advance();
    \u0275\u0275property("address", ctx.actualOrder.billingAddress);
    \u0275\u0275advance();
    \u0275\u0275property("address", ctx.actualOrder.shippingAddress);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faArrowLeft);
  }
}, dependencies: [NgForOf, ErrorComponent, FaIconComponent, RouterLink, NgxSpinnerComponent, AddressViewComponent, PricePipe], encapsulation: 2 });
var OrderViewComponent = _OrderViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(OrderViewComponent, { className: "OrderViewComponent", filePath: "src/app/order/order-view/order-view.component.ts", lineNumber: 19 });
})();

// src/app/model/generic-config/generic-config-key-dto.ts
var GenericConfigKeyDto;
(function(GenericConfigKeyDto2) {
  GenericConfigKeyDto2.ModuleEnum = {
    FRONTEND_ADMIN: "FRONTEND_ADMIN",
    FRONTEND_CUSTOMER: "FRONTEND_CUSTOMER",
    TEXT_CONTENT: "TEXT_CONTENT",
    CUSTOM: "CUSTOM"
  };
})(GenericConfigKeyDto || (GenericConfigKeyDto = {}));

// src/app/model/generic-config/generic-config-create-dto.ts
var GenericConfigCreateDto = class {
  constructor(data) {
    this.data = data;
  }
};

// src/app/model/generic-config/generic-config-update-dto.ts
var GenericConfigUpdateDto = class {
  constructor(data) {
    this.data = data;
  }
};

// src/app/service/generic-config.service.ts
var _GenericConfigService = class _GenericConfigService extends BaseService {
  constructor(httpClient) {
    super();
    this.httpClient = httpClient;
  }
  getGenericConfigs(module, errorDto) {
    let genericConfigEndpoint = AppConstants.baseUrl + "/api/generic-config/" + module.toString() + "/by-module";
    return this.httpClient.get(genericConfigEndpoint, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  getGenericConfigBy(module, key, errorDto) {
    let genericConfigEndpoint = AppConstants.baseUrl + "/api/generic-config/" + module + "/" + key;
    return this.httpClient.get(genericConfigEndpoint, { headers: AppConstants.acceptJson }).pipe(retry(1), catchError((err) => this.handleError(err, errorDto)));
  }
  postGenericConfig(createDto, errorDto) {
    let postEndpoint = AppConstants.baseUrl + "/api/generic-config";
    const body = JSON.stringify(new GenericConfigCreateDto(createDto));
    return this.httpClient.post(postEndpoint, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  putGenericConfig(module, key, data, errorDto) {
    let genericConfigEndpoint = AppConstants.baseUrl + "/api/generic-config/" + module + "/" + key;
    const body = JSON.stringify(new GenericConfigUpdateDto(data));
    return this.httpClient.put(genericConfigEndpoint, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  deleteGenericConfig(module, key, errorDto) {
    let genericConfigEndpoint = AppConstants.baseUrl + "/api/generic-config/" + module + "/" + key;
    return this.httpClient.delete(genericConfigEndpoint, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
};
_GenericConfigService.\u0275fac = function GenericConfigService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GenericConfigService)(\u0275\u0275inject(HttpClient));
};
_GenericConfigService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _GenericConfigService, factory: _GenericConfigService.\u0275fac, providedIn: "root" });
var GenericConfigService = _GenericConfigService;

// src/app/genericconfig/generic-config-list/generic-config-list.component.ts
var ModuleEnum = GenericConfigKeyDto.ModuleEnum;
var _c017 = (a0, a1) => ["/generic-configs/edit/", a0, a1];
function GenericConfigListComponent_div_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16)(1, "div", 17)(2, "div", 7);
    \u0275\u0275element(3, "span", 18);
    \u0275\u0275elementStart(4, "span", 19);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 9);
    \u0275\u0275element(7, "span", 20);
    \u0275\u0275elementStart(8, "span", 19);
    \u0275\u0275text(9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "div", 7);
    \u0275\u0275element(11, "span", 21);
    \u0275\u0275elementStart(12, "span", 22);
    \u0275\u0275text(13);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "div", 7);
    \u0275\u0275element(15, "span", 23);
    \u0275\u0275elementStart(16, "span", 19);
    \u0275\u0275text(17);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "div", 11)(19, "button", 24);
    \u0275\u0275element(20, "fa-icon", 25);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(21, "div", 11)(22, "button", 26);
    \u0275\u0275element(23, "fa-icon", 25);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const config_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(config_r1.key.module);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(config_r1.key.name);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(config_r1.type);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(config_r1.value);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction2(7, _c017, config_r1.key.module, config_r1.key.name));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r1.faEdit);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx_r1.faDelete);
  }
}
var _GenericConfigListComponent = class _GenericConfigListComponent {
  constructor(genericConfigService, spinner, toastr) {
    this.genericConfigService = genericConfigService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.defaultModule = ModuleEnum.FRONTEND_ADMIN;
    this.genericConfigs = [];
    this.errorDto = new ErrorDto();
    this.destroy$ = new Subject();
    this.faEdit = AppConstants.iconEdit;
    this.faDelete = AppConstants.iconDelete;
  }
  ngOnInit() {
    this.loadConfigsFromServer(this.defaultModule);
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  loadConfigsFromServer(module) {
    this.spinner.show().then((r2) => r2);
    this.genericConfigService.getGenericConfigs(module, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (genericConfigResponse) => {
        this.spinner.hide().then(() => {
          this.genericConfigs = genericConfigResponse.data;
          this.errorDto = new ErrorDto();
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " failed", "Generic config"));
      }
    });
  }
  filterChanged($event) {
    this.loadConfigsFromServer($event);
  }
  deleteGenericConfig(config3) {
    this.spinner.show().then((r2) => r2);
    if (!confirm("Are you sure to delete product (" + config3.key.module + config3.key.name + ") ?")) {
      this.spinner.hide().then((r2) => r2);
      return;
    }
  }
};
_GenericConfigListComponent.\u0275fac = function GenericConfigListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GenericConfigListComponent)(\u0275\u0275directiveInject(GenericConfigService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_GenericConfigListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GenericConfigListComponent, selectors: [["app-generic-config-list"]], standalone: false, decls: 29, vars: 2, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-9", "col-md-12", "align-self-center"], [1, "box-part", "text-center"], [1, "text-orange", "mb-3"], [1, "row"], [1, "input-group", "d-none", "d-sm-inline-flex"], [1, "col-12", "col-sm-2"], [1, "text-darkorange", "text-center"], [1, "col-12", "col-sm-4"], [1, "text-darkorange"], [1, "col-12", "col-sm-1"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["class", "row border-bottom link text-center text-md-start", 4, "ngFor", "ngForOf"], [3, "errorDto"], ["routerLinkActive", "active", "routerLink", "/generic-configs/create", 1, "btn", "btn-primary"], [1, "row", "border-bottom", "link", "text-center", "text-md-start"], [1, "input-group"], ["data-label", "Module", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "d-inline-block", "m-2", "text-white", "text-break"], ["data-label", "Name", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], ["data-label", "Type", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "d-inline-block", "m-2", "text-white"], ["data-label", "Value", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], ["routerLinkActive", "active", 1, "btn", "btn-primary", "btn-sm", "m-2", 3, "routerLink"], [3, "icon"], [1, "btn", "btn-primary", "btn-sm", "m-2"]], template: function GenericConfigListComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h3", 4);
    \u0275\u0275text(5, "Generic config admin");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 5)(7, "div", 6)(8, "div", 7)(9, "span", 8);
    \u0275\u0275text(10, "Module");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 9)(12, "span", 10);
    \u0275\u0275text(13, "Name");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "div", 7)(15, "span", 10);
    \u0275\u0275text(16, "Type");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 7)(18, "span", 10);
    \u0275\u0275text(19, "Value");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(20, "div", 11);
    \u0275\u0275element(21, "span", 10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "div", 11);
    \u0275\u0275element(23, "span", 10);
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(24, "ngx-spinner", 12);
    \u0275\u0275template(25, GenericConfigListComponent_div_25_Template, 24, 10, "div", 13);
    \u0275\u0275element(26, "app-error", 14);
    \u0275\u0275elementStart(27, "button", 15);
    \u0275\u0275text(28, "Create config ");
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(25);
    \u0275\u0275property("ngForOf", ctx.genericConfigs);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
  }
}, dependencies: [NgForOf, ErrorComponent, NgxSpinnerComponent, FaIconComponent, RouterLink], encapsulation: 2 });
var GenericConfigListComponent = _GenericConfigListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GenericConfigListComponent, { className: "GenericConfigListComponent", filePath: "src/app/genericconfig/generic-config-list/generic-config-list.component.ts", lineNumber: 19 });
})();

// src/app/model/generic-config/generic-config-data-dto.ts
var GenericConfigDataDto;
(function(GenericConfigDataDto2) {
  GenericConfigDataDto2.ConfigTypeEnum = {
    SHORTSTRING: "SHORT_STRING",
    LONGTEXT: "LONG_TEXT",
    NUMBER: "NUMBER"
  };
})(GenericConfigDataDto || (GenericConfigDataDto = {}));

// src/app/genericconfig/generic-config-edit-detail/generic-config-edit-detail.component.ts
var ModuleEnum2 = GenericConfigKeyDto.ModuleEnum;
var ConfigTypeEnum = GenericConfigDataDto.ConfigTypeEnum;
function GenericConfigEditDetailComponent_option_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 25);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const module_r3 = ctx.$implicit;
    \u0275\u0275property("ngValue", module_r3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", module_r3, " ");
  }
}
function GenericConfigEditDetailComponent_div_16_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Key is required");
    \u0275\u0275elementEnd();
  }
}
function GenericConfigEditDetailComponent_div_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 26);
    \u0275\u0275template(1, GenericConfigEditDetailComponent_div_16_div_1_Template, 2, 0, "div", 27);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const configModule_r4 = \u0275\u0275reference(14);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", configModule_r4.errors.required);
  }
}
function GenericConfigEditDetailComponent_div_22_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Key is required");
    \u0275\u0275elementEnd();
  }
}
function GenericConfigEditDetailComponent_div_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 26);
    \u0275\u0275template(1, GenericConfigEditDetailComponent_div_22_div_1_Template, 2, 0, "div", 27);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const configKey_r5 = \u0275\u0275reference(21);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", configKey_r5.errors.required);
  }
}
function GenericConfigEditDetailComponent_option_28_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 25);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const type_r6 = ctx.$implicit;
    \u0275\u0275property("ngValue", type_r6);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", type_r6, " ");
  }
}
function GenericConfigEditDetailComponent_div_29_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Config Type is required");
    \u0275\u0275elementEnd();
  }
}
function GenericConfigEditDetailComponent_div_29_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 26);
    \u0275\u0275template(1, GenericConfigEditDetailComponent_div_29_div_1_Template, 2, 0, "div", 27);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const configType_r7 = \u0275\u0275reference(27);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", configType_r7.errors.required);
  }
}
function GenericConfigEditDetailComponent_div_35_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Value is required");
    \u0275\u0275elementEnd();
  }
}
function GenericConfigEditDetailComponent_div_35_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 26);
    \u0275\u0275template(1, GenericConfigEditDetailComponent_div_35_div_1_Template, 2, 0, "div", 27);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const configValue_r8 = \u0275\u0275reference(34);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", configValue_r8.errors.required);
  }
}
var _GenericConfigEditDetailComponent = class _GenericConfigEditDetailComponent {
  initGenericConfigDefault() {
    return {
      key: { name: "PREDEFINNED_KEY", module: ModuleEnum2.FRONTEND_ADMIN },
      type: ConfigTypeEnum.SHORTSTRING,
      value: "..."
    };
  }
  constructor(genericConfigService, spinner, toastr, route, actRoute) {
    this.genericConfigService = genericConfigService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.route = route;
    this.actRoute = actRoute;
    this.isCreate = false;
    this.module = null;
    this.key = null;
    this.availableModules = Object.values(ModuleEnum2);
    this.availableConfigTypes = Object.values(ConfigTypeEnum);
    this.destroy$ = new Subject();
    this.errorDto = new ErrorDto();
    this.genericConfigRequest = this.initGenericConfigDefault();
  }
  ngOnInit() {
    if (this.isCreate) {
      return;
    } else {
      this.actRoute.paramMap.subscribe((params) => {
        this.genericConfigRequest.key.name = params.get("key");
        this.genericConfigRequest.key.module = ModuleEnum2[params.get("module")];
      });
    }
    this.loadConfigBy();
  }
  loadConfigBy() {
    this.spinner.show().then((r2) => r2);
    this.genericConfigService.getGenericConfigBy(this.genericConfigRequest.key.module, this.genericConfigRequest.key.name, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (genericConfigResponse) => {
        this.spinner.hide().then(() => this.toastr.info(genericConfigResponse.data.key + " generic configs reloaded", "Generic config"));
        this.genericConfigRequest = genericConfigResponse.data;
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error("Load failed" + this.errorDto.httpStatus, "Generic config"));
      }
    });
  }
  genericConfigSaveOperation() {
    if (this.isCreate) {
      this.createGenericConfig();
    } else {
      this.updateGenericConfig();
    }
  }
  updateGenericConfig() {
    this.genericConfigService.putGenericConfig(this.genericConfigRequest.key.module, this.genericConfigRequest.key.name, this.genericConfigRequest.value, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide().then(() => {
          this.toastr.success("Config updated", "Generic config");
          this.errorDto = new ErrorDto();
          setTimeout(() => {
            this.route.navigate(["/generic-configs"]);
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " update failed", "Generic config"));
      }
    });
  }
  createGenericConfig() {
    this.genericConfigService.postGenericConfig(this.genericConfigRequest, this.errorDto).subscribe({
      next: (genericConfigResponse) => {
        this.errorDto = new ErrorDto();
        this.spinner.hide().then(() => this.toastr.info(genericConfigResponse.data.value + " created", "Generic config"));
        setTimeout(() => {
          this.route.navigate(["/generic-configs"]);
        }, AppConstants.toastSuccessDelay);
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(" Generic config post failed" + this.errorDto.httpStatus, "Generic config"));
      }
    });
  }
  getAction() {
    return this.isCreate ? "CREATE" : "UPDATE";
  }
};
_GenericConfigEditDetailComponent.\u0275fac = function GenericConfigEditDetailComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GenericConfigEditDetailComponent)(\u0275\u0275directiveInject(GenericConfigService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute));
};
_GenericConfigEditDetailComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GenericConfigEditDetailComponent, selectors: [["app-generic-config-edit-detail"]], inputs: { isCreate: "isCreate", module: "module", key: "key" }, standalone: false, decls: 40, vars: 13, consts: [["createGenericForm", "ngForm"], ["configModule", "ngModel"], ["configKey", "ngModel"], ["configType", "ngModel"], ["configValue", "ngModel"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-4", "col-sm-10", "align-self-center"], [1, "box-part", "text-center"], ["novalidate", "", 3, "ngSubmit"], [1, "detail"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "mb-3"], ["for", "module-input"], ["id", "module-input", "name", "configModule", "required", "", 1, "form-select", "form-select-md", 3, "ngModelChange", "ngModel"], [3, "ngValue", 4, "ngFor", "ngForOf"], ["class", "alert alert-danger", 4, "ngIf"], ["for", "config-key"], ["id", "config-key", "name", "configKey", "type", "text", "placeholder", "required SOME_KEY", "required", "", 1, "form-control", 3, "ngModelChange", "ngModel"], ["for", "configType-input"], ["id", "configType-input", "name", "configType", "required", "", 1, "form-select", "form-select-md", 3, "ngModelChange", "ngModel"], ["for", "config-value"], ["id", "config-value", "name", "configValue", "type", "text", "placeholder", "required lorem ipsum", "required", "", 1, "form-control", 3, "ngModelChange", "ngModel"], [3, "errorDto"], ["type", "submit", 1, "btn", "btn-primary"], [3, "ngValue"], [1, "alert", "alert-danger"], [4, "ngIf"]], template: function GenericConfigEditDetailComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 5)(1, "div", 6)(2, "div", 7)(3, "div", 8)(4, "form", 9, 0);
    \u0275\u0275listener("ngSubmit", function GenericConfigEditDetailComponent_Template_form_ngSubmit_4_listener() {
      \u0275\u0275restoreView(_r1);
      const createGenericForm_r2 = \u0275\u0275reference(5);
      return \u0275\u0275resetView(createGenericForm_r2.form.valid && ctx.genericConfigSaveOperation());
    });
    \u0275\u0275elementStart(6, "h2");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 10);
    \u0275\u0275element(9, "ngx-spinner", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "div", 12)(11, "label", 13);
    \u0275\u0275text(12, "Module");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "select", 14, 1);
    \u0275\u0275twoWayListener("ngModelChange", function GenericConfigEditDetailComponent_Template_select_ngModelChange_13_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.genericConfigRequest.key.module, $event) || (ctx.genericConfigRequest.key.module = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275template(15, GenericConfigEditDetailComponent_option_15_Template, 2, 2, "option", 15);
    \u0275\u0275elementEnd();
    \u0275\u0275template(16, GenericConfigEditDetailComponent_div_16_Template, 2, 1, "div", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "div", 12)(18, "label", 17);
    \u0275\u0275text(19, "Key");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "input", 18, 2);
    \u0275\u0275twoWayListener("ngModelChange", function GenericConfigEditDetailComponent_Template_input_ngModelChange_20_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.genericConfigRequest.key.name, $event) || (ctx.genericConfigRequest.key.name = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(22, GenericConfigEditDetailComponent_div_22_Template, 2, 1, "div", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(23, "div", 12)(24, "label", 19);
    \u0275\u0275text(25, "Config type");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(26, "select", 20, 3);
    \u0275\u0275twoWayListener("ngModelChange", function GenericConfigEditDetailComponent_Template_select_ngModelChange_26_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.genericConfigRequest.type, $event) || (ctx.genericConfigRequest.type = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275template(28, GenericConfigEditDetailComponent_option_28_Template, 2, 2, "option", 15);
    \u0275\u0275elementEnd();
    \u0275\u0275template(29, GenericConfigEditDetailComponent_div_29_Template, 2, 1, "div", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(30, "div", 12)(31, "label", 21);
    \u0275\u0275text(32, "Value");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(33, "input", 22, 4);
    \u0275\u0275twoWayListener("ngModelChange", function GenericConfigEditDetailComponent_Template_input_ngModelChange_33_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.genericConfigRequest.value, $event) || (ctx.genericConfigRequest.value = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(35, GenericConfigEditDetailComponent_div_35_Template, 2, 1, "div", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275element(36, "app-error", 23);
    \u0275\u0275elementStart(37, "div", 12)(38, "button", 24);
    \u0275\u0275text(39);
    \u0275\u0275elementEnd()()()()()()();
  }
  if (rf & 2) {
    const createGenericForm_r2 = \u0275\u0275reference(5);
    const configModule_r4 = \u0275\u0275reference(14);
    const configKey_r5 = \u0275\u0275reference(21);
    const configType_r7 = \u0275\u0275reference(27);
    const configValue_r8 = \u0275\u0275reference(34);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1("", ctx.getAction(), " generic config");
    \u0275\u0275advance(6);
    \u0275\u0275twoWayProperty("ngModel", ctx.genericConfigRequest.key.module);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.availableModules);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", createGenericForm_r2.submitted && configModule_r4.errors);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.genericConfigRequest.key.name);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", createGenericForm_r2.submitted && configKey_r5.errors);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.genericConfigRequest.type);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.availableConfigTypes);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", createGenericForm_r2.submitted && configType_r7.errors);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.genericConfigRequest.value);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", createGenericForm_r2.submitted && configValue_r8.errors);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx.getAction());
  }
}, dependencies: [NgForOf, NgIf, ErrorComponent, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, SelectControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, NgModel, NgForm, NgxSpinnerComponent], encapsulation: 2 });
var GenericConfigEditDetailComponent = _GenericConfigEditDetailComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GenericConfigEditDetailComponent, { className: "GenericConfigEditDetailComponent", filePath: "src/app/genericconfig/generic-config-edit-detail/generic-config-edit-detail.component.ts", lineNumber: 20 });
})();

// src/app/genericconfig/generic-config-create/generic-config-create.component.ts
var _GenericConfigCreateComponent = class _GenericConfigCreateComponent {
};
_GenericConfigCreateComponent.\u0275fac = function GenericConfigCreateComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GenericConfigCreateComponent)();
};
_GenericConfigCreateComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GenericConfigCreateComponent, selectors: [["app-generic-config-create"]], standalone: false, decls: 1, vars: 1, consts: [[3, "isCreate"]], template: function GenericConfigCreateComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-generic-config-edit-detail", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("isCreate", true);
  }
}, dependencies: [GenericConfigEditDetailComponent], encapsulation: 2 });
var GenericConfigCreateComponent = _GenericConfigCreateComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GenericConfigCreateComponent, { className: "GenericConfigCreateComponent", filePath: "src/app/genericconfig/generic-config-create/generic-config-create.component.ts", lineNumber: 8 });
})();

// src/app/genericconfig/generic-config-edit/generic-config-edit.component.ts
var _GenericConfigEditComponent = class _GenericConfigEditComponent {
};
_GenericConfigEditComponent.\u0275fac = function GenericConfigEditComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GenericConfigEditComponent)();
};
_GenericConfigEditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GenericConfigEditComponent, selectors: [["app-generic-config-edit"]], standalone: false, decls: 1, vars: 1, consts: [[3, "isCreate"]], template: function GenericConfigEditComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-generic-config-edit-detail", 0);
  }
  if (rf & 2) {
    \u0275\u0275property("isCreate", false);
  }
}, dependencies: [GenericConfigEditDetailComponent], encapsulation: 2 });
var GenericConfigEditComponent = _GenericConfigEditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GenericConfigEditComponent, { className: "GenericConfigEditComponent", filePath: "src/app/genericconfig/generic-config-edit/generic-config-edit.component.ts", lineNumber: 8 });
})();

// src/app/category/category-list/category-list.component.ts
var _c018 = (a0) => ["/categories/view/", a0];
var _c110 = () => ["/categories/upsert"];
var _c210 = (a0) => ({ categoryUrl: a0 });
function CategoryListComponent_div_22_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 15)(1, "div", 16)(2, "div", 6);
    \u0275\u0275element(3, "span", 17);
    \u0275\u0275elementStart(4, "span", 18);
    \u0275\u0275element(5, "fa-icon", 19);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 20);
    \u0275\u0275element(8, "span", 21);
    \u0275\u0275elementStart(9, "span", 22);
    \u0275\u0275text(10);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 8);
    \u0275\u0275element(12, "span", 23);
    \u0275\u0275elementStart(13, "span", 24);
    \u0275\u0275text(14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(15, "div", 25)(16, "button", 26);
    \u0275\u0275element(17, "fa-icon", 27);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(18, "div", 28)(19, "button", 29);
    \u0275\u0275listener("click", function CategoryListComponent_div_22_Template_button_click_19_listener() {
      const category_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.removeCategory(category_r2));
    });
    \u0275\u0275element(20, "fa-icon", 27);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const category_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(9, _c018, category_r2.url));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r2.faEye);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", category_r2.name, " ");
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(category_r2.url);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(category_r2.description);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(11, _c110))("queryParams", \u0275\u0275pureFunction1(12, _c210, category_r2.url));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r2.faEdit);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx_r2.faTrash);
  }
}
var _CategoryListComponent = class _CategoryListComponent {
  constructor(categoryService, spinner, toastr) {
    this.categoryService = categoryService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.categories = [];
    this.destroy$ = new Subject();
    this.faTrash = AppConstants.iconTrash;
    this.faEdit = AppConstants.iconEdit;
    this.faEye = AppConstants.iconEye;
    this.faBan = AppConstants.iconBan;
    this.errorDto = new ErrorDto();
  }
  ngOnInit() {
    this.getCategories();
  }
  getCategories() {
    this.spinner.show().then((r2) => r2);
    this.categoryService.getCategories(this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (categoriesResponse) => {
        this.spinner.hide().then((r2) => r2);
        this.categories = categoriesResponse.data;
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " load categories failed", "Category"));
      }
    });
  }
  removeCategory(category) {
    if (!confirm("Are you sure to delete category" + category.name + "?")) {
      return;
    }
    this.spinner.show().then((r2) => r2);
    this.categoryService.deleteCategory(category, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide().then(() => {
          this.toastr.info("Category " + category.url + " deleted", "Category");
          this.categories = this.categories.filter((data) => data.url !== category.url);
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " delete failed", "Category"));
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_CategoryListComponent.\u0275fac = function CategoryListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CategoryListComponent)(\u0275\u0275directiveInject(CategoryService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_CategoryListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _CategoryListComponent, selectors: [["app-category-list"]], standalone: false, decls: 26, vars: 4, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-6", "col-md-8", "col-sm-10", "align-self-center"], [1, "box-part", "text-center"], [1, "row", "text-center"], [1, "input-group", "d-none", "d-sm-inline-flex"], [1, "col-12", "col-sm-3"], [1, "text-darkorange"], [1, "col-12", "col-sm-4"], [1, "col-12", "col-sm-1"], [1, "text-darkorange", 3, "icon"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["class", "row link text-center text-md-start", 4, "ngFor", "ngForOf"], [3, "errorDto"], ["routerLinkActive", "active", "routerLink", "/categories/upsert", 1, "btn", "btn-primary", "mt-4", "text-center"], [1, "row", "link", "text-center", "text-md-start"], [1, "input-group", "border-bottom", "py-2"], ["data-label", "Name", 1, "d-inline-block", "m-2", "text-orange", "d-sm-none"], ["routerLinkActive", "active", 1, "d-inline-block", "m-2", "text-white", "pointer", 3, "routerLink"], [1, "mx-2", 3, "icon"], [1, "col-12", "col-sm-3", "text-white"], ["data-label", "Url", 1, "d-inline-block", "m-2", "text-orange", "d-sm-none"], [1, "d-inline-block", "m-2", "text-white"], ["data-label", "Description", 1, "d-inline-block", "m-2", "text-orange", "d-sm-none"], [1, "d-inline-block", "m-2", "text-white", "overflow"], [1, "col-12", "col-sm-1", "my-auto"], ["routerLinkActive", "active", 1, "btn", "btn-info", "mt-1", 3, "routerLink", "queryParams"], [3, "icon"], [1, "col-12", "col-sm-1", "my-auto", "text-center"], [1, "btn", "btn-danger", "mt-1", 3, "click"]], template: function CategoryListComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h3");
    \u0275\u0275text(5, "Categories");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 4)(7, "div", 5)(8, "div", 6)(9, "span", 7);
    \u0275\u0275text(10, "Name");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 6)(12, "span", 7);
    \u0275\u0275text(13, "Url");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "div", 8)(15, "span", 7);
    \u0275\u0275text(16, "Description");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 9);
    \u0275\u0275element(18, "fa-icon", 10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "div", 9);
    \u0275\u0275element(20, "fa-icon", 10);
    \u0275\u0275elementEnd()()();
    \u0275\u0275element(21, "ngx-spinner", 11);
    \u0275\u0275template(22, CategoryListComponent_div_22_Template, 21, 14, "div", 12);
    \u0275\u0275element(23, "app-error", 13);
    \u0275\u0275elementStart(24, "button", 14);
    \u0275\u0275text(25, "Add category ");
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(18);
    \u0275\u0275property("icon", ctx.faEdit);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faTrash);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.categories);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
  }
}, dependencies: [NgForOf, FaIconComponent, ErrorComponent, RouterLink, NgxSpinnerComponent], encapsulation: 2 });
var CategoryListComponent = _CategoryListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(CategoryListComponent, { className: "CategoryListComponent", filePath: "src/app/category/category-list/category-list.component.ts", lineNumber: 19 });
})();

// src/app/model/category/category.ts
var Category = class {
};

// src/app/category/category-upsert/category-upsert.component.ts
function CategoryUpsertComponent_div_13_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Name is required.");
    \u0275\u0275elementEnd();
  }
}
function CategoryUpsertComponent_div_13_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Name must be at least 4 characters long.");
    \u0275\u0275elementEnd();
  }
}
function CategoryUpsertComponent_div_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 23);
    \u0275\u0275template(1, CategoryUpsertComponent_div_13_div_1_Template, 2, 0, "div", 24)(2, CategoryUpsertComponent_div_13_div_2_Template, 2, 0, "div", 24);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const catName_r3 = \u0275\u0275reference(12);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", catName_r3.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", catName_r3.errors.minlength);
  }
}
function CategoryUpsertComponent_div_20_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Url is required.");
    \u0275\u0275elementEnd();
  }
}
function CategoryUpsertComponent_div_20_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Url must be valid");
    \u0275\u0275elementEnd();
  }
}
function CategoryUpsertComponent_div_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 23);
    \u0275\u0275template(1, CategoryUpsertComponent_div_20_div_1_Template, 2, 0, "div", 24)(2, CategoryUpsertComponent_div_20_div_2_Template, 2, 0, "div", 24);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const url_r4 = \u0275\u0275reference(19);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", url_r4.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", url_r4.errors.isInvalidUrl && !url_r4.errors.required);
  }
}
function CategoryUpsertComponent_div_26_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Description must be at least 12 characters long. ");
    \u0275\u0275elementEnd();
  }
}
function CategoryUpsertComponent_div_26_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Description must be maximum least 60 characters long. ");
    \u0275\u0275elementEnd();
  }
}
function CategoryUpsertComponent_div_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 23);
    \u0275\u0275template(1, CategoryUpsertComponent_div_26_div_1_Template, 2, 0, "div", 24)(2, CategoryUpsertComponent_div_26_div_2_Template, 2, 0, "div", 24);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const description_r5 = \u0275\u0275reference(25);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", description_r5.errors.minlength);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", description_r5.errors.minlength);
  }
}
var _CategoryUpsertComponent = class _CategoryUpsertComponent {
  constructor(categoryService, route, actRoute, spinner, toastr) {
    this.categoryService = categoryService;
    this.route = route;
    this.actRoute = actRoute;
    this.spinner = spinner;
    this.toastr = toastr;
    this.selectedCategory = new Category();
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.destroy$ = new Subject();
    this.errorDto = new ErrorDto();
    this.operation = "Create";
  }
  ngOnInit() {
    this.actRoute.queryParamMap.subscribe((params) => {
      this.selectedOriginalCategoryUrl = params.get("categoryUrl");
      if (!this.selectedOriginalCategoryUrl) {
        this.operation = "Create";
      } else {
        this.operation = "Update";
      }
      this.loadCategory();
    });
  }
  loadCategory() {
    if (this.operation == "Update") {
      this.getCategory();
    }
  }
  getCategory() {
    this.spinner.show().then((r2) => r2);
    this.categoryService.getCategory(this.selectedOriginalCategoryUrl, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (categories) => {
        this.spinner.hide().then((r2) => r2);
        this.selectedCategory = categories.data;
        this.operation = "Update";
      },
      error: () => {
        this.spinner.hide().then((r2) => {
          this.operation = "Create";
          this.toastr.error(this.errorDto.httpStatus + " load categories failed", "Category");
        });
      }
    });
  }
  upsertCategory() {
    if (this.operation == "Create") {
      this.createCategory();
    } else {
      this.updateCategory();
    }
  }
  updateCategory() {
    this.spinner.show().then((r2) => r2);
    this.categoryService.updateCategory(this.selectedCategory, this.selectedOriginalCategoryUrl, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide().then(() => {
          this.toastr.success(" Category updated", "Account");
          setTimeout(() => {
            this.route.navigate(["/categories/view/", this.selectedCategory.url]).then((r2) => r2);
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " update failed", "Category"));
      }
    });
  }
  createCategory() {
    this.spinner.show().then((r2) => r2);
    this.categoryService.createCategory(this.selectedCategory, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide().then(() => {
          this.toastr.success("Category " + this.selectedCategory.url + " inserted", "Category");
          setTimeout(() => {
            this.route.navigate(["/categories/view/", this.selectedCategory.url]).then((r2) => r2);
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " Category failed!", "Category"));
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_CategoryUpsertComponent.\u0275fac = function CategoryUpsertComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CategoryUpsertComponent)(\u0275\u0275directiveInject(CategoryService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_CategoryUpsertComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _CategoryUpsertComponent, selectors: [["app-category-edited"]], standalone: false, decls: 34, vars: 10, consts: [["upsertCategoryForm", "ngForm"], ["catName", "ngModel"], ["url", "ngModel"], ["description", "ngModel"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-4", "col-sm-8", "align-self-center"], [1, "box-part", "text-center"], ["novalidate", "", 3, "ngSubmit"], [1, "mb-3"], ["for", "category-edit-name", 1, "form-label"], ["id", "category-edit-name", "name", "catName", "type", "text", "placeholder", "required", "required", "", "minlength", "4", 1, "form-control", 3, "ngModelChange", "ngModel"], ["class", "alert alert-danger", 4, "ngIf"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["for", "category-edit-url", 1, "form-label"], ["id", "category-edit-url", "name", "url", "type", "text", "placeholder", "required", "required", "", "appUrlValidator", "", 1, "form-control", 3, "ngModelChange", "ngModel"], ["for", "category-edit-description", 1, "form-label"], ["id", "category-edit-description", "name", "description", "maxlength", "60", "minlength", "12", 1, "form-control", 3, "ngModelChange", "ngModel"], [3, "errorDto"], [1, "col-auto", "mb-3"], ["type", "submit", 1, "btn", "btn-primary", "mx-3", "mx-sm-5"], ["type", "button", "appBackButton", "", 1, "btn", "btn-danger", "mx-3", "mx-sm-5"], [3, "icon"], [1, "alert", "alert-danger"], [4, "ngIf"]], template: function CategoryUpsertComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 5)(2, "div", 6)(3, "div", 7)(4, "form", 8, 0);
    \u0275\u0275listener("ngSubmit", function CategoryUpsertComponent_Template_form_ngSubmit_4_listener() {
      \u0275\u0275restoreView(_r1);
      const upsertCategoryForm_r2 = \u0275\u0275reference(5);
      return \u0275\u0275resetView(upsertCategoryForm_r2.valid && ctx.upsertCategory());
    });
    \u0275\u0275elementStart(6, "h2");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 9)(9, "label", 10);
    \u0275\u0275text(10, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "input", 11, 1);
    \u0275\u0275twoWayListener("ngModelChange", function CategoryUpsertComponent_Template_input_ngModelChange_11_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedCategory.name, $event) || (ctx.selectedCategory.name = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(13, CategoryUpsertComponent_div_13_Template, 3, 2, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275element(14, "ngx-spinner", 13);
    \u0275\u0275elementStart(15, "div", 9)(16, "label", 14);
    \u0275\u0275text(17, "Url");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "input", 15, 2);
    \u0275\u0275twoWayListener("ngModelChange", function CategoryUpsertComponent_Template_input_ngModelChange_18_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedCategory.url, $event) || (ctx.selectedCategory.url = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(20, CategoryUpsertComponent_div_20_Template, 3, 2, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "div", 9)(22, "label", 16);
    \u0275\u0275text(23, "Description");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(24, "textarea", 17, 3);
    \u0275\u0275twoWayListener("ngModelChange", function CategoryUpsertComponent_Template_textarea_ngModelChange_24_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedCategory.description, $event) || (ctx.selectedCategory.description = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(26, CategoryUpsertComponent_div_26_Template, 3, 2, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275element(27, "app-error", 18);
    \u0275\u0275elementStart(28, "div", 19)(29, "button", 20);
    \u0275\u0275text(30);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(31, "button", 21);
    \u0275\u0275element(32, "fa-icon", 22);
    \u0275\u0275text(33, "\xA0Back ");
    \u0275\u0275elementEnd()()()()()()();
  }
  if (rf & 2) {
    const upsertCategoryForm_r2 = \u0275\u0275reference(5);
    const catName_r3 = \u0275\u0275reference(12);
    const url_r4 = \u0275\u0275reference(19);
    const description_r5 = \u0275\u0275reference(25);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate1("", ctx.operation, " category");
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedCategory.name);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", upsertCategoryForm_r2.submitted && catName_r3.invalid);
    \u0275\u0275advance(5);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedCategory.url);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", upsertCategoryForm_r2.submitted && url_r4.invalid && (url_r4.dirty || url_r4.touched));
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedCategory.description);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", upsertCategoryForm_r2.submitted && description_r5.invalid && (description_r5.dirty || description_r5.touched));
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx.operation);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faArrowLeft);
  }
}, dependencies: [NgIf, FaIconComponent, ErrorComponent, NgxSpinnerComponent, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, NgModel, NgForm], encapsulation: 2 });
var CategoryUpsertComponent = _CategoryUpsertComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(CategoryUpsertComponent, { className: "CategoryUpsertComponent", filePath: "src/app/category/category-upsert/category-upsert.component.ts", lineNumber: 20 });
})();

// src/app/shared/audit/audit.component.ts
var _AuditComponent = class _AuditComponent {
  constructor() {
    this.faCalendar = AppConstants.iconCalendar;
    this.faUser = AppConstants.iconUser;
    this.audit = new Audit();
  }
};
_AuditComponent.\u0275fac = function AuditComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AuditComponent)();
};
_AuditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AuditComponent, selectors: [["app-audit"]], inputs: { audit: "audit" }, standalone: false, decls: 37, vars: 14, consts: [[1, "container"], [1, "row", "text-center", "text-sm-start"], [1, "col"], [1, "d-block", "d-sm-inline-flex", "badge"], ["data-suffix", ":", 1, "customize-short"], [1, "pointer-base", "me-2", 3, "icon"], [1, "mx-auto", "ms-sm-2", "d-block", "d-sm-inline-flex", "customize-long", "p-2", "p-sm-0"]], template: function AuditComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h2");
    \u0275\u0275text(2, "Audit");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 1)(4, "div", 2)(5, "span", 3)(6, "span", 4);
    \u0275\u0275element(7, "fa-icon", 5);
    \u0275\u0275text(8, "Created\xA0at");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "span", 6);
    \u0275\u0275text(10);
    \u0275\u0275pipe(11, "date");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(12, "div", 1)(13, "div", 2)(14, "span", 3)(15, "span", 4);
    \u0275\u0275element(16, "fa-icon", 5);
    \u0275\u0275text(17, "Created\xA0by");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "span", 6);
    \u0275\u0275text(19);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(20, "div", 1)(21, "div", 2)(22, "span", 3)(23, "span", 4);
    \u0275\u0275element(24, "fa-icon", 5);
    \u0275\u0275text(25, "Modified\xA0at");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(26, "span", 6);
    \u0275\u0275text(27);
    \u0275\u0275pipe(28, "date");
    \u0275\u0275elementEnd()()()();
    \u0275\u0275elementStart(29, "div", 1)(30, "div", 2)(31, "span", 3)(32, "span", 4);
    \u0275\u0275element(33, "fa-icon", 5);
    \u0275\u0275text(34, "Modified\xA0by");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(35, "span", 6);
    \u0275\u0275text(36);
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(7);
    \u0275\u0275property("icon", ctx.faCalendar);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(11, 8, ctx.audit == null ? null : ctx.audit.createdAt, "dd-MM-yyyy hh:mm:ss"));
    \u0275\u0275advance(6);
    \u0275\u0275property("icon", ctx.faUser);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx.audit == null ? null : ctx.audit.createdBy);
    \u0275\u0275advance(5);
    \u0275\u0275property("icon", ctx.faCalendar);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(28, 11, ctx.audit == null ? null : ctx.audit.modifiedAt, "dd-MM-yyyy hh:mm:ss"));
    \u0275\u0275advance(6);
    \u0275\u0275property("icon", ctx.faUser);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx.audit == null ? null : ctx.audit.modifiedBy);
  }
}, dependencies: [FaIconComponent, DatePipe], styles: ["\n\n.container[_ngcontent-%COMP%] {\n  max-width: 280px;\n  color: #e5e5e5;\n  border-style: solid;\n  border-width: thin;\n  box-shadow: 0 1px 3px 1px rgba(211, 116, 0, 0.2588235294);\n  border-color: #343a40;\n  border-radius: 20px;\n  padding-top: 10px;\n  padding-bottom: 10px;\n}\n.customize-short[_ngcontent-%COMP%] {\n  color: var(--color-text);\n  width: 95px;\n}\n.customize-long[_ngcontent-%COMP%] {\n  color: var(--color-text);\n  width: 190px;\n}\n.badge[_ngcontent-%COMP%] {\n  font-size: 0.85em;\n  font-weight: 500;\n}\n@media screen and (min-width: 487px) {\n  span[_ngcontent-%COMP%]:after {\n    content: attr(data-suffix);\n  }\n}\n/*# sourceMappingURL=audit.component.css.map */"] });
var AuditComponent = _AuditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AuditComponent, { className: "AuditComponent", filePath: "src/app/shared/audit/audit.component.ts", lineNumber: 11 });
})();

// src/app/category/category-view/category-view.component.ts
var _c019 = () => ["/categories/upsert"];
var _c111 = (a0) => ({ categoryUrl: a0 });
function CategoryViewComponent_span_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty description!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faThrash);
  }
}
function CategoryViewComponent_div_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 17)(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.selectedCategory.description);
  }
}
var _CategoryViewComponent = class _CategoryViewComponent {
  constructor(categoryService, route, actRoute, spinner, toastr) {
    this.categoryService = categoryService;
    this.route = route;
    this.actRoute = actRoute;
    this.spinner = spinner;
    this.toastr = toastr;
    this.selectedCategory = new Category();
    this.auditCategory = new Audit();
    this.faEdit = AppConstants.iconEdit;
    this.faThrash = AppConstants.iconTrash;
    this.faCalendar = AppConstants.iconCalendar;
    this.faUser = AppConstants.iconUser;
    this.faEye = AppConstants.iconEye;
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.errorDto = new ErrorDto();
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.spinner.show().then((r2) => r2);
    this.actRoute.paramMap.subscribe((params) => {
      this.selectedOriginalCategoryUrl = params.get("categoryUrl");
    });
    this.categoryService.getCategory(this.selectedOriginalCategoryUrl, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (categoryResponse) => {
        this.spinner.hide().then(() => this.toastr.info("Category " + this.selectedOriginalCategoryUrl + " loaded", "Category"));
        this.selectedCategory = categoryResponse.data;
        this.auditCategory = categoryResponse.audit;
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto + " failed", "Category"));
        this.selectedCategory = new Category();
        this.auditCategory = new Audit();
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_CategoryViewComponent.\u0275fac = function CategoryViewComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CategoryViewComponent)(\u0275\u0275directiveInject(CategoryService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_CategoryViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _CategoryViewComponent, selectors: [["app-category-view"]], standalone: false, decls: 24, vars: 13, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-4", "col-sm-8", "align-self-center"], [1, "box-part", "text-center", "text-white"], [1, "mb-3"], [1, "pointer", 3, "routerLink", "queryParams"], [1, "url", 3, "icon"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "mb-3", "mx-3"], ["class", "trash", 4, "ngIf"], [1, "text-center"], ["class", "content", 4, "ngIf"], [3, "audit"], [3, "errorDto"], ["type", "button", "appBackButton", "", 1, "btn", "btn-danger"], [3, "icon"], [1, "trash"], [1, "content"]], template: function CategoryViewComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h2");
    \u0275\u0275text(5, "Category Detail");
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "hr");
    \u0275\u0275elementStart(7, "span");
    \u0275\u0275text(8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "div", 4)(10, "div", 5);
    \u0275\u0275element(11, "fa-icon", 6);
    \u0275\u0275text(12);
    \u0275\u0275elementEnd()();
    \u0275\u0275element(13, "ngx-spinner", 7);
    \u0275\u0275elementStart(14, "div", 8);
    \u0275\u0275template(15, CategoryViewComponent_span_15_Template, 3, 1, "span", 9);
    \u0275\u0275elementStart(16, "span", 10);
    \u0275\u0275text(17, " Description");
    \u0275\u0275elementEnd();
    \u0275\u0275template(18, CategoryViewComponent_div_18_Template, 3, 1, "div", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275element(19, "app-audit", 12)(20, "app-error", 13);
    \u0275\u0275elementStart(21, "button", 14);
    \u0275\u0275element(22, "fa-icon", 15);
    \u0275\u0275text(23, "\xA0Back ");
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(8);
    \u0275\u0275textInterpolate1("name: ", ctx.selectedCategory.name, "");
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(10, _c019))("queryParams", \u0275\u0275pureFunction1(11, _c111, ctx.selectedOriginalCategoryUrl));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx.faEdit);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0", ctx.selectedOriginalCategoryUrl, " ");
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", !ctx.selectedCategory.description);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx.selectedCategory.description);
    \u0275\u0275advance();
    \u0275\u0275property("audit", ctx.auditCategory);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faArrowLeft);
  }
}, dependencies: [NgIf, FaIconComponent, ErrorComponent, AuditComponent, RouterLink, NgxSpinnerComponent], encapsulation: 2 });
var CategoryViewComponent = _CategoryViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(CategoryViewComponent, { className: "CategoryViewComponent", filePath: "src/app/category/category-view/category-view.component.ts", lineNumber: 22 });
})();

// src/app/model/admin/role.ts
var Role;
(function(Role2) {
  Role2[Role2["OWNER"] = 0] = "OWNER";
  Role2[Role2["ADMIN"] = 1] = "ADMIN";
  Role2[Role2["EMPLOYEE"] = 2] = "EMPLOYEE";
  Role2[Role2["USER"] = 3] = "USER";
})(Role || (Role = {}));

// src/app/account/account-list/account-list.component.ts
var _c020 = (a0) => ({ "col-sm-3": a0 });
var _c112 = (a0) => ["/accounts/edit/", a0];
function AccountListComponent_div_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275element(1, "fa-icon", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faDelete);
  }
}
function AccountListComponent_div_20_div_25_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 25)(1, "button", 29);
    \u0275\u0275listener("click", function AccountListComponent_div_20_div_25_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r2);
      const admin_r3 = \u0275\u0275nextContext().$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.deleteAccount(admin_r3.username));
    });
    \u0275\u0275element(2, "fa-icon", 27);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx_r0.faDelete);
  }
}
function AccountListComponent_div_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 18)(1, "div", 19)(2, "div", 20)(3, "span", 21);
    \u0275\u0275text(4, "Username:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "span", 22);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 23)(8, "span", 21);
    \u0275\u0275text(9, "Email:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "span", 22);
    \u0275\u0275text(11);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(12, "div", 20)(13, "span", 21);
    \u0275\u0275text(14, "Role:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "span", 22);
    \u0275\u0275text(16);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 24)(18, "span", 21);
    \u0275\u0275text(19, "Status:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "span", 22);
    \u0275\u0275text(21);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "div", 25)(23, "button", 26);
    \u0275\u0275element(24, "fa-icon", 27);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(25, AccountListComponent_div_20_div_25_Template, 3, 1, "div", 28);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const admin_r3 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(admin_r3.username);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(admin_r3.email);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(admin_r3.role);
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(8, _c020, !ctx_r0.showDelete()));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(admin_r3.status);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(10, _c112, admin_r3.username));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faEdit);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.showDelete());
  }
}
var _AccountListComponent = class _AccountListComponent {
  constructor(accountService, authService, router, spinner, toastr) {
    this.accountService = accountService;
    this.authService = authService;
    this.router = router;
    this.spinner = spinner;
    this.toastr = toastr;
    this.destroy$ = new Subject();
    this.adminList = new Array();
    this.faEdit = AppConstants.iconEdit;
    this.faDelete = AppConstants.iconDelete;
  }
  ngOnInit() {
    this.errorDto = new ErrorDto();
    this.currentAdmin = this.authService.currentAdminValue;
    this.getAccounts();
  }
  getAccounts() {
    this.spinner.show("accountSpinner").then((r2) => r2);
    this.accountService.getAccounts(this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (adminList) => {
        this.spinner.hide("accountSpinner").then(() => this.toastr.info(adminList.data.length + " accounts reloaded", "Accounts"));
        this.adminList = adminList.data;
      },
      error: () => {
        this.spinner.hide("accountSpinner").then(() => {
          this.toastr.error(this.errorDto.httpStatus + " load accounts failed", "Accounts");
          this.adminList = new Array();
        });
      }
    });
  }
  deleteAccount(username) {
    if (!confirm("Are you sure to delete account?" + username + "?")) {
      return;
    }
    this.spinner.show().then((r2) => r2);
    this.accountService.deleteAccount(username, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide().then(() => {
          this.info = "Account " + username + " deleted";
          this.errorDto = new ErrorDto();
          this.toastr.success(" 204 account " + username + " deleted", "Account");
          setTimeout(() => {
            this.info = null;
          }, AppConstants.toastSuccessDelay);
          this.getAccounts();
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(+this.errorDto.httpStatus + " delete failed", "Account"));
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  showDelete() {
    return this.currentAdmin?.role?.toString() == Role[Role.OWNER];
  }
};
_AccountListComponent.\u0275fac = function AccountListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AccountListComponent)(\u0275\u0275directiveInject(AccountService), \u0275\u0275directiveInject(AuthService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_AccountListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AccountListComponent, selectors: [["app-account-list"]], standalone: false, decls: 25, vars: 8, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-8", "col-md-10", "col-12", "align-self-center"], [1, "box-part", "text-center"], [1, "text-orange", "mb-3"], [1, "row", "text-center", "d-none", "d-sm-flex"], [1, "col-sm-4"], [1, "text-darkorange"], [1, "col-sm-2"], [1, "col-sm-2", 3, "ngClass"], [1, "col-sm-1"], [1, "text-darkorange", 3, "icon"], ["class", "col-sm-1", 4, "ngIf"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["class", "row text-center text-sm-start", 4, "ngFor", "ngForOf"], [3, "info"], [3, "errorDto"], ["routerLink", "/accounts/create", 1, "btn", "btn-primary", "mt-3"], [1, "row", "text-center", "text-sm-start"], [1, "input-group", "link"], [1, "col-12", "col-sm-2", "border-bottom"], [1, "d-sm-none", "text-darkorange"], [1, "text-white"], [1, "col-12", "col-sm-4", "border-bottom"], [1, "col-12", "col-sm-2", "border-bottom", 3, "ngClass"], [1, "col-12", "col-sm-1", "border-bottom", "text-center"], [1, "btn", "btn-primary", "btn-sm", 3, "routerLink"], [3, "icon"], ["class", "col-12 col-sm-1 border-bottom text-center", 4, "ngIf"], [1, "btn", "btn-danger", "btn-sm", 3, "click"]], template: function AccountListComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h3", 4);
    \u0275\u0275text(5, "Accounts");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 5)(7, "div", 6)(8, "span", 7);
    \u0275\u0275text(9, "Email");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "div", 8)(11, "span", 7);
    \u0275\u0275text(12, "Role");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "div", 9)(14, "span", 7);
    \u0275\u0275text(15, "Status");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(16, "div", 10);
    \u0275\u0275element(17, "fa-icon", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275template(18, AccountListComponent_div_18_Template, 2, 1, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275element(19, "ngx-spinner", 13);
    \u0275\u0275template(20, AccountListComponent_div_20_Template, 26, 12, "div", 14);
    \u0275\u0275element(21, "app-info", 15)(22, "app-error", 16);
    \u0275\u0275elementStart(23, "button", 17);
    \u0275\u0275text(24, " Create account ");
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(13);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(6, _c020, !ctx.showDelete()));
    \u0275\u0275advance(4);
    \u0275\u0275property("icon", ctx.faEdit);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.showDelete());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.adminList);
    \u0275\u0275advance();
    \u0275\u0275property("info", ctx.info);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
  }
}, dependencies: [NgClass, NgForOf, NgIf, ErrorComponent, InfoComponent, NgxSpinnerComponent, FaIconComponent, RouterLink], encapsulation: 2 });
var AccountListComponent = _AccountListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AccountListComponent, { className: "AccountListComponent", filePath: "src/app/account/account-list/account-list.component.ts", lineNumber: 21 });
})();

// src/app/model/admin/admin.ts
var Admin = class {
};

// src/app/account/account-edit/account-edit.component.ts
var _c021 = () => ({ standalone: true });
function AccountEditComponent_div_14_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Name is required.");
    \u0275\u0275elementEnd();
  }
}
function AccountEditComponent_div_14_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Name must be at least 4 characters long.");
    \u0275\u0275elementEnd();
  }
}
function AccountEditComponent_div_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 26);
    \u0275\u0275template(1, AccountEditComponent_div_14_div_1_Template, 2, 0, "div", 27)(2, AccountEditComponent_div_14_div_2_Template, 2, 0, "div", 27);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const username_r2 = \u0275\u0275reference(13);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", username_r2.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", username_r2.errors.minlength);
  }
}
function AccountEditComponent_div_20_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Email is required.");
    \u0275\u0275elementEnd();
  }
}
function AccountEditComponent_div_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 26);
    \u0275\u0275template(1, AccountEditComponent_div_20_div_1_Template, 2, 0, "div", 27);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const email_r3 = \u0275\u0275reference(19);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", email_r3.errors.required);
  }
}
function AccountEditComponent_option_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const role_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", role_r5, " ");
  }
}
function AccountEditComponent_div_27_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Role must be selected. ");
    \u0275\u0275elementEnd();
  }
}
function AccountEditComponent_div_27_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Role must be at least 4 characters long. ");
    \u0275\u0275elementEnd();
  }
}
function AccountEditComponent_div_27_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 26);
    \u0275\u0275template(1, AccountEditComponent_div_27_div_1_Template, 2, 0, "div", 27)(2, AccountEditComponent_div_27_div_2_Template, 2, 0, "div", 27);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const select_r4 = \u0275\u0275reference(25);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", select_r4.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", select_r4.errors.minlength);
  }
}
var _AccountEditComponent = class _AccountEditComponent {
  constructor(accountService, authService, spinner, toastr, route, actRoute) {
    this.accountService = accountService;
    this.authService = authService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.route = route;
    this.actRoute = actRoute;
    this.originalUsername = "";
    this.selectedAccount = new Admin();
    this.audit = new Audit();
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.destroy$ = new Subject();
    this.info = "";
    this.faUser = AppConstants.iconUser;
    this.faCalendar = AppConstants.iconCalendar;
    this.roleHelper = Role;
  }
  ngOnInit() {
    this.roles = Object.keys(Role).map((key) => Role[key]).filter((value2) => typeof value2 === "string" && value2 != Role[Role.OWNER]);
    this.currentAdmin = this.authService.currentAdminValue;
    this.errorDto = new ErrorDto();
    this.actRoute.paramMap.subscribe((params) => {
      this.originalUsername = params.get("username");
      this.loadAccount(this.originalUsername);
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  updateAccount() {
    this.spinner.show("accountSpinner").then((r2) => r2);
    this.accountService.editAccount(this.selectedAccount, this.originalUsername, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (adminResponse) => {
        this.spinner.hide("accountSpinner").then(() => {
          this.toastr.success("Account updated 200", "Accounts");
          this.selectedAccount = adminResponse.data;
          this.audit = adminResponse.audit;
          this.errorDto = new ErrorDto();
          this.info = "Account updated";
          setTimeout(() => {
            this.route.navigate(["/accounts"]);
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide("accountSpinner").then(() => {
          this.toastr.error("Account update failed " + this.errorDto.httpStatus, "Accounts");
        });
      }
    });
  }
  loadAccount(username) {
    this.spinner.show("accountSpinner").then((r2) => r2);
    this.accountService.getAccount(username, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (adminResponse) => {
        this.spinner.hide("accountSpinner").then(() => this.toastr.info("account reloaded", "Accounts"));
        this.selectedAccount = adminResponse.data;
        this.audit = adminResponse.audit;
        this.errorDto = new ErrorDto();
        if (this.selectedAccount.role.toString() == Role[Role.OWNER]) {
          this.roles.push(Role[Role.OWNER]);
        }
      },
      error: () => {
        this.spinner.hide("accountSpinner").then(() => {
          this.selectedAccount = new Admin();
          this.toastr.error("Unable to load account " + this.errorDto.httpStatus, "Accounts");
        });
      }
    });
  }
  selectRole(value2) {
    this.selectedAccount.role = value2;
  }
  isOwnAccountOrOwnerRole() {
    return !this.isNotOwnAccount() || this.selectedAccount?.role?.toString() == Role[Role.OWNER];
  }
  isNotOwnAccount() {
    return this.currentAdmin.username != this.originalUsername;
  }
};
_AccountEditComponent.\u0275fac = function AccountEditComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AccountEditComponent)(\u0275\u0275directiveInject(AccountService), \u0275\u0275directiveInject(AuthService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute));
};
_AccountEditComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AccountEditComponent, selectors: [["app-account-edit"]], standalone: false, decls: 37, vars: 17, consts: [["editAccountForm", "ngForm"], ["username", "ngModel"], ["email", "ngModel"], ["select", "ngModel"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-4", "col-sm-6", "align-self-center"], [1, "box-part", "text-center"], ["novalidate", "", 3, "ngSubmit"], [3, "audit"], [1, "mb-1"], ["for", "account-username", 1, "col-form-label"], ["id", "account-username", "name", "username", "type", "text", "placeholder", "required", "required", "", "minlength", "4", 1, "form-control", 3, "ngModelChange", "ngModel", "disabled"], ["class", "alert alert-danger", 4, "ngIf"], ["for", "account-email", 1, "col-form-label"], ["id", "account-email", "name", "email", "type", "text", "placeholder", "required", "required", "", "minlength", "4", 1, "form-control", 3, "ngModelChange", "ngModel", "disabled"], ["for", "account-role", 1, "col-form-label"], ["id", "account-role", "minlength", "4", 1, "form-select", "mb-3", 3, "ngModelChange", "ngModel", "ngModelOptions", "disabled"], [4, "ngFor", "ngForOf"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [3, "info"], [3, "errorDto"], [1, "col-auto"], ["type", "submit", 1, "ms-3", "ms-sm-5", "btn", "btn-primary", 3, "disabled"], ["type", "button", "appBackButton", "", 1, "ms-3", "ms-sm-5", "btn", "btn-danger"], [1, "me-2", 3, "icon"], [1, "alert", "alert-danger"], [4, "ngIf"]], template: function AccountEditComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 5)(2, "div", 6)(3, "div", 7)(4, "form", 8, 0);
    \u0275\u0275listener("ngSubmit", function AccountEditComponent_Template_form_ngSubmit_4_listener() {
      \u0275\u0275restoreView(_r1);
      const username_r2 = \u0275\u0275reference(13);
      const email_r3 = \u0275\u0275reference(19);
      const select_r4 = \u0275\u0275reference(25);
      return \u0275\u0275resetView((select_r4.valid || select_r4.isDisabled) && (email_r3.valid || email_r3.isDisabled) && (username_r2.valid || username_r2.isDisabled) && ctx.updateAccount());
    });
    \u0275\u0275elementStart(6, "h2");
    \u0275\u0275text(7, "Update account");
    \u0275\u0275elementEnd();
    \u0275\u0275element(8, "app-audit", 9);
    \u0275\u0275elementStart(9, "div", 10)(10, "label", 11);
    \u0275\u0275text(11, "Username");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "input", 12, 1);
    \u0275\u0275twoWayListener("ngModelChange", function AccountEditComponent_Template_input_ngModelChange_12_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedAccount.username, $event) || (ctx.selectedAccount.username = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(14, AccountEditComponent_div_14_Template, 3, 2, "div", 13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "div", 10)(16, "label", 14);
    \u0275\u0275text(17, "Email");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "input", 15, 2);
    \u0275\u0275twoWayListener("ngModelChange", function AccountEditComponent_Template_input_ngModelChange_18_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedAccount.email, $event) || (ctx.selectedAccount.email = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(20, AccountEditComponent_div_20_Template, 2, 1, "div", 13);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(21, "div", 10)(22, "label", 16);
    \u0275\u0275text(23, "Role");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(24, "select", 17, 3);
    \u0275\u0275twoWayListener("ngModelChange", function AccountEditComponent_Template_select_ngModelChange_24_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedAccount.role, $event) || (ctx.selectedAccount.role = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function AccountEditComponent_Template_select_ngModelChange_24_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.selectRole($event));
    });
    \u0275\u0275template(26, AccountEditComponent_option_26_Template, 2, 1, "option", 18);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(27, AccountEditComponent_div_27_Template, 3, 2, "div", 13);
    \u0275\u0275element(28, "ngx-spinner", 19)(29, "app-info", 20)(30, "app-error", 21);
    \u0275\u0275elementStart(31, "div", 22)(32, "button", 23);
    \u0275\u0275text(33, "Submit");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(34, "button", 24);
    \u0275\u0275element(35, "fa-icon", 25);
    \u0275\u0275text(36, "Back");
    \u0275\u0275elementEnd()()()()()()();
  }
  if (rf & 2) {
    const editAccountForm_r6 = \u0275\u0275reference(5);
    const username_r2 = \u0275\u0275reference(13);
    const email_r3 = \u0275\u0275reference(19);
    const select_r4 = \u0275\u0275reference(25);
    \u0275\u0275advance(8);
    \u0275\u0275property("audit", ctx.audit);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedAccount.username);
    \u0275\u0275property("disabled", ctx.isNotOwnAccount());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", editAccountForm_r6.submitted && username_r2.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedAccount.email);
    \u0275\u0275property("disabled", ctx.isNotOwnAccount());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", editAccountForm_r6.submitted && email_r3.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedAccount.role);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(16, _c021))("disabled", ctx.isOwnAccountOrOwnerRole());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.roles);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", editAccountForm_r6.submitted && select_r4.invalid);
    \u0275\u0275advance(2);
    \u0275\u0275property("info", ctx.info);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(2);
    \u0275\u0275property("disabled", !(editAccountForm_r6.dirty || select_r4.dirty));
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx.faArrowLeft);
  }
}, dependencies: [NgForOf, NgIf, ErrorComponent, InfoComponent, AuditComponent, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, SelectControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, NgModel, NgForm, NgxSpinnerComponent, FaIconComponent], styles: ["\n\n.list-unstyled[_ngcontent-%COMP%] {\n  color: #e5e5e5;\n  text-align: left;\n}\n.child[_ngcontent-%COMP%] {\n  min-width: 100px;\n  width: 220px;\n  margin: 0 auto;\n}\n/*# sourceMappingURL=account-edit.component.css.map */"] });
var AccountEditComponent = _AccountEditComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AccountEditComponent, { className: "AccountEditComponent", filePath: "src/app/account/account-edit/account-edit.component.ts", lineNumber: 24 });
})();

// src/app/account/account-create/account-create.component.ts
var _c022 = () => ({ standalone: true });
function AccountCreateComponent_div_14_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Name is required.");
    \u0275\u0275elementEnd();
  }
}
function AccountCreateComponent_div_14_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Name must be at least 4 characters long.");
    \u0275\u0275elementEnd();
  }
}
function AccountCreateComponent_div_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 27);
    \u0275\u0275template(1, AccountCreateComponent_div_14_div_1_Template, 2, 0, "div", 28)(2, AccountCreateComponent_div_14_div_2_Template, 2, 0, "div", 28);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const username_r3 = \u0275\u0275reference(12);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", username_r3.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", username_r3.errors.minlength);
  }
}
function AccountCreateComponent_div_20_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Email is required.");
    \u0275\u0275elementEnd();
  }
}
function AccountCreateComponent_div_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 29);
    \u0275\u0275template(1, AccountCreateComponent_div_20_div_1_Template, 2, 0, "div", 28);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const email_r4 = \u0275\u0275reference(19);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", email_r4.errors.required);
  }
}
function AccountCreateComponent_option_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 30);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const role_r5 = ctx.$implicit;
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275property("ngValue", ctx_r5.roleHelper[role_r5]);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", role_r5, " ");
  }
}
function AccountCreateComponent_div_27_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " ROle must be selected. ");
    \u0275\u0275elementEnd();
  }
}
function AccountCreateComponent_div_27_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Role must be at least 4 characters long. ");
    \u0275\u0275elementEnd();
  }
}
function AccountCreateComponent_div_27_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 27);
    \u0275\u0275template(1, AccountCreateComponent_div_27_div_1_Template, 2, 0, "div", 28)(2, AccountCreateComponent_div_27_div_2_Template, 2, 0, "div", 28);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const select_r7 = \u0275\u0275reference(25);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", select_r7.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", select_r7.errors.minlength);
  }
}
function AccountCreateComponent_div_30_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 31);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("", ctx_r5.info, " ");
  }
}
var _AccountCreateComponent = class _AccountCreateComponent {
  constructor(accountService, authService, spinner, toastr, route) {
    this.accountService = accountService;
    this.authService = authService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.route = route;
    this.account = new Admin();
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.destroy$ = new Subject();
    this.info = "";
    this.roles = Object.keys(Role).map((key) => Role[key]).filter((value2) => typeof value2 === "string" && value2 != Role[Role.OWNER]);
    this.faUser = AppConstants.iconUser;
    this.roleHelper = Role;
    this.faCalendar = AppConstants.iconCalendar;
  }
  ngOnInit() {
    this.account = new Admin();
    this.account.role = Role.ADMIN;
    this.errorDto = new ErrorDto();
  }
  selectRole(value2) {
    this.account.role = value2;
  }
  createAccount() {
    this.spinner.show("accountSpinner").then((r2) => r2);
    this.accountService.createAccount(this.account, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (adminResponse) => {
        this.spinner.hide("accountSpinner").then(() => {
          this.toastr.success("Account updated 200", "Accounts");
          this.account = adminResponse.data;
          this.errorDto = new ErrorDto();
          this.info = "Account created";
          setTimeout(() => {
            this.route.navigate(["/accounts"]);
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide("accountSpinner").then(() => {
          this.toastr.error("Account create failed " + this.errorDto.httpStatus, "Accounts");
        });
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_AccountCreateComponent.\u0275fac = function AccountCreateComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AccountCreateComponent)(\u0275\u0275directiveInject(AccountService), \u0275\u0275directiveInject(AuthService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService), \u0275\u0275directiveInject(Router));
};
_AccountCreateComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AccountCreateComponent, selectors: [["app-account-create"]], standalone: false, decls: 38, vars: 12, consts: [["createAccountForm", "ngForm"], ["username", "ngModel"], ["email", "ngModel"], ["select", "ngModel"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-3", "col-md-10", "col-sm-12", "align-self-center"], [1, "box-part", "text-center"], ["novalidate", "", 3, "ngSubmit"], [1, "mb-1"], ["for", "account-username", 1, "col-form-label"], ["id", "account-username", "name", "username", "type", "text", "placeholder", "required", "required", "", "minlength", "4", 1, "form-control", 3, "ngModelChange", "ngModel"], [1, "mt-1"], ["class", "alert alert-danger", 4, "ngIf"], ["for", "account-email", 1, "col-form-label"], ["id", "account-email", "name", "email", "type", "text", "placeholder", "required", "required", "", "minlength", "4", 1, "form-control", 3, "ngModelChange", "ngModel"], ["class", "alert alert-danger mt-1", 4, "ngIf"], ["for", "account-role", 1, "col-form-label"], ["id", "account-role", "minlength", "4", 1, "form-select", "form-select-lg", "mb-3", 3, "ngModelChange", "ngModel", "ngModelOptions"], [3, "ngValue", 4, "ngFor", "ngForOf"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "mb-3"], ["class", "alert alert-success", "role", "alert", 4, "ngIf"], [3, "errorDto"], ["type", "submit", 1, "btn", "btn-primary", "m-3"], ["type", "button", "appBackButton", "", 1, "ms-2", "btn", "btn-danger", "m-3"], [3, "icon"], [1, "alert", "alert-danger"], [4, "ngIf"], [1, "alert", "alert-danger", "mt-1"], [3, "ngValue"], ["role", "alert", 1, "alert", "alert-success"]], template: function AccountCreateComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 5)(2, "div", 6)(3, "div", 7)(4, "form", 8, 0);
    \u0275\u0275listener("ngSubmit", function AccountCreateComponent_Template_form_ngSubmit_4_listener() {
      \u0275\u0275restoreView(_r1);
      const createAccountForm_r2 = \u0275\u0275reference(5);
      return \u0275\u0275resetView(createAccountForm_r2.form.valid && ctx.createAccount());
    });
    \u0275\u0275elementStart(6, "h2");
    \u0275\u0275text(7, "Create account");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 9)(9, "label", 10);
    \u0275\u0275text(10, "Username");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "input", 11, 1);
    \u0275\u0275twoWayListener("ngModelChange", function AccountCreateComponent_Template_input_ngModelChange_11_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.account.username, $event) || (ctx.account.username = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "div", 12);
    \u0275\u0275template(14, AccountCreateComponent_div_14_Template, 3, 2, "div", 13);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(15, "div", 9)(16, "label", 14);
    \u0275\u0275text(17, "Email");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(18, "input", 15, 2);
    \u0275\u0275twoWayListener("ngModelChange", function AccountCreateComponent_Template_input_ngModelChange_18_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.account.email, $event) || (ctx.account.email = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275template(20, AccountCreateComponent_div_20_Template, 2, 1, "div", 16);
    \u0275\u0275elementStart(21, "div", 9)(22, "label", 17);
    \u0275\u0275text(23, "Role");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(24, "select", 18, 3);
    \u0275\u0275twoWayListener("ngModelChange", function AccountCreateComponent_Template_select_ngModelChange_24_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.account.role, $event) || (ctx.account.role = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function AccountCreateComponent_Template_select_ngModelChange_24_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.selectRole($event));
    });
    \u0275\u0275template(26, AccountCreateComponent_option_26_Template, 2, 2, "option", 19);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(27, AccountCreateComponent_div_27_Template, 3, 2, "div", 13);
    \u0275\u0275element(28, "ngx-spinner", 20);
    \u0275\u0275elementStart(29, "div", 21);
    \u0275\u0275template(30, AccountCreateComponent_div_30_Template, 2, 1, "div", 22);
    \u0275\u0275elementEnd();
    \u0275\u0275element(31, "app-error", 23);
    \u0275\u0275elementStart(32, "div", 21)(33, "button", 24);
    \u0275\u0275text(34, "Create ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(35, "button", 25);
    \u0275\u0275element(36, "fa-icon", 26);
    \u0275\u0275text(37, "\xA0Back ");
    \u0275\u0275elementEnd()()()()()()();
  }
  if (rf & 2) {
    const createAccountForm_r2 = \u0275\u0275reference(5);
    const username_r3 = \u0275\u0275reference(12);
    const email_r4 = \u0275\u0275reference(19);
    const select_r7 = \u0275\u0275reference(25);
    \u0275\u0275advance(11);
    \u0275\u0275twoWayProperty("ngModel", ctx.account.username);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", createAccountForm_r2.submitted && username_r3.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.account.email);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", createAccountForm_r2.submitted && email_r4.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.account.role);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(11, _c022));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.roles);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", createAccountForm_r2.submitted && select_r7.invalid);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx.info);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(5);
    \u0275\u0275property("icon", ctx.faArrowLeft);
  }
}, dependencies: [NgForOf, NgIf, ErrorComponent, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, SelectControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, NgModel, NgForm, NgxSpinnerComponent, FaIconComponent], encapsulation: 2 });
var AccountCreateComponent = _AccountCreateComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AccountCreateComponent, { className: "AccountCreateComponent", filePath: "src/app/account/account-create/account-create.component.ts", lineNumber: 21 });
})();

// src/app/shared/pagination/pagination.component.ts
var _c023 = (a0) => ({ "disabled": a0 });
var _c113 = (a0) => ({ "active": a0 });
function PaginationComponent_li_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 1)(1, "a", 2);
    \u0275\u0275listener("click", function PaginationComponent_li_4_Template_a_click_1_listener($event) {
      const i_r2 = \u0275\u0275restoreView(_r1).index;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.setPage(i_r2, $event));
    });
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const i_r2 = ctx.index;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(2, _c113, i_r2 === ctx_r2.page));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(i_r2);
  }
}
var _PaginationComponent = class _PaginationComponent {
  constructor() {
    this.page = 0;
    this.pageChangeEmitter = new EventEmitter();
  }
  setPage(i, event) {
    event.preventDefault();
    this.page = i;
    this.pageChangeEmitter.emit(this.page);
  }
  setPageBack(event) {
    event.preventDefault();
    if (this.page - 1 >= 0) {
      this.page = this.page - 1;
      this.pageChangeEmitter.emit(this.page);
    }
  }
  setPageForward(event) {
    event.preventDefault();
    if (this.page + 1 < this.pages.length) {
      this.page = this.page + 1;
      this.pageChangeEmitter.emit(this.page);
    }
  }
};
_PaginationComponent.\u0275fac = function PaginationComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PaginationComponent)();
};
_PaginationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _PaginationComponent, selectors: [["app-pagination"]], inputs: { pages: "pages" }, outputs: { pageChangeEmitter: "pageChangeEmitter" }, standalone: false, decls: 8, vars: 7, consts: [[1, "pagination"], [1, "page-item", 3, "ngClass"], [1, "page-link", 3, "click"], ["class", "page-item", 3, "ngClass", 4, "ngFor", "ngForOf"]], template: function PaginationComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 0)(1, "li", 1)(2, "a", 2);
    \u0275\u0275listener("click", function PaginationComponent_Template_a_click_2_listener($event) {
      return ctx.setPageBack($event);
    });
    \u0275\u0275text(3, "Previous");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(4, PaginationComponent_li_4_Template, 3, 4, "li", 3);
    \u0275\u0275elementStart(5, "li", 1)(6, "a", 2);
    \u0275\u0275listener("click", function PaginationComponent_Template_a_click_6_listener($event) {
      return ctx.setPageForward($event);
    });
    \u0275\u0275text(7, "Next");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(3, _c023, ctx.page === 0));
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx.pages);
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(5, _c023, ctx.page === ctx.pages.length - 1));
  }
}, dependencies: [NgClass, NgForOf], encapsulation: 2 });
var PaginationComponent = _PaginationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(PaginationComponent, { className: "PaginationComponent", filePath: "src/app/shared/pagination/pagination.component.ts", lineNumber: 22 });
})();

// src/app/product/product-list/product-list.component.ts
var _c024 = (a0) => ["/products/view/", a0];
var _c114 = () => ["/products/upsert"];
var _c211 = (a0) => ({ productUrl: a0 });
function ProductListComponent_select_10_option_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 25);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const category_r3 = ctx.$implicit;
    \u0275\u0275property("ngValue", category_r3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", category_r3.url, " ");
  }
}
function ProductListComponent_select_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "select", 23);
    \u0275\u0275listener("ngModelChange", function ProductListComponent_select_10_Template_select_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.selectCategory($event));
    });
    \u0275\u0275template(1, ProductListComponent_select_10_option_1_Template, 2, 2, "option", 24);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngModel", ctx_r1.selectedCategory);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.categories);
  }
}
function ProductListComponent_div_36_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 9)(1, "div", 26)(2, "div", 11);
    \u0275\u0275element(3, "span", 27);
    \u0275\u0275elementStart(4, "span", 28);
    \u0275\u0275element(5, "fa-icon", 29);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 13);
    \u0275\u0275element(8, "span", 30);
    \u0275\u0275elementStart(9, "span", 31);
    \u0275\u0275text(10);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 13);
    \u0275\u0275element(12, "span", 32);
    \u0275\u0275elementStart(13, "span", 31);
    \u0275\u0275text(14);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(15, "div", 11);
    \u0275\u0275element(16, "span", 33);
    \u0275\u0275elementStart(17, "span", 31);
    \u0275\u0275text(18);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(19, "div", 11);
    \u0275\u0275element(20, "span", 34);
    \u0275\u0275elementStart(21, "span", 31);
    \u0275\u0275text(22);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(23, "div", 35)(24, "button", 36);
    \u0275\u0275element(25, "fa-icon", 37);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(26, "div", 35)(27, "button", 38);
    \u0275\u0275listener("click", function ProductListComponent_div_36_Template_button_click_27_listener() {
      const product_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.removeProduct(product_r5));
    });
    \u0275\u0275element(28, "fa-icon", 37);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const product_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(4);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(11, _c024, product_r5.url));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r1.faView);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(product_r5.name);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(product_r5.priceAmount);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(product_r5.priceCurrency);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(product_r5.url);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(product_r5.categoryUrls);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(13, _c114))("queryParams", \u0275\u0275pureFunction1(14, _c211, product_r5.url));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r1.faEdit);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx_r1.faTrash);
  }
}
var _ProductListComponent = class _ProductListComponent {
  constructor(categoryService, productService, spinner, toastr) {
    this.categoryService = categoryService;
    this.productService = productService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.pages = new Array(0);
    this.page = 0;
    this.selectedCategory = null;
    this.destroy$ = new Subject();
    this.faTrash = AppConstants.iconTrash;
    this.faEdit = AppConstants.iconEdit;
    this.faEye = AppConstants.iconEye;
    this.faBan = AppConstants.iconBan;
    this.faView = AppConstants.iconEye;
    this.errorDto = new ErrorDto();
  }
  ngOnInit() {
    this.filterProducts(null);
    this.getCategories();
  }
  filterProducts(name) {
    this.spinner.show("productsSpinner").then((r2) => r2);
    this.productService.listProducts(this.page, this.errorDto, name, this.selectedCategory).pipe(debounceTime(400), takeUntil(this.destroy$)).subscribe({
      next: (productFilterResponseDto) => {
        this.spinner.hide("productsSpinner").then(() => {
          this.products = productFilterResponseDto.data;
          this.pages = new Array(productFilterResponseDto.meta.totalPages);
          setTimeout(() => {
            this.errorDto = new ErrorDto();
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide("productsSpinner").then(() => this.toastr.error(this.errorDto.httpStatus + " failed", "Product"));
      }
    });
  }
  removeProduct(product) {
    this.spinner.show("productsSpinner").then((r2) => r2);
    if (!confirm("Are you sure to delete product" + product.name + "?")) {
      this.spinner.hide("productsSpinner").then((r2) => r2);
      return;
    }
    this.productService.deleteProduct(product, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide("productsSpinner").then(() => {
          this.toastr.success(product.name + " deleted", "Product");
          this.products = this.products.filter((data) => data.url !== product.url);
        });
      },
      error: () => {
        this.spinner.hide("productsSpinner").then(() => this.toastr.error(this.errorDto.httpStatus + " delete failed!", "Product"));
      }
    });
  }
  getCategories() {
    this.spinner.show("categoriesSpinner").then((r2) => r2);
    this.categoryService.getCategories(this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (categoriesResponse) => {
        this.spinner.hide("categoriesSpinner").then(() => {
          this.categories = categoriesResponse.data;
          this.categories.push(new Category());
          setTimeout(() => {
            this.errorDto = new ErrorDto();
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide("categoriesSpinner").then(() => this.toastr.error(this.errorDto.httpStatus + " categories failed!", "Category"));
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  selectCategory(event) {
    !event.url ? this.selectedCategory = new Category() : this.selectedCategory = event;
    this.filterProducts();
  }
  setPage($event) {
    this.page = $event;
    this.filterProducts();
  }
};
_ProductListComponent.\u0275fac = function ProductListComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ProductListComponent)(\u0275\u0275directiveInject(CategoryService), \u0275\u0275directiveInject(ProductService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_ProductListComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ProductListComponent, selectors: [["app-product-list"]], standalone: false, decls: 41, vars: 7, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-8", "col-md-10", "col-sm-12", "align-self-center"], [1, "box-part", "text-center"], [1, "text-orange", "mb-3"], [1, "input-group", "my-3"], ["name", "q", "type", "text", "placeholder", "Search by name", 1, "form-control", 3, "ngModelChange", "ngModel"], [1, "input-group-btn"], ["class", "form-control", 3, "ngModel", "ngModelChange", 4, "ngIf"], [1, "row", "link", "text-center", "text-md-start"], [1, "input-group", "d-none", "d-sm-inline-flex"], [1, "col-12", "col-sm-2"], [1, "text-darkorange", "text-center"], [1, "col-12", "col-sm-1"], [1, "text-darkorange"], [1, "col-12", "col-sm-1", "text-center"], [1, "text-darkorange", 3, "icon"], ["name", "categoriesSpinner", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["name", "productsSpinner", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["class", "row link text-center text-md-start", 4, "ngFor", "ngForOf"], [3, "errorDto"], [3, "pageChangeEmitter", "pages"], ["routerLinkActive", "active", "routerLink", "/products/upsert", 1, "btn", "btn-primary"], [1, "form-control", 3, "ngModelChange", "ngModel"], [3, "ngValue", 4, "ngFor", "ngForOf"], [3, "ngValue"], [1, "input-group", "border-bottom", "py-2"], ["data-label", "Name", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], ["routerLinkActive", "active", 1, "pointer", "d-inline-block", "m-2", "text-white", "text-break", 3, "routerLink"], [1, "me-2", 3, "icon"], ["data-label", "Price", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "d-inline-block", "m-2", "text-white"], ["data-label", "Currency", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], ["data-label", "Url", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], ["data-label", "Category url", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "col-12", "col-sm-1", "text-center", "my-auto"], ["routerLinkActive", "active", 1, "btn", "btn-primary", 3, "routerLink", "queryParams"], [3, "icon"], ["routerLinkActive", "active", 1, "btn", "btn-danger", 3, "click"]], template: function ProductListComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h3", 4);
    \u0275\u0275text(5, "Products");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div")(7, "div", 5)(8, "input", 6);
    \u0275\u0275listener("ngModelChange", function ProductListComponent_Template_input_ngModelChange_8_listener($event) {
      return ctx.filterProducts($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "div", 7);
    \u0275\u0275template(10, ProductListComponent_select_10_Template, 2, 2, "select", 8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 9)(12, "div", 10)(13, "div", 11)(14, "span", 12);
    \u0275\u0275text(15, "Name");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(16, "div", 13)(17, "span", 14);
    \u0275\u0275text(18, "Price");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(19, "div", 13)(20, "span", 14);
    \u0275\u0275text(21, "Currency");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(22, "div", 11)(23, "span", 14);
    \u0275\u0275text(24, "Url");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(25, "div", 11)(26, "span", 14);
    \u0275\u0275text(27, "Category url");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(28, "div", 15)(29, "span", 14);
    \u0275\u0275element(30, "fa-icon", 16);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(31, "div", 15)(32, "span", 14);
    \u0275\u0275element(33, "fa-icon", 16);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275element(34, "ngx-spinner", 17)(35, "ngx-spinner", 18);
    \u0275\u0275template(36, ProductListComponent_div_36_Template, 29, 16, "div", 19);
    \u0275\u0275element(37, "app-error", 20);
    \u0275\u0275elementStart(38, "app-pagination", 21);
    \u0275\u0275listener("pageChangeEmitter", function ProductListComponent_Template_app_pagination_pageChangeEmitter_38_listener($event) {
      return ctx.setPage($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(39, "button", 22);
    \u0275\u0275text(40, "Create product ");
    \u0275\u0275elementEnd()()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(8);
    \u0275\u0275property("ngModel", ctx.name);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.categories);
    \u0275\u0275advance(20);
    \u0275\u0275property("icon", ctx.faEdit);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx.faTrash);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx.products);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance();
    \u0275\u0275property("pages", ctx.pages);
  }
}, dependencies: [NgForOf, NgIf, ErrorComponent, PaginationComponent, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, SelectControlValueAccessor, NgControlStatus, NgModel, NgxSpinnerComponent, FaIconComponent, RouterLink], encapsulation: 2 });
var ProductListComponent = _ProductListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ProductListComponent, { className: "ProductListComponent", filePath: "src/app/product/product-list/product-list.component.ts", lineNumber: 19 });
})();

// src/app/model/product/product.ts
var Product = class {
};

// src/app/model/product-sku/product-sku-request.ts
var ProductSkuRequest = class {
  constructor(data) {
    this.data = data;
  }
};

// src/app/service/product-sku.service.ts
var _ProductSkuService = class _ProductSkuService extends BaseService {
  constructor(httpClient) {
    super();
    this.httpClient = httpClient;
    this.productSkuRootUrl = AppConstants.baseUrl + "/api/products/skus/";
    this.productImageEndpoint = this.productSkuRootUrl + "img-upload/";
  }
  upsertProductSkuImage(file, productSkuUrl, errorDto) {
    const formData = new FormData();
    formData.append("file", file);
    return this.httpClient.put(this.productImageEndpoint + productSkuUrl, formData).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  createProductSku(rootUrl, productSkuu, errorDto) {
    const body = JSON.stringify(new ProductSkuRequest(productSkuu));
    return this.httpClient.post(this.productSkuRootUrl + rootUrl, body, { headers: AppConstants.contentTypeAndAcceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  getProductSku(sku, errorDto) {
    return this.httpClient.get(this.productSkuRootUrl + sku, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  deleteProductSku(sku, errorDto) {
    return this.httpClient.delete(this.productSkuRootUrl + sku, { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
  skuList(rootUrl, errorDto) {
    return this.httpClient.get(this.productSkuRootUrl + rootUrl.concat("/by-parent-product"), { headers: AppConstants.acceptJson }).pipe(catchError((err) => this.handleError(err, errorDto)));
  }
};
_ProductSkuService.\u0275fac = function ProductSkuService_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ProductSkuService)(\u0275\u0275inject(HttpClient));
};
_ProductSkuService.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ProductSkuService, factory: _ProductSkuService.\u0275fac, providedIn: "root" });
var ProductSkuService = _ProductSkuService;

// src/app/product/img/img-view.component.ts
function ImgViewComponent_img_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 6);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275propertyInterpolate("alt", ctx_r0.imgName);
    \u0275\u0275property("src", ctx_r0.existingImage.getValue(), \u0275\u0275sanitizeUrl);
  }
}
function ImgViewComponent_img_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 7);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("src", ctx_r0.emptyDefaultImage, \u0275\u0275sanitizeUrl);
  }
}
function ImgViewComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.imgContentType);
  }
}
function ImgViewComponent_details_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "details")(1, "summary");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "code");
    \u0275\u0275text(4, "height x width");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate2("", ctx_r0.height, " x ", ctx_r0.width, "");
  }
}
var _ImgViewComponent = class _ImgViewComponent {
  constructor() {
    this.emptyDefaultImage = AppConstants.emptyDefaultImage;
  }
  ngOnInit() {
    this.existingImage.subscribe((data) => {
      const img = new Image();
      img.src = data;
      img.onload = () => {
        this.width = img.width;
        this.height = img.height;
      };
    });
  }
};
_ImgViewComponent.\u0275fac = function ImgViewComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ImgViewComponent)();
};
_ImgViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ImgViewComponent, selectors: [["app-img-view"]], inputs: { existingImage: "existingImage", imgName: "imgName", imgContentType: "imgContentType" }, standalone: false, decls: 8, vars: 4, consts: [[1, "row", "justify-content-center", "content"], [1, "col-xs-12", "col-md-8"], ["class", "img-fluid mb-2", 3, "src", "alt", 4, "ngIf"], ["class", "img-fluid show-image mb-2", "alt", "empty image", 3, "src", 4, "ngIf"], [1, "info"], [4, "ngIf"], [1, "img-fluid", "mb-2", 3, "src", "alt"], ["alt", "empty image", 1, "img-fluid", "show-image", "mb-2", 3, "src"]], template: function ImgViewComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
    \u0275\u0275template(2, ImgViewComponent_img_2_Template, 1, 2, "img", 2)(3, ImgViewComponent_img_3_Template, 1, 1, "img", 3);
    \u0275\u0275elementStart(4, "div", 4);
    \u0275\u0275template(5, ImgViewComponent_span_5_Template, 2, 1, "span", 5);
    \u0275\u0275element(6, "br");
    \u0275\u0275template(7, ImgViewComponent_details_7_Template, 5, 2, "details", 5);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.existingImage.getValue());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.existingImage.getValue());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.imgContentType);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.height);
  }
}, dependencies: [NgIf], styles: ["\n\ninput[type=file][_ngcontent-%COMP%] {\n  display: none;\n}\n.img-responsive[_ngcontent-%COMP%] {\n  max-width: 100%;\n  height: auto;\n}\n/*# sourceMappingURL=img-update.component.css.map */"] });
var ImgViewComponent = _ImgViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ImgViewComponent, { className: "ImgViewComponent", filePath: "src/app/product/img/img-view.component.ts", lineNumber: 25 });
})();

// src/app/product/product-view/product-view.component.ts
var _c025 = (a0) => ["/products/sku/", a0];
var _c115 = (a0) => ["/categories/view/", a0];
var _c212 = (a0) => ["/products/sku/view/", a0];
function ProductViewComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21)(1, "div", 22)(2, "div", 23);
    \u0275\u0275element(3, "fa-icon", 24);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const cat_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(3, _c115, cat_r1));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r1.faEye);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0", cat_r1, " ");
  }
}
function ProductViewComponent_span_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275element(1, "fa-icon", 19);
    \u0275\u0275text(2, "\xA0\xA0Empty description!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r1.faThrash);
  }
}
function ProductViewComponent_div_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275element(1, "div", 25);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", ctx_r1.selectedProduct.description, \u0275\u0275sanitizeHtml);
  }
}
function ProductViewComponent_div_23_div_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 26)(1, "div", 35)(2, "div", 28);
    \u0275\u0275element(3, "span", 36);
    \u0275\u0275elementStart(4, "span", 37);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 30);
    \u0275\u0275element(7, "span", 38);
    \u0275\u0275elementStart(8, "span", 39);
    \u0275\u0275text(9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(10, "div", 30);
    \u0275\u0275element(11, "span", 40);
    \u0275\u0275elementStart(12, "span", 39);
    \u0275\u0275text(13);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(14, "div", 41)(15, "button", 42);
    \u0275\u0275element(16, "fa-icon", 19);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(17, "div", 41)(18, "button", 43);
    \u0275\u0275listener("click", function ProductViewComponent_div_23_div_18_Template_button_click_18_listener() {
      const productSku_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.removeProductSku(productSku_r4));
    });
    \u0275\u0275element(19, "fa-icon", 19);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const productSku_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(productSku_r4.name);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(productSku_r4.sku);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(productSku_r4.priceAmount);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(6, _c212, productSku_r4.sku));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r1.faEye);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx_r1.faTrash);
  }
}
function ProductViewComponent_div_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "div", 26)(2, "div", 27)(3, "div", 28)(4, "span", 29);
    \u0275\u0275text(5, "Name");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 30)(7, "span", 31);
    \u0275\u0275text(8, "Sku");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "div", 30)(10, "span", 31);
    \u0275\u0275text(11, "Price");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(12, "div", 32)(13, "span", 31);
    \u0275\u0275element(14, "fa-icon", 33);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(15, "div", 32)(16, "span", 31);
    \u0275\u0275element(17, "fa-icon", 33);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275template(18, ProductViewComponent_div_23_div_18_Template, 20, 8, "div", 34);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(14);
    \u0275\u0275property("icon", ctx_r1.faEye);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx_r1.faTrash);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.productSkus);
  }
}
var _ProductViewComponent = class _ProductViewComponent {
  constructor(productService, productSkuService, route, actRoute, spinner, toastr) {
    this.productService = productService;
    this.productSkuService = productSkuService;
    this.route = route;
    this.actRoute = actRoute;
    this.spinner = spinner;
    this.toastr = toastr;
    this.selectedProduct = new Product();
    this.selectedAudit = new Audit();
    this.faEdit = AppConstants.iconEdit;
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.faPlus = AppConstants.iconPlus;
    this.faThrash = AppConstants.iconTrash;
    this.faUser = AppConstants.iconUser;
    this.faEye = AppConstants.iconEye;
    this.faTrash = AppConstants.iconTrash;
    this.existingImage = new BehaviorSubject("");
    this.errorDto = new ErrorDto();
    this.destroy$ = new Subject();
    this.errorProductSkuDto = new ErrorDto();
  }
  ngOnInit() {
    this.actRoute.paramMap.subscribe((params) => {
      this.selectedProductOriginalUrl = params.get("productUrl");
      this.getProduct();
      this.getImage();
      this.loadSkus();
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  loadSkus() {
    this.spinner.show("productSkuSpinner").then((r2) => r2);
    return this.productSkuService.skuList(this.selectedProductOriginalUrl, this.errorProductSkuDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (skuResponse) => {
        this.spinner.hide("productSkuSpinner").then(() => {
          this.productSkus = skuResponse.data;
          this.errorProductSkuDto = new ErrorDto();
        });
      },
      error: () => {
        this.spinner.hide("productSkuSpinner").then(() => this.toastr.error(this.errorProductSkuDto.httpStatus + " product skus failed", "Product"));
      }
    });
  }
  getProduct() {
    this.spinner.show("productSpinner").then((r2) => r2);
    return this.productService.getProduct(this.selectedProductOriginalUrl, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (productResponse) => {
        this.spinner.hide("productSpinner").then(() => {
          this.selectedProduct = productResponse.data;
          this.selectedAudit = productResponse.audit;
          this.selectedCategoryUrl = this.selectedProduct.categoryUrls[0];
        });
      },
      error: () => {
        this.spinner.hide("productSpinner").then(() => this.toastr.error(this.errorDto.httpStatus + " product reload failed", "Product"));
      }
    });
  }
  getImage() {
    this.spinner.show("productImageSpinner").then((r2) => r2);
    this.productService.getProductImage(this.selectedProductOriginalUrl, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (productImageData) => {
        this.spinner.hide("productImageSpinner").then(() => {
          if (productImageData.data.bytes == null) {
            this.imgContentType = null;
            this.toastr.warning(this.selectedProductOriginalUrl + " has empty image", "Product");
          } else {
            this.existingImage.next("data:image/jpeg;base64," + productImageData.data.bytes);
            this.imgContentType = productImageData.data.type;
            this.toastr.info(this.selectedProductOriginalUrl + " image reloaded", "Product");
          }
        });
      },
      error: () => {
        this.spinner.hide("productImageSpinner").then(() => this.toastr.error(this.errorDto.httpStatus + " image reloaded fail", "Product"));
      }
    });
  }
  removeProductSku(productSku) {
    if (!confirm("Are you sure to delete sku?" + productSku.sku + "?")) {
      return;
    }
    this.spinner.show("productSkuSpinner").then((r2) => r2);
    return this.productSkuService.deleteProductSku(productSku.sku, this.errorProductSkuDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide("productSkuSpinner").then(() => {
          this.errorProductSkuDto = new ErrorDto();
          this.loadSkus();
        });
      },
      error: () => {
        this.spinner.hide("productSkuSpinner").then(() => this.toastr.error(this.errorProductSkuDto.httpStatus + " product skus failed", "Product"));
      }
    });
  }
};
_ProductViewComponent.\u0275fac = function ProductViewComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ProductViewComponent)(\u0275\u0275directiveInject(ProductService), \u0275\u0275directiveInject(ProductSkuService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_ProductViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ProductViewComponent, selectors: [["app-product-view"]], standalone: false, decls: 31, vars: 16, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-6", "col-sm-10", "align-self-center"], [1, "box-part", "text-center"], ["name", "productImageSpinner", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["name", "productSpinner", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["name", "productSkuSpinner", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "border-bottom", "pb-2"], [1, "m-3"], [3, "audit"], [1, "content", "mt-1"], ["class", "row text-white mb-3", 4, "ngFor", "ngForOf"], [1, "row", "justify-content-center", "content"], [1, "col-xs-12", "col-md-8"], [4, "ngIf"], [3, "imgName", "existingImage", "imgContentType"], [3, "errorDto"], [1, "col-auto", "mt-3"], ["type", "button", "aria-hidden", "true", "appBackButton", "", 1, "btn", "btn-danger", "me-2"], [3, "icon"], ["type", "button", "routerLinkActive", "active", 1, "btn", "btn-primary", "ms-2", 3, "routerLink"], [1, "row", "text-white", "mb-3"], [1, "col"], [1, "pointer", 3, "routerLink"], [1, "url", 3, "icon"], [3, "innerHTML"], [1, "row", "link", "text-center", "text-md-start"], [1, "input-group", "d-none", "d-sm-inline-flex"], [1, "col-12", "col-sm-4"], [1, "text-darkorange", "text-center"], [1, "col-12", "col-sm-3"], [1, "text-darkorange"], [1, "col-12", "col-sm-1", "text-center"], [1, "text-darkorange", 3, "icon"], ["class", "row link text-center text-md-start", 4, "ngFor", "ngForOf"], [1, "input-group", "border-bottom", "py-2"], ["data-label", "Name", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "pointer", "d-inline-block", "m-2", "text-white", "text-break"], ["data-label", "Sku", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "d-inline-block", "m-2", "text-white"], ["data-label", "Price", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "col-12", "col-sm-1", "text-center", "my-auto"], ["routerLinkActive", "active", 1, "btn", "btn-primary", 3, "routerLink"], ["routerLinkActive", "active", 1, "btn", "btn-danger", 3, "click"]], template: function ProductViewComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3);
    \u0275\u0275element(4, "ngx-spinner", 4)(5, "ngx-spinner", 5)(6, "ngx-spinner", 6);
    \u0275\u0275elementStart(7, "h2", 7);
    \u0275\u0275text(8, "Product\xA0detail");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "h3", 8);
    \u0275\u0275text(10);
    \u0275\u0275elementEnd();
    \u0275\u0275element(11, "app-audit", 9);
    \u0275\u0275elementStart(12, "h4", 8);
    \u0275\u0275text(13, "Categories");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "div", 10);
    \u0275\u0275template(15, ProductViewComponent_div_15_Template, 5, 5, "div", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "div", 12)(17, "div", 13);
    \u0275\u0275template(18, ProductViewComponent_span_18_Template, 3, 1, "span", 14)(19, ProductViewComponent_div_19_Template, 2, 1, "div", 14);
    \u0275\u0275elementEnd()();
    \u0275\u0275element(20, "app-img-view", 15)(21, "app-error", 16)(22, "app-error", 16);
    \u0275\u0275template(23, ProductViewComponent_div_23_Template, 19, 3, "div", 14);
    \u0275\u0275elementStart(24, "div", 17)(25, "button", 18);
    \u0275\u0275element(26, "fa-icon", 19);
    \u0275\u0275text(27, "\xA0Back ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(28, "button", 20);
    \u0275\u0275element(29, "fa-icon", 19);
    \u0275\u0275text(30, " Add\xA0sku ");
    \u0275\u0275elementEnd()()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(10);
    \u0275\u0275textInterpolate(ctx.selectedProduct.name);
    \u0275\u0275advance();
    \u0275\u0275property("audit", ctx.selectedAudit);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngForOf", ctx.selectedProduct.categoryUrls);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", !ctx.selectedProduct.description);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.selectedProduct.description);
    \u0275\u0275advance();
    \u0275\u0275property("imgName", ctx.selectedProduct == null ? null : ctx.selectedProduct.name)("existingImage", ctx.existingImage)("imgContentType", ctx.imgContentType);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorProductSkuDto);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", (ctx.productSkus == null ? null : ctx.productSkus.length) > 0);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx.faArrowLeft);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(14, _c025, ctx.selectedProductOriginalUrl));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx.faPlus);
  }
}, dependencies: [NgForOf, NgIf, ErrorComponent, AuditComponent, NgxSpinnerComponent, FaIconComponent, RouterLink, ImgViewComponent], encapsulation: 2 });
var ProductViewComponent = _ProductViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ProductViewComponent, { className: "ProductViewComponent", filePath: "src/app/product/product-view/product-view.component.ts", lineNumber: 26 });
})();

// src/app/common/abstract/base-image-component.ts
var ModuleEnum3 = GenericConfigKeyDto.ModuleEnum;
var BaseImageComponent = class {
  constructor(spinner, toastr, router, productService, genericConfigService, call) {
    this.spinner = spinner;
    this.toastr = toastr;
    this.router = router;
    this.productService = productService;
    this.genericConfigService = genericConfigService;
    this.call = call;
    this.imgErrorDto = new ErrorDto();
    this.maxSize = 0;
    this.maxDimension = 0;
    this.destroy$ = new Subject();
    if (call) {
      this.getConfiguration();
    }
  }
  upsertProductImage(productUrl, errorDto) {
    if (this.selectedFile == null || productUrl == null) {
      this.toastr.success("Product updated");
      return;
    }
    this.spinner.show().then((r2) => r2);
    this.productService.updateProductImage(this.selectedFile, productUrl, errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide().then(() => {
          this.selectedFile = null;
          this.toastr.success(productUrl + "Product with image updated", "Product");
          setTimeout(() => {
            this.router.navigate(["/products"]).then((r2) => r2);
          }, AppConstants.toastSuccessDelay);
        });
      },
      error: () => {
        this.spinner.hide().then(() => {
          this.toastr.error(errorDto.httpStatus + "image upsert failed", "Product");
        });
      }
    });
  }
  getConfiguration() {
    this.genericConfigService.getGenericConfigs(ModuleEnum3.FRONTEND_ADMIN, this.imgErrorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (configurationDto) => {
        console.log("Configuration GET called successful", this.maxSize, this.maxDimension);
        this.maxSize = Number(configurationDto.data.filter((data) => data.key.name == "IMG_SIZE")[0].value);
        this.maxDimension = Number(configurationDto.data.filter((data) => data.key.name == "IMG_DIMENSION")[0].value);
        this.imgErrorDto = new ErrorDto();
        this.toastr.info(this.maxSize + " x " + this.maxDimension + "  maxSize x Dimension set", "Product");
      },
      error: () => {
        this.toastr.error("Get configuration for image failed", "Product");
      }
    });
  }
};

// src/app/model/product-sku/product-sku.ts
var ProductSku = class {
};

// src/app/model/product-sku/product-sku-variant.ts
var ProductSkuVariant = class {
  constructor(variantName, variantCatalog) {
    this.variantName = variantName;
    this.variantCatalog = variantCatalog;
  }
};

// src/app/product/product-sku/product-sku.component.ts
var _c026 = () => ({ standalone: true });
function ProductSkuComponent_div_12_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Name is required.");
    \u0275\u0275elementEnd();
  }
}
function ProductSkuComponent_div_12_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Name must be at least 4 characters long.");
    \u0275\u0275elementEnd();
  }
}
function ProductSkuComponent_div_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275template(1, ProductSkuComponent_div_12_div_1_Template, 2, 0, "div", 15)(2, ProductSkuComponent_div_12_div_2_Template, 2, 0, "div", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const prodSkuName_r3 = \u0275\u0275reference(11);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", prodSkuName_r3.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", prodSkuName_r3.errors.minlength);
  }
}
function ProductSkuComponent_div_18_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Sku name is required.");
    \u0275\u0275elementEnd();
  }
}
function ProductSkuComponent_div_18_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Sku name must be at least 4 characters long.");
    \u0275\u0275elementEnd();
  }
}
function ProductSkuComponent_div_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275template(1, ProductSkuComponent_div_18_div_1_Template, 2, 0, "div", 15)(2, ProductSkuComponent_div_18_div_2_Template, 2, 0, "div", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const prodSkuName_r3 = \u0275\u0275reference(11);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", prodSkuName_r3.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", prodSkuName_r3.errors.minlength);
  }
}
function ProductSkuComponent_div_24_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Price is required");
    \u0275\u0275elementEnd();
  }
}
function ProductSkuComponent_div_24_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Price must be valid ");
    \u0275\u0275elementEnd();
  }
}
function ProductSkuComponent_div_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275template(1, ProductSkuComponent_div_24_div_1_Template, 2, 0, "div", 15)(2, ProductSkuComponent_div_24_div_2_Template, 2, 0, "div", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const price_r4 = \u0275\u0275reference(23);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", price_r4.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", price_r4.errors.isInvalidPrice && !price_r4.errors.required);
  }
}
function ProductSkuComponent_option_29_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 22);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const catalog_r5 = ctx.$implicit;
    \u0275\u0275property("ngValue", catalog_r5);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", catalog_r5.paramName, " ");
  }
}
function ProductSkuComponent_div_30_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 24)(1, "div", 25)(2, "div", 26)(3, "span", 27);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "div", 28)(6, "button", 29);
    \u0275\u0275listener("click", function ProductSkuComponent_div_30_div_3_Template_button_click_6_listener() {
      const variant_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r7 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r7.addVariant(variant_r7, ctx_r7.selectedCatalog));
    });
    \u0275\u0275text(7, "+ ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const variant_r7 = ctx.$implicit;
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(variant_r7.name);
  }
}
function ProductSkuComponent_div_30_div_4_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 24)(1, "div", 25)(2, "div", 26)(3, "span", 27);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "div", 28)(6, "button", 31);
    \u0275\u0275listener("click", function ProductSkuComponent_div_30_div_4_div_3_Template_button_click_6_listener() {
      const i_r10 = \u0275\u0275restoreView(_r9).index;
      const ctx_r7 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r7.removeVariant(i_r10));
    });
    \u0275\u0275text(7, "- ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const variant_r11 = ctx.$implicit;
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate2("", variant_r11.variantName, " ", variant_r11.variantCatalog, "");
  }
}
function ProductSkuComponent_div_30_div_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "h5", 30);
    \u0275\u0275text(2, "Variants added");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, ProductSkuComponent_div_30_div_4_div_3_Template, 8, 2, "div", 23);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r7.addedVariants);
  }
}
function ProductSkuComponent_div_30_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "h5");
    \u0275\u0275text(2, "Variants ");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, ProductSkuComponent_div_30_div_3_Template, 8, 1, "div", 23)(4, ProductSkuComponent_div_30_div_4_Template, 4, 1, "div", 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r7.selectedCatalog == null ? null : ctx_r7.selectedCatalog.variants);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r7.addedVariants.length > 0);
  }
}
function ProductSkuComponent_div_37_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 24)(1, "div", 25)(2, "div", 26)(3, "span", 27);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "div", 28)(6, "button", 31);
    \u0275\u0275listener("click", function ProductSkuComponent_div_37_div_3_Template_button_click_6_listener() {
      const i_r13 = \u0275\u0275restoreView(_r12).index;
      const ctx_r7 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r7.removeSku(i_r13));
    });
    \u0275\u0275text(7, "- ");
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const productSku_r14 = ctx.$implicit;
    const ctx_r7 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(ctx_r7.resolveVariants(productSku_r14));
  }
}
function ProductSkuComponent_div_37_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 33)(1, "button", 34);
    \u0275\u0275listener("click", function ProductSkuComponent_div_37_div_4_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r15);
      const ctx_r7 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r7.saveProductVariants());
    });
    \u0275\u0275text(2, "Save");
    \u0275\u0275elementEnd()();
  }
}
function ProductSkuComponent_div_37_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "h5");
    \u0275\u0275text(2, "Product skus ");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, ProductSkuComponent_div_37_div_3_Template, 8, 1, "div", 23)(4, ProductSkuComponent_div_37_div_4_Template, 3, 0, "div", 32);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r7.productSkus);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", (ctx_r7.productSkus == null ? null : ctx_r7.productSkus.length) > 0);
  }
}
var _ProductSkuComponent = class _ProductSkuComponent extends BaseImageComponent {
  constructor(productService, genericConfig, productSkuService, variantCatalog, route, actRoute, spinner, toastr) {
    super(spinner, toastr, route, productService, genericConfig, true);
    this.productService = productService;
    this.genericConfig = genericConfig;
    this.productSkuService = productSkuService;
    this.variantCatalog = variantCatalog;
    this.route = route;
    this.actRoute = actRoute;
    this.spinner = spinner;
    this.toastr = toastr;
    this.rootProduct = new Product();
    this.productSku = new ProductSku();
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.destroy$ = new Subject();
    this.errorDto = new ErrorDto();
    this.addedVariants = [];
    this.productSkus = [];
  }
  ngOnChanges(changes) {
    this.rootProduct = changes.rootProduct.currentValue;
    this.productSku.priceAmount = this.rootProduct.priceAmount;
    this.productSku.name = this.rootProduct.name;
    this.productSku.sku = this.rootProduct.url;
    this.getCatalogs();
  }
  getCatalogs() {
    this.spinner.show("catalogSpinner").then((r2) => r2);
    return this.variantCatalog.listAll(this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (response) => {
        this.spinner.hide("catalogSpinner").then(() => {
          this.variantCatalogs = response.data;
          this.selectedCatalog = this.variantCatalogs[0];
          this.errorDto = new ErrorDto();
        });
      },
      error: () => {
        this.spinner.hide("catalogSpinner").then(() => {
          this.toastr.error(this.errorDto.httpStatus + " load catalog failed!", "Product");
        });
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  selectCatalog($event) {
    this.selectedCatalog = $event;
  }
  addVariant(variant, catalogName) {
    const val = new ProductSkuVariant(variant?.name, catalogName?.paramName);
    const filtered = this.addedVariants.filter((data) => data.variantCatalog === catalogName.paramName);
    if (filtered.length == 0) {
      this.addedVariants.push(val);
    }
  }
  removeVariant(index) {
    this.addedVariants = this.addedVariants.filter((ele, ind) => ind !== index);
  }
  insertSku() {
    this.productSku.variants = this.addedVariants;
    this.productSku.priceCurrency = "CZK";
    this.productSkus.push(Object.assign({}, this.productSku));
    this.addedVariants = [];
  }
  removeSku(index) {
    this.productSkus = this.productSkus.filter((ele, int) => int !== index);
  }
  resolveVariants(productSku) {
    const val = productSku.variants?.length > 0 ? " [ " + productSku.variants.map((data) => data.variantName).join(", ") + " ] " : "";
    return productSku.sku.concat(val);
  }
  saveProductVariants() {
    this.productSkus.forEach((data) => this.createProductSku(data));
    setTimeout(() => {
      if (this.productSkus.length == 0) {
        this.route.navigate(["/products/view/", this.selectedProductRootUrl]).then((r2) => r2);
      }
    }, AppConstants.toastSuccessDelay);
  }
  createProductSku(productSku) {
    this.spinner.show("productSkuSpinner").then((r2) => r2);
    this.productSkuService.createProductSku(this.selectedProductRootUrl, productSku, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: () => {
        this.spinner.hide("productSkuSpinner").then(() => {
          this.productSkus = this.productSkus.filter((ele) => ele !== ele);
          this.toastr.success("Sku" + productSku + " added ", "Product");
        });
      },
      error: () => {
        this.spinner.hide("productSkuSpinner").then(() => {
          this.toastr.error(this.errorDto.httpStatus + " add sku failed!", "Product");
        });
      }
    });
  }
};
_ProductSkuComponent.\u0275fac = function ProductSkuComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ProductSkuComponent)(\u0275\u0275directiveInject(ProductService), \u0275\u0275directiveInject(GenericConfigService), \u0275\u0275directiveInject(ProductSkuService), \u0275\u0275directiveInject(VariantCatalogService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_ProductSkuComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ProductSkuComponent, selectors: [["app-product-sku"]], inputs: { selectedProductRootUrl: "selectedProductRootUrl", rootProduct: "rootProduct" }, standalone: false, features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature], decls: 38, vars: 14, consts: [["upsertProductSkuForm", "ngForm"], ["prodSkuName", "ngModel"], ["price", "ngModel"], ["novalidate", "", 3, "ngSubmit"], [1, "mb-3"], ["for", "product-sku-name", 1, "form-label"], ["id", "product-sku-name", "name", "prodSkuName", "type", "text", "placeholder", "required", "required", "", "minlength", "4", 1, "form-control", 3, "ngModelChange", "ngModel"], ["class", "alert alert-danger", 4, "ngIf"], ["for", "product-sku-sku", 1, "form-label"], ["id", "product-sku-sku", "name", "prodSkuSku", "type", "text", "placeholder", "required", "required", "", "minlength", "4", 1, "form-control", 3, "ngModelChange", "ngModel"], ["for", "product-price", 1, "form-label"], ["id", "product-price", "name", "product-price", "type", "text", "placeholder", "required", "appPriceValidator", "", 1, "form-control", 3, "ngModelChange", "ngModel"], [1, "mb-3", "box-part"], ["minlength", "3", 1, "form-select", "mb-3", 3, "ngModelChange", "ngModel", "ngModelOptions"], [3, "ngValue", 4, "ngFor", "ngForOf"], [4, "ngIf"], ["name", "catalogSpinner", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["name", "productSkuSpinner", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [3, "errorDto"], [1, "col-auto", "mb-3"], ["type", "submit", 1, "btn", "btn-primary", "mx-3", "mx-sm-5"], [1, "alert", "alert-danger"], [3, "ngValue"], ["class", "row text-center", 4, "ngFor", "ngForOf"], [1, "row", "text-center"], [1, "input-group", "link", "border-bottom", "mt-1"], [1, "col-12", "col-sm-11"], [1, "d-inline-block", "text-white", "text-break"], [1, "col-12", "col-sm-1"], ["type", "button", 1, "btn", "btn-primary", "btn-sm", "mb-1", 3, "click"], [1, "mt-2"], ["type", "button", 1, "btn", "btn-danger", "btn-sm", "mb-1", 3, "click"], ["class", "col-auto mt-3", 4, "ngIf"], [1, "col-auto", "mt-3"], ["type", "submit", 1, "btn", "btn-primary", "mx-3", "mx-sm-5", 3, "click"]], template: function ProductSkuComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "form", 3, 0);
    \u0275\u0275listener("ngSubmit", function ProductSkuComponent_Template_form_ngSubmit_0_listener() {
      \u0275\u0275restoreView(_r1);
      const upsertProductSkuForm_r2 = \u0275\u0275reference(1);
      return \u0275\u0275resetView(upsertProductSkuForm_r2.valid && ctx.insertSku());
    });
    \u0275\u0275elementStart(2, "h2");
    \u0275\u0275text(3, "Add product sku");
    \u0275\u0275elementEnd();
    \u0275\u0275element(4, "hr");
    \u0275\u0275elementStart(5, "h5");
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "div", 4)(8, "label", 5);
    \u0275\u0275text(9, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "input", 6, 1);
    \u0275\u0275twoWayListener("ngModelChange", function ProductSkuComponent_Template_input_ngModelChange_10_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.productSku.name, $event) || (ctx.productSku.name = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(12, ProductSkuComponent_div_12_Template, 3, 2, "div", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "div", 4)(14, "label", 8);
    \u0275\u0275text(15, "Sku");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "input", 9, 1);
    \u0275\u0275twoWayListener("ngModelChange", function ProductSkuComponent_Template_input_ngModelChange_16_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.productSku.sku, $event) || (ctx.productSku.sku = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(18, ProductSkuComponent_div_18_Template, 3, 2, "div", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "div", 4)(20, "label", 10);
    \u0275\u0275text(21, "Price");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(22, "input", 11, 2);
    \u0275\u0275twoWayListener("ngModelChange", function ProductSkuComponent_Template_input_ngModelChange_22_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.productSku.priceAmount, $event) || (ctx.productSku.priceAmount = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(24, ProductSkuComponent_div_24_Template, 3, 2, "div", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(25, "div", 12)(26, "h5");
    \u0275\u0275text(27, "Product sku detail");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(28, "select", 13);
    \u0275\u0275twoWayListener("ngModelChange", function ProductSkuComponent_Template_select_ngModelChange_28_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedCatalog, $event) || (ctx.selectedCatalog = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function ProductSkuComponent_Template_select_ngModelChange_28_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.selectCatalog($event));
    });
    \u0275\u0275template(29, ProductSkuComponent_option_29_Template, 2, 2, "option", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275template(30, ProductSkuComponent_div_30_Template, 5, 2, "div", 15);
    \u0275\u0275elementEnd();
    \u0275\u0275element(31, "ngx-spinner", 16)(32, "ngx-spinner", 17)(33, "app-error", 18);
    \u0275\u0275elementStart(34, "div", 19)(35, "button", 20);
    \u0275\u0275text(36, "Add sku");
    \u0275\u0275elementEnd()()();
    \u0275\u0275template(37, ProductSkuComponent_div_37_Template, 5, 2, "div", 15);
  }
  if (rf & 2) {
    const upsertProductSkuForm_r2 = \u0275\u0275reference(1);
    const prodSkuName_r3 = \u0275\u0275reference(11);
    const price_r4 = \u0275\u0275reference(23);
    \u0275\u0275advance(6);
    \u0275\u0275textInterpolate(ctx.rootProduct.name);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.productSku.name);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", upsertProductSkuForm_r2.submitted && prodSkuName_r3.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.productSku.sku);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", upsertProductSkuForm_r2.submitted && prodSkuName_r3.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.productSku.priceAmount);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", upsertProductSkuForm_r2.submitted && price_r4.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedCatalog);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(13, _c026));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx.variantCatalogs);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.selectedCatalog);
    \u0275\u0275advance(3);
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", (ctx.productSkus == null ? null : ctx.productSkus.length) > 0);
  }
}, dependencies: [NgForOf, NgIf, ErrorComponent, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, SelectControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, NgModel, NgForm, NgxSpinnerComponent], encapsulation: 2 });
var ProductSkuComponent = _ProductSkuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ProductSkuComponent, { className: "ProductSkuComponent", filePath: "src/app/product/product-sku/product-sku.component.ts", lineNumber: 28 });
})();

// src/app/product/img/img-update.component.ts
function ImgUpdateComponent_img_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 13);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275propertyInterpolate("alt", ctx_r0.existingImageName);
    \u0275\u0275property("src", ctx_r0.existingImage, \u0275\u0275sanitizeUrl);
  }
}
function ImgUpdateComponent_img_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 14);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("src", ctx_r0.emptyDefaultImage, \u0275\u0275sanitizeUrl);
  }
}
function ImgUpdateComponent_img_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 14);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("src", ctx_r0.selectedImage, \u0275\u0275sanitizeUrl);
  }
}
function ImgUpdateComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.invalidImage, " ");
  }
}
function ImgUpdateComponent_div_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "h5");
    \u0275\u0275text(2, " To be updated image");
    \u0275\u0275elementEnd();
    \u0275\u0275element(3, "img", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275property("src", ctx_r0.selectedImage, \u0275\u0275sanitizeUrl);
  }
}
function ImgUpdateComponent_div_21_details_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "details")(1, "summary", 19);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "code");
    \u0275\u0275text(4, "height x width");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate2("", ctx_r0.height, " x ", ctx_r0.width, "");
  }
}
function ImgUpdateComponent_div_21_div_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 20)(1, "button", 21);
    \u0275\u0275listener("click", function ImgUpdateComponent_div_21_div_8_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.revert());
    });
    \u0275\u0275text(2, "\xA0Revert");
    \u0275\u0275elementEnd()();
  }
}
function ImgUpdateComponent_div_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 17)(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275element(3, "br");
    \u0275\u0275elementStart(4, "span");
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "br");
    \u0275\u0275template(7, ImgUpdateComponent_div_21_details_7_Template, 5, 2, "details", 9)(8, ImgUpdateComponent_div_21_div_8_Template, 3, 0, "div", 18);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.selectedFile.name);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1("", ctx_r0.selectedFile.size / 1e3, " kb");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.height);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.revertImage);
  }
}
var _ImgUpdateComponent = class _ImgUpdateComponent {
  constructor() {
    this.regex = new RegExp("\\w*.(gif|jpe?g|tiff?|png|webp|bmp)$");
    this.reader = new FileReader();
    this.emptyDefaultImage = AppConstants.emptyDefaultImage;
    this.faUpload = AppConstants.iconUpload;
    this.selectedImage = null;
    this.revertImage = false;
    this.selectedImageEmitter = new EventEmitter();
  }
  revert() {
    this.revertImage = false;
    this.selectedImage = null;
    this.selectedFile = null;
    this.invalidImage = null;
  }
  selectFile(event) {
    console.log("Select file call");
    const element = event.currentTarget;
    const fileList = element.files;
    console.log(fileList);
    if (!fileList) {
      console.log("No file selected");
      this.selectedFile = null;
      this.selectedImage = null;
      this.selectedImageEmitter.emit(null);
      return;
    }
    this.selectedFile = fileList.item(0);
    if (this.regex.test(this.selectedFile.name.toLowerCase())) {
      this.invalidImage = null;
    } else {
      this.invalidImage = "Only image should be added";
      this.selectedFile = null;
      this.selectedImage = null;
      this.selectedImageEmitter.emit(this.selectedFile);
      return;
    }
    const selectedFileSize = this.selectedFile.size / 1e3;
    if (selectedFileSize > this.maxSize) {
      this.invalidImage = "Size image too large! Maximum: " + this.maxSize;
      console.error(this.invalidImage, selectedFileSize);
      this.selectedImageEmitter.emit(null);
      return;
    }
    this.reader.readAsDataURL(this.selectedFile);
    this.reader.onload = (event2) => {
      this.selectedImage = event2.target.result;
      this.selectedImageEmitter.emit(this.selectedFile);
      this.revertImage = true;
      const img = new Image();
      img.src = this.selectedImage;
      img.onload = () => {
        this.width = img.width;
        this.height = img.height;
        this.overlapScale("width", this.width);
        this.overlapScale("height", this.height);
      };
      img.onerror = () => {
        console.error("Img could not be read: ", event2.target.error.code);
        this.selectedImageEmitter.emit(null);
      };
    };
    this.reader.onerror = (event2) => {
      this.revertImage = false;
      console.error("File could not be read: ", event2.target.error.code);
    };
  }
  overlapScale(fieldName, scale) {
    if (scale > this.maxDimension) {
      console.error("Maximum image " + fieldName + "!", this.maxDimension, scale);
      this.invalidImage = "Image " + fieldName + " oversize! Maximum: " + this.maxDimension;
      this.selectedFile = null;
      this.selectedImage = null;
      this.revertImage = false;
      this.selectedImageEmitter.emit(null);
    }
  }
};
_ImgUpdateComponent.\u0275fac = function ImgUpdateComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ImgUpdateComponent)();
};
_ImgUpdateComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ImgUpdateComponent, selectors: [["app-img-insert"]], inputs: { existingImage: "existingImage", existingImageName: "existingImageName", headerName: "headerName", maxSize: "maxSize", maxDimension: "maxDimension" }, outputs: { selectedImageEmitter: "selectedImageEmitter" }, standalone: false, decls: 22, vars: 8, consts: [[1, "content", "text-center", "mx-2"], [1, "row"], [1, "col"], ["class", "img-fluid", 3, "src", "alt", 4, "ngIf"], ["class", "img-fluid", "alt", "empty image", 3, "src", 4, "ngIf"], ["for", "file-upload", 1, "file-uploader"], [3, "icon"], ["id", "file-upload", "type", "file", "accept", "image/*", 3, "change"], ["class", "alert alert-danger", 4, "ngIf"], [4, "ngIf"], [1, "row", "justify-content-center"], [1, "col-12", "col-md-6"], ["class", "content", 4, "ngIf"], [1, "img-fluid", 3, "src", "alt"], ["alt", "empty image", 1, "img-fluid", 3, "src"], [1, "alert", "alert-danger"], ["alt", "added new image", 1, "img-responsive", 3, "src"], [1, "content"], ["class", "col p-3", 4, "ngIf"], [1, "p-2"], [1, "col", "p-3"], ["type", "button", 1, "btn", "btn-primary", 3, "click"]], template: function ImgUpdateComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "h5");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 1)(4, "div", 2);
    \u0275\u0275template(5, ImgUpdateComponent_img_5_Template, 1, 2, "img", 3)(6, ImgUpdateComponent_img_6_Template, 1, 1, "img", 4)(7, ImgUpdateComponent_img_7_Template, 1, 1, "img", 4);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(8, "div", 1)(9, "div", 2)(10, "label", 5);
    \u0275\u0275text(11, " \xA0\xA0\xA0\xA0\xA0");
    \u0275\u0275element(12, "fa-icon", 6);
    \u0275\u0275text(13, "\xA0\xA0\xA0\xA0\xA0 ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "input", 7);
    \u0275\u0275listener("change", function ImgUpdateComponent_Template_input_change_14_listener($event) {
      return ctx.selectFile($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(15, ImgUpdateComponent_div_15_Template, 2, 1, "div", 8);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(16, "div", 1)(17, "div", 2);
    \u0275\u0275template(18, ImgUpdateComponent_div_18_Template, 4, 1, "div", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(19, "div", 10)(20, "div", 11);
    \u0275\u0275template(21, ImgUpdateComponent_div_21_Template, 9, 4, "div", 12);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx.headerName);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx.existingImage);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.existingImage && !ctx.selectedImage);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.selectedImage && !ctx.existingImage);
    \u0275\u0275advance(5);
    \u0275\u0275property("icon", ctx.faUpload);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx.invalidImage);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx.existingImage && ctx.revertImage);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx.selectedFile);
  }
}, dependencies: [NgIf, FaIconComponent], styles: ["\n\ninput[type=file][_ngcontent-%COMP%] {\n  display: none;\n}\n.img-responsive[_ngcontent-%COMP%] {\n  max-width: 100%;\n  height: auto;\n}\n/*# sourceMappingURL=img-update.component.css.map */"] });
var ImgUpdateComponent = _ImgUpdateComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ImgUpdateComponent, { className: "ImgUpdateComponent", filePath: "src/app/product/img/img-update.component.ts", lineNumber: 62 });
})();

// src/app/product/product-upsert/product-upsert.component.ts
var _c027 = () => ({ standalone: true });
var _c116 = (a0) => ["/categories/view/", a0];
function ProductUpsertComponent_option_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 51);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const category_r3 = ctx.$implicit;
    \u0275\u0275property("ngValue", category_r3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", category_r3.url, " ");
  }
}
function ProductUpsertComponent_div_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 52);
    \u0275\u0275text(1, " Category must be selected.");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_23_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Category must be selected. ");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_23_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Category must be at least 3 characters long. ");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_23_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 52);
    \u0275\u0275template(1, ProductUpsertComponent_div_23_div_1_Template, 2, 0, "div", 25)(2, ProductUpsertComponent_div_23_div_2_Template, 2, 0, "div", 25);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const select_r4 = \u0275\u0275reference(20);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", select_r4.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", select_r4.errors.minlength);
  }
}
function ProductUpsertComponent_li_31_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li");
    \u0275\u0275element(1, "fa-icon", 24);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty description!! ");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r4.faThrash);
  }
}
function ProductUpsertComponent_li_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "li", 18);
    \u0275\u0275element(1, "fa-icon", 24);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r4.faBars);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0\xA0\xA0", ctx_r4.selectedCategory.description, "");
  }
}
function ProductUpsertComponent_div_37_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 53)(1, "div", 54)(2, "div", 55);
    \u0275\u0275element(3, "span", 56);
    \u0275\u0275elementStart(4, "span", 57);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(6, "div", 58)(7, "button", 59);
    \u0275\u0275listener("click", function ProductUpsertComponent_div_37_Template_button_click_7_listener() {
      const url_r7 = \u0275\u0275restoreView(_r6).$implicit;
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.removeCategories(url_r7));
    });
    \u0275\u0275element(8, "fa-icon", 47);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const url_r7 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate(url_r7);
    \u0275\u0275advance(3);
    \u0275\u0275property("icon", ctx_r4.faThrash);
  }
}
function ProductUpsertComponent_div_47_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Name is required. ");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_47_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Name must be at least 4 characters long. ");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_47_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 52);
    \u0275\u0275template(1, ProductUpsertComponent_div_47_div_1_Template, 2, 0, "div", 25)(2, ProductUpsertComponent_div_47_div_2_Template, 2, 0, "div", 25);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const name_r8 = \u0275\u0275reference(46);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", name_r8.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", name_r8.errors.minlength);
  }
}
function ProductUpsertComponent_div_53_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Url is required.");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_53_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Url must be valid");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_53_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 52);
    \u0275\u0275template(1, ProductUpsertComponent_div_53_div_1_Template, 2, 0, "div", 25)(2, ProductUpsertComponent_div_53_div_2_Template, 2, 0, "div", 25);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const url_r9 = \u0275\u0275reference(52);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", url_r9.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", url_r9.errors.isInvalidUrl && !url_r9.errors.required);
  }
}
function ProductUpsertComponent_div_59_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " ISBN is required");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_59_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " ISBN must be valid");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_59_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 52);
    \u0275\u0275template(1, ProductUpsertComponent_div_59_div_1_Template, 2, 0, "div", 25)(2, ProductUpsertComponent_div_59_div_2_Template, 2, 0, "div", 25);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const isbn_r10 = \u0275\u0275reference(58);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", isbn_r10.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", isbn_r10.errors.isInvalidIsbn && !isbn_r10.errors.required);
  }
}
function ProductUpsertComponent_div_65_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Price is required");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_65_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Price must be valid ");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_65_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 52);
    \u0275\u0275template(1, ProductUpsertComponent_div_65_div_1_Template, 2, 0, "div", 25)(2, ProductUpsertComponent_div_65_div_2_Template, 2, 0, "div", 25);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const price_r11 = \u0275\u0275reference(64);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", price_r11.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", price_r11.errors.isInvalidPrice && !price_r11.errors.required);
  }
}
function ProductUpsertComponent_option_71_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 51);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const currency_r12 = ctx.$implicit;
    \u0275\u0275property("ngValue", currency_r12);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", currency_r12, " ");
  }
}
function ProductUpsertComponent_div_72_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Currency is required. ");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_72_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, " Currency must be at least 3 characters long. ");
    \u0275\u0275elementEnd();
  }
}
function ProductUpsertComponent_div_72_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 52);
    \u0275\u0275template(1, ProductUpsertComponent_div_72_div_1_Template, 2, 0, "div", 25)(2, ProductUpsertComponent_div_72_div_2_Template, 2, 0, "div", 25);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const currency_r13 = \u0275\u0275reference(70);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", currency_r13.errors.required);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", currency_r13.errors.minlength);
  }
}
function ProductUpsertComponent_div_85_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 60)(1, "button", 61);
    \u0275\u0275listener("click", function ProductUpsertComponent_div_85_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r14);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.show());
    });
    \u0275\u0275element(2, "fa-icon", 47);
    \u0275\u0275text(3, " Add\xA0sku ");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx_r4.faPlus);
  }
}
function ProductUpsertComponent_div_87_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 62);
    \u0275\u0275element(1, "app-product-sku", 63);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("selectedProductRootUrl", ctx_r4.selectedProductOriginalUrl)("rootProduct", ctx_r4.selectedProduct);
  }
}
var _ProductUpsertComponent = class _ProductUpsertComponent extends BaseImageComponent {
  constructor(categoryService, productService, genericConfigService, route, actRoute, spinner, toastr, catalogService) {
    super(spinner, toastr, route, productService, genericConfigService, true);
    this.categoryService = categoryService;
    this.productService = productService;
    this.genericConfigService = genericConfigService;
    this.route = route;
    this.actRoute = actRoute;
    this.spinner = spinner;
    this.toastr = toastr;
    this.catalogService = catalogService;
    this.selectedProduct = new Product();
    this.selectedCategory = new Category();
    this.addedCategories = [];
    this.currencies = ["CZK", "EUR"];
    this.existingImage = null;
    this.htmlContent = "";
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.faPlus = AppConstants.iconPlus;
    this.faThrash = AppConstants.iconTrash;
    this.faBars = AppConstants.iconBars;
    this.faEye = AppConstants.iconEye;
    this.faAddressCard = AppConstants.iconAddressCard;
    this.errorDto = new ErrorDto();
    this.operation = "Create";
    this.destroy$ = new Subject();
    this.catalogErrorDto = new ErrorDto();
    this.editorConfig = {
      editable: true,
      spellcheck: true,
      height: "15rem",
      minHeight: "5rem",
      placeholder: "Enter text here...",
      translate: "no",
      defaultParagraphSeparator: "p",
      defaultFontName: "",
      toolbarHiddenButtons: [
        [
          "undo",
          "redo",
          "indent",
          "subscript",
          "superscript",
          "strikeThrough"
        ],
        [
          "link",
          "unlink",
          "insertImage",
          "insertVideo",
          "insertHorizontalRule"
        ]
      ]
    };
    this.headerName = "Product image";
    this.shown = false;
  }
  ngOnInit() {
    this.actRoute.queryParamMap.subscribe((params) => {
      this.selectedProductOriginalUrl = params.get("productUrl");
      if (!this.selectedProductOriginalUrl) {
        this.operation = "Create";
      } else {
        this.operation = "Update";
      }
      this.resolveLoading();
    });
  }
  resolveLoading() {
    this.getCategories();
    this.getCatalogs();
    if (this.operation == "Create") {
      return;
    }
    this.getProduct();
    this.getImage();
  }
  upsertProduct() {
    if (this.operation == "Create") {
      this.createProduct();
    } else {
      this.updateProduct();
    }
  }
  getProduct() {
    this.spinner.show("productSpinnerEdited").then((r2) => r2);
    return this.productService.getProduct(this.selectedProductOriginalUrl, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (productResponse) => {
        this.spinner.hide("productSpinnerEdited").then(() => {
          this.selectedProduct = productResponse.data;
          this.addedCategories = this.selectedProduct.categoryUrls;
          this.htmlContent = this.selectedProduct.description;
          this.errorDto = new ErrorDto();
        });
      },
      error: () => {
        this.spinner.hide("productSpinnerEdited").then(() => {
          this.toastr.error(this.errorDto.httpStatus + " load product failed!", "Product");
          this.categories = [];
          this.selectedCategory = new Category();
        });
      }
    });
  }
  getCatalogs() {
    this.spinner.show("catalogSpinner").then((r2) => r2);
    this.catalogService.listAll(this.catalogErrorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (catalogResponse) => {
        this.spinner.hide("catalogSpinner").then(() => {
          this.catalogs = catalogResponse.data;
          this.selectedCatalog = this.catalogs[0];
        });
      },
      error: () => {
        this.spinner.hide("catalogSpinner").then(() => this.toastr.error(this.errorDto.httpStatus + " load catalog failed!", "Catalog"));
      }
    });
  }
  getCategories() {
    this.spinner.show("categoriesSpinnerEdited").then((r2) => r2);
    this.categoryService.getCategories(this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (categoriesResponse) => {
        this.spinner.hide("categoriesSpinnerEdited").then(() => {
          this.categories = categoriesResponse.data;
          this.selectedCategory = this.categories[0];
        });
      },
      error: () => {
        this.spinner.hide("categoriesSpinnerEdited").then(() => this.toastr.error(this.errorDto.httpStatus + " load category failed!", "Category"));
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
  getImage() {
    this.spinner.show("productImageSpinnerEdited").then((r2) => r2);
    this.productService.getProductImage(this.selectedProductOriginalUrl, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (productImageData) => {
        this.spinner.hide("productImageSpinnerEdited").then(() => {
          if (productImageData.data.bytes == null) {
            this.existingImage = null;
            this.imgContentType = null;
          } else {
            this.existingImage = "data:image/jpeg;base64," + productImageData.data.bytes;
            this.imgContentType = productImageData.data.type;
          }
        });
      },
      error: () => {
        this.spinner.hide("productImageSpinnerEdited").then(() => this.toastr.error(this.errorDto.httpStatus + " load image failed!", "Product"));
      }
    });
  }
  selectImage(event) {
    this.selectedFile = event;
  }
  updateProduct() {
    this.spinner.show("productImageSpinnerEdited").then((r2) => r2);
    this.selectedProduct.categoryUrls = this.addedCategories;
    this.selectedProduct.description = this.htmlContent;
    if (this.selectedProduct?.description?.length < 12 && this.selectedProduct?.description?.length > 0) {
      this.errorDto.httpStatus = 400;
      this.errorDto.httpStatusMessage = "Bad Request";
      this.errorDto.httpStatusMessage = "Description length < 12";
      this.spinner.hide("productImageSpinnerEdited").then((r2) => r2);
      return;
    }
    if (this.selectedProduct?.description?.length > 600 && this.selectedProduct.description?.length > 0) {
      this.errorDto.httpStatus = 400;
      this.errorDto.httpStatusMessage = "Bad Request";
      this.errorDto.httpStatusMessage = "Description length < 12";
      this.spinner.hide("productImageSpinnerEdited").then((r2) => r2);
      return;
    }
    this.productService.updateProduct(this.selectedProduct, this.selectedProductOriginalUrl, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (productResponse) => {
        this.spinner.hide("productImageSpinnerEdited").then(() => {
          this.htmlContent = "";
          this.selectedProduct = productResponse.data;
          this.selectedProductOriginalUrl = productResponse.data.url;
          this.upsertProductImage(this.selectedProductOriginalUrl, this.errorDto);
        });
      },
      error: () => {
        this.spinner.hide("productImageSpinnerEdited").then(() => this.toastr.error(this.selectedProductOriginalUrl + " product update failed", "Product"));
      }
    });
  }
  createProduct() {
    this.selectedProduct.categoryUrls = this.addedCategories;
    this.selectedProduct.description = this.htmlContent;
    if (this.selectedProduct?.description?.length < 12 && this.selectedProduct?.description?.length > 0) {
      this.errorDto.httpStatus = 400;
      this.errorDto.httpStatusMessage = "Bad Request";
      this.errorDto.httpStatusMessage = "Description length < 12";
      this.spinner.hide("productImageSpinnerEdited").then((r2) => r2);
      return;
    }
    if (this.selectedProduct?.description?.length > 600 && this.selectedProduct.description?.length > 0) {
      this.errorDto.httpStatus = 400;
      this.errorDto.httpStatusMessage = "Bad Request";
      this.errorDto.httpStatusMessage = "Description length < 12";
      this.spinner.hide("productImageSpinnerEdited").then((r2) => r2);
      return;
    }
    this.spinner.show().then((r2) => r2);
    this.productService.createProduct(this.selectedProduct, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (productResponse) => {
        this.spinner.hide().then(() => this.toastr.success(productResponse.data.name, "Product"));
        this.selectedProduct = productResponse.data;
        this.upsertProductImage(this.selectedProduct.url, this.errorDto);
      },
      error: (err) => {
        this.spinner.hide().then(() => this.toastr.error(this.selectedProduct.name + " create failed", "Product"));
      }
    });
  }
  selectCurrency(event) {
    this.selectedProduct.priceCurrency = event;
  }
  selectCategory(event) {
    this.selectedCategory = event;
  }
  addCategory() {
    const category = this.addedCategories.find((url) => url === this.selectedCategory.url);
    if (!category && this.selectedCategory?.url) {
      this.addedCategories.push(this.selectedCategory.url);
    }
  }
  removeCategories(catUrl) {
    this.addedCategories = this.addedCategories.filter((url) => url !== catUrl);
  }
  show() {
    this.shown = !this.shown;
  }
};
_ProductUpsertComponent.\u0275fac = function ProductUpsertComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ProductUpsertComponent)(\u0275\u0275directiveInject(CategoryService), \u0275\u0275directiveInject(ProductService), \u0275\u0275directiveInject(GenericConfigService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService), \u0275\u0275directiveInject(VariantCatalogService));
};
_ProductUpsertComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ProductUpsertComponent, selectors: [["app-product-edited"]], standalone: false, features: [\u0275\u0275InheritDefinitionFeature], decls: 88, vars: 43, consts: [["editProductForm", "ngForm"], ["select", "ngModel"], ["name", "ngModel"], ["url", "ngModel"], ["isbn", "ngModel"], ["price", "ngModel"], ["currency", "ngModel"], [1, "box"], [1, "row", "justify-content-center", "box-part"], [1, "col-lg-5", "col-sm-12"], [1, "text-center"], [1, "text-orange", "mb-3"], ["novalidate", "", 3, "ngSubmit"], ["name", "categoriesSpinnerEdited", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["name", "productImageSpinnerEdited", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["name", "productSpinnerEdited", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], ["name", "catalogSpinner", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "content"], [1, "m-2"], ["minlength", "3", 1, "form-select", "mb-3", 3, "ngModelChange", "ngModel", "ngModelOptions"], [3, "ngValue", 4, "ngFor", "ngForOf"], ["class", "alert alert-danger", 4, "ngIf"], [1, "list-unstyled", "text-start", "m-2"], ["aria-hidden", "true", "routerLinkActive", "active", 1, "pointer", "m-2", 3, "routerLink"], [1, "text-darkorange", 3, "icon"], [4, "ngIf"], ["class", "m-2", 4, "ngIf"], ["type", "button", 1, "btn", "btn-primary", 3, "click"], ["class", "row link text-center", 4, "ngFor", "ngForOf"], [3, "selectedImageEmitter", "headerName", "maxDimension", "maxSize", "existingImage", "existingImageName"], [1, "mt-3"], ["for", "product-name", 1, "form-label"], ["id", "product-name", "name", "name", "type", "text", "placeholder", "required", "minlength", "4", 1, "form-control", 3, "ngModelChange", "ngModel"], ["for", "product-url", 1, "form-label"], ["id", "product-url", "name", "url", "type", "text", "placeholder", "required", "appUrlValidator", "", 1, "form-control", 3, "ngModelChange", "ngModel"], ["for", "product-isbn", 1, "form-label"], ["id", "product-isbn", "name", "isbn", "type", "text", "placeholder", "required (9971502100)", "appIsbnValidator", "", 1, "form-control", 3, "ngModelChange", "ngModel"], ["for", "product-price", 1, "form-label"], ["id", "product-price", "name", "product-price", "type", "text", "placeholder", "required", "appPriceValidator", "", 1, "form-control", 3, "ngModelChange", "ngModel"], ["for", "product-currency", 1, "form-label"], ["id", "product-currency", "minlength", "3", 1, "form-select", "mb-3", 3, "ngModelChange", "ngModel", "ngModelOptions"], ["for", "product-edited-description", 1, "form-label"], ["id", "product-edited-description", "name", "description", 1, "form-control", 3, "ngModelChange", "placeholder", "ngModel", "config"], [3, "errorDto"], [1, "col-auto"], ["type", "submit", 1, "btn", "btn-primary"], ["type", "button", "appBackButton", "", 1, "ms-5", "btn", "btn-danger"], [3, "icon"], ["class", "col-auto mt-3", 4, "ngIf"], [1, "col-lg-1", "col-sm-12"], ["class", "col-lg-5 col-sm-12 text-center justify-content-end", 4, "ngIf"], [3, "ngValue"], [1, "alert", "alert-danger"], [1, "row", "link", "text-center"], [1, "input-group", "border-bottom", "py-2"], [1, "col-12", "col-sm-10"], ["data-label", "Name", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "pointer", "d-inline-block", "m-2", "text-white", "text-break"], [1, "col-12", "col-sm-1", "text-center", "my-auto"], ["type", "button", 1, "btn", "btn-danger", 3, "click"], [1, "col-auto", "mt-3"], ["type", "button", "routerLinkActive", "active", 1, "btn", "btn-primary", "ms-2", 3, "click"], [1, "col-lg-5", "col-sm-12", "text-center", "justify-content-end"], [3, "selectedProductRootUrl", "rootProduct"]], template: function ProductUpsertComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 7)(1, "div", 8)(2, "div", 9)(3, "div", 10)(4, "h3", 11);
    \u0275\u0275text(5, "Update product");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "form", 12, 0);
    \u0275\u0275listener("ngSubmit", function ProductUpsertComponent_Template_form_ngSubmit_6_listener() {
      \u0275\u0275restoreView(_r1);
      const editProductForm_r2 = \u0275\u0275reference(7);
      return \u0275\u0275resetView(editProductForm_r2.form.valid && ctx.upsertProduct());
    });
    \u0275\u0275element(8, "ngx-spinner", 13)(9, "ngx-spinner", 14)(10, "ngx-spinner", 15)(11, "ngx-spinner", 16)(12, "hr");
    \u0275\u0275elementStart(13, "h4");
    \u0275\u0275text(14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "div", 17)(16, "div", 18)(17, "h5");
    \u0275\u0275text(18, "Category");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(19, "select", 19, 1);
    \u0275\u0275twoWayListener("ngModelChange", function ProductUpsertComponent_Template_select_ngModelChange_19_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedCategory, $event) || (ctx.selectedCategory = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function ProductUpsertComponent_Template_select_ngModelChange_19_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.selectCategory($event));
    });
    \u0275\u0275template(21, ProductUpsertComponent_option_21_Template, 2, 2, "option", 20);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(22, ProductUpsertComponent_div_22_Template, 2, 0, "div", 21)(23, ProductUpsertComponent_div_23_Template, 3, 2, "div", 21);
    \u0275\u0275elementStart(24, "ul", 22)(25, "li", 23);
    \u0275\u0275element(26, "fa-icon", 24);
    \u0275\u0275text(27);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(28, "li", 18);
    \u0275\u0275element(29, "fa-icon", 24);
    \u0275\u0275text(30);
    \u0275\u0275elementEnd();
    \u0275\u0275template(31, ProductUpsertComponent_li_31_Template, 3, 1, "li", 25)(32, ProductUpsertComponent_li_32_Template, 3, 2, "li", 26);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(33, "button", 27);
    \u0275\u0275listener("click", function ProductUpsertComponent_Template_button_click_33_listener() {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.addCategory());
    });
    \u0275\u0275text(34, "\xA0Add category");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(35, "h5");
    \u0275\u0275text(36, "Categories");
    \u0275\u0275elementEnd();
    \u0275\u0275template(37, ProductUpsertComponent_div_37_Template, 9, 2, "div", 28);
    \u0275\u0275elementStart(38, "app-img-insert", 29);
    \u0275\u0275listener("selectedImageEmitter", function ProductUpsertComponent_Template_app_img_insert_selectedImageEmitter_38_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.selectImage($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(39, "div", 17)(40, "h4", 30);
    \u0275\u0275text(41, "Product detail");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(42, "div", 18)(43, "label", 31);
    \u0275\u0275text(44, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(45, "input", 32, 2);
    \u0275\u0275twoWayListener("ngModelChange", function ProductUpsertComponent_Template_input_ngModelChange_45_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedProduct.name, $event) || (ctx.selectedProduct.name = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(47, ProductUpsertComponent_div_47_Template, 3, 2, "div", 21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(48, "div", 18)(49, "label", 33);
    \u0275\u0275text(50, "Url");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(51, "input", 34, 3);
    \u0275\u0275twoWayListener("ngModelChange", function ProductUpsertComponent_Template_input_ngModelChange_51_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedProduct.url, $event) || (ctx.selectedProduct.url = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(53, ProductUpsertComponent_div_53_Template, 3, 2, "div", 21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(54, "div", 18)(55, "label", 35);
    \u0275\u0275text(56, "ISBN");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(57, "input", 36, 4);
    \u0275\u0275twoWayListener("ngModelChange", function ProductUpsertComponent_Template_input_ngModelChange_57_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedProduct.isbn, $event) || (ctx.selectedProduct.isbn = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(59, ProductUpsertComponent_div_59_Template, 3, 2, "div", 21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(60, "div", 18)(61, "label", 37);
    \u0275\u0275text(62, "Price");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(63, "input", 38, 5);
    \u0275\u0275twoWayListener("ngModelChange", function ProductUpsertComponent_Template_input_ngModelChange_63_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedProduct.priceAmount, $event) || (ctx.selectedProduct.priceAmount = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(65, ProductUpsertComponent_div_65_Template, 3, 2, "div", 21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(66, "div", 18)(67, "label", 39);
    \u0275\u0275text(68, "Currency");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(69, "select", 40, 6);
    \u0275\u0275twoWayListener("ngModelChange", function ProductUpsertComponent_Template_select_ngModelChange_69_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.selectedProduct.priceCurrency, $event) || (ctx.selectedProduct.priceCurrency = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function ProductUpsertComponent_Template_select_ngModelChange_69_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView(ctx.selectCurrency($event));
    });
    \u0275\u0275template(71, ProductUpsertComponent_option_71_Template, 2, 2, "option", 20);
    \u0275\u0275elementEnd();
    \u0275\u0275template(72, ProductUpsertComponent_div_72_Template, 3, 2, "div", 21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(73, "div", 18)(74, "label", 41);
    \u0275\u0275text(75, "Description");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(76, "angular-editor", 42);
    \u0275\u0275twoWayListener("ngModelChange", function ProductUpsertComponent_Template_angular_editor_ngModelChange_76_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.htmlContent, $event) || (ctx.htmlContent = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275element(77, "app-error", 43)(78, "app-error", 43);
    \u0275\u0275elementStart(79, "div", 44)(80, "button", 45);
    \u0275\u0275text(81, "\xA0Submit");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(82, "button", 46);
    \u0275\u0275element(83, "fa-icon", 47);
    \u0275\u0275text(84, "\xA0Back ");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(85, ProductUpsertComponent_div_85_Template, 4, 1, "div", 48);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275element(86, "div", 49);
    \u0275\u0275template(87, ProductUpsertComponent_div_87_Template, 2, 2, "div", 50);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const editProductForm_r2 = \u0275\u0275reference(7);
    const select_r4 = \u0275\u0275reference(20);
    const name_r8 = \u0275\u0275reference(46);
    const url_r9 = \u0275\u0275reference(52);
    const isbn_r10 = \u0275\u0275reference(58);
    const price_r11 = \u0275\u0275reference(64);
    const currency_r13 = \u0275\u0275reference(70);
    \u0275\u0275advance(14);
    \u0275\u0275textInterpolate(ctx.selectedProduct.name);
    \u0275\u0275advance(5);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedCategory);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(39, _c027));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.categories);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.selectedCategory.url);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", editProductForm_r2.submitted && select_r4.invalid);
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(40, _c116, ctx.selectedCategory.url));
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx.faEye);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0\xA0 ", ctx.selectedCategory.url, " ");
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faAddressCard);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0\xA0", ctx.selectedCategory.name, " ");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.selectedCategory.description);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.selectedCategory.description);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngForOf", ctx.addedCategories);
    \u0275\u0275advance();
    \u0275\u0275property("headerName", ctx.headerName)("maxDimension", ctx.maxDimension)("maxSize", ctx.maxSize)("existingImage", ctx.existingImage)("existingImageName", ctx.selectedProduct.name);
    \u0275\u0275advance(7);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedProduct.name);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", editProductForm_r2.submitted && name_r8.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedProduct.url);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", editProductForm_r2.submitted && url_r9.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedProduct.isbn);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", editProductForm_r2.submitted && isbn_r10.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedProduct.priceAmount);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", editProductForm_r2.submitted && price_r11.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedProduct.priceCurrency);
    \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(42, _c027));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx.currencies);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", editProductForm_r2.submitted && currency_r13.invalid);
    \u0275\u0275advance(4);
    \u0275\u0275property("placeholder", "Enter text here...");
    \u0275\u0275twoWayProperty("ngModel", ctx.htmlContent);
    \u0275\u0275property("config", ctx.editorConfig);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.imgErrorDto);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(5);
    \u0275\u0275property("icon", ctx.faArrowLeft);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.selectedProduct == null ? null : ctx.selectedProduct.url);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx.shown);
  }
}, dependencies: [NgForOf, NgIf, ErrorComponent, \u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, SelectControlValueAccessor, NgControlStatus, NgControlStatusGroup, MinLengthValidator, NgModel, NgForm, NgxSpinnerComponent, FaIconComponent, RouterLink, AngularEditorComponent, ProductSkuComponent, ImgUpdateComponent], encapsulation: 2 });
var ProductUpsertComponent = _ProductUpsertComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ProductUpsertComponent, { className: "ProductUpsertComponent", filePath: "src/app/product/product-upsert/product-upsert.component.ts", lineNumber: 29 });
})();

// src/app/product/sku-view/product-sku-view.component.ts
function ProductSkuViewComponent_div_17_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13)(1, "div", 14)(2, "div", 15);
    \u0275\u0275element(3, "span", 16);
    \u0275\u0275elementStart(4, "span", 17);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "span", 17);
    \u0275\u0275text(7);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const variant_r1 = ctx.$implicit;
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1("", variant_r1.variantName, " - ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(variant_r1.variantCatalog);
  }
}
function ProductSkuViewComponent_div_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "h5");
    \u0275\u0275text(2, "Variant names - catalog");
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, ProductSkuViewComponent_div_17_div_3_Template, 8, 2, "div", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275property("ngForOf", ctx_r1.productSku.variants);
  }
}
var _ProductSkuViewComponent = class _ProductSkuViewComponent {
  constructor(productSkuService, route, actRoute, spinner, toastr) {
    this.productSkuService = productSkuService;
    this.route = route;
    this.actRoute = actRoute;
    this.spinner = spinner;
    this.toastr = toastr;
    this.productSku = new ProductSku();
    this.audit = new Audit();
    this.faEdit = AppConstants.iconEdit;
    this.errorDto = new ErrorDto();
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.destroy$ = new Subject();
    this.existingImage = new BehaviorSubject("");
  }
  ngOnInit() {
    this.actRoute.paramMap.subscribe((params) => {
      this.productSku.sku = params.get("sku");
      this.loadSku();
    });
  }
  loadSku() {
    this.spinner.show("productSkuSpinner").then((r2) => r2);
    console.log("");
    return this.productSkuService.getProductSku(this.productSku.sku, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (skuResponse) => {
        this.spinner.hide("productSkuSpinner").then(() => {
          this.productSku = skuResponse.data;
          this.audit = skuResponse.audit;
          this.imgContentType = skuResponse.data.file.type;
          this.existingImage.next("data:image/jpeg;base64," + skuResponse.data.file.bytes);
          this.errorDto = new ErrorDto();
        });
      },
      error: () => {
        this.spinner.hide("productSkuSpinner").then(() => this.toastr.error(this.errorDto.httpStatus + " product skus failed", "Product"));
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_ProductSkuViewComponent.\u0275fac = function ProductSkuViewComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ProductSkuViewComponent)(\u0275\u0275directiveInject(ProductSkuService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_ProductSkuViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ProductSkuViewComponent, selectors: [["app-sku-view"]], standalone: false, decls: 21, vars: 10, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-6", "col-sm-8", "align-self-center"], [1, "box-part", "text-center", "text-white"], [1, "d-block"], [3, "imgName", "existingImage", "imgContentType"], ["name", "productSkuSpinner", "bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [3, "audit"], [3, "errorDto"], [4, "ngIf"], ["type", "button", "appBackButton", "", 1, "btn", "btn-danger", "mt-3"], [3, "icon"], ["class", "row text-center text-sm-center", 4, "ngFor", "ngForOf"], [1, "row", "text-center", "text-sm-center"], [1, "input-group", "link", "border-bottom"], [1, "col-sm-10", "col"], ["data-label", "Name", 1, "d-inline-block", "m-2", "text-darkorange", "d-sm-none"], [1, "d-inline-block", "m-2", "text-white"]], template: function ProductSkuViewComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h2");
    \u0275\u0275text(5, "Sku Detail");
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "hr");
    \u0275\u0275elementStart(7, "span", 4);
    \u0275\u0275text(8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "span", 4);
    \u0275\u0275text(10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "span", 4);
    \u0275\u0275text(12);
    \u0275\u0275elementEnd();
    \u0275\u0275element(13, "app-img-view", 5)(14, "ngx-spinner", 6)(15, "app-audit", 7)(16, "app-error", 8);
    \u0275\u0275template(17, ProductSkuViewComponent_div_17_Template, 4, 1, "div", 9);
    \u0275\u0275elementStart(18, "button", 10);
    \u0275\u0275element(19, "fa-icon", 11);
    \u0275\u0275text(20, "\xA0Back ");
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(8);
    \u0275\u0275textInterpolate1("name: ", ctx.productSku.name, "");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("sku: ", ctx.productSku.sku, "");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("price: ", ctx.productSku.priceAmount, " K\u010D");
    \u0275\u0275advance();
    \u0275\u0275property("imgName", ctx.productSku.name)("existingImage", ctx.existingImage)("imgContentType", ctx.imgContentType);
    \u0275\u0275advance(2);
    \u0275\u0275property("audit", ctx.audit);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", (ctx.productSku.variants == null ? null : ctx.productSku.variants.length) > 0);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faArrowLeft);
  }
}, dependencies: [NgForOf, NgIf, ErrorComponent, AuditComponent, NgxSpinnerComponent, FaIconComponent, ImgViewComponent], encapsulation: 2 });
var ProductSkuViewComponent = _ProductSkuViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ProductSkuViewComponent, { className: "ProductSkuViewComponent", filePath: "src/app/product/sku-view/product-sku-view.component.ts", lineNumber: 21 });
})();

// src/app/genericconfig/img-configuration/img-configuration.component.ts
var ModuleEnum4 = GenericConfigKeyDto.ModuleEnum;
var _ImgConfigurationComponent = class _ImgConfigurationComponent {
  constructor(genericConfigService, spinner, toastr) {
    this.genericConfigService = genericConfigService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.faUser = AppConstants.iconUser;
    this.destroy$ = new Subject();
    this.errorDto = new ErrorDto();
    this.ESHOP_IMG_SIZE = "IMG_SIZE";
    this.ESHOP_IMG_DIMENSION = "IMG_DIMENSION";
  }
  ngOnInit() {
    [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')).map(function(tooltipTriggerEl) {
      return new bootstrap.Tooltip(tooltipTriggerEl);
    });
    this.getValueFileSize();
    this.getDimensionSize();
  }
  getValueFileSize() {
    this.spinner.show().then((r2) => r2);
    this.genericConfigService.getGenericConfigBy(ModuleEnum4.FRONTEND_ADMIN, this.ESHOP_IMG_SIZE, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (config3) => {
        this.spinner.hide().then(() => {
          this.errorDto = new ErrorDto();
          this.maxFileSize = config3.data.value;
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " file size load failed", "Img Config"));
      }
    });
  }
  getDimensionSize() {
    this.spinner.show().then((r2) => r2);
    this.genericConfigService.getGenericConfigBy(ModuleEnum4.FRONTEND_ADMIN, this.ESHOP_IMG_DIMENSION, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (config3) => {
        this.spinner.hide().then(() => {
          this.errorDto = new ErrorDto();
          this.maxDimensionSize = config3.data.value;
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " dimension size load failed", "Img Config"));
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_ImgConfigurationComponent.\u0275fac = function ImgConfigurationComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ImgConfigurationComponent)(\u0275\u0275directiveInject(GenericConfigService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_ImgConfigurationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ImgConfigurationComponent, selectors: [["app-img-configuration"]], standalone: false, decls: 19, vars: 4, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-4", "col-sm-8", "align-self-center"], [1, "box-part", "text-center"], [1, "pb-3"], [1, "input-group", "mb-3"], ["data-bs-toggle", "tooltip", "data-bs-placement", "top", "data-bs-title", "Maximum size in Kb for products in eshop", "data-bs-customClass", "custom-tooltip", 1, "input-group-text", "col-12", "col-sm-5", "text-wrap"], ["readonly", "", "name", "fileSize", "type", "text", 1, "form-control", 3, "ngModel"], ["data-bs-toggle", "tooltip", "data-bs-placement", "top", "data-bs-title", "Maximum height and width for product", "data-bs-customClass", "custom-tooltip", 1, "input-group-text", "col-12", "col-sm-5", "text-wrap"], ["readonly", "", "name", "fileDimension", "type", "text", 1, "form-control", 3, "ngModel"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [3, "errorDto"], ["type", "button", "aria-hidden", "true", "appBackButton", "", 1, "btn", "btn-danger", "mt-2"], [3, "icon"]], template: function ImgConfigurationComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h2", 4);
    \u0275\u0275text(5, "Image configuration");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 5)(7, "span", 6);
    \u0275\u0275text(8, "File size [kb]");
    \u0275\u0275elementEnd();
    \u0275\u0275element(9, "input", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "div", 5)(11, "span", 8);
    \u0275\u0275text(12, "Dimension [px]");
    \u0275\u0275elementEnd();
    \u0275\u0275element(13, "input", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275element(14, "ngx-spinner", 10)(15, "app-error", 11);
    \u0275\u0275elementStart(16, "button", 12);
    \u0275\u0275element(17, "fa-icon", 13);
    \u0275\u0275text(18, "\xA0Back ");
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(9);
    \u0275\u0275property("ngModel", ctx.maxFileSize);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngModel", ctx.maxDimensionSize);
    \u0275\u0275advance(2);
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faArrowLeft);
  }
}, dependencies: [ErrorComponent, DefaultValueAccessor, NgControlStatus, NgModel, NgxSpinnerComponent, FaIconComponent], encapsulation: 2 });
var ImgConfigurationComponent = _ImgConfigurationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ImgConfigurationComponent, { className: "ImgConfigurationComponent", filePath: "src/app/genericconfig/img-configuration/img-configuration.component.ts", lineNumber: 20 });
})();

// src/app/model/configuration/config.ts
var Config = class _Config {
  static findValueByKey(name, data) {
    if (data == null) {
      return null;
    }
    return _Config.findConfigByKey(name, data)?.value;
  }
  static findConfigByKey(name, data) {
    if (data == null) {
      return null;
    }
    return data.find((key) => key.key.name == name);
  }
};

// src/app/model/configuration/advertisement.ts
var _Advertisement = class _Advertisement extends Config {
  static mapFrom(data) {
    let advertisement = new _Advertisement();
    advertisement.who = super.findValueByKey(this.ADVERTISEMENT_WHO, data);
    advertisement.address = super.findValueByKey(this.ADVERTISEMENT_ADDRESS, data);
    advertisement.complaintDays = super.findValueByKey(this.ADVERTISEMENT_COMPLAINT_DAYS, data);
    advertisement.consumer = super.findValueByKey(this.ADVERTISEMENT_CONSUMER, data);
    advertisement.complaintDaysDelay = super.findValueByKey(this.ADVERTISEMENT_COMPLAINT_DAYS_DELAY, data);
    advertisement.dueDate = super.findValueByKey(this.ADVERTISEMENT_DUE_DATE, data);
    advertisement.ico = super.findValueByKey(this.ADVERTISEMENT_ICO, data);
    advertisement.phone = super.findValueByKey(this.ADVERTISEMENT_PHONE, data);
    advertisement.emailWho = super.findValueByKey(this.ADVERTISEMENT_EMAIL, data);
    advertisement.eshopEmail = super.findValueByKey(this.ADVERTISEMENT_EMAIL_WHO, data);
    advertisement.webEshopAddress = super.findValueByKey(this.ADVERTISEMENT_WEB_ADDRESS, data);
    advertisement.sortiment = super.findValueByKey(this.ADVERTISEMENT_SORTIMENT, data);
    advertisement.eshopName = super.findValueByKey(this.ADVERTISEMENT_NAME, data);
    advertisement.limitFreeShippingPrice = super.findValueByKey(this.ADVERTISEMENT_FREE_SHIPPING_CZ, data);
    return advertisement;
  }
};
_Advertisement.ADVERTISEMENT_ADDRESS = "ADVERTISEMENT_ADDRESS";
_Advertisement.ADVERTISEMENT_ICO = "ADVERTISEMENT_ICO";
_Advertisement.ADVERTISEMENT_PHONE = "ADVERTISEMENT_PHONE";
_Advertisement.ADVERTISEMENT_WHO = "ADVERTISEMENT_WHO";
_Advertisement.ADVERTISEMENT_COMPLAINT_DAYS = "ADVERTISEMENT_COMPLAINT_DAYS";
_Advertisement.ADVERTISEMENT_COMPLAINT_DAYS_DELAY = "ADVERTISEMENT_COMPLAINT_DAYS_DELAY";
_Advertisement.ADVERTISEMENT_DUE_DATE = "ADVERTISEMENT_DUE_DATE";
_Advertisement.ADVERTISEMENT_CONSUMER = "ADVERTISEMENT_CONSUMER";
_Advertisement.ADVERTISEMENT_NAME = "ADVERTISEMENT_NAME";
_Advertisement.ADVERTISEMENT_SORTIMENT = "ADVERTISEMENT_SORTIMENT";
_Advertisement.ADVERTISEMENT_EMAIL = "ADVERTISEMENT_EMAIL";
_Advertisement.ADVERTISEMENT_EMAIL_WHO = "ADVERTISEMENT_EMAIL_WHO";
_Advertisement.ADVERTISEMENT_WEB_ADDRESS = "ADVERTISEMENT_WEB_ADDRESS";
_Advertisement.ADVERTISEMENT_FREE_SHIPPING_CZ = "ADVERTISEMENT_FREE_SHIPPING_CZK";
var Advertisement = _Advertisement;

// src/app/genericconfig/advertisement-view/advertisement-view.component.ts
var ModuleEnum5 = GenericConfigKeyDto.ModuleEnum;
function AdvertisementViewComponent_span_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.eshopEmail, " ");
  }
}
function AdvertisementViewComponent_span_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.emailWho, " ");
  }
}
function AdvertisementViewComponent_span_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.webEshopAddress, " ");
  }
}
function AdvertisementViewComponent_span_30_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_31_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.sortiment, " ");
  }
}
function AdvertisementViewComponent_span_36_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_37_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.eshopName, " ");
  }
}
function AdvertisementViewComponent_span_41_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_42_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.address, " ");
  }
}
function AdvertisementViewComponent_span_47_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_48_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.ico, " ");
  }
}
function AdvertisementViewComponent_span_52_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty phone!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_span_53_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty email!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_54_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16)(1, "span", 17);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 17);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.advertisement.phone);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.emailWho, "");
  }
}
function AdvertisementViewComponent_span_59_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_60_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.limitFreeShippingPrice, " ");
  }
}
function AdvertisementViewComponent_span_64_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_65_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.dueDate, " ");
  }
}
function AdvertisementViewComponent_span_70_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_71_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.who, " ");
  }
}
function AdvertisementViewComponent_span_75_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_76_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement.consumer, " ");
  }
}
function AdvertisementViewComponent_span_81_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_82_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement == null ? null : ctx_r0.advertisement.complaintDays, " ");
  }
}
function AdvertisementViewComponent_span_86_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 18);
    \u0275\u0275element(1, "fa-icon", 15);
    \u0275\u0275text(2, "\xA0\xA0\xA0Empty!!");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("icon", ctx_r0.faTrash);
  }
}
function AdvertisementViewComponent_div_87_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.advertisement == null ? null : ctx_r0.advertisement.complaintDaysDelay, " ");
  }
}
var _AdvertisementViewComponent = class _AdvertisementViewComponent {
  constructor(genericConfigService, spinner, toastr) {
    this.genericConfigService = genericConfigService;
    this.spinner = spinner;
    this.toastr = toastr;
    this.faTrash = AppConstants.iconTrash;
    this.faEdit = AppConstants.iconEdit;
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.advertisement = new Advertisement();
    this.destroy$ = new Subject();
    this.errorDto = new ErrorDto();
  }
  ngOnInit() {
    this.loadConfigs();
  }
  loadConfigs() {
    this.spinner.show("accountSpinner").then((r2) => r2);
    this.genericConfigService.getGenericConfigs(ModuleEnum5.FRONTEND_ADMIN, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (genericConfigResponse) => {
        this.spinner.hide("accountSpinner").then(() => {
          this.advertisement = Advertisement.mapFrom(genericConfigResponse.data);
          this.errorDto = new ErrorDto();
        });
      },
      error: () => {
        this.spinner.hide("accountSpinner").then(() => {
          this.toastr.error(this.errorDto.httpStatus + " config reloaded failed", "Config");
        });
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_AdvertisementViewComponent.\u0275fac = function AdvertisementViewComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AdvertisementViewComponent)(\u0275\u0275directiveInject(GenericConfigService), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_AdvertisementViewComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AdvertisementViewComponent, selectors: [["app-advertisement-view"]], standalone: false, decls: 92, vars: 33, consts: [[1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-6", "col-sm-8", "align-self-center"], [1, "box-part", "text-center", "text-white"], [1, "text-white"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [1, "row"], [1, "col", "pt-4"], [1, "text-darkorange", "d-block"], ["class", "fw-bold", 4, "ngIf"], [1, "col-12", "col-sm-6", "pt-4"], ["class", "trash fw-bold", 4, "ngIf"], ["class", "info fw-bold", 4, "ngIf"], [3, "errorDto"], ["type", "button", "aria-hidden", "true", "appBackButton", "", 1, "btn", "btn-danger", "m-5"], [3, "icon"], [1, "fw-bold"], [1, "d-block"], [1, "trash", "fw-bold"], [1, "info", "fw-bold"]], template: function AdvertisementViewComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "h2");
    \u0275\u0275text(5, "Advertisement Configuration");
    \u0275\u0275elementEnd();
    \u0275\u0275element(6, "hr");
    \u0275\u0275elementStart(7, "h3", 4);
    \u0275\u0275text(8);
    \u0275\u0275elementEnd();
    \u0275\u0275element(9, "ngx-spinner", 5);
    \u0275\u0275elementStart(10, "div", 6)(11, "div", 7)(12, "span", 8);
    \u0275\u0275text(13, "Email eshopu pro reklamaci:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(14, AdvertisementViewComponent_span_14_Template, 3, 1, "span", 9)(15, AdvertisementViewComponent_div_15_Template, 2, 1, "div", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(16, "div", 7)(17, "span", 8);
    \u0275\u0275text(18, "Email na majitele eshopu:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(19, AdvertisementViewComponent_span_19_Template, 3, 1, "span", 9)(20, AdvertisementViewComponent_div_20_Template, 2, 1, "div", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(21, "div", 6)(22, "div", 10)(23, "span", 8);
    \u0275\u0275text(24, "Internetov\xFD obchod, kter\xFD je provozov\xE1n na webov\xE9 adrese:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(25, AdvertisementViewComponent_span_25_Template, 3, 1, "span", 9)(26, AdvertisementViewComponent_div_26_Template, 2, 1, "div", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(27, "div", 10)(28, "span", 8);
    \u0275\u0275text(29, "Mezi kupuj\xEDc\xEDm a prod\xE1vaj\xEDc\xEDm v oblasti prodeje:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(30, AdvertisementViewComponent_span_30_Template, 3, 1, "span", 9)(31, AdvertisementViewComponent_div_31_Template, 2, 1, "div", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(32, "div", 6)(33, "div", 10)(34, "span", 8);
    \u0275\u0275text(35, " Souvisej\xEDc\xEDho zbo\u017E\xED mezi spole\u010Dnost\xED :");
    \u0275\u0275elementEnd();
    \u0275\u0275template(36, AdvertisementViewComponent_span_36_Template, 3, 1, "span", 9)(37, AdvertisementViewComponent_div_37_Template, 2, 1, "div", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(38, "div", 10)(39, "span", 8);
    \u0275\u0275text(40);
    \u0275\u0275elementEnd();
    \u0275\u0275template(41, AdvertisementViewComponent_span_41_Template, 3, 1, "span", 9)(42, AdvertisementViewComponent_div_42_Template, 2, 1, "div", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(43, "div", 6)(44, "div", 10)(45, "span", 8);
    \u0275\u0275text(46, "I\u010CO:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(47, AdvertisementViewComponent_span_47_Template, 3, 1, "span", 9)(48, AdvertisementViewComponent_div_48_Template, 2, 1, "div", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(49, "div", 10)(50, "span", 8);
    \u0275\u0275text(51, " Kontaktn\xED \xFAdaje na prod\xE1vaj\xEDc\xEDho jsou:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(52, AdvertisementViewComponent_span_52_Template, 3, 1, "span", 9)(53, AdvertisementViewComponent_span_53_Template, 3, 1, "span", 9)(54, AdvertisementViewComponent_div_54_Template, 5, 2, "div", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(55, "div", 6)(56, "div", 10)(57, "span", 8);
    \u0275\u0275text(58, " P\u0159i n\xE1kupu zbo\u017E\xED nad:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(59, AdvertisementViewComponent_span_59_Template, 3, 1, "span", 11)(60, AdvertisementViewComponent_div_60_Template, 2, 1, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(61, "div", 10)(62, "span", 8);
    \u0275\u0275text(63, " Mezi Prod\xE1vaj\xEDc\xEDm a Kupuj\xEDc\xEDm s platnost\xED od:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(64, AdvertisementViewComponent_span_64_Template, 3, 1, "span", 11)(65, AdvertisementViewComponent_div_65_Template, 2, 1, "div", 12);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(66, "div", 6)(67, "div", 10)(68, "span", 8);
    \u0275\u0275text(69, "Tento reklama\u010Dn\xED \u0159\xE1d se vztahuje na prodej zbo\u017E\xED:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(70, AdvertisementViewComponent_span_70_Template, 3, 1, "span", 11)(71, AdvertisementViewComponent_div_71_Template, 2, 1, "div", 12);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(72, "div", 10)(73, "span", 8);
    \u0275\u0275text(74, "Z\xE1ru\u010Dn\xED lh\u016Fta pro:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(75, AdvertisementViewComponent_span_75_Template, 3, 1, "span", 9)(76, AdvertisementViewComponent_div_76_Template, 2, 1, "div", 9);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(77, "div", 6)(78, "div", 10)(79, "span", 8);
    \u0275\u0275text(80, "Prod\xE1vaj\xEDc\xED je povinen o reklamaci rozhodnout ihned, ve slo\u017Eit\u011Bj\u0161\xEDch p\u0159\xEDpadech do:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(81, AdvertisementViewComponent_span_81_Template, 3, 1, "span", 9)(82, AdvertisementViewComponent_div_82_Template, 2, 1, "div", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(83, "div", 10)(84, "span", 8);
    \u0275\u0275text(85, "Nejpozd\u011Bji do:");
    \u0275\u0275elementEnd();
    \u0275\u0275template(86, AdvertisementViewComponent_span_86_Template, 3, 1, "span", 11)(87, AdvertisementViewComponent_div_87_Template, 2, 1, "div", 12);
    \u0275\u0275elementEnd()();
    \u0275\u0275element(88, "app-error", 13);
    \u0275\u0275elementStart(89, "button", 14);
    \u0275\u0275element(90, "fa-icon", 15);
    \u0275\u0275text(91, "\xA0Back ");
    \u0275\u0275elementEnd()()()()();
  }
  if (rf & 2) {
    \u0275\u0275advance(8);
    \u0275\u0275textInterpolate(ctx.advertisement == null ? null : ctx.advertisement.eshopName);
    \u0275\u0275advance(6);
    \u0275\u0275property("ngIf", !ctx.advertisement.eshopEmail);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.eshopEmail);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", !ctx.advertisement.emailWho);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.emailWho);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", !ctx.advertisement.webEshopAddress);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.webEshopAddress);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", !ctx.advertisement.sortiment);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.sortiment);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", !ctx.advertisement.eshopName);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.eshopName);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" Prod\xE1vaj\xEDc\xEDm je spole\u010Dnost ", ctx.advertisement.eshopName, " , se s\xEDdlem :");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.advertisement.address);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.address);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", !ctx.advertisement.ico);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.ico);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", !ctx.advertisement.phone);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx.advertisement.emailWho);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.phone || (ctx.advertisement == null ? null : ctx.advertisement.emailWho));
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", !ctx.advertisement.limitFreeShippingPrice);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.limitFreeShippingPrice);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", !ctx.advertisement.dueDate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.dueDate);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", !ctx.advertisement.who);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.who);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", !ctx.advertisement.consumer);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.consumer);
    \u0275\u0275advance(5);
    \u0275\u0275property("ngIf", !ctx.advertisement.complaintDays);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.complaintDays);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", !ctx.advertisement.complaintDaysDelay);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx.advertisement.complaintDaysDelay);
    \u0275\u0275advance();
    \u0275\u0275property("errorDto", ctx.errorDto);
    \u0275\u0275advance(2);
    \u0275\u0275property("icon", ctx.faArrowLeft);
  }
}, dependencies: [NgIf, ErrorComponent, NgxSpinnerComponent, FaIconComponent], encapsulation: 2 });
var AdvertisementViewComponent = _AdvertisementViewComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AdvertisementViewComponent, { className: "AdvertisementViewComponent", filePath: "src/app/genericconfig/advertisement-view/advertisement-view.component.ts", lineNumber: 20 });
})();

// src/app/model/configuration/bank-configuration-dto.ts
var BankConfigurationDto = class {
  constructor(iban) {
    this.iban = iban;
  }
};

// src/app/genericconfig/bank-configuration/bank-configuration.component.ts
var ModuleEnum6 = GenericConfigKeyDto.ModuleEnum;
function BankConfigurationComponent_div_15_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1, "Iban is required.");
    \u0275\u0275elementEnd();
  }
}
function BankConfigurationComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275template(1, BankConfigurationComponent_div_15_div_1_Template, 2, 0, "div", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const ibanName_r3 = \u0275\u0275reference(12);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ibanName_r3.errors.required);
  }
}
var _BankConfigurationComponent = class _BankConfigurationComponent {
  constructor(genericConfigService, route, actRoute, spinner, toastr) {
    this.genericConfigService = genericConfigService;
    this.route = route;
    this.actRoute = actRoute;
    this.spinner = spinner;
    this.toastr = toastr;
    this.ESHOP_BANK_IBAN = "BANK_IBAN";
    this.faArrowLeft = AppConstants.iconArrowLeft;
    this.faUser = AppConstants.iconUser;
    this.destroy$ = new Subject();
    this.bankConfigurationDto = new BankConfigurationDto(null);
    this.errorDto = new ErrorDto();
  }
  ngOnInit() {
    [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')).map(function(tooltipTriggerEl) {
      return new bootstrap.Tooltip(tooltipTriggerEl);
    });
    this.spinner.show().then((r2) => r2);
    this.genericConfigService.getGenericConfigBy(ModuleEnum6.FRONTEND_ADMIN, this.ESHOP_BANK_IBAN, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (bankConfig) => {
        this.spinner.hide().then(() => {
          this.genericData = bankConfig.data;
          this.bankConfigurationDto = new BankConfigurationDto(this.genericData.value);
          this.errorDto = new ErrorDto();
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " load failed", "Bank Config"));
      }
    });
  }
  upsertIban() {
    this.spinner.show().then((r2) => r2);
    this.genericData.value = this.bankConfigurationDto.iban;
    this.genericConfigService.putGenericConfig(ModuleEnum6.FRONTEND_ADMIN, this.ESHOP_BANK_IBAN, this.genericData.value, this.errorDto).pipe(takeUntil(this.destroy$)).subscribe({
      next: (bankConfig) => {
        this.spinner.hide().then(() => {
          this.toastr.success("Bank config updated", "Bank Config");
          this.bankConfigurationDto = new BankConfigurationDto(bankConfig.data.value);
          this.errorDto = new ErrorDto();
        });
      },
      error: () => {
        this.spinner.hide().then(() => this.toastr.error(this.errorDto.httpStatus + " update failed", "Bank Config"));
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next(true);
    this.destroy$.complete();
  }
};
_BankConfigurationComponent.\u0275fac = function BankConfigurationComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _BankConfigurationComponent)(\u0275\u0275directiveInject(GenericConfigService), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(NgxSpinnerService), \u0275\u0275directiveInject(ToastrService));
};
_BankConfigurationComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _BankConfigurationComponent, selectors: [["app-bank-configuration"]], standalone: false, decls: 18, vars: 3, consts: [["editBankForm", "ngForm"], ["ibanName", "ngModel"], [1, "box"], [1, "row", "justify-content-center"], [1, "col-lg-5", "col-sm-7", "align-self-center"], [1, "box-part", "text-center"], ["novalidate", "", 3, "ngSubmit"], [1, "pb-3"], [1, "input-group", "mb-3"], ["data-bs-toggle", "tooltip", "data-bs-placement", "top", "data-bs-title", "CZ bank IBAN", "data-bs-customClass", "custom-tooltip", 1, "input-group-text"], ["name", "ibanName", "type", "text", "required", "", 1, "form-control", 3, "ngModelChange", "ngModel"], ["type", "submit", 1, "btn", "btn-primary"], ["class", "alert alert-danger", 4, "ngIf"], ["bdColor", "rgba(51,51,51,0.8)", "size", "medium", "color", "#fff", "type", "ball-spin-clockwise"], [3, "errorDto"], [1, "alert", "alert-danger"], [4, "ngIf"]], template: function BankConfigurationComponent_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2)(1, "div", 3)(2, "div", 4)(3, "div", 5)(4, "form", 6, 0);
    \u0275\u0275listener("ngSubmit", function BankConfigurationComponent_Template_form_ngSubmit_4_listener() {
      \u0275\u0275restoreView(_r1);
      const editBankForm_r2 = \u0275\u0275reference(5);
      return \u0275\u0275resetView(editBankForm_r2.valid && ctx.upsertIban());
    });
    \u0275\u0275elementStart(6, "h2", 7);
    \u0275\u0275text(7, "Bank configuration");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 8)(9, "span", 9);
    \u0275\u0275text(10, "Iban");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "input", 10, 1);
    \u0275\u0275twoWayListener("ngModelChange", function BankConfigurationComponent_Template_input_ngModelChange_11_listener($event) {
      \u0275\u0275restoreView(_r1);
      \u0275\u0275twoWayBindingSet(ctx.bankConfigurationDto.iban, $event) || (ctx.bankConfigurationDto.iban = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(13, "button", 11);
    \u0275\u0275text(14, "Update");
    \u0275\u0275elementEnd()();
    \u0275\u0275template(15, BankConfigurationComponent_div_15_Template, 2, 1, "div", 12);
    \u0275\u0275element(16, "ngx-spinner", 13);
    \u0275\u0275elementEnd();
    \u0275\u0275element(17, "app-error", 14);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const editBankForm_r2 = \u0275\u0275reference(5);
    const ibanName_r3 = \u0275\u0275reference(12);
    \u0275\u0275advance(11);
    \u0275\u0275twoWayProperty("ngModel", ctx.bankConfigurationDto.iban);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", editBankForm_r2.submitted && ibanName_r3.invalid);
    \u0275\u0275advance(2);
    \u0275\u0275property("errorDto", ctx.errorDto);
  }
}, dependencies: [NgIf, ErrorComponent, \u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, NgModel, NgForm, NgxSpinnerComponent], encapsulation: 2 });
var BankConfigurationComponent = _BankConfigurationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(BankConfigurationComponent, { className: "BankConfigurationComponent", filePath: "src/app/genericconfig/bank-configuration/bank-configuration.component.ts", lineNumber: 25 });
})();

// src/app/app-routing.module.ts
var routes = [
  { path: "", pathMatch: "full", redirectTo: "home" },
  { path: "home", component: HomeComponent, canActivate: [authGuard] },
  { path: "login", component: LoginComponent },
  { path: "password-change", component: PasswordChangeComponent },
  { path: "forgot-password", component: ForgotPasswordComponent },
  { path: "advertisement", component: AdvertisementViewComponent, canActivate: [authGuard] },
  { path: "bank", component: BankConfigurationComponent, canActivate: [authGuard] },
  { path: "img", component: ImgConfigurationComponent, canActivate: [authGuard] },
  { path: "qr-code", component: QrComponent, canActivate: [authGuard] },
  { path: "categories", component: CategoryListComponent, canActivate: [authGuard] },
  { path: "categories/upsert", component: CategoryUpsertComponent, canActivate: [authGuard] },
  { path: "categories/view/:categoryUrl", component: CategoryViewComponent, canActivate: [authGuard] },
  { path: "products", component: ProductListComponent, canActivate: [authGuard] },
  { path: "products/view/:productUrl", component: ProductViewComponent, canActivate: [authGuard] },
  { path: "products/upsert", component: ProductUpsertComponent, canActivate: [authGuard] },
  { path: "products/sku/:productUrl", component: ProductSkuComponent, canActivate: [authGuard] },
  { path: "products/sku/view/:sku", component: ProductSkuViewComponent, canActivate: [authGuard] },
  { path: "accounts", component: AccountListComponent, canActivate: [authGuard] },
  { path: "accounts/edit/:username", component: AccountEditComponent, canActivate: [authGuard] },
  { path: "accounts/create", component: AccountCreateComponent, canActivate: [authGuard] },
  { path: "generic-configs", component: GenericConfigListComponent, canActivate: [authGuard] },
  { path: "generic-configs/create", component: GenericConfigCreateComponent, canActivate: [authGuard] },
  { path: "generic-configs/edit/:module/:key", component: GenericConfigEditComponent, canActivate: [authGuard] },
  { path: "email/write-us", component: WriteUsListComponent, canActivate: [authGuard] },
  { path: "email/write-us/:email", component: WriteUsComponent, canActivate: [authGuard] },
  { path: "variant-catalogs", component: VariantCatalogListComponent, canActivate: [authGuard] },
  { path: "variant-catalogs/create", component: UpsertVariantCatalogComponent, canActivate: [authGuard] },
  { path: "variant-catalogs/:paramName", component: UpsertVariantCatalogComponent, canActivate: [authGuard] },
  { path: "graph/home", component: GraphHomeComponent, canActivate: [authGuard] },
  { path: "orders", component: OrderListComponent, canActivate: [authGuard] },
  { path: "orders/view/:orderId", component: OrderViewComponent, canActivate: [authGuard] }
];
var _AppRoutingModule = class _AppRoutingModule {
};
_AppRoutingModule.\u0275fac = function AppRoutingModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AppRoutingModule)();
};
_AppRoutingModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _AppRoutingModule });
_AppRoutingModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [RouterModule.forRoot(routes), RouterModule] });
var AppRoutingModule = _AppRoutingModule;

// src/app/validator/isbn-validator.directive.ts
var _IsbnValidatorDirective = class _IsbnValidatorDirective {
  constructor() {
    this.regex = new RegExp("^(?:ISBN(?:-1[03])?:? )?(?=[0-9X]{10}$|(?=(?:[0-9]+[- ]){3})[- 0-9X]{13}$|97[89][0-9]{10}$|(?=(?:[0-9]+[- ]){4})[- 0-9]{17}$)(?:97[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$");
  }
  validate(control) {
    return this.regex.test(control.value) ? null : { isInvalidIsbn: true };
  }
};
_IsbnValidatorDirective.\u0275fac = function IsbnValidatorDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _IsbnValidatorDirective)();
};
_IsbnValidatorDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _IsbnValidatorDirective, selectors: [["", "appIsbnValidator", ""]], standalone: false, features: [\u0275\u0275ProvidersFeature([{
  provide: NG_VALIDATORS,
  useExisting: _IsbnValidatorDirective,
  multi: true
}])] });
var IsbnValidatorDirective = _IsbnValidatorDirective;

// src/app/validator/price-validator.directive.ts
var _PriceValidatorDirective = class _PriceValidatorDirective {
  constructor() {
    this.regex = new RegExp("^(?:0|[1-9]\\d{0,7})(?:\\.\\d+)?$");
  }
  validate(control) {
    return this.regex.test(control.value) ? null : { isInvalidPrice: true };
  }
};
_PriceValidatorDirective.\u0275fac = function PriceValidatorDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _PriceValidatorDirective)();
};
_PriceValidatorDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _PriceValidatorDirective, selectors: [["", "appPriceValidator", ""]], standalone: false, features: [\u0275\u0275ProvidersFeature([{
  provide: NG_VALIDATORS,
  useExisting: _PriceValidatorDirective,
  multi: true
}])] });
var PriceValidatorDirective = _PriceValidatorDirective;

// src/app/validator/url-validator.directive.ts
var _UrlValidatorDirective = class _UrlValidatorDirective {
  constructor() {
    this.regex = new RegExp("^[a-zA-Z0-9]{3,13}[-]{0,1}[a-zA-Z0-9]{0,13}$");
  }
  validate(control) {
    return this.regex.test(control.value) ? null : { isInvalidUrl: true };
  }
};
_UrlValidatorDirective.\u0275fac = function UrlValidatorDirective_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _UrlValidatorDirective)();
};
_UrlValidatorDirective.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _UrlValidatorDirective, selectors: [["", "appUrlValidator", ""]], standalone: false, features: [\u0275\u0275ProvidersFeature([{
  provide: NG_VALIDATORS,
  useExisting: _UrlValidatorDirective,
  multi: true
}])] });
var UrlValidatorDirective = _UrlValidatorDirective;

// src/app/interceptor/auth.interceptor.ts
var TOKEN_HEADER_KEY = "Authorization";
var _AuthInterceptor = class _AuthInterceptor {
  constructor(storageService) {
    this.storageService = storageService;
  }
  intercept(req, next) {
    let authReq = req;
    const token = this.storageService.getAdmin()?.token;
    console.log(token);
    if (token != null) {
      authReq = req.clone({ headers: req.headers.set(TOKEN_HEADER_KEY, "Bearer " + token) });
    }
    return next.handle(authReq);
  }
};
_AuthInterceptor.\u0275fac = function AuthInterceptor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AuthInterceptor)(\u0275\u0275inject(TokenStorageService));
};
_AuthInterceptor.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _AuthInterceptor, factory: _AuthInterceptor.\u0275fac });
var AuthInterceptor = _AuthInterceptor;
var authInterceptorProviders = [
  { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
];

// src/app/interceptor/error.interceptor.ts
var _ErrorInterceptor = class _ErrorInterceptor {
  constructor(authService, route) {
    this.authService = authService;
    this.route = route;
  }
  intercept(request, next) {
    return next.handle(request).pipe(catchError((err) => {
      if (err.status === 401) {
        this.authService.logout();
        this.route.navigate(["/login"]);
      }
      return throwError(err);
    }));
  }
};
_ErrorInterceptor.\u0275fac = function ErrorInterceptor_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ErrorInterceptor)(\u0275\u0275inject(AuthService), \u0275\u0275inject(Router));
};
_ErrorInterceptor.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ErrorInterceptor, factory: _ErrorInterceptor.\u0275fac });
var ErrorInterceptor = _ErrorInterceptor;
var errorInterceptorProviders = [
  { provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true }
];

// node_modules/@angular/animations/fesm2022/browser.mjs
var LINE_START = "\n - ";
function invalidTimingValue(exp) {
  return new RuntimeError(3e3, ngDevMode && `The provided timing value "${exp}" is invalid.`);
}
function negativeStepValue() {
  return new RuntimeError(3100, ngDevMode && "Duration values below 0 are not allowed for this animation step.");
}
function negativeDelayValue() {
  return new RuntimeError(3101, ngDevMode && "Delay values below 0 are not allowed for this animation step.");
}
function invalidStyleParams(varName) {
  return new RuntimeError(3001, ngDevMode && `Unable to resolve the local animation param ${varName} in the given list of values`);
}
function invalidParamValue(varName) {
  return new RuntimeError(3003, ngDevMode && `Please provide a value for the animation param ${varName}`);
}
function invalidNodeType(nodeType) {
  return new RuntimeError(3004, ngDevMode && `Unable to resolve animation metadata node #${nodeType}`);
}
function invalidCssUnitValue(userProvidedProperty, value2) {
  return new RuntimeError(3005, ngDevMode && `Please provide a CSS unit value for ${userProvidedProperty}:${value2}`);
}
function invalidTrigger() {
  return new RuntimeError(3006, ngDevMode && "animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))");
}
function invalidDefinition() {
  return new RuntimeError(3007, ngDevMode && "only state() and transition() definitions can sit inside of a trigger()");
}
function invalidState(metadataName, missingSubs) {
  return new RuntimeError(3008, ngDevMode && `state("${metadataName}", ...) must define default values for all the following style substitutions: ${missingSubs.join(", ")}`);
}
function invalidStyleValue(value2) {
  return new RuntimeError(3002, ngDevMode && `The provided style string value ${value2} is not allowed.`);
}
function invalidParallelAnimation(prop, firstStart, firstEnd, secondStart, secondEnd) {
  return new RuntimeError(3010, ngDevMode && `The CSS property "${prop}" that exists between the times of "${firstStart}ms" and "${firstEnd}ms" is also being animated in a parallel animation between the times of "${secondStart}ms" and "${secondEnd}ms"`);
}
function invalidKeyframes() {
  return new RuntimeError(3011, ngDevMode && `keyframes() must be placed inside of a call to animate()`);
}
function invalidOffset() {
  return new RuntimeError(3012, ngDevMode && `Please ensure that all keyframe offsets are between 0 and 1`);
}
function keyframeOffsetsOutOfOrder() {
  return new RuntimeError(3200, ngDevMode && `Please ensure that all keyframe offsets are in order`);
}
function keyframesMissingOffsets() {
  return new RuntimeError(3202, ngDevMode && `Not all style() steps within the declared keyframes() contain offsets`);
}
function invalidStagger() {
  return new RuntimeError(3013, ngDevMode && `stagger() can only be used inside of query()`);
}
function invalidQuery(selector) {
  return new RuntimeError(3014, ngDevMode && `\`query("${selector}")\` returned zero elements. (Use \`query("${selector}", { optional: true })\` if you wish to allow this.)`);
}
function invalidExpression(expr) {
  return new RuntimeError(3015, ngDevMode && `The provided transition expression "${expr}" is not supported`);
}
function invalidTransitionAlias(alias) {
  return new RuntimeError(3016, ngDevMode && `The transition alias value "${alias}" is not supported`);
}
function triggerBuildFailed(name, errors) {
  return new RuntimeError(3404, ngDevMode && `The animation trigger "${name}" has failed to build due to the following errors:
 - ${errors.map((err) => err.message).join("\n - ")}`);
}
function animationFailed(errors) {
  return new RuntimeError(3502, ngDevMode && `Unable to animate due to the following errors:${LINE_START}${errors.map((err) => err.message).join(LINE_START)}`);
}
function registerFailed(errors) {
  return new RuntimeError(3503, ngDevMode && `Unable to build the animation due to the following errors: ${errors.map((err) => err.message).join("\n")}`);
}
function missingOrDestroyedAnimation() {
  return new RuntimeError(3300, ngDevMode && "The requested animation doesn't exist or has already been destroyed");
}
function createAnimationFailed(errors) {
  return new RuntimeError(3504, ngDevMode && `Unable to create the animation due to the following errors:${errors.map((err) => err.message).join("\n")}`);
}
function missingPlayer(id3) {
  return new RuntimeError(3301, ngDevMode && `Unable to find the timeline player referenced by ${id3}`);
}
function missingTrigger(phase, name) {
  return new RuntimeError(3302, ngDevMode && `Unable to listen on the animation trigger event "${phase}" because the animation trigger "${name}" doesn't exist!`);
}
function missingEvent(name) {
  return new RuntimeError(3303, ngDevMode && `Unable to listen on the animation trigger "${name}" because the provided event is undefined!`);
}
function unsupportedTriggerEvent(phase, name) {
  return new RuntimeError(3400, ngDevMode && `The provided animation trigger event "${phase}" for the animation trigger "${name}" is not supported!`);
}
function unregisteredTrigger(name) {
  return new RuntimeError(3401, ngDevMode && `The provided animation trigger "${name}" has not been registered!`);
}
function triggerTransitionsFailed(errors) {
  return new RuntimeError(3402, ngDevMode && `Unable to process animations due to the following failed trigger transitions
 ${errors.map((err) => err.message).join("\n")}`);
}
function transitionFailed(name, errors) {
  return new RuntimeError(3505, ngDevMode && `@${name} has failed due to:
 ${errors.map((err) => err.message).join("\n- ")}`);
}
var ANIMATABLE_PROP_SET = /* @__PURE__ */ new Set(["-moz-outline-radius", "-moz-outline-radius-bottomleft", "-moz-outline-radius-bottomright", "-moz-outline-radius-topleft", "-moz-outline-radius-topright", "-ms-grid-columns", "-ms-grid-rows", "-webkit-line-clamp", "-webkit-text-fill-color", "-webkit-text-stroke", "-webkit-text-stroke-color", "accent-color", "all", "backdrop-filter", "background", "background-color", "background-position", "background-size", "block-size", "border", "border-block-end", "border-block-end-color", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-width", "border-color", "border-end-end-radius", "border-end-start-radius", "border-image-outset", "border-image-slice", "border-image-width", "border-inline-end", "border-inline-end-color", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-width", "border-left", "border-left-color", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-width", "border-start-end-radius", "border-start-start-radius", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-width", "border-width", "bottom", "box-shadow", "caret-color", "clip", "clip-path", "color", "column-count", "column-gap", "column-rule", "column-rule-color", "column-rule-width", "column-width", "columns", "filter", "flex", "flex-basis", "flex-grow", "flex-shrink", "font", "font-size", "font-size-adjust", "font-stretch", "font-variation-settings", "font-weight", "gap", "grid-column-gap", "grid-gap", "grid-row-gap", "grid-template-columns", "grid-template-rows", "height", "inline-size", "input-security", "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline", "inset-inline-end", "inset-inline-start", "left", "letter-spacing", "line-clamp", "line-height", "margin", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "mask", "mask-border", "mask-position", "mask-size", "max-block-size", "max-height", "max-inline-size", "max-lines", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "object-position", "offset", "offset-anchor", "offset-distance", "offset-path", "offset-position", "offset-rotate", "opacity", "order", "outline", "outline-color", "outline-offset", "outline-width", "padding", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "perspective", "perspective-origin", "right", "rotate", "row-gap", "scale", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-coordinate", "scroll-snap-destination", "scrollbar-color", "shape-image-threshold", "shape-margin", "shape-outside", "tab-size", "text-decoration", "text-decoration-color", "text-decoration-thickness", "text-emphasis", "text-emphasis-color", "text-indent", "text-shadow", "text-underline-offset", "top", "transform", "transform-origin", "translate", "vertical-align", "visibility", "width", "word-spacing", "z-index", "zoom"]);
function optimizeGroupPlayer(players) {
  switch (players.length) {
    case 0:
      return new NoopAnimationPlayer();
    case 1:
      return players[0];
    default:
      return new AnimationGroupPlayer(players);
  }
}
function normalizeKeyframes$1(normalizer, keyframes, preStyles = /* @__PURE__ */ new Map(), postStyles = /* @__PURE__ */ new Map()) {
  const errors = [];
  const normalizedKeyframes = [];
  let previousOffset = -1;
  let previousKeyframe = null;
  keyframes.forEach((kf) => {
    const offset2 = kf.get("offset");
    const isSameOffset = offset2 == previousOffset;
    const normalizedKeyframe = isSameOffset && previousKeyframe || /* @__PURE__ */ new Map();
    kf.forEach((val, prop) => {
      let normalizedProp = prop;
      let normalizedValue = val;
      if (prop !== "offset") {
        normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
        switch (normalizedValue) {
          case \u0275PRE_STYLE:
            normalizedValue = preStyles.get(prop);
            break;
          case AUTO_STYLE:
            normalizedValue = postStyles.get(prop);
            break;
          default:
            normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
            break;
        }
      }
      normalizedKeyframe.set(normalizedProp, normalizedValue);
    });
    if (!isSameOffset) {
      normalizedKeyframes.push(normalizedKeyframe);
    }
    previousKeyframe = normalizedKeyframe;
    previousOffset = offset2;
  });
  if (errors.length) {
    throw animationFailed(errors);
  }
  return normalizedKeyframes;
}
function listenOnPlayer(player, eventName, event, callback) {
  switch (eventName) {
    case "start":
      player.onStart(() => callback(event && copyAnimationEvent(event, "start", player)));
      break;
    case "done":
      player.onDone(() => callback(event && copyAnimationEvent(event, "done", player)));
      break;
    case "destroy":
      player.onDestroy(() => callback(event && copyAnimationEvent(event, "destroy", player)));
      break;
  }
}
function copyAnimationEvent(e, phaseName, player) {
  const totalTime = player.totalTime;
  const disabled2 = player.disabled ? true : false;
  const event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == void 0 ? e.totalTime : totalTime, disabled2);
  const data = e["_data"];
  if (data != null) {
    event["_data"] = data;
  }
  return event;
}
function makeAnimationEvent(element, triggerName, fromState, toState, phaseName = "", totalTime = 0, disabled2) {
  return {
    element,
    triggerName,
    fromState,
    toState,
    phaseName,
    totalTime,
    disabled: !!disabled2
  };
}
function getOrSetDefaultValue(map3, key, defaultValue) {
  let value2 = map3.get(key);
  if (!value2) {
    map3.set(key, value2 = defaultValue);
  }
  return value2;
}
function parseTimelineCommand(command) {
  const separatorPos = command.indexOf(":");
  const id3 = command.substring(1, separatorPos);
  const action = command.slice(separatorPos + 1);
  return [id3, action];
}
var documentElement = /* @__PURE__ */ (() => typeof document === "undefined" ? null : document.documentElement)();
function getParentElement(element) {
  const parent = element.parentNode || element.host || null;
  if (parent === documentElement) {
    return null;
  }
  return parent;
}
function containsVendorPrefix(prop) {
  return prop.substring(1, 6) == "ebkit";
}
var _CACHED_BODY = null;
var _IS_WEBKIT = false;
function validateStyleProperty(prop) {
  if (!_CACHED_BODY) {
    _CACHED_BODY = getBodyNode() || {};
    _IS_WEBKIT = _CACHED_BODY.style ? "WebkitAppearance" in _CACHED_BODY.style : false;
  }
  let result = true;
  if (_CACHED_BODY.style && !containsVendorPrefix(prop)) {
    result = prop in _CACHED_BODY.style;
    if (!result && _IS_WEBKIT) {
      const camelProp = "Webkit" + prop.charAt(0).toUpperCase() + prop.slice(1);
      result = camelProp in _CACHED_BODY.style;
    }
  }
  return result;
}
function validateWebAnimatableStyleProperty(prop) {
  return ANIMATABLE_PROP_SET.has(prop);
}
function getBodyNode() {
  if (typeof document != "undefined") {
    return document.body;
  }
  return null;
}
function containsElement(elm1, elm2) {
  while (elm2) {
    if (elm2 === elm1) {
      return true;
    }
    elm2 = getParentElement(elm2);
  }
  return false;
}
function invokeQuery(element, selector, multi) {
  if (multi) {
    return Array.from(element.querySelectorAll(selector));
  }
  const elem = element.querySelector(selector);
  return elem ? [elem] : [];
}
var NoopAnimationDriver = class _NoopAnimationDriver {
  /**
   * @returns Whether `prop` is a valid CSS property
   */
  validateStyleProperty(prop) {
    return validateStyleProperty(prop);
  }
  /**
   *
   * @returns Whether elm1 contains elm2.
   */
  containsElement(elm1, elm2) {
    return containsElement(elm1, elm2);
  }
  /**
   * @returns Rhe parent of the given element or `null` if the element is the `document`
   */
  getParentElement(element) {
    return getParentElement(element);
  }
  /**
   * @returns The result of the query selector on the element. The array will contain up to 1 item
   *     if `multi` is  `false`.
   */
  query(element, selector, multi) {
    return invokeQuery(element, selector, multi);
  }
  /**
   * @returns The `defaultValue` or empty string
   */
  computeStyle(element, prop, defaultValue) {
    return defaultValue || "";
  }
  /**
   * @returns An `NoopAnimationPlayer`
   */
  animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {
    return new NoopAnimationPlayer(duration, delay);
  }
  static \u0275fac = function NoopAnimationDriver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoopAnimationDriver)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NoopAnimationDriver,
    factory: _NoopAnimationDriver.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoopAnimationDriver, [{
    type: Injectable
  }], null, null);
})();
var AnimationDriver = class {
  /**
   * @deprecated Use the NoopAnimationDriver class.
   */
  static NOOP = new NoopAnimationDriver();
};
var AnimationStyleNormalizer = class {
};
var ONE_SECOND = 1e3;
var SUBSTITUTION_EXPR_START = "{{";
var SUBSTITUTION_EXPR_END = "}}";
var ENTER_CLASSNAME = "ng-enter";
var LEAVE_CLASSNAME = "ng-leave";
var NG_TRIGGER_CLASSNAME = "ng-trigger";
var NG_TRIGGER_SELECTOR = ".ng-trigger";
var NG_ANIMATING_CLASSNAME = "ng-animating";
var NG_ANIMATING_SELECTOR = ".ng-animating";
function resolveTimingValue(value2) {
  if (typeof value2 == "number") return value2;
  const matches = value2.match(/^(-?[\.\d]+)(m?s)/);
  if (!matches || matches.length < 2) return 0;
  return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
}
function _convertTimeValueToMS(value2, unit2) {
  switch (unit2) {
    case "s":
      return value2 * ONE_SECOND;
    default:
      return value2;
  }
}
function resolveTiming(timings, errors, allowNegativeValues) {
  return timings.hasOwnProperty("duration") ? timings : parseTimeExpression(timings, errors, allowNegativeValues);
}
function parseTimeExpression(exp, errors, allowNegativeValues) {
  const regex = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
  let duration;
  let delay = 0;
  let easing = "";
  if (typeof exp === "string") {
    const matches = exp.match(regex);
    if (matches === null) {
      errors.push(invalidTimingValue(exp));
      return {
        duration: 0,
        delay: 0,
        easing: ""
      };
    }
    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
    const delayMatch = matches[3];
    if (delayMatch != null) {
      delay = _convertTimeValueToMS(parseFloat(delayMatch), matches[4]);
    }
    const easingVal = matches[5];
    if (easingVal) {
      easing = easingVal;
    }
  } else {
    duration = exp;
  }
  if (!allowNegativeValues) {
    let containsErrors = false;
    let startIndex = errors.length;
    if (duration < 0) {
      errors.push(negativeStepValue());
      containsErrors = true;
    }
    if (delay < 0) {
      errors.push(negativeDelayValue());
      containsErrors = true;
    }
    if (containsErrors) {
      errors.splice(startIndex, 0, invalidTimingValue(exp));
    }
  }
  return {
    duration,
    delay,
    easing
  };
}
function normalizeKeyframes(keyframes) {
  if (!keyframes.length) {
    return [];
  }
  if (keyframes[0] instanceof Map) {
    return keyframes;
  }
  return keyframes.map((kf) => new Map(Object.entries(kf)));
}
function setStyles(element, styles2, formerStyles) {
  styles2.forEach((val, prop) => {
    const camelProp = dashCaseToCamelCase(prop);
    if (formerStyles && !formerStyles.has(prop)) {
      formerStyles.set(prop, element.style[camelProp]);
    }
    element.style[camelProp] = val;
  });
}
function eraseStyles(element, styles2) {
  styles2.forEach((_, prop) => {
    const camelProp = dashCaseToCamelCase(prop);
    element.style[camelProp] = "";
  });
}
function normalizeAnimationEntry(steps) {
  if (Array.isArray(steps)) {
    if (steps.length == 1) return steps[0];
    return sequence(steps);
  }
  return steps;
}
function validateStyleParams(value2, options, errors) {
  const params = options.params || {};
  const matches = extractStyleParams(value2);
  if (matches.length) {
    matches.forEach((varName) => {
      if (!params.hasOwnProperty(varName)) {
        errors.push(invalidStyleParams(varName));
      }
    });
  }
}
var PARAM_REGEX = new RegExp(`${SUBSTITUTION_EXPR_START}\\s*(.+?)\\s*${SUBSTITUTION_EXPR_END}`, "g");
function extractStyleParams(value2) {
  let params = [];
  if (typeof value2 === "string") {
    let match2;
    while (match2 = PARAM_REGEX.exec(value2)) {
      params.push(match2[1]);
    }
    PARAM_REGEX.lastIndex = 0;
  }
  return params;
}
function interpolateParams(value2, params, errors) {
  const original = `${value2}`;
  const str = original.replace(PARAM_REGEX, (_, varName) => {
    let localVal = params[varName];
    if (localVal == null) {
      errors.push(invalidParamValue(varName));
      localVal = "";
    }
    return localVal.toString();
  });
  return str == original ? value2 : str;
}
var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
function dashCaseToCamelCase(input2) {
  return input2.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
function camelCaseToDashCase2(input2) {
  return input2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function allowPreviousPlayerStylesMerge(duration, delay) {
  return duration === 0 || delay === 0;
}
function balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles) {
  if (previousStyles.size && keyframes.length) {
    let startingKeyframe = keyframes[0];
    let missingStyleProps = [];
    previousStyles.forEach((val, prop) => {
      if (!startingKeyframe.has(prop)) {
        missingStyleProps.push(prop);
      }
      startingKeyframe.set(prop, val);
    });
    if (missingStyleProps.length) {
      for (let i = 1; i < keyframes.length; i++) {
        let kf = keyframes[i];
        missingStyleProps.forEach((prop) => kf.set(prop, computeStyle(element, prop)));
      }
    }
  }
  return keyframes;
}
function visitDslNode(visitor, node, context2) {
  switch (node.type) {
    case AnimationMetadataType.Trigger:
      return visitor.visitTrigger(node, context2);
    case AnimationMetadataType.State:
      return visitor.visitState(node, context2);
    case AnimationMetadataType.Transition:
      return visitor.visitTransition(node, context2);
    case AnimationMetadataType.Sequence:
      return visitor.visitSequence(node, context2);
    case AnimationMetadataType.Group:
      return visitor.visitGroup(node, context2);
    case AnimationMetadataType.Animate:
      return visitor.visitAnimate(node, context2);
    case AnimationMetadataType.Keyframes:
      return visitor.visitKeyframes(node, context2);
    case AnimationMetadataType.Style:
      return visitor.visitStyle(node, context2);
    case AnimationMetadataType.Reference:
      return visitor.visitReference(node, context2);
    case AnimationMetadataType.AnimateChild:
      return visitor.visitAnimateChild(node, context2);
    case AnimationMetadataType.AnimateRef:
      return visitor.visitAnimateRef(node, context2);
    case AnimationMetadataType.Query:
      return visitor.visitQuery(node, context2);
    case AnimationMetadataType.Stagger:
      return visitor.visitStagger(node, context2);
    default:
      throw invalidNodeType(node.type);
  }
}
function computeStyle(element, prop) {
  return window.getComputedStyle(element)[prop];
}
var DIMENSIONAL_PROP_SET = /* @__PURE__ */ new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]);
var WebAnimationsStyleNormalizer = class extends AnimationStyleNormalizer {
  normalizePropertyName(propertyName, errors) {
    return dashCaseToCamelCase(propertyName);
  }
  normalizeStyleValue(userProvidedProperty, normalizedProperty, value2, errors) {
    let unit2 = "";
    const strVal = value2.toString().trim();
    if (DIMENSIONAL_PROP_SET.has(normalizedProperty) && value2 !== 0 && value2 !== "0") {
      if (typeof value2 === "number") {
        unit2 = "px";
      } else {
        const valAndSuffixMatch = value2.match(/^[+-]?[\d\.]+([a-z]*)$/);
        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
          errors.push(invalidCssUnitValue(userProvidedProperty, value2));
        }
      }
    }
    return strVal + unit2;
  }
};
function createListOfWarnings(warnings) {
  const LINE_START2 = "\n - ";
  return `${LINE_START2}${warnings.filter(Boolean).map((warning) => warning).join(LINE_START2)}`;
}
function warnTriggerBuild(name, warnings) {
  (typeof ngDevMode === "undefined" || ngDevMode) && console.warn(`The animation trigger "${name}" has built with the following warnings:${createListOfWarnings(warnings)}`);
}
function warnRegister(warnings) {
  (typeof ngDevMode === "undefined" || ngDevMode) && console.warn(`Animation built with the following warnings:${createListOfWarnings(warnings)}`);
}
function pushUnrecognizedPropertiesWarning(warnings, props) {
  if (props.length) {
    warnings.push(`The following provided properties are not recognized: ${props.join(", ")}`);
  }
}
var ANY_STATE = "*";
function parseTransitionExpr(transitionValue, errors) {
  const expressions = [];
  if (typeof transitionValue == "string") {
    transitionValue.split(/\s*,\s*/).forEach((str) => parseInnerTransitionStr(str, expressions, errors));
  } else {
    expressions.push(transitionValue);
  }
  return expressions;
}
function parseInnerTransitionStr(eventStr, expressions, errors) {
  if (eventStr[0] == ":") {
    const result = parseAnimationAlias(eventStr, errors);
    if (typeof result == "function") {
      expressions.push(result);
      return;
    }
    eventStr = result;
  }
  const match2 = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
  if (match2 == null || match2.length < 4) {
    errors.push(invalidExpression(eventStr));
    return expressions;
  }
  const fromState = match2[1];
  const separator = match2[2];
  const toState = match2[3];
  expressions.push(makeLambdaFromStates(fromState, toState));
  const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
  if (separator[0] == "<" && !isFullAnyStateExpr) {
    expressions.push(makeLambdaFromStates(toState, fromState));
  }
  return;
}
function parseAnimationAlias(alias, errors) {
  switch (alias) {
    case ":enter":
      return "void => *";
    case ":leave":
      return "* => void";
    case ":increment":
      return (fromState, toState) => parseFloat(toState) > parseFloat(fromState);
    case ":decrement":
      return (fromState, toState) => parseFloat(toState) < parseFloat(fromState);
    default:
      errors.push(invalidTransitionAlias(alias));
      return "* => *";
  }
}
var TRUE_BOOLEAN_VALUES = /* @__PURE__ */ new Set(["true", "1"]);
var FALSE_BOOLEAN_VALUES = /* @__PURE__ */ new Set(["false", "0"]);
function makeLambdaFromStates(lhs, rhs) {
  const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);
  const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);
  return (fromState, toState) => {
    let lhsMatch = lhs == ANY_STATE || lhs == fromState;
    let rhsMatch = rhs == ANY_STATE || rhs == toState;
    if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === "boolean") {
      lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);
    }
    if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === "boolean") {
      rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);
    }
    return lhsMatch && rhsMatch;
  };
}
var SELF_TOKEN = ":self";
var SELF_TOKEN_REGEX = new RegExp(`s*${SELF_TOKEN}s*,?`, "g");
function buildAnimationAst(driver, metadata, errors, warnings) {
  return new AnimationAstBuilderVisitor(driver).build(metadata, errors, warnings);
}
var ROOT_SELECTOR = "";
var AnimationAstBuilderVisitor = class {
  _driver;
  constructor(_driver) {
    this._driver = _driver;
  }
  build(metadata, errors, warnings) {
    const context2 = new AnimationAstBuilderContext(errors);
    this._resetContextStyleTimingState(context2);
    const ast = visitDslNode(this, normalizeAnimationEntry(metadata), context2);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (context2.unsupportedCSSPropertiesFound.size) {
        pushUnrecognizedPropertiesWarning(warnings, [...context2.unsupportedCSSPropertiesFound.keys()]);
      }
    }
    return ast;
  }
  _resetContextStyleTimingState(context2) {
    context2.currentQuerySelector = ROOT_SELECTOR;
    context2.collectedStyles = /* @__PURE__ */ new Map();
    context2.collectedStyles.set(ROOT_SELECTOR, /* @__PURE__ */ new Map());
    context2.currentTime = 0;
  }
  visitTrigger(metadata, context2) {
    let queryCount = context2.queryCount = 0;
    let depCount = context2.depCount = 0;
    const states = [];
    const transitions = [];
    if (metadata.name.charAt(0) == "@") {
      context2.errors.push(invalidTrigger());
    }
    metadata.definitions.forEach((def) => {
      this._resetContextStyleTimingState(context2);
      if (def.type == AnimationMetadataType.State) {
        const stateDef = def;
        const name = stateDef.name;
        name.toString().split(/\s*,\s*/).forEach((n) => {
          stateDef.name = n;
          states.push(this.visitState(stateDef, context2));
        });
        stateDef.name = name;
      } else if (def.type == AnimationMetadataType.Transition) {
        const transition3 = this.visitTransition(def, context2);
        queryCount += transition3.queryCount;
        depCount += transition3.depCount;
        transitions.push(transition3);
      } else {
        context2.errors.push(invalidDefinition());
      }
    });
    return {
      type: AnimationMetadataType.Trigger,
      name: metadata.name,
      states,
      transitions,
      queryCount,
      depCount,
      options: null
    };
  }
  visitState(metadata, context2) {
    const styleAst = this.visitStyle(metadata.styles, context2);
    const astParams = metadata.options && metadata.options.params || null;
    if (styleAst.containsDynamicStyles) {
      const missingSubs = /* @__PURE__ */ new Set();
      const params = astParams || {};
      styleAst.styles.forEach((style2) => {
        if (style2 instanceof Map) {
          style2.forEach((value2) => {
            extractStyleParams(value2).forEach((sub) => {
              if (!params.hasOwnProperty(sub)) {
                missingSubs.add(sub);
              }
            });
          });
        }
      });
      if (missingSubs.size) {
        context2.errors.push(invalidState(metadata.name, [...missingSubs.values()]));
      }
    }
    return {
      type: AnimationMetadataType.State,
      name: metadata.name,
      style: styleAst,
      options: astParams ? {
        params: astParams
      } : null
    };
  }
  visitTransition(metadata, context2) {
    context2.queryCount = 0;
    context2.depCount = 0;
    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context2);
    const matchers = parseTransitionExpr(metadata.expr, context2.errors);
    return {
      type: AnimationMetadataType.Transition,
      matchers,
      animation,
      queryCount: context2.queryCount,
      depCount: context2.depCount,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitSequence(metadata, context2) {
    return {
      type: AnimationMetadataType.Sequence,
      steps: metadata.steps.map((s2) => visitDslNode(this, s2, context2)),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitGroup(metadata, context2) {
    const currentTime = context2.currentTime;
    let furthestTime = 0;
    const steps = metadata.steps.map((step) => {
      context2.currentTime = currentTime;
      const innerAst = visitDslNode(this, step, context2);
      furthestTime = Math.max(furthestTime, context2.currentTime);
      return innerAst;
    });
    context2.currentTime = furthestTime;
    return {
      type: AnimationMetadataType.Group,
      steps,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimate(metadata, context2) {
    const timingAst = constructTimingAst(metadata.timings, context2.errors);
    context2.currentAnimateTimings = timingAst;
    let styleAst;
    let styleMetadata = metadata.styles ? metadata.styles : style({});
    if (styleMetadata.type == AnimationMetadataType.Keyframes) {
      styleAst = this.visitKeyframes(styleMetadata, context2);
    } else {
      let styleMetadata2 = metadata.styles;
      let isEmpty = false;
      if (!styleMetadata2) {
        isEmpty = true;
        const newStyleData = {};
        if (timingAst.easing) {
          newStyleData["easing"] = timingAst.easing;
        }
        styleMetadata2 = style(newStyleData);
      }
      context2.currentTime += timingAst.duration + timingAst.delay;
      const _styleAst = this.visitStyle(styleMetadata2, context2);
      _styleAst.isEmptyStep = isEmpty;
      styleAst = _styleAst;
    }
    context2.currentAnimateTimings = null;
    return {
      type: AnimationMetadataType.Animate,
      timings: timingAst,
      style: styleAst,
      options: null
    };
  }
  visitStyle(metadata, context2) {
    const ast = this._makeStyleAst(metadata, context2);
    this._validateStyleAst(ast, context2);
    return ast;
  }
  _makeStyleAst(metadata, context2) {
    const styles2 = [];
    const metadataStyles = Array.isArray(metadata.styles) ? metadata.styles : [metadata.styles];
    for (let styleTuple of metadataStyles) {
      if (typeof styleTuple === "string") {
        if (styleTuple === AUTO_STYLE) {
          styles2.push(styleTuple);
        } else {
          context2.errors.push(invalidStyleValue(styleTuple));
        }
      } else {
        styles2.push(new Map(Object.entries(styleTuple)));
      }
    }
    let containsDynamicStyles = false;
    let collectedEasing = null;
    styles2.forEach((styleData) => {
      if (styleData instanceof Map) {
        if (styleData.has("easing")) {
          collectedEasing = styleData.get("easing");
          styleData.delete("easing");
        }
        if (!containsDynamicStyles) {
          for (let value2 of styleData.values()) {
            if (value2.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
              containsDynamicStyles = true;
              break;
            }
          }
        }
      }
    });
    return {
      type: AnimationMetadataType.Style,
      styles: styles2,
      easing: collectedEasing,
      offset: metadata.offset,
      containsDynamicStyles,
      options: null
    };
  }
  _validateStyleAst(ast, context2) {
    const timings = context2.currentAnimateTimings;
    let endTime = context2.currentTime;
    let startTime = context2.currentTime;
    if (timings && startTime > 0) {
      startTime -= timings.duration + timings.delay;
    }
    ast.styles.forEach((tuple) => {
      if (typeof tuple === "string") return;
      tuple.forEach((value2, prop) => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          if (!this._driver.validateStyleProperty(prop)) {
            tuple.delete(prop);
            context2.unsupportedCSSPropertiesFound.add(prop);
            return;
          }
        }
        const collectedStyles = context2.collectedStyles.get(context2.currentQuerySelector);
        const collectedEntry = collectedStyles.get(prop);
        let updateCollectedStyle = true;
        if (collectedEntry) {
          if (startTime != endTime && startTime >= collectedEntry.startTime && endTime <= collectedEntry.endTime) {
            context2.errors.push(invalidParallelAnimation(prop, collectedEntry.startTime, collectedEntry.endTime, startTime, endTime));
            updateCollectedStyle = false;
          }
          startTime = collectedEntry.startTime;
        }
        if (updateCollectedStyle) {
          collectedStyles.set(prop, {
            startTime,
            endTime
          });
        }
        if (context2.options) {
          validateStyleParams(value2, context2.options, context2.errors);
        }
      });
    });
  }
  visitKeyframes(metadata, context2) {
    const ast = {
      type: AnimationMetadataType.Keyframes,
      styles: [],
      options: null
    };
    if (!context2.currentAnimateTimings) {
      context2.errors.push(invalidKeyframes());
      return ast;
    }
    const MAX_KEYFRAME_OFFSET = 1;
    let totalKeyframesWithOffsets = 0;
    const offsets = [];
    let offsetsOutOfOrder = false;
    let keyframesOutOfRange = false;
    let previousOffset = 0;
    const keyframes = metadata.steps.map((styles2) => {
      const style2 = this._makeStyleAst(styles2, context2);
      let offsetVal = style2.offset != null ? style2.offset : consumeOffset(style2.styles);
      let offset2 = 0;
      if (offsetVal != null) {
        totalKeyframesWithOffsets++;
        offset2 = style2.offset = offsetVal;
      }
      keyframesOutOfRange = keyframesOutOfRange || offset2 < 0 || offset2 > 1;
      offsetsOutOfOrder = offsetsOutOfOrder || offset2 < previousOffset;
      previousOffset = offset2;
      offsets.push(offset2);
      return style2;
    });
    if (keyframesOutOfRange) {
      context2.errors.push(invalidOffset());
    }
    if (offsetsOutOfOrder) {
      context2.errors.push(keyframeOffsetsOutOfOrder());
    }
    const length = metadata.steps.length;
    let generatedOffset = 0;
    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
      context2.errors.push(keyframesMissingOffsets());
    } else if (totalKeyframesWithOffsets == 0) {
      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
    }
    const limit = length - 1;
    const currentTime = context2.currentTime;
    const currentAnimateTimings = context2.currentAnimateTimings;
    const animateDuration = currentAnimateTimings.duration;
    keyframes.forEach((kf, i) => {
      const offset2 = generatedOffset > 0 ? i == limit ? 1 : generatedOffset * i : offsets[i];
      const durationUpToThisFrame = offset2 * animateDuration;
      context2.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
      currentAnimateTimings.duration = durationUpToThisFrame;
      this._validateStyleAst(kf, context2);
      kf.offset = offset2;
      ast.styles.push(kf);
    });
    return ast;
  }
  visitReference(metadata, context2) {
    return {
      type: AnimationMetadataType.Reference,
      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context2),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimateChild(metadata, context2) {
    context2.depCount++;
    return {
      type: AnimationMetadataType.AnimateChild,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimateRef(metadata, context2) {
    return {
      type: AnimationMetadataType.AnimateRef,
      animation: this.visitReference(metadata.animation, context2),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitQuery(metadata, context2) {
    const parentSelector = context2.currentQuerySelector;
    const options = metadata.options || {};
    context2.queryCount++;
    context2.currentQuery = metadata;
    const [selector, includeSelf] = normalizeSelector(metadata.selector);
    context2.currentQuerySelector = parentSelector.length ? parentSelector + " " + selector : selector;
    getOrSetDefaultValue(context2.collectedStyles, context2.currentQuerySelector, /* @__PURE__ */ new Map());
    const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context2);
    context2.currentQuery = null;
    context2.currentQuerySelector = parentSelector;
    return {
      type: AnimationMetadataType.Query,
      selector,
      limit: options.limit || 0,
      optional: !!options.optional,
      includeSelf,
      animation,
      originalSelector: metadata.selector,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitStagger(metadata, context2) {
    if (!context2.currentQuery) {
      context2.errors.push(invalidStagger());
    }
    const timings = metadata.timings === "full" ? {
      duration: 0,
      delay: 0,
      easing: "full"
    } : resolveTiming(metadata.timings, context2.errors, true);
    return {
      type: AnimationMetadataType.Stagger,
      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context2),
      timings,
      options: null
    };
  }
};
function normalizeSelector(selector) {
  const hasAmpersand = selector.split(/\s*,\s*/).find((token) => token == SELF_TOKEN) ? true : false;
  if (hasAmpersand) {
    selector = selector.replace(SELF_TOKEN_REGEX, "");
  }
  selector = selector.replace(/@\*/g, NG_TRIGGER_SELECTOR).replace(/@\w+/g, (match2) => NG_TRIGGER_SELECTOR + "-" + match2.slice(1)).replace(/:animating/g, NG_ANIMATING_SELECTOR);
  return [selector, hasAmpersand];
}
function normalizeParams(obj) {
  return obj ? __spreadValues({}, obj) : null;
}
var AnimationAstBuilderContext = class {
  errors;
  queryCount = 0;
  depCount = 0;
  currentTransition = null;
  currentQuery = null;
  currentQuerySelector = null;
  currentAnimateTimings = null;
  currentTime = 0;
  collectedStyles = /* @__PURE__ */ new Map();
  options = null;
  unsupportedCSSPropertiesFound = /* @__PURE__ */ new Set();
  constructor(errors) {
    this.errors = errors;
  }
};
function consumeOffset(styles2) {
  if (typeof styles2 == "string") return null;
  let offset2 = null;
  if (Array.isArray(styles2)) {
    styles2.forEach((styleTuple) => {
      if (styleTuple instanceof Map && styleTuple.has("offset")) {
        const obj = styleTuple;
        offset2 = parseFloat(obj.get("offset"));
        obj.delete("offset");
      }
    });
  } else if (styles2 instanceof Map && styles2.has("offset")) {
    const obj = styles2;
    offset2 = parseFloat(obj.get("offset"));
    obj.delete("offset");
  }
  return offset2;
}
function constructTimingAst(value2, errors) {
  if (value2.hasOwnProperty("duration")) {
    return value2;
  }
  if (typeof value2 == "number") {
    const duration = resolveTiming(value2, errors).duration;
    return makeTimingAst(duration, 0, "");
  }
  const strValue = value2;
  const isDynamic = strValue.split(/\s+/).some((v) => v.charAt(0) == "{" && v.charAt(1) == "{");
  if (isDynamic) {
    const ast = makeTimingAst(0, 0, "");
    ast.dynamic = true;
    ast.strValue = strValue;
    return ast;
  }
  const timings = resolveTiming(strValue, errors);
  return makeTimingAst(timings.duration, timings.delay, timings.easing);
}
function normalizeAnimationOptions(options) {
  if (options) {
    options = __spreadValues({}, options);
    if (options["params"]) {
      options["params"] = normalizeParams(options["params"]);
    }
  } else {
    options = {};
  }
  return options;
}
function makeTimingAst(duration, delay, easing) {
  return {
    duration,
    delay,
    easing
  };
}
function createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing = null, subTimeline = false) {
  return {
    type: 1,
    element,
    keyframes,
    preStyleProps,
    postStyleProps,
    duration,
    delay,
    totalTime: duration + delay,
    easing,
    subTimeline
  };
}
var ElementInstructionMap = class {
  _map = /* @__PURE__ */ new Map();
  get(element) {
    return this._map.get(element) || [];
  }
  append(element, instructions) {
    let existingInstructions = this._map.get(element);
    if (!existingInstructions) {
      this._map.set(element, existingInstructions = []);
    }
    existingInstructions.push(...instructions);
  }
  has(element) {
    return this._map.has(element);
  }
  clear() {
    this._map.clear();
  }
};
var ONE_FRAME_IN_MILLISECONDS = 1;
var ENTER_TOKEN = ":enter";
var ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, "g");
var LEAVE_TOKEN = ":leave";
var LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, "g");
function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles = /* @__PURE__ */ new Map(), finalStyles = /* @__PURE__ */ new Map(), options, subInstructions, errors = []) {
  return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);
}
var AnimationTimelineBuilderVisitor = class {
  buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors = []) {
    subInstructions = subInstructions || new ElementInstructionMap();
    const context2 = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);
    context2.options = options;
    const delay = options.delay ? resolveTimingValue(options.delay) : 0;
    context2.currentTimeline.delayNextStep(delay);
    context2.currentTimeline.setStyles([startingStyles], null, context2.errors, options);
    visitDslNode(this, ast, context2);
    const timelines = context2.timelines.filter((timeline) => timeline.containsAnimation());
    if (timelines.length && finalStyles.size) {
      let lastRootTimeline;
      for (let i = timelines.length - 1; i >= 0; i--) {
        const timeline = timelines[i];
        if (timeline.element === rootElement) {
          lastRootTimeline = timeline;
          break;
        }
      }
      if (lastRootTimeline && !lastRootTimeline.allowOnlyTimelineStyles()) {
        lastRootTimeline.setStyles([finalStyles], null, context2.errors, options);
      }
    }
    return timelines.length ? timelines.map((timeline) => timeline.buildKeyframes()) : [createTimelineInstruction(rootElement, [], [], [], 0, delay, "", false)];
  }
  visitTrigger(ast, context2) {
  }
  visitState(ast, context2) {
  }
  visitTransition(ast, context2) {
  }
  visitAnimateChild(ast, context2) {
    const elementInstructions = context2.subInstructions.get(context2.element);
    if (elementInstructions) {
      const innerContext = context2.createSubContext(ast.options);
      const startTime = context2.currentTimeline.currentTime;
      const endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);
      if (startTime != endTime) {
        context2.transformIntoNewTimeline(endTime);
      }
    }
    context2.previousNode = ast;
  }
  visitAnimateRef(ast, context2) {
    const innerContext = context2.createSubContext(ast.options);
    innerContext.transformIntoNewTimeline();
    this._applyAnimationRefDelays([ast.options, ast.animation.options], context2, innerContext);
    this.visitReference(ast.animation, innerContext);
    context2.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
    context2.previousNode = ast;
  }
  _applyAnimationRefDelays(animationsRefsOptions, context2, innerContext) {
    for (const animationRefOptions of animationsRefsOptions) {
      const animationDelay = animationRefOptions?.delay;
      if (animationDelay) {
        const animationDelayValue = typeof animationDelay === "number" ? animationDelay : resolveTimingValue(interpolateParams(animationDelay, animationRefOptions?.params ?? {}, context2.errors));
        innerContext.delayNextStep(animationDelayValue);
      }
    }
  }
  _visitSubInstructions(instructions, context2, options) {
    const startTime = context2.currentTimeline.currentTime;
    let furthestTime = startTime;
    const duration = options.duration != null ? resolveTimingValue(options.duration) : null;
    const delay = options.delay != null ? resolveTimingValue(options.delay) : null;
    if (duration !== 0) {
      instructions.forEach((instruction) => {
        const instructionTimings = context2.appendInstructionToTimeline(instruction, duration, delay);
        furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
      });
    }
    return furthestTime;
  }
  visitReference(ast, context2) {
    context2.updateOptions(ast.options, true);
    visitDslNode(this, ast.animation, context2);
    context2.previousNode = ast;
  }
  visitSequence(ast, context2) {
    const subContextCount = context2.subContextCount;
    let ctx = context2;
    const options = ast.options;
    if (options && (options.params || options.delay)) {
      ctx = context2.createSubContext(options);
      ctx.transformIntoNewTimeline();
      if (options.delay != null) {
        if (ctx.previousNode.type == AnimationMetadataType.Style) {
          ctx.currentTimeline.snapshotCurrentStyles();
          ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        }
        const delay = resolveTimingValue(options.delay);
        ctx.delayNextStep(delay);
      }
    }
    if (ast.steps.length) {
      ast.steps.forEach((s2) => visitDslNode(this, s2, ctx));
      ctx.currentTimeline.applyStylesToKeyframe();
      if (ctx.subContextCount > subContextCount) {
        ctx.transformIntoNewTimeline();
      }
    }
    context2.previousNode = ast;
  }
  visitGroup(ast, context2) {
    const innerTimelines = [];
    let furthestTime = context2.currentTimeline.currentTime;
    const delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
    ast.steps.forEach((s2) => {
      const innerContext = context2.createSubContext(ast.options);
      if (delay) {
        innerContext.delayNextStep(delay);
      }
      visitDslNode(this, s2, innerContext);
      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
      innerTimelines.push(innerContext.currentTimeline);
    });
    innerTimelines.forEach((timeline) => context2.currentTimeline.mergeTimelineCollectedStyles(timeline));
    context2.transformIntoNewTimeline(furthestTime);
    context2.previousNode = ast;
  }
  _visitTiming(ast, context2) {
    if (ast.dynamic) {
      const strValue = ast.strValue;
      const timingValue = context2.params ? interpolateParams(strValue, context2.params, context2.errors) : strValue;
      return resolveTiming(timingValue, context2.errors);
    } else {
      return {
        duration: ast.duration,
        delay: ast.delay,
        easing: ast.easing
      };
    }
  }
  visitAnimate(ast, context2) {
    const timings = context2.currentAnimateTimings = this._visitTiming(ast.timings, context2);
    const timeline = context2.currentTimeline;
    if (timings.delay) {
      context2.incrementTime(timings.delay);
      timeline.snapshotCurrentStyles();
    }
    const style2 = ast.style;
    if (style2.type == AnimationMetadataType.Keyframes) {
      this.visitKeyframes(style2, context2);
    } else {
      context2.incrementTime(timings.duration);
      this.visitStyle(style2, context2);
      timeline.applyStylesToKeyframe();
    }
    context2.currentAnimateTimings = null;
    context2.previousNode = ast;
  }
  visitStyle(ast, context2) {
    const timeline = context2.currentTimeline;
    const timings = context2.currentAnimateTimings;
    if (!timings && timeline.hasCurrentStyleProperties()) {
      timeline.forwardFrame();
    }
    const easing = timings && timings.easing || ast.easing;
    if (ast.isEmptyStep) {
      timeline.applyEmptyStep(easing);
    } else {
      timeline.setStyles(ast.styles, easing, context2.errors, context2.options);
    }
    context2.previousNode = ast;
  }
  visitKeyframes(ast, context2) {
    const currentAnimateTimings = context2.currentAnimateTimings;
    const startTime = context2.currentTimeline.duration;
    const duration = currentAnimateTimings.duration;
    const innerContext = context2.createSubContext();
    const innerTimeline = innerContext.currentTimeline;
    innerTimeline.easing = currentAnimateTimings.easing;
    ast.styles.forEach((step) => {
      const offset2 = step.offset || 0;
      innerTimeline.forwardTime(offset2 * duration);
      innerTimeline.setStyles(step.styles, step.easing, context2.errors, context2.options);
      innerTimeline.applyStylesToKeyframe();
    });
    context2.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);
    context2.transformIntoNewTimeline(startTime + duration);
    context2.previousNode = ast;
  }
  visitQuery(ast, context2) {
    const startTime = context2.currentTimeline.currentTime;
    const options = ast.options || {};
    const delay = options.delay ? resolveTimingValue(options.delay) : 0;
    if (delay && (context2.previousNode.type === AnimationMetadataType.Style || startTime == 0 && context2.currentTimeline.hasCurrentStyleProperties())) {
      context2.currentTimeline.snapshotCurrentStyles();
      context2.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    }
    let furthestTime = startTime;
    const elms = context2.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context2.errors);
    context2.currentQueryTotal = elms.length;
    let sameElementTimeline = null;
    elms.forEach((element, i) => {
      context2.currentQueryIndex = i;
      const innerContext = context2.createSubContext(ast.options, element);
      if (delay) {
        innerContext.delayNextStep(delay);
      }
      if (element === context2.element) {
        sameElementTimeline = innerContext.currentTimeline;
      }
      visitDslNode(this, ast.animation, innerContext);
      innerContext.currentTimeline.applyStylesToKeyframe();
      const endTime = innerContext.currentTimeline.currentTime;
      furthestTime = Math.max(furthestTime, endTime);
    });
    context2.currentQueryIndex = 0;
    context2.currentQueryTotal = 0;
    context2.transformIntoNewTimeline(furthestTime);
    if (sameElementTimeline) {
      context2.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
      context2.currentTimeline.snapshotCurrentStyles();
    }
    context2.previousNode = ast;
  }
  visitStagger(ast, context2) {
    const parentContext = context2.parentContext;
    const tl = context2.currentTimeline;
    const timings = ast.timings;
    const duration = Math.abs(timings.duration);
    const maxTime = duration * (context2.currentQueryTotal - 1);
    let delay = duration * context2.currentQueryIndex;
    let staggerTransformer = timings.duration < 0 ? "reverse" : timings.easing;
    switch (staggerTransformer) {
      case "reverse":
        delay = maxTime - delay;
        break;
      case "full":
        delay = parentContext.currentStaggerTime;
        break;
    }
    const timeline = context2.currentTimeline;
    if (delay) {
      timeline.delayNextStep(delay);
    }
    const startingTime = timeline.currentTime;
    visitDslNode(this, ast.animation, context2);
    context2.previousNode = ast;
    parentContext.currentStaggerTime = tl.currentTime - startingTime + (tl.startTime - parentContext.currentTimeline.startTime);
  }
};
var DEFAULT_NOOP_PREVIOUS_NODE = {};
var AnimationTimelineContext = class _AnimationTimelineContext {
  _driver;
  element;
  subInstructions;
  _enterClassName;
  _leaveClassName;
  errors;
  timelines;
  parentContext = null;
  currentTimeline;
  currentAnimateTimings = null;
  previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
  subContextCount = 0;
  options = {};
  currentQueryIndex = 0;
  currentQueryTotal = 0;
  currentStaggerTime = 0;
  constructor(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {
    this._driver = _driver;
    this.element = element;
    this.subInstructions = subInstructions;
    this._enterClassName = _enterClassName;
    this._leaveClassName = _leaveClassName;
    this.errors = errors;
    this.timelines = timelines;
    this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);
    timelines.push(this.currentTimeline);
  }
  get params() {
    return this.options.params;
  }
  updateOptions(options, skipIfExists) {
    if (!options) return;
    const newOptions = options;
    let optionsToUpdate = this.options;
    if (newOptions.duration != null) {
      optionsToUpdate.duration = resolveTimingValue(newOptions.duration);
    }
    if (newOptions.delay != null) {
      optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
    }
    const newParams = newOptions.params;
    if (newParams) {
      let paramsToUpdate = optionsToUpdate.params;
      if (!paramsToUpdate) {
        paramsToUpdate = this.options.params = {};
      }
      Object.keys(newParams).forEach((name) => {
        if (!skipIfExists || !paramsToUpdate.hasOwnProperty(name)) {
          paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, this.errors);
        }
      });
    }
  }
  _copyOptions() {
    const options = {};
    if (this.options) {
      const oldParams = this.options.params;
      if (oldParams) {
        const params = options["params"] = {};
        Object.keys(oldParams).forEach((name) => {
          params[name] = oldParams[name];
        });
      }
    }
    return options;
  }
  createSubContext(options = null, element, newTime) {
    const target = element || this.element;
    const context2 = new _AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
    context2.previousNode = this.previousNode;
    context2.currentAnimateTimings = this.currentAnimateTimings;
    context2.options = this._copyOptions();
    context2.updateOptions(options);
    context2.currentQueryIndex = this.currentQueryIndex;
    context2.currentQueryTotal = this.currentQueryTotal;
    context2.parentContext = this;
    this.subContextCount++;
    return context2;
  }
  transformIntoNewTimeline(newTime) {
    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
    this.timelines.push(this.currentTimeline);
    return this.currentTimeline;
  }
  appendInstructionToTimeline(instruction, duration, delay) {
    const updatedTimings = {
      duration: duration != null ? duration : instruction.duration,
      delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,
      easing: ""
    };
    const builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
    this.timelines.push(builder);
    return updatedTimings;
  }
  incrementTime(time2) {
    this.currentTimeline.forwardTime(this.currentTimeline.duration + time2);
  }
  delayNextStep(delay) {
    if (delay > 0) {
      this.currentTimeline.delayNextStep(delay);
    }
  }
  invokeQuery(selector, originalSelector, limit, includeSelf, optional2, errors) {
    let results = [];
    if (includeSelf) {
      results.push(this.element);
    }
    if (selector.length > 0) {
      selector = selector.replace(ENTER_TOKEN_REGEX, "." + this._enterClassName);
      selector = selector.replace(LEAVE_TOKEN_REGEX, "." + this._leaveClassName);
      const multi = limit != 1;
      let elements = this._driver.query(this.element, selector, multi);
      if (limit !== 0) {
        elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) : elements.slice(0, limit);
      }
      results.push(...elements);
    }
    if (!optional2 && results.length == 0) {
      errors.push(invalidQuery(originalSelector));
    }
    return results;
  }
};
var TimelineBuilder = class _TimelineBuilder {
  _driver;
  element;
  startTime;
  _elementTimelineStylesLookup;
  duration = 0;
  easing = null;
  _previousKeyframe = /* @__PURE__ */ new Map();
  _currentKeyframe = /* @__PURE__ */ new Map();
  _keyframes = /* @__PURE__ */ new Map();
  _styleSummary = /* @__PURE__ */ new Map();
  _localTimelineStyles = /* @__PURE__ */ new Map();
  _globalTimelineStyles;
  _pendingStyles = /* @__PURE__ */ new Map();
  _backFill = /* @__PURE__ */ new Map();
  _currentEmptyStepKeyframe = null;
  constructor(_driver, element, startTime, _elementTimelineStylesLookup) {
    this._driver = _driver;
    this.element = element;
    this.startTime = startTime;
    this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
    if (!this._elementTimelineStylesLookup) {
      this._elementTimelineStylesLookup = /* @__PURE__ */ new Map();
    }
    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);
    if (!this._globalTimelineStyles) {
      this._globalTimelineStyles = this._localTimelineStyles;
      this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
    }
    this._loadKeyframe();
  }
  containsAnimation() {
    switch (this._keyframes.size) {
      case 0:
        return false;
      case 1:
        return this.hasCurrentStyleProperties();
      default:
        return true;
    }
  }
  hasCurrentStyleProperties() {
    return this._currentKeyframe.size > 0;
  }
  get currentTime() {
    return this.startTime + this.duration;
  }
  delayNextStep(delay) {
    const hasPreStyleStep = this._keyframes.size === 1 && this._pendingStyles.size;
    if (this.duration || hasPreStyleStep) {
      this.forwardTime(this.currentTime + delay);
      if (hasPreStyleStep) {
        this.snapshotCurrentStyles();
      }
    } else {
      this.startTime += delay;
    }
  }
  fork(element, currentTime) {
    this.applyStylesToKeyframe();
    return new _TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
  }
  _loadKeyframe() {
    if (this._currentKeyframe) {
      this._previousKeyframe = this._currentKeyframe;
    }
    this._currentKeyframe = this._keyframes.get(this.duration);
    if (!this._currentKeyframe) {
      this._currentKeyframe = /* @__PURE__ */ new Map();
      this._keyframes.set(this.duration, this._currentKeyframe);
    }
  }
  forwardFrame() {
    this.duration += ONE_FRAME_IN_MILLISECONDS;
    this._loadKeyframe();
  }
  forwardTime(time2) {
    this.applyStylesToKeyframe();
    this.duration = time2;
    this._loadKeyframe();
  }
  _updateStyle(prop, value2) {
    this._localTimelineStyles.set(prop, value2);
    this._globalTimelineStyles.set(prop, value2);
    this._styleSummary.set(prop, {
      time: this.currentTime,
      value: value2
    });
  }
  allowOnlyTimelineStyles() {
    return this._currentEmptyStepKeyframe !== this._currentKeyframe;
  }
  applyEmptyStep(easing) {
    if (easing) {
      this._previousKeyframe.set("easing", easing);
    }
    for (let [prop, value2] of this._globalTimelineStyles) {
      this._backFill.set(prop, value2 || AUTO_STYLE);
      this._currentKeyframe.set(prop, AUTO_STYLE);
    }
    this._currentEmptyStepKeyframe = this._currentKeyframe;
  }
  setStyles(input2, easing, errors, options) {
    if (easing) {
      this._previousKeyframe.set("easing", easing);
    }
    const params = options && options.params || {};
    const styles2 = flattenStyles(input2, this._globalTimelineStyles);
    for (let [prop, value2] of styles2) {
      const val = interpolateParams(value2, params, errors);
      this._pendingStyles.set(prop, val);
      if (!this._localTimelineStyles.has(prop)) {
        this._backFill.set(prop, this._globalTimelineStyles.get(prop) ?? AUTO_STYLE);
      }
      this._updateStyle(prop, val);
    }
  }
  applyStylesToKeyframe() {
    if (this._pendingStyles.size == 0) return;
    this._pendingStyles.forEach((val, prop) => {
      this._currentKeyframe.set(prop, val);
    });
    this._pendingStyles.clear();
    this._localTimelineStyles.forEach((val, prop) => {
      if (!this._currentKeyframe.has(prop)) {
        this._currentKeyframe.set(prop, val);
      }
    });
  }
  snapshotCurrentStyles() {
    for (let [prop, val] of this._localTimelineStyles) {
      this._pendingStyles.set(prop, val);
      this._updateStyle(prop, val);
    }
  }
  getFinalKeyframe() {
    return this._keyframes.get(this.duration);
  }
  get properties() {
    const properties = [];
    for (let prop in this._currentKeyframe) {
      properties.push(prop);
    }
    return properties;
  }
  mergeTimelineCollectedStyles(timeline) {
    timeline._styleSummary.forEach((details1, prop) => {
      const details0 = this._styleSummary.get(prop);
      if (!details0 || details1.time > details0.time) {
        this._updateStyle(prop, details1.value);
      }
    });
  }
  buildKeyframes() {
    this.applyStylesToKeyframe();
    const preStyleProps = /* @__PURE__ */ new Set();
    const postStyleProps = /* @__PURE__ */ new Set();
    const isEmpty = this._keyframes.size === 1 && this.duration === 0;
    let finalKeyframes = [];
    this._keyframes.forEach((keyframe, time2) => {
      const finalKeyframe = new Map([...this._backFill, ...keyframe]);
      finalKeyframe.forEach((value2, prop) => {
        if (value2 === \u0275PRE_STYLE) {
          preStyleProps.add(prop);
        } else if (value2 === AUTO_STYLE) {
          postStyleProps.add(prop);
        }
      });
      if (!isEmpty) {
        finalKeyframe.set("offset", time2 / this.duration);
      }
      finalKeyframes.push(finalKeyframe);
    });
    const preProps = [...preStyleProps.values()];
    const postProps = [...postStyleProps.values()];
    if (isEmpty) {
      const kf0 = finalKeyframes[0];
      const kf1 = new Map(kf0);
      kf0.set("offset", 0);
      kf1.set("offset", 1);
      finalKeyframes = [kf0, kf1];
    }
    return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
  }
};
var SubTimelineBuilder = class extends TimelineBuilder {
  keyframes;
  preStyleProps;
  postStyleProps;
  _stretchStartingKeyframe;
  timings;
  constructor(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe = false) {
    super(driver, element, timings.delay);
    this.keyframes = keyframes;
    this.preStyleProps = preStyleProps;
    this.postStyleProps = postStyleProps;
    this._stretchStartingKeyframe = _stretchStartingKeyframe;
    this.timings = {
      duration: timings.duration,
      delay: timings.delay,
      easing: timings.easing
    };
  }
  containsAnimation() {
    return this.keyframes.length > 1;
  }
  buildKeyframes() {
    let keyframes = this.keyframes;
    let {
      delay,
      duration,
      easing
    } = this.timings;
    if (this._stretchStartingKeyframe && delay) {
      const newKeyframes = [];
      const totalTime = duration + delay;
      const startingGap = delay / totalTime;
      const newFirstKeyframe = new Map(keyframes[0]);
      newFirstKeyframe.set("offset", 0);
      newKeyframes.push(newFirstKeyframe);
      const oldFirstKeyframe = new Map(keyframes[0]);
      oldFirstKeyframe.set("offset", roundOffset(startingGap));
      newKeyframes.push(oldFirstKeyframe);
      const limit = keyframes.length - 1;
      for (let i = 1; i <= limit; i++) {
        let kf = new Map(keyframes[i]);
        const oldOffset = kf.get("offset");
        const timeAtKeyframe = delay + oldOffset * duration;
        kf.set("offset", roundOffset(timeAtKeyframe / totalTime));
        newKeyframes.push(kf);
      }
      duration = totalTime;
      delay = 0;
      easing = "";
      keyframes = newKeyframes;
    }
    return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);
  }
};
function roundOffset(offset2, decimalPoints = 3) {
  const mult = Math.pow(10, decimalPoints - 1);
  return Math.round(offset2 * mult) / mult;
}
function flattenStyles(input2, allStyles) {
  const styles2 = /* @__PURE__ */ new Map();
  let allProperties;
  input2.forEach((token) => {
    if (token === "*") {
      allProperties ??= allStyles.keys();
      for (let prop of allProperties) {
        styles2.set(prop, AUTO_STYLE);
      }
    } else {
      for (let [prop, val] of token) {
        styles2.set(prop, val);
      }
    }
  });
  return styles2;
}
function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {
  return {
    type: 0,
    element,
    triggerName,
    isRemovalTransition,
    fromState,
    fromStyles,
    toState,
    toStyles,
    timelines,
    queriedElements,
    preStyleProps,
    postStyleProps,
    totalTime,
    errors
  };
}
var EMPTY_OBJECT = {};
var AnimationTransitionFactory = class {
  _triggerName;
  ast;
  _stateStyles;
  constructor(_triggerName, ast, _stateStyles) {
    this._triggerName = _triggerName;
    this.ast = ast;
    this._stateStyles = _stateStyles;
  }
  match(currentState, nextState, element, params) {
    return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);
  }
  buildStyles(stateName, params, errors) {
    let styler = this._stateStyles.get("*");
    if (stateName !== void 0) {
      styler = this._stateStyles.get(stateName?.toString()) || styler;
    }
    return styler ? styler.buildStyles(params, errors) : /* @__PURE__ */ new Map();
  }
  build(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {
    const errors = [];
    const transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;
    const currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;
    const currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);
    const nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;
    const nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);
    const queriedElements = /* @__PURE__ */ new Set();
    const preStyleMap = /* @__PURE__ */ new Map();
    const postStyleMap = /* @__PURE__ */ new Map();
    const isRemoval = nextState === "void";
    const animationOptions = {
      params: applyParamDefaults(nextAnimationParams, transitionAnimationParams),
      delay: this.ast.options?.delay
    };
    const timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
    let totalTime = 0;
    timelines.forEach((tl) => {
      totalTime = Math.max(tl.duration + tl.delay, totalTime);
    });
    if (errors.length) {
      return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);
    }
    timelines.forEach((tl) => {
      const elm = tl.element;
      const preProps = getOrSetDefaultValue(preStyleMap, elm, /* @__PURE__ */ new Set());
      tl.preStyleProps.forEach((prop) => preProps.add(prop));
      const postProps = getOrSetDefaultValue(postStyleMap, elm, /* @__PURE__ */ new Set());
      tl.postStyleProps.forEach((prop) => postProps.add(prop));
      if (elm !== element) {
        queriedElements.add(elm);
      }
    });
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      checkNonAnimatableInTimelines(timelines, this._triggerName, driver);
    }
    return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, [...queriedElements.values()], preStyleMap, postStyleMap, totalTime);
  }
};
function checkNonAnimatableInTimelines(timelines, triggerName, driver) {
  if (!driver.validateAnimatableStyleProperty) {
    return;
  }
  const allowedNonAnimatableProps = /* @__PURE__ */ new Set([
    // 'easing' is a utility/synthetic prop we use to represent
    // easing functions, it represents a property of the animation
    // which is not animatable but different values can be used
    // in different steps
    "easing"
  ]);
  const invalidNonAnimatableProps = /* @__PURE__ */ new Set();
  timelines.forEach(({
    keyframes
  }) => {
    const nonAnimatablePropsInitialValues = /* @__PURE__ */ new Map();
    keyframes.forEach((keyframe) => {
      const entriesToCheck = Array.from(keyframe.entries()).filter(([prop]) => !allowedNonAnimatableProps.has(prop));
      for (const [prop, value2] of entriesToCheck) {
        if (!driver.validateAnimatableStyleProperty(prop)) {
          if (nonAnimatablePropsInitialValues.has(prop) && !invalidNonAnimatableProps.has(prop)) {
            const propInitialValue = nonAnimatablePropsInitialValues.get(prop);
            if (propInitialValue !== value2) {
              invalidNonAnimatableProps.add(prop);
            }
          } else {
            nonAnimatablePropsInitialValues.set(prop, value2);
          }
        }
      }
    });
  });
  if (invalidNonAnimatableProps.size > 0) {
    console.warn(`Warning: The animation trigger "${triggerName}" is attempting to animate the following not animatable properties: ` + Array.from(invalidNonAnimatableProps).join(", ") + "\n(to check the list of all animatable properties visit https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties)");
  }
}
function oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {
  return matchFns.some((fn) => fn(currentState, nextState, element, params));
}
function applyParamDefaults(userParams, defaults) {
  const result = __spreadValues({}, defaults);
  Object.entries(userParams).forEach(([key, value2]) => {
    if (value2 != null) {
      result[key] = value2;
    }
  });
  return result;
}
var AnimationStateStyles = class {
  styles;
  defaultParams;
  normalizer;
  constructor(styles2, defaultParams, normalizer) {
    this.styles = styles2;
    this.defaultParams = defaultParams;
    this.normalizer = normalizer;
  }
  buildStyles(params, errors) {
    const finalStyles = /* @__PURE__ */ new Map();
    const combinedParams = applyParamDefaults(params, this.defaultParams);
    this.styles.styles.forEach((value2) => {
      if (typeof value2 !== "string") {
        value2.forEach((val, prop) => {
          if (val) {
            val = interpolateParams(val, combinedParams, errors);
          }
          const normalizedProp = this.normalizer.normalizePropertyName(prop, errors);
          val = this.normalizer.normalizeStyleValue(prop, normalizedProp, val, errors);
          finalStyles.set(prop, val);
        });
      }
    });
    return finalStyles;
  }
};
function buildTrigger(name, ast, normalizer) {
  return new AnimationTrigger(name, ast, normalizer);
}
var AnimationTrigger = class {
  name;
  ast;
  _normalizer;
  transitionFactories = [];
  fallbackTransition;
  states = /* @__PURE__ */ new Map();
  constructor(name, ast, _normalizer) {
    this.name = name;
    this.ast = ast;
    this._normalizer = _normalizer;
    ast.states.forEach((ast2) => {
      const defaultParams = ast2.options && ast2.options.params || {};
      this.states.set(ast2.name, new AnimationStateStyles(ast2.style, defaultParams, _normalizer));
    });
    balanceProperties(this.states, "true", "1");
    balanceProperties(this.states, "false", "0");
    ast.transitions.forEach((ast2) => {
      this.transitionFactories.push(new AnimationTransitionFactory(name, ast2, this.states));
    });
    this.fallbackTransition = createFallbackTransition(name, this.states, this._normalizer);
  }
  get containsQueries() {
    return this.ast.queryCount > 0;
  }
  matchTransition(currentState, nextState, element, params) {
    const entry = this.transitionFactories.find((f) => f.match(currentState, nextState, element, params));
    return entry || null;
  }
  matchStyles(currentState, params, errors) {
    return this.fallbackTransition.buildStyles(currentState, params, errors);
  }
};
function createFallbackTransition(triggerName, states, normalizer) {
  const matchers = [(fromState, toState) => true];
  const animation = {
    type: AnimationMetadataType.Sequence,
    steps: [],
    options: null
  };
  const transition3 = {
    type: AnimationMetadataType.Transition,
    animation,
    matchers,
    options: null,
    queryCount: 0,
    depCount: 0
  };
  return new AnimationTransitionFactory(triggerName, transition3, states);
}
function balanceProperties(stateMap, key1, key2) {
  if (stateMap.has(key1)) {
    if (!stateMap.has(key2)) {
      stateMap.set(key2, stateMap.get(key1));
    }
  } else if (stateMap.has(key2)) {
    stateMap.set(key1, stateMap.get(key2));
  }
}
var EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();
var TimelineAnimationEngine = class {
  bodyNode;
  _driver;
  _normalizer;
  _animations = /* @__PURE__ */ new Map();
  _playersById = /* @__PURE__ */ new Map();
  players = [];
  constructor(bodyNode, _driver, _normalizer) {
    this.bodyNode = bodyNode;
    this._driver = _driver;
    this._normalizer = _normalizer;
  }
  register(id3, metadata) {
    const errors = [];
    const warnings = [];
    const ast = buildAnimationAst(this._driver, metadata, errors, warnings);
    if (errors.length) {
      throw registerFailed(errors);
    } else {
      if (warnings.length) {
        warnRegister(warnings);
      }
      this._animations.set(id3, ast);
    }
  }
  _buildPlayer(i, preStyles, postStyles) {
    const element = i.element;
    const keyframes = normalizeKeyframes$1(this._normalizer, i.keyframes, preStyles, postStyles);
    return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], true);
  }
  create(id3, element, options = {}) {
    const errors = [];
    const ast = this._animations.get(id3);
    let instructions;
    const autoStylesMap = /* @__PURE__ */ new Map();
    if (ast) {
      instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), options, EMPTY_INSTRUCTION_MAP, errors);
      instructions.forEach((inst) => {
        const styles2 = getOrSetDefaultValue(autoStylesMap, inst.element, /* @__PURE__ */ new Map());
        inst.postStyleProps.forEach((prop) => styles2.set(prop, null));
      });
    } else {
      errors.push(missingOrDestroyedAnimation());
      instructions = [];
    }
    if (errors.length) {
      throw createAnimationFailed(errors);
    }
    autoStylesMap.forEach((styles2, element2) => {
      styles2.forEach((_, prop) => {
        styles2.set(prop, this._driver.computeStyle(element2, prop, AUTO_STYLE));
      });
    });
    const players = instructions.map((i) => {
      const styles2 = autoStylesMap.get(i.element);
      return this._buildPlayer(i, /* @__PURE__ */ new Map(), styles2);
    });
    const player = optimizeGroupPlayer(players);
    this._playersById.set(id3, player);
    player.onDestroy(() => this.destroy(id3));
    this.players.push(player);
    return player;
  }
  destroy(id3) {
    const player = this._getPlayer(id3);
    player.destroy();
    this._playersById.delete(id3);
    const index = this.players.indexOf(player);
    if (index >= 0) {
      this.players.splice(index, 1);
    }
  }
  _getPlayer(id3) {
    const player = this._playersById.get(id3);
    if (!player) {
      throw missingPlayer(id3);
    }
    return player;
  }
  listen(id3, element, eventName, callback) {
    const baseEvent = makeAnimationEvent(element, "", "", "");
    listenOnPlayer(this._getPlayer(id3), eventName, baseEvent, callback);
    return () => {
    };
  }
  command(id3, element, command, args) {
    if (command == "register") {
      this.register(id3, args[0]);
      return;
    }
    if (command == "create") {
      const options = args[0] || {};
      this.create(id3, element, options);
      return;
    }
    const player = this._getPlayer(id3);
    switch (command) {
      case "play":
        player.play();
        break;
      case "pause":
        player.pause();
        break;
      case "reset":
        player.reset();
        break;
      case "restart":
        player.restart();
        break;
      case "finish":
        player.finish();
        break;
      case "init":
        player.init();
        break;
      case "setPosition":
        player.setPosition(parseFloat(args[0]));
        break;
      case "destroy":
        this.destroy(id3);
        break;
    }
  }
};
var QUEUED_CLASSNAME = "ng-animate-queued";
var QUEUED_SELECTOR = ".ng-animate-queued";
var DISABLED_CLASSNAME = "ng-animate-disabled";
var DISABLED_SELECTOR = ".ng-animate-disabled";
var STAR_CLASSNAME = "ng-star-inserted";
var STAR_SELECTOR = ".ng-star-inserted";
var EMPTY_PLAYER_ARRAY = [];
var NULL_REMOVAL_STATE = {
  namespaceId: "",
  setForRemoval: false,
  setForMove: false,
  hasAnimation: false,
  removedBeforeQueried: false
};
var NULL_REMOVED_QUERIED_STATE = {
  namespaceId: "",
  setForMove: false,
  setForRemoval: false,
  hasAnimation: false,
  removedBeforeQueried: true
};
var REMOVAL_FLAG = "__ng_removed";
var StateValue = class {
  namespaceId;
  value;
  options;
  get params() {
    return this.options.params;
  }
  constructor(input2, namespaceId = "") {
    this.namespaceId = namespaceId;
    const isObj = input2 && input2.hasOwnProperty("value");
    const value2 = isObj ? input2["value"] : input2;
    this.value = normalizeTriggerValue(value2);
    if (isObj) {
      const _a = input2, {
        value: value3
      } = _a, options = __objRest(_a, [
        "value"
      ]);
      this.options = options;
    } else {
      this.options = {};
    }
    if (!this.options.params) {
      this.options.params = {};
    }
  }
  absorbOptions(options) {
    const newParams = options.params;
    if (newParams) {
      const oldParams = this.options.params;
      Object.keys(newParams).forEach((prop) => {
        if (oldParams[prop] == null) {
          oldParams[prop] = newParams[prop];
        }
      });
    }
  }
};
var VOID_VALUE = "void";
var DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);
var AnimationTransitionNamespace = class {
  id;
  hostElement;
  _engine;
  players = [];
  _triggers = /* @__PURE__ */ new Map();
  _queue = [];
  _elementListeners = /* @__PURE__ */ new Map();
  _hostClassName;
  constructor(id3, hostElement, _engine) {
    this.id = id3;
    this.hostElement = hostElement;
    this._engine = _engine;
    this._hostClassName = "ng-tns-" + id3;
    addClass(hostElement, this._hostClassName);
  }
  listen(element, name, phase, callback) {
    if (!this._triggers.has(name)) {
      throw missingTrigger(phase, name);
    }
    if (phase == null || phase.length == 0) {
      throw missingEvent(name);
    }
    if (!isTriggerEventValid(phase)) {
      throw unsupportedTriggerEvent(phase, name);
    }
    const listeners = getOrSetDefaultValue(this._elementListeners, element, []);
    const data = {
      name,
      phase,
      callback
    };
    listeners.push(data);
    const triggersWithStates = getOrSetDefaultValue(this._engine.statesByElement, element, /* @__PURE__ */ new Map());
    if (!triggersWithStates.has(name)) {
      addClass(element, NG_TRIGGER_CLASSNAME);
      addClass(element, NG_TRIGGER_CLASSNAME + "-" + name);
      triggersWithStates.set(name, DEFAULT_STATE_VALUE);
    }
    return () => {
      this._engine.afterFlush(() => {
        const index = listeners.indexOf(data);
        if (index >= 0) {
          listeners.splice(index, 1);
        }
        if (!this._triggers.has(name)) {
          triggersWithStates.delete(name);
        }
      });
    };
  }
  register(name, ast) {
    if (this._triggers.has(name)) {
      return false;
    } else {
      this._triggers.set(name, ast);
      return true;
    }
  }
  _getTrigger(name) {
    const trigger2 = this._triggers.get(name);
    if (!trigger2) {
      throw unregisteredTrigger(name);
    }
    return trigger2;
  }
  trigger(element, triggerName, value2, defaultToFallback = true) {
    const trigger2 = this._getTrigger(triggerName);
    const player = new TransitionAnimationPlayer(this.id, triggerName, element);
    let triggersWithStates = this._engine.statesByElement.get(element);
    if (!triggersWithStates) {
      addClass(element, NG_TRIGGER_CLASSNAME);
      addClass(element, NG_TRIGGER_CLASSNAME + "-" + triggerName);
      this._engine.statesByElement.set(element, triggersWithStates = /* @__PURE__ */ new Map());
    }
    let fromState = triggersWithStates.get(triggerName);
    const toState = new StateValue(value2, this.id);
    const isObj = value2 && value2.hasOwnProperty("value");
    if (!isObj && fromState) {
      toState.absorbOptions(fromState.options);
    }
    triggersWithStates.set(triggerName, toState);
    if (!fromState) {
      fromState = DEFAULT_STATE_VALUE;
    }
    const isRemoval = toState.value === VOID_VALUE;
    if (!isRemoval && fromState.value === toState.value) {
      if (!objEquals(fromState.params, toState.params)) {
        const errors = [];
        const fromStyles = trigger2.matchStyles(fromState.value, fromState.params, errors);
        const toStyles = trigger2.matchStyles(toState.value, toState.params, errors);
        if (errors.length) {
          this._engine.reportError(errors);
        } else {
          this._engine.afterFlush(() => {
            eraseStyles(element, fromStyles);
            setStyles(element, toStyles);
          });
        }
      }
      return;
    }
    const playersOnElement = getOrSetDefaultValue(this._engine.playersByElement, element, []);
    playersOnElement.forEach((player2) => {
      if (player2.namespaceId == this.id && player2.triggerName == triggerName && player2.queued) {
        player2.destroy();
      }
    });
    let transition3 = trigger2.matchTransition(fromState.value, toState.value, element, toState.params);
    let isFallbackTransition = false;
    if (!transition3) {
      if (!defaultToFallback) return;
      transition3 = trigger2.fallbackTransition;
      isFallbackTransition = true;
    }
    this._engine.totalQueuedPlayers++;
    this._queue.push({
      element,
      triggerName,
      transition: transition3,
      fromState,
      toState,
      player,
      isFallbackTransition
    });
    if (!isFallbackTransition) {
      addClass(element, QUEUED_CLASSNAME);
      player.onStart(() => {
        removeClass(element, QUEUED_CLASSNAME);
      });
    }
    player.onDone(() => {
      let index = this.players.indexOf(player);
      if (index >= 0) {
        this.players.splice(index, 1);
      }
      const players = this._engine.playersByElement.get(element);
      if (players) {
        let index2 = players.indexOf(player);
        if (index2 >= 0) {
          players.splice(index2, 1);
        }
      }
    });
    this.players.push(player);
    playersOnElement.push(player);
    return player;
  }
  deregister(name) {
    this._triggers.delete(name);
    this._engine.statesByElement.forEach((stateMap) => stateMap.delete(name));
    this._elementListeners.forEach((listeners, element) => {
      this._elementListeners.set(element, listeners.filter((entry) => {
        return entry.name != name;
      }));
    });
  }
  clearElementCache(element) {
    this._engine.statesByElement.delete(element);
    this._elementListeners.delete(element);
    const elementPlayers = this._engine.playersByElement.get(element);
    if (elementPlayers) {
      elementPlayers.forEach((player) => player.destroy());
      this._engine.playersByElement.delete(element);
    }
  }
  _signalRemovalForInnerTriggers(rootElement, context2) {
    const elements = this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true);
    elements.forEach((elm) => {
      if (elm[REMOVAL_FLAG]) return;
      const namespaces = this._engine.fetchNamespacesByElement(elm);
      if (namespaces.size) {
        namespaces.forEach((ns) => ns.triggerLeaveAnimation(elm, context2, false, true));
      } else {
        this.clearElementCache(elm);
      }
    });
    this._engine.afterFlushAnimationsDone(() => elements.forEach((elm) => this.clearElementCache(elm)));
  }
  triggerLeaveAnimation(element, context2, destroyAfterComplete, defaultToFallback) {
    const triggerStates = this._engine.statesByElement.get(element);
    const previousTriggersValues = /* @__PURE__ */ new Map();
    if (triggerStates) {
      const players = [];
      triggerStates.forEach((state2, triggerName) => {
        previousTriggersValues.set(triggerName, state2.value);
        if (this._triggers.has(triggerName)) {
          const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);
          if (player) {
            players.push(player);
          }
        }
      });
      if (players.length) {
        this._engine.markElementAsRemoved(this.id, element, true, context2, previousTriggersValues);
        if (destroyAfterComplete) {
          optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));
        }
        return true;
      }
    }
    return false;
  }
  prepareLeaveAnimationListeners(element) {
    const listeners = this._elementListeners.get(element);
    const elementStates = this._engine.statesByElement.get(element);
    if (listeners && elementStates) {
      const visitedTriggers = /* @__PURE__ */ new Set();
      listeners.forEach((listener2) => {
        const triggerName = listener2.name;
        if (visitedTriggers.has(triggerName)) return;
        visitedTriggers.add(triggerName);
        const trigger2 = this._triggers.get(triggerName);
        const transition3 = trigger2.fallbackTransition;
        const fromState = elementStates.get(triggerName) || DEFAULT_STATE_VALUE;
        const toState = new StateValue(VOID_VALUE);
        const player = new TransitionAnimationPlayer(this.id, triggerName, element);
        this._engine.totalQueuedPlayers++;
        this._queue.push({
          element,
          triggerName,
          transition: transition3,
          fromState,
          toState,
          player,
          isFallbackTransition: true
        });
      });
    }
  }
  removeNode(element, context2) {
    const engine = this._engine;
    if (element.childElementCount) {
      this._signalRemovalForInnerTriggers(element, context2);
    }
    if (this.triggerLeaveAnimation(element, context2, true)) return;
    let containsPotentialParentTransition = false;
    if (engine.totalAnimations) {
      const currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
      if (currentPlayers && currentPlayers.length) {
        containsPotentialParentTransition = true;
      } else {
        let parent = element;
        while (parent = parent.parentNode) {
          const triggers = engine.statesByElement.get(parent);
          if (triggers) {
            containsPotentialParentTransition = true;
            break;
          }
        }
      }
    }
    this.prepareLeaveAnimationListeners(element);
    if (containsPotentialParentTransition) {
      engine.markElementAsRemoved(this.id, element, false, context2);
    } else {
      const removalFlag = element[REMOVAL_FLAG];
      if (!removalFlag || removalFlag === NULL_REMOVAL_STATE) {
        engine.afterFlush(() => this.clearElementCache(element));
        engine.destroyInnerAnimations(element);
        engine._onRemovalComplete(element, context2);
      }
    }
  }
  insertNode(element, parent) {
    addClass(element, this._hostClassName);
  }
  drainQueuedTransitions(microtaskId) {
    const instructions = [];
    this._queue.forEach((entry) => {
      const player = entry.player;
      if (player.destroyed) return;
      const element = entry.element;
      const listeners = this._elementListeners.get(element);
      if (listeners) {
        listeners.forEach((listener2) => {
          if (listener2.name == entry.triggerName) {
            const baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
            baseEvent["_data"] = microtaskId;
            listenOnPlayer(entry.player, listener2.phase, baseEvent, listener2.callback);
          }
        });
      }
      if (player.markedForDestroy) {
        this._engine.afterFlush(() => {
          player.destroy();
        });
      } else {
        instructions.push(entry);
      }
    });
    this._queue = [];
    return instructions.sort((a, b) => {
      const d0 = a.transition.ast.depCount;
      const d1 = b.transition.ast.depCount;
      if (d0 == 0 || d1 == 0) {
        return d0 - d1;
      }
      return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
    });
  }
  destroy(context2) {
    this.players.forEach((p2) => p2.destroy());
    this._signalRemovalForInnerTriggers(this.hostElement, context2);
  }
};
var TransitionAnimationEngine = class {
  bodyNode;
  driver;
  _normalizer;
  players = [];
  newHostElements = /* @__PURE__ */ new Map();
  playersByElement = /* @__PURE__ */ new Map();
  playersByQueriedElement = /* @__PURE__ */ new Map();
  statesByElement = /* @__PURE__ */ new Map();
  disabledNodes = /* @__PURE__ */ new Set();
  totalAnimations = 0;
  totalQueuedPlayers = 0;
  _namespaceLookup = {};
  _namespaceList = [];
  _flushFns = [];
  _whenQuietFns = [];
  namespacesByHostElement = /* @__PURE__ */ new Map();
  collectedEnterElements = [];
  collectedLeaveElements = [];
  // this method is designed to be overridden by the code that uses this engine
  onRemovalComplete = (element, context2) => {
  };
  /** @internal */
  _onRemovalComplete(element, context2) {
    this.onRemovalComplete(element, context2);
  }
  constructor(bodyNode, driver, _normalizer) {
    this.bodyNode = bodyNode;
    this.driver = driver;
    this._normalizer = _normalizer;
  }
  get queuedPlayers() {
    const players = [];
    this._namespaceList.forEach((ns) => {
      ns.players.forEach((player) => {
        if (player.queued) {
          players.push(player);
        }
      });
    });
    return players;
  }
  createNamespace(namespaceId, hostElement) {
    const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
    if (this.bodyNode && this.driver.containsElement(this.bodyNode, hostElement)) {
      this._balanceNamespaceList(ns, hostElement);
    } else {
      this.newHostElements.set(hostElement, ns);
      this.collectEnterElement(hostElement);
    }
    return this._namespaceLookup[namespaceId] = ns;
  }
  _balanceNamespaceList(ns, hostElement) {
    const namespaceList = this._namespaceList;
    const namespacesByHostElement = this.namespacesByHostElement;
    const limit = namespaceList.length - 1;
    if (limit >= 0) {
      let found = false;
      let ancestor = this.driver.getParentElement(hostElement);
      while (ancestor) {
        const ancestorNs = namespacesByHostElement.get(ancestor);
        if (ancestorNs) {
          const index = namespaceList.indexOf(ancestorNs);
          namespaceList.splice(index + 1, 0, ns);
          found = true;
          break;
        }
        ancestor = this.driver.getParentElement(ancestor);
      }
      if (!found) {
        namespaceList.unshift(ns);
      }
    } else {
      namespaceList.push(ns);
    }
    namespacesByHostElement.set(hostElement, ns);
    return ns;
  }
  register(namespaceId, hostElement) {
    let ns = this._namespaceLookup[namespaceId];
    if (!ns) {
      ns = this.createNamespace(namespaceId, hostElement);
    }
    return ns;
  }
  registerTrigger(namespaceId, name, trigger2) {
    let ns = this._namespaceLookup[namespaceId];
    if (ns && ns.register(name, trigger2)) {
      this.totalAnimations++;
    }
  }
  destroy(namespaceId, context2) {
    if (!namespaceId) return;
    this.afterFlush(() => {
    });
    this.afterFlushAnimationsDone(() => {
      const ns = this._fetchNamespace(namespaceId);
      this.namespacesByHostElement.delete(ns.hostElement);
      const index = this._namespaceList.indexOf(ns);
      if (index >= 0) {
        this._namespaceList.splice(index, 1);
      }
      ns.destroy(context2);
      delete this._namespaceLookup[namespaceId];
    });
  }
  _fetchNamespace(id3) {
    return this._namespaceLookup[id3];
  }
  fetchNamespacesByElement(element) {
    const namespaces = /* @__PURE__ */ new Set();
    const elementStates = this.statesByElement.get(element);
    if (elementStates) {
      for (let stateValue of elementStates.values()) {
        if (stateValue.namespaceId) {
          const ns = this._fetchNamespace(stateValue.namespaceId);
          if (ns) {
            namespaces.add(ns);
          }
        }
      }
    }
    return namespaces;
  }
  trigger(namespaceId, element, name, value2) {
    if (isElementNode(element)) {
      const ns = this._fetchNamespace(namespaceId);
      if (ns) {
        ns.trigger(element, name, value2);
        return true;
      }
    }
    return false;
  }
  insertNode(namespaceId, element, parent, insertBefore) {
    if (!isElementNode(element)) return;
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) {
      details.setForRemoval = false;
      details.setForMove = true;
      const index = this.collectedLeaveElements.indexOf(element);
      if (index >= 0) {
        this.collectedLeaveElements.splice(index, 1);
      }
    }
    if (namespaceId) {
      const ns = this._fetchNamespace(namespaceId);
      if (ns) {
        ns.insertNode(element, parent);
      }
    }
    if (insertBefore) {
      this.collectEnterElement(element);
    }
  }
  collectEnterElement(element) {
    this.collectedEnterElements.push(element);
  }
  markElementAsDisabled(element, value2) {
    if (value2) {
      if (!this.disabledNodes.has(element)) {
        this.disabledNodes.add(element);
        addClass(element, DISABLED_CLASSNAME);
      }
    } else if (this.disabledNodes.has(element)) {
      this.disabledNodes.delete(element);
      removeClass(element, DISABLED_CLASSNAME);
    }
  }
  removeNode(namespaceId, element, context2) {
    if (isElementNode(element)) {
      const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
      if (ns) {
        ns.removeNode(element, context2);
      } else {
        this.markElementAsRemoved(namespaceId, element, false, context2);
      }
      const hostNS = this.namespacesByHostElement.get(element);
      if (hostNS && hostNS.id !== namespaceId) {
        hostNS.removeNode(element, context2);
      }
    } else {
      this._onRemovalComplete(element, context2);
    }
  }
  markElementAsRemoved(namespaceId, element, hasAnimation, context2, previousTriggersValues) {
    this.collectedLeaveElements.push(element);
    element[REMOVAL_FLAG] = {
      namespaceId,
      setForRemoval: context2,
      hasAnimation,
      removedBeforeQueried: false,
      previousTriggersValues
    };
  }
  listen(namespaceId, element, name, phase, callback) {
    if (isElementNode(element)) {
      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
    }
    return () => {
    };
  }
  _buildInstruction(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {
    return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);
  }
  destroyInnerAnimations(containerElement) {
    let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
    elements.forEach((element) => this.destroyActiveAnimationsForElement(element));
    if (this.playersByQueriedElement.size == 0) return;
    elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
    elements.forEach((element) => this.finishActiveQueriedAnimationOnElement(element));
  }
  destroyActiveAnimationsForElement(element) {
    const players = this.playersByElement.get(element);
    if (players) {
      players.forEach((player) => {
        if (player.queued) {
          player.markedForDestroy = true;
        } else {
          player.destroy();
        }
      });
    }
  }
  finishActiveQueriedAnimationOnElement(element) {
    const players = this.playersByQueriedElement.get(element);
    if (players) {
      players.forEach((player) => player.finish());
    }
  }
  whenRenderingDone() {
    return new Promise((resolve) => {
      if (this.players.length) {
        return optimizeGroupPlayer(this.players).onDone(() => resolve());
      } else {
        resolve();
      }
    });
  }
  processLeaveNode(element) {
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) {
      element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;
      if (details.namespaceId) {
        this.destroyInnerAnimations(element);
        const ns = this._fetchNamespace(details.namespaceId);
        if (ns) {
          ns.clearElementCache(element);
        }
      }
      this._onRemovalComplete(element, details.setForRemoval);
    }
    if (element.classList?.contains(DISABLED_CLASSNAME)) {
      this.markElementAsDisabled(element, false);
    }
    this.driver.query(element, DISABLED_SELECTOR, true).forEach((node) => {
      this.markElementAsDisabled(node, false);
    });
  }
  flush(microtaskId = -1) {
    let players = [];
    if (this.newHostElements.size) {
      this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));
      this.newHostElements.clear();
    }
    if (this.totalAnimations && this.collectedEnterElements.length) {
      for (let i = 0; i < this.collectedEnterElements.length; i++) {
        const elm = this.collectedEnterElements[i];
        addClass(elm, STAR_CLASSNAME);
      }
    }
    if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
      const cleanupFns = [];
      try {
        players = this._flushAnimations(cleanupFns, microtaskId);
      } finally {
        for (let i = 0; i < cleanupFns.length; i++) {
          cleanupFns[i]();
        }
      }
    } else {
      for (let i = 0; i < this.collectedLeaveElements.length; i++) {
        const element = this.collectedLeaveElements[i];
        this.processLeaveNode(element);
      }
    }
    this.totalQueuedPlayers = 0;
    this.collectedEnterElements.length = 0;
    this.collectedLeaveElements.length = 0;
    this._flushFns.forEach((fn) => fn());
    this._flushFns = [];
    if (this._whenQuietFns.length) {
      const quietFns = this._whenQuietFns;
      this._whenQuietFns = [];
      if (players.length) {
        optimizeGroupPlayer(players).onDone(() => {
          quietFns.forEach((fn) => fn());
        });
      } else {
        quietFns.forEach((fn) => fn());
      }
    }
  }
  reportError(errors) {
    throw triggerTransitionsFailed(errors);
  }
  _flushAnimations(cleanupFns, microtaskId) {
    const subTimelines = new ElementInstructionMap();
    const skippedPlayers = [];
    const skippedPlayersMap = /* @__PURE__ */ new Map();
    const queuedInstructions = [];
    const queriedElements = /* @__PURE__ */ new Map();
    const allPreStyleElements = /* @__PURE__ */ new Map();
    const allPostStyleElements = /* @__PURE__ */ new Map();
    const disabledElementsSet = /* @__PURE__ */ new Set();
    this.disabledNodes.forEach((node) => {
      disabledElementsSet.add(node);
      const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);
      for (let i2 = 0; i2 < nodesThatAreDisabled.length; i2++) {
        disabledElementsSet.add(nodesThatAreDisabled[i2]);
      }
    });
    const bodyNode = this.bodyNode;
    const allTriggerElements = Array.from(this.statesByElement.keys());
    const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);
    const enterNodeMapIds = /* @__PURE__ */ new Map();
    let i = 0;
    enterNodeMap.forEach((nodes, root3) => {
      const className = ENTER_CLASSNAME + i++;
      enterNodeMapIds.set(root3, className);
      nodes.forEach((node) => addClass(node, className));
    });
    const allLeaveNodes = [];
    const mergedLeaveNodes = /* @__PURE__ */ new Set();
    const leaveNodesWithoutAnimations = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < this.collectedLeaveElements.length; i2++) {
      const element = this.collectedLeaveElements[i2];
      const details = element[REMOVAL_FLAG];
      if (details && details.setForRemoval) {
        allLeaveNodes.push(element);
        mergedLeaveNodes.add(element);
        if (details.hasAnimation) {
          this.driver.query(element, STAR_SELECTOR, true).forEach((elm) => mergedLeaveNodes.add(elm));
        } else {
          leaveNodesWithoutAnimations.add(element);
        }
      }
    }
    const leaveNodeMapIds = /* @__PURE__ */ new Map();
    const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));
    leaveNodeMap.forEach((nodes, root3) => {
      const className = LEAVE_CLASSNAME + i++;
      leaveNodeMapIds.set(root3, className);
      nodes.forEach((node) => addClass(node, className));
    });
    cleanupFns.push(() => {
      enterNodeMap.forEach((nodes, root3) => {
        const className = enterNodeMapIds.get(root3);
        nodes.forEach((node) => removeClass(node, className));
      });
      leaveNodeMap.forEach((nodes, root3) => {
        const className = leaveNodeMapIds.get(root3);
        nodes.forEach((node) => removeClass(node, className));
      });
      allLeaveNodes.forEach((element) => {
        this.processLeaveNode(element);
      });
    });
    const allPlayers = [];
    const erroneousTransitions = [];
    for (let i2 = this._namespaceList.length - 1; i2 >= 0; i2--) {
      const ns = this._namespaceList[i2];
      ns.drainQueuedTransitions(microtaskId).forEach((entry) => {
        const player = entry.player;
        const element = entry.element;
        allPlayers.push(player);
        if (this.collectedEnterElements.length) {
          const details = element[REMOVAL_FLAG];
          if (details && details.setForMove) {
            if (details.previousTriggersValues && details.previousTriggersValues.has(entry.triggerName)) {
              const previousValue = details.previousTriggersValues.get(entry.triggerName);
              const triggersWithStates = this.statesByElement.get(entry.element);
              if (triggersWithStates && triggersWithStates.has(entry.triggerName)) {
                const state2 = triggersWithStates.get(entry.triggerName);
                state2.value = previousValue;
                triggersWithStates.set(entry.triggerName, state2);
              }
            }
            player.destroy();
            return;
          }
        }
        const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);
        const leaveClassName = leaveNodeMapIds.get(element);
        const enterClassName = enterNodeMapIds.get(element);
        const instruction = this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);
        if (instruction.errors && instruction.errors.length) {
          erroneousTransitions.push(instruction);
          return;
        }
        if (nodeIsOrphaned) {
          player.onStart(() => eraseStyles(element, instruction.fromStyles));
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          skippedPlayers.push(player);
          return;
        }
        if (entry.isFallbackTransition) {
          player.onStart(() => eraseStyles(element, instruction.fromStyles));
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          skippedPlayers.push(player);
          return;
        }
        const timelines = [];
        instruction.timelines.forEach((tl) => {
          tl.stretchStartingKeyframe = true;
          if (!this.disabledNodes.has(tl.element)) {
            timelines.push(tl);
          }
        });
        instruction.timelines = timelines;
        subTimelines.append(element, instruction.timelines);
        const tuple = {
          instruction,
          player,
          element
        };
        queuedInstructions.push(tuple);
        instruction.queriedElements.forEach((element2) => getOrSetDefaultValue(queriedElements, element2, []).push(player));
        instruction.preStyleProps.forEach((stringMap, element2) => {
          if (stringMap.size) {
            let setVal = allPreStyleElements.get(element2);
            if (!setVal) {
              allPreStyleElements.set(element2, setVal = /* @__PURE__ */ new Set());
            }
            stringMap.forEach((_, prop) => setVal.add(prop));
          }
        });
        instruction.postStyleProps.forEach((stringMap, element2) => {
          let setVal = allPostStyleElements.get(element2);
          if (!setVal) {
            allPostStyleElements.set(element2, setVal = /* @__PURE__ */ new Set());
          }
          stringMap.forEach((_, prop) => setVal.add(prop));
        });
      });
    }
    if (erroneousTransitions.length) {
      const errors = [];
      erroneousTransitions.forEach((instruction) => {
        errors.push(transitionFailed(instruction.triggerName, instruction.errors));
      });
      allPlayers.forEach((player) => player.destroy());
      this.reportError(errors);
    }
    const allPreviousPlayersMap = /* @__PURE__ */ new Map();
    const animationElementMap = /* @__PURE__ */ new Map();
    queuedInstructions.forEach((entry) => {
      const element = entry.element;
      if (subTimelines.has(element)) {
        animationElementMap.set(element, element);
        this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
      }
    });
    skippedPlayers.forEach((player) => {
      const element = player.element;
      const previousPlayers = this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);
      previousPlayers.forEach((prevPlayer) => {
        getOrSetDefaultValue(allPreviousPlayersMap, element, []).push(prevPlayer);
        prevPlayer.destroy();
      });
    });
    const replaceNodes = allLeaveNodes.filter((node) => {
      return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
    });
    const postStylesMap = /* @__PURE__ */ new Map();
    const allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, AUTO_STYLE);
    allLeaveQueriedNodes.forEach((node) => {
      if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {
        replaceNodes.push(node);
      }
    });
    const preStylesMap = /* @__PURE__ */ new Map();
    enterNodeMap.forEach((nodes, root3) => {
      cloakAndComputeStyles(preStylesMap, this.driver, new Set(nodes), allPreStyleElements, \u0275PRE_STYLE);
    });
    replaceNodes.forEach((node) => {
      const post = postStylesMap.get(node);
      const pre = preStylesMap.get(node);
      postStylesMap.set(node, new Map([...post?.entries() ?? [], ...pre?.entries() ?? []]));
    });
    const rootPlayers = [];
    const subPlayers = [];
    const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};
    queuedInstructions.forEach((entry) => {
      const {
        element,
        player,
        instruction
      } = entry;
      if (subTimelines.has(element)) {
        if (disabledElementsSet.has(element)) {
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          player.disabled = true;
          player.overrideTotalTime(instruction.totalTime);
          skippedPlayers.push(player);
          return;
        }
        let parentWithAnimation = NO_PARENT_ANIMATION_ELEMENT_DETECTED;
        if (animationElementMap.size > 1) {
          let elm = element;
          const parentsToAdd = [];
          while (elm = elm.parentNode) {
            const detectedParent = animationElementMap.get(elm);
            if (detectedParent) {
              parentWithAnimation = detectedParent;
              break;
            }
            parentsToAdd.push(elm);
          }
          parentsToAdd.forEach((parent) => animationElementMap.set(parent, parentWithAnimation));
        }
        const innerPlayer = this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
        player.setRealPlayer(innerPlayer);
        if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {
          rootPlayers.push(player);
        } else {
          const parentPlayers = this.playersByElement.get(parentWithAnimation);
          if (parentPlayers && parentPlayers.length) {
            player.parentPlayer = optimizeGroupPlayer(parentPlayers);
          }
          skippedPlayers.push(player);
        }
      } else {
        eraseStyles(element, instruction.fromStyles);
        player.onDestroy(() => setStyles(element, instruction.toStyles));
        subPlayers.push(player);
        if (disabledElementsSet.has(element)) {
          skippedPlayers.push(player);
        }
      }
    });
    subPlayers.forEach((player) => {
      const playersForElement = skippedPlayersMap.get(player.element);
      if (playersForElement && playersForElement.length) {
        const innerPlayer = optimizeGroupPlayer(playersForElement);
        player.setRealPlayer(innerPlayer);
      }
    });
    skippedPlayers.forEach((player) => {
      if (player.parentPlayer) {
        player.syncPlayerEvents(player.parentPlayer);
      } else {
        player.destroy();
      }
    });
    for (let i2 = 0; i2 < allLeaveNodes.length; i2++) {
      const element = allLeaveNodes[i2];
      const details = element[REMOVAL_FLAG];
      removeClass(element, LEAVE_CLASSNAME);
      if (details && details.hasAnimation) continue;
      let players = [];
      if (queriedElements.size) {
        let queriedPlayerResults = queriedElements.get(element);
        if (queriedPlayerResults && queriedPlayerResults.length) {
          players.push(...queriedPlayerResults);
        }
        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);
        for (let j = 0; j < queriedInnerElements.length; j++) {
          let queriedPlayers = queriedElements.get(queriedInnerElements[j]);
          if (queriedPlayers && queriedPlayers.length) {
            players.push(...queriedPlayers);
          }
        }
      }
      const activePlayers = players.filter((p2) => !p2.destroyed);
      if (activePlayers.length) {
        removeNodesAfterAnimationDone(this, element, activePlayers);
      } else {
        this.processLeaveNode(element);
      }
    }
    allLeaveNodes.length = 0;
    rootPlayers.forEach((player) => {
      this.players.push(player);
      player.onDone(() => {
        player.destroy();
        const index = this.players.indexOf(player);
        this.players.splice(index, 1);
      });
      player.play();
    });
    return rootPlayers;
  }
  afterFlush(callback) {
    this._flushFns.push(callback);
  }
  afterFlushAnimationsDone(callback) {
    this._whenQuietFns.push(callback);
  }
  _getPreviousPlayers(element, isQueriedElement, namespaceId, triggerName, toStateValue) {
    let players = [];
    if (isQueriedElement) {
      const queriedElementPlayers = this.playersByQueriedElement.get(element);
      if (queriedElementPlayers) {
        players = queriedElementPlayers;
      }
    } else {
      const elementPlayers = this.playersByElement.get(element);
      if (elementPlayers) {
        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;
        elementPlayers.forEach((player) => {
          if (player.queued) return;
          if (!isRemovalAnimation && player.triggerName != triggerName) return;
          players.push(player);
        });
      }
    }
    if (namespaceId || triggerName) {
      players = players.filter((player) => {
        if (namespaceId && namespaceId != player.namespaceId) return false;
        if (triggerName && triggerName != player.triggerName) return false;
        return true;
      });
    }
    return players;
  }
  _beforeAnimationBuild(namespaceId, instruction, allPreviousPlayersMap) {
    const triggerName = instruction.triggerName;
    const rootElement = instruction.element;
    const targetNameSpaceId = instruction.isRemovalTransition ? void 0 : namespaceId;
    const targetTriggerName = instruction.isRemovalTransition ? void 0 : triggerName;
    for (const timelineInstruction of instruction.timelines) {
      const element = timelineInstruction.element;
      const isQueriedElement = element !== rootElement;
      const players = getOrSetDefaultValue(allPreviousPlayersMap, element, []);
      const previousPlayers = this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);
      previousPlayers.forEach((player) => {
        const realPlayer = player.getRealPlayer();
        if (realPlayer.beforeDestroy) {
          realPlayer.beforeDestroy();
        }
        player.destroy();
        players.push(player);
      });
    }
    eraseStyles(rootElement, instruction.fromStyles);
  }
  _buildAnimation(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
    const triggerName = instruction.triggerName;
    const rootElement = instruction.element;
    const allQueriedPlayers = [];
    const allConsumedElements = /* @__PURE__ */ new Set();
    const allSubElements = /* @__PURE__ */ new Set();
    const allNewPlayers = instruction.timelines.map((timelineInstruction) => {
      const element = timelineInstruction.element;
      allConsumedElements.add(element);
      const details = element[REMOVAL_FLAG];
      if (details && details.removedBeforeQueried) return new NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);
      const isQueriedElement = element !== rootElement;
      const previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map((p2) => p2.getRealPlayer())).filter((p2) => {
        const pp = p2;
        return pp.element ? pp.element === element : false;
      });
      const preStyles = preStylesMap.get(element);
      const postStyles = postStylesMap.get(element);
      const keyframes = normalizeKeyframes$1(this._normalizer, timelineInstruction.keyframes, preStyles, postStyles);
      const player2 = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);
      if (timelineInstruction.subTimeline && skippedPlayersMap) {
        allSubElements.add(element);
      }
      if (isQueriedElement) {
        const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
        wrappedPlayer.setRealPlayer(player2);
        allQueriedPlayers.push(wrappedPlayer);
      }
      return player2;
    });
    allQueriedPlayers.forEach((player2) => {
      getOrSetDefaultValue(this.playersByQueriedElement, player2.element, []).push(player2);
      player2.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player2.element, player2));
    });
    allConsumedElements.forEach((element) => addClass(element, NG_ANIMATING_CLASSNAME));
    const player = optimizeGroupPlayer(allNewPlayers);
    player.onDestroy(() => {
      allConsumedElements.forEach((element) => removeClass(element, NG_ANIMATING_CLASSNAME));
      setStyles(rootElement, instruction.toStyles);
    });
    allSubElements.forEach((element) => {
      getOrSetDefaultValue(skippedPlayersMap, element, []).push(player);
    });
    return player;
  }
  _buildPlayer(instruction, keyframes, previousPlayers) {
    if (keyframes.length > 0) {
      return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
    }
    return new NoopAnimationPlayer(instruction.duration, instruction.delay);
  }
};
var TransitionAnimationPlayer = class {
  namespaceId;
  triggerName;
  element;
  _player = new NoopAnimationPlayer();
  _containsRealPlayer = false;
  _queuedCallbacks = /* @__PURE__ */ new Map();
  destroyed = false;
  parentPlayer = null;
  markedForDestroy = false;
  disabled = false;
  queued = true;
  totalTime = 0;
  constructor(namespaceId, triggerName, element) {
    this.namespaceId = namespaceId;
    this.triggerName = triggerName;
    this.element = element;
  }
  setRealPlayer(player) {
    if (this._containsRealPlayer) return;
    this._player = player;
    this._queuedCallbacks.forEach((callbacks, phase) => {
      callbacks.forEach((callback) => listenOnPlayer(player, phase, void 0, callback));
    });
    this._queuedCallbacks.clear();
    this._containsRealPlayer = true;
    this.overrideTotalTime(player.totalTime);
    this.queued = false;
  }
  getRealPlayer() {
    return this._player;
  }
  overrideTotalTime(totalTime) {
    this.totalTime = totalTime;
  }
  syncPlayerEvents(player) {
    const p2 = this._player;
    if (p2.triggerCallback) {
      player.onStart(() => p2.triggerCallback("start"));
    }
    player.onDone(() => this.finish());
    player.onDestroy(() => this.destroy());
  }
  _queueEvent(name, callback) {
    getOrSetDefaultValue(this._queuedCallbacks, name, []).push(callback);
  }
  onDone(fn) {
    if (this.queued) {
      this._queueEvent("done", fn);
    }
    this._player.onDone(fn);
  }
  onStart(fn) {
    if (this.queued) {
      this._queueEvent("start", fn);
    }
    this._player.onStart(fn);
  }
  onDestroy(fn) {
    if (this.queued) {
      this._queueEvent("destroy", fn);
    }
    this._player.onDestroy(fn);
  }
  init() {
    this._player.init();
  }
  hasStarted() {
    return this.queued ? false : this._player.hasStarted();
  }
  play() {
    !this.queued && this._player.play();
  }
  pause() {
    !this.queued && this._player.pause();
  }
  restart() {
    !this.queued && this._player.restart();
  }
  finish() {
    this._player.finish();
  }
  destroy() {
    this.destroyed = true;
    this._player.destroy();
  }
  reset() {
    !this.queued && this._player.reset();
  }
  setPosition(p2) {
    if (!this.queued) {
      this._player.setPosition(p2);
    }
  }
  getPosition() {
    return this.queued ? 0 : this._player.getPosition();
  }
  /** @internal */
  triggerCallback(phaseName) {
    const p2 = this._player;
    if (p2.triggerCallback) {
      p2.triggerCallback(phaseName);
    }
  }
};
function deleteOrUnsetInMap(map3, key, value2) {
  let currentValues = map3.get(key);
  if (currentValues) {
    if (currentValues.length) {
      const index = currentValues.indexOf(value2);
      currentValues.splice(index, 1);
    }
    if (currentValues.length == 0) {
      map3.delete(key);
    }
  }
  return currentValues;
}
function normalizeTriggerValue(value2) {
  return value2 != null ? value2 : null;
}
function isElementNode(node) {
  return node && node["nodeType"] === 1;
}
function isTriggerEventValid(eventName) {
  return eventName == "start" || eventName == "done";
}
function cloakElement(element, value2) {
  const oldValue = element.style.display;
  element.style.display = value2 != null ? value2 : "none";
  return oldValue;
}
function cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {
  const cloakVals = [];
  elements.forEach((element) => cloakVals.push(cloakElement(element)));
  const failedElements = [];
  elementPropsMap.forEach((props, element) => {
    const styles2 = /* @__PURE__ */ new Map();
    props.forEach((prop) => {
      const value2 = driver.computeStyle(element, prop, defaultStyle);
      styles2.set(prop, value2);
      if (!value2 || value2.length == 0) {
        element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
        failedElements.push(element);
      }
    });
    valuesMap.set(element, styles2);
  });
  let i = 0;
  elements.forEach((element) => cloakElement(element, cloakVals[i++]));
  return failedElements;
}
function buildRootMap(roots, nodes) {
  const rootMap = /* @__PURE__ */ new Map();
  roots.forEach((root3) => rootMap.set(root3, []));
  if (nodes.length == 0) return rootMap;
  const NULL_NODE = 1;
  const nodeSet = new Set(nodes);
  const localRootMap = /* @__PURE__ */ new Map();
  function getRoot(node) {
    if (!node) return NULL_NODE;
    let root3 = localRootMap.get(node);
    if (root3) return root3;
    const parent = node.parentNode;
    if (rootMap.has(parent)) {
      root3 = parent;
    } else if (nodeSet.has(parent)) {
      root3 = NULL_NODE;
    } else {
      root3 = getRoot(parent);
    }
    localRootMap.set(node, root3);
    return root3;
  }
  nodes.forEach((node) => {
    const root3 = getRoot(node);
    if (root3 !== NULL_NODE) {
      rootMap.get(root3).push(node);
    }
  });
  return rootMap;
}
function addClass(element, className) {
  element.classList?.add(className);
}
function removeClass(element, className) {
  element.classList?.remove(className);
}
function removeNodesAfterAnimationDone(engine, element, players) {
  optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));
}
function flattenGroupPlayers(players) {
  const finalPlayers = [];
  _flattenGroupPlayersRecur(players, finalPlayers);
  return finalPlayers;
}
function _flattenGroupPlayersRecur(players, finalPlayers) {
  for (let i = 0; i < players.length; i++) {
    const player = players[i];
    if (player instanceof AnimationGroupPlayer) {
      _flattenGroupPlayersRecur(player.players, finalPlayers);
    } else {
      finalPlayers.push(player);
    }
  }
}
function objEquals(a, b) {
  const k1 = Object.keys(a);
  const k2 = Object.keys(b);
  if (k1.length != k2.length) return false;
  for (let i = 0; i < k1.length; i++) {
    const prop = k1[i];
    if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;
  }
  return true;
}
function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
  const postEntry = allPostStyleElements.get(element);
  if (!postEntry) return false;
  let preEntry = allPreStyleElements.get(element);
  if (preEntry) {
    postEntry.forEach((data) => preEntry.add(data));
  } else {
    allPreStyleElements.set(element, postEntry);
  }
  allPostStyleElements.delete(element);
  return true;
}
var AnimationEngine = class {
  _driver;
  _normalizer;
  _transitionEngine;
  _timelineEngine;
  _triggerCache = {};
  // this method is designed to be overridden by the code that uses this engine
  onRemovalComplete = (element, context2) => {
  };
  constructor(doc, _driver, _normalizer) {
    this._driver = _driver;
    this._normalizer = _normalizer;
    this._transitionEngine = new TransitionAnimationEngine(doc.body, _driver, _normalizer);
    this._timelineEngine = new TimelineAnimationEngine(doc.body, _driver, _normalizer);
    this._transitionEngine.onRemovalComplete = (element, context2) => this.onRemovalComplete(element, context2);
  }
  registerTrigger(componentId, namespaceId, hostElement, name, metadata) {
    const cacheKey = componentId + "-" + name;
    let trigger2 = this._triggerCache[cacheKey];
    if (!trigger2) {
      const errors = [];
      const warnings = [];
      const ast = buildAnimationAst(this._driver, metadata, errors, warnings);
      if (errors.length) {
        throw triggerBuildFailed(name, errors);
      }
      if (warnings.length) {
        warnTriggerBuild(name, warnings);
      }
      trigger2 = buildTrigger(name, ast, this._normalizer);
      this._triggerCache[cacheKey] = trigger2;
    }
    this._transitionEngine.registerTrigger(namespaceId, name, trigger2);
  }
  register(namespaceId, hostElement) {
    this._transitionEngine.register(namespaceId, hostElement);
  }
  destroy(namespaceId, context2) {
    this._transitionEngine.destroy(namespaceId, context2);
  }
  onInsert(namespaceId, element, parent, insertBefore) {
    this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
  }
  onRemove(namespaceId, element, context2) {
    this._transitionEngine.removeNode(namespaceId, element, context2);
  }
  disableAnimations(element, disable) {
    this._transitionEngine.markElementAsDisabled(element, disable);
  }
  process(namespaceId, element, property, value2) {
    if (property.charAt(0) == "@") {
      const [id3, action] = parseTimelineCommand(property);
      const args = value2;
      this._timelineEngine.command(id3, element, action, args);
    } else {
      this._transitionEngine.trigger(namespaceId, element, property, value2);
    }
  }
  listen(namespaceId, element, eventName, eventPhase, callback) {
    if (eventName.charAt(0) == "@") {
      const [id3, action] = parseTimelineCommand(eventName);
      return this._timelineEngine.listen(id3, element, action, callback);
    }
    return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
  }
  flush(microtaskId = -1) {
    this._transitionEngine.flush(microtaskId);
  }
  get players() {
    return [...this._transitionEngine.players, ...this._timelineEngine.players];
  }
  whenRenderingDone() {
    return this._transitionEngine.whenRenderingDone();
  }
  afterFlushAnimationsDone(cb) {
    this._transitionEngine.afterFlushAnimationsDone(cb);
  }
};
function packageNonAnimatableStyles(element, styles2) {
  let startStyles = null;
  let endStyles = null;
  if (Array.isArray(styles2) && styles2.length) {
    startStyles = filterNonAnimatableStyles(styles2[0]);
    if (styles2.length > 1) {
      endStyles = filterNonAnimatableStyles(styles2[styles2.length - 1]);
    }
  } else if (styles2 instanceof Map) {
    startStyles = filterNonAnimatableStyles(styles2);
  }
  return startStyles || endStyles ? new SpecialCasedStyles(element, startStyles, endStyles) : null;
}
var SpecialCasedStyles = class _SpecialCasedStyles {
  _element;
  _startStyles;
  _endStyles;
  static initialStylesByElement = /* @__PURE__ */ new WeakMap();
  _state = 0;
  _initialStyles;
  constructor(_element, _startStyles, _endStyles) {
    this._element = _element;
    this._startStyles = _startStyles;
    this._endStyles = _endStyles;
    let initialStyles = _SpecialCasedStyles.initialStylesByElement.get(_element);
    if (!initialStyles) {
      _SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = /* @__PURE__ */ new Map());
    }
    this._initialStyles = initialStyles;
  }
  start() {
    if (this._state < 1) {
      if (this._startStyles) {
        setStyles(this._element, this._startStyles, this._initialStyles);
      }
      this._state = 1;
    }
  }
  finish() {
    this.start();
    if (this._state < 2) {
      setStyles(this._element, this._initialStyles);
      if (this._endStyles) {
        setStyles(this._element, this._endStyles);
        this._endStyles = null;
      }
      this._state = 1;
    }
  }
  destroy() {
    this.finish();
    if (this._state < 3) {
      _SpecialCasedStyles.initialStylesByElement.delete(this._element);
      if (this._startStyles) {
        eraseStyles(this._element, this._startStyles);
        this._endStyles = null;
      }
      if (this._endStyles) {
        eraseStyles(this._element, this._endStyles);
        this._endStyles = null;
      }
      setStyles(this._element, this._initialStyles);
      this._state = 3;
    }
  }
};
function filterNonAnimatableStyles(styles2) {
  let result = null;
  styles2.forEach((val, prop) => {
    if (isNonAnimatableStyle(prop)) {
      result = result || /* @__PURE__ */ new Map();
      result.set(prop, val);
    }
  });
  return result;
}
function isNonAnimatableStyle(prop) {
  return prop === "display" || prop === "position";
}
var WebAnimationsPlayer = class {
  element;
  keyframes;
  options;
  _specialStyles;
  _onDoneFns = [];
  _onStartFns = [];
  _onDestroyFns = [];
  _duration;
  _delay;
  _initialized = false;
  _finished = false;
  _started = false;
  _destroyed = false;
  _finalKeyframe;
  // the following original fns are persistent copies of the _onStartFns and _onDoneFns
  // and are used to reset the fns to their original values upon reset()
  // (since the _onStartFns and _onDoneFns get deleted after they are called)
  _originalOnDoneFns = [];
  _originalOnStartFns = [];
  // using non-null assertion because it's re(set) by init();
  domPlayer;
  time = 0;
  parentPlayer = null;
  currentSnapshot = /* @__PURE__ */ new Map();
  constructor(element, keyframes, options, _specialStyles) {
    this.element = element;
    this.keyframes = keyframes;
    this.options = options;
    this._specialStyles = _specialStyles;
    this._duration = options["duration"];
    this._delay = options["delay"] || 0;
    this.time = this._duration + this._delay;
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach((fn) => fn());
      this._onDoneFns = [];
    }
  }
  init() {
    this._buildPlayer();
    this._preparePlayerBeforeStart();
  }
  _buildPlayer() {
    if (this._initialized) return;
    this._initialized = true;
    const keyframes = this.keyframes;
    this.domPlayer = this._triggerWebAnimation(this.element, keyframes, this.options);
    this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : /* @__PURE__ */ new Map();
    const onFinish = () => this._onFinish();
    this.domPlayer.addEventListener("finish", onFinish);
    this.onDestroy(() => {
      this.domPlayer.removeEventListener("finish", onFinish);
    });
  }
  _preparePlayerBeforeStart() {
    if (this._delay) {
      this._resetDomPlayerState();
    } else {
      this.domPlayer.pause();
    }
  }
  _convertKeyframesToObject(keyframes) {
    const kfs = [];
    keyframes.forEach((frame2) => {
      kfs.push(Object.fromEntries(frame2));
    });
    return kfs;
  }
  /** @internal */
  _triggerWebAnimation(element, keyframes, options) {
    return element.animate(this._convertKeyframesToObject(keyframes), options);
  }
  onStart(fn) {
    this._originalOnStartFns.push(fn);
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._originalOnDoneFns.push(fn);
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  play() {
    this._buildPlayer();
    if (!this.hasStarted()) {
      this._onStartFns.forEach((fn) => fn());
      this._onStartFns = [];
      this._started = true;
      if (this._specialStyles) {
        this._specialStyles.start();
      }
    }
    this.domPlayer.play();
  }
  pause() {
    this.init();
    this.domPlayer.pause();
  }
  finish() {
    this.init();
    if (this._specialStyles) {
      this._specialStyles.finish();
    }
    this._onFinish();
    this.domPlayer.finish();
  }
  reset() {
    this._resetDomPlayerState();
    this._destroyed = false;
    this._finished = false;
    this._started = false;
    this._onStartFns = this._originalOnStartFns;
    this._onDoneFns = this._originalOnDoneFns;
  }
  _resetDomPlayerState() {
    if (this.domPlayer) {
      this.domPlayer.cancel();
    }
  }
  restart() {
    this.reset();
    this.play();
  }
  hasStarted() {
    return this._started;
  }
  destroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      this._resetDomPlayerState();
      this._onFinish();
      if (this._specialStyles) {
        this._specialStyles.destroy();
      }
      this._onDestroyFns.forEach((fn) => fn());
      this._onDestroyFns = [];
    }
  }
  setPosition(p2) {
    if (this.domPlayer === void 0) {
      this.init();
    }
    this.domPlayer.currentTime = p2 * this.time;
  }
  getPosition() {
    return +(this.domPlayer.currentTime ?? 0) / this.time;
  }
  get totalTime() {
    return this._delay + this._duration;
  }
  beforeDestroy() {
    const styles2 = /* @__PURE__ */ new Map();
    if (this.hasStarted()) {
      const finalKeyframe = this._finalKeyframe;
      finalKeyframe.forEach((val, prop) => {
        if (prop !== "offset") {
          styles2.set(prop, this._finished ? val : computeStyle(this.element, prop));
        }
      });
    }
    this.currentSnapshot = styles2;
  }
  /** @internal */
  triggerCallback(phaseName) {
    const methods = phaseName === "start" ? this._onStartFns : this._onDoneFns;
    methods.forEach((fn) => fn());
    methods.length = 0;
  }
};
var WebAnimationsDriver = class {
  validateStyleProperty(prop) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      return validateStyleProperty(prop);
    }
    return true;
  }
  validateAnimatableStyleProperty(prop) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const cssProp = camelCaseToDashCase2(prop);
      return validateWebAnimatableStyleProperty(cssProp);
    }
    return true;
  }
  containsElement(elm1, elm2) {
    return containsElement(elm1, elm2);
  }
  getParentElement(element) {
    return getParentElement(element);
  }
  query(element, selector, multi) {
    return invokeQuery(element, selector, multi);
  }
  computeStyle(element, prop, defaultValue) {
    return computeStyle(element, prop);
  }
  animate(element, keyframes, duration, delay, easing, previousPlayers = []) {
    const fill = delay == 0 ? "both" : "forwards";
    const playerOptions = {
      duration,
      delay,
      fill
    };
    if (easing) {
      playerOptions["easing"] = easing;
    }
    const previousStyles = /* @__PURE__ */ new Map();
    const previousWebAnimationPlayers = previousPlayers.filter((player) => player instanceof WebAnimationsPlayer);
    if (allowPreviousPlayerStylesMerge(duration, delay)) {
      previousWebAnimationPlayers.forEach((player) => {
        player.currentSnapshot.forEach((val, prop) => previousStyles.set(prop, val));
      });
    }
    let _keyframes = normalizeKeyframes(keyframes).map((styles2) => new Map(styles2));
    _keyframes = balancePreviousStylesIntoKeyframes(element, _keyframes, previousStyles);
    const specialStyles = packageNonAnimatableStyles(element, _keyframes);
    return new WebAnimationsPlayer(element, _keyframes, playerOptions, specialStyles);
  }
};
var ANIMATION_PREFIX = "@";
var DISABLE_ANIMATIONS_FLAG = "@.disabled";
var BaseAnimationRenderer = class {
  namespaceId;
  delegate;
  engine;
  _onDestroy;
  // We need to explicitly type this property because of an api-extractor bug
  // See https://github.com/microsoft/rushstack/issues/4390
  \u0275type = 0;
  constructor(namespaceId, delegate, engine, _onDestroy) {
    this.namespaceId = namespaceId;
    this.delegate = delegate;
    this.engine = engine;
    this._onDestroy = _onDestroy;
  }
  get data() {
    return this.delegate.data;
  }
  destroyNode(node) {
    this.delegate.destroyNode?.(node);
  }
  destroy() {
    this.engine.destroy(this.namespaceId, this.delegate);
    this.engine.afterFlushAnimationsDone(() => {
      queueMicrotask(() => {
        this.delegate.destroy();
      });
    });
    this._onDestroy?.();
  }
  createElement(name, namespace2) {
    return this.delegate.createElement(name, namespace2);
  }
  createComment(value2) {
    return this.delegate.createComment(value2);
  }
  createText(value2) {
    return this.delegate.createText(value2);
  }
  appendChild(parent, newChild) {
    this.delegate.appendChild(parent, newChild);
    this.engine.onInsert(this.namespaceId, newChild, parent, false);
  }
  insertBefore(parent, newChild, refChild, isMove = true) {
    this.delegate.insertBefore(parent, newChild, refChild);
    this.engine.onInsert(this.namespaceId, newChild, parent, isMove);
  }
  removeChild(parent, oldChild, isHostElement) {
    if (this.parentNode(oldChild)) {
      this.engine.onRemove(this.namespaceId, oldChild, this.delegate);
    }
  }
  selectRootElement(selectorOrNode, preserveContent) {
    return this.delegate.selectRootElement(selectorOrNode, preserveContent);
  }
  parentNode(node) {
    return this.delegate.parentNode(node);
  }
  nextSibling(node) {
    return this.delegate.nextSibling(node);
  }
  setAttribute(el, name, value2, namespace2) {
    this.delegate.setAttribute(el, name, value2, namespace2);
  }
  removeAttribute(el, name, namespace2) {
    this.delegate.removeAttribute(el, name, namespace2);
  }
  addClass(el, name) {
    this.delegate.addClass(el, name);
  }
  removeClass(el, name) {
    this.delegate.removeClass(el, name);
  }
  setStyle(el, style2, value2, flags) {
    this.delegate.setStyle(el, style2, value2, flags);
  }
  removeStyle(el, style2, flags) {
    this.delegate.removeStyle(el, style2, flags);
  }
  setProperty(el, name, value2) {
    if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
      this.disableAnimations(el, !!value2);
    } else {
      this.delegate.setProperty(el, name, value2);
    }
  }
  setValue(node, value2) {
    this.delegate.setValue(node, value2);
  }
  listen(target, eventName, callback) {
    return this.delegate.listen(target, eventName, callback);
  }
  disableAnimations(element, value2) {
    this.engine.disableAnimations(element, value2);
  }
};
var AnimationRenderer = class extends BaseAnimationRenderer {
  factory;
  constructor(factory, namespaceId, delegate, engine, onDestroy) {
    super(namespaceId, delegate, engine, onDestroy);
    this.factory = factory;
    this.namespaceId = namespaceId;
  }
  setProperty(el, name, value2) {
    if (name.charAt(0) == ANIMATION_PREFIX) {
      if (name.charAt(1) == "." && name == DISABLE_ANIMATIONS_FLAG) {
        value2 = value2 === void 0 ? true : !!value2;
        this.disableAnimations(el, value2);
      } else {
        this.engine.process(this.namespaceId, el, name.slice(1), value2);
      }
    } else {
      this.delegate.setProperty(el, name, value2);
    }
  }
  listen(target, eventName, callback) {
    if (eventName.charAt(0) == ANIMATION_PREFIX) {
      const element = resolveElementFromTarget(target);
      let name = eventName.slice(1);
      let phase = "";
      if (name.charAt(0) != ANIMATION_PREFIX) {
        [name, phase] = parseTriggerCallbackName(name);
      }
      return this.engine.listen(this.namespaceId, element, name, phase, (event) => {
        const countId = event["_data"] || -1;
        this.factory.scheduleListenerCallback(countId, callback, event);
      });
    }
    return this.delegate.listen(target, eventName, callback);
  }
};
function resolveElementFromTarget(target) {
  switch (target) {
    case "body":
      return document.body;
    case "document":
      return document;
    case "window":
      return window;
    default:
      return target;
  }
}
function parseTriggerCallbackName(triggerName) {
  const dotIndex = triggerName.indexOf(".");
  const trigger2 = triggerName.substring(0, dotIndex);
  const phase = triggerName.slice(dotIndex + 1);
  return [trigger2, phase];
}
var AnimationRendererFactory = class {
  delegate;
  engine;
  _zone;
  _currentId = 0;
  _microtaskId = 1;
  _animationCallbacksBuffer = [];
  _rendererCache = /* @__PURE__ */ new Map();
  _cdRecurDepth = 0;
  constructor(delegate, engine, _zone) {
    this.delegate = delegate;
    this.engine = engine;
    this._zone = _zone;
    engine.onRemovalComplete = (element, delegate2) => {
      delegate2?.removeChild(null, element);
    };
  }
  createRenderer(hostElement, type2) {
    const EMPTY_NAMESPACE_ID = "";
    const delegate = this.delegate.createRenderer(hostElement, type2);
    if (!hostElement || !type2?.data?.["animation"]) {
      const cache2 = this._rendererCache;
      let renderer = cache2.get(delegate);
      if (!renderer) {
        const onRendererDestroy = () => cache2.delete(delegate);
        renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine, onRendererDestroy);
        cache2.set(delegate, renderer);
      }
      return renderer;
    }
    const componentId = type2.id;
    const namespaceId = type2.id + "-" + this._currentId;
    this._currentId++;
    this.engine.register(namespaceId, hostElement);
    const registerTrigger = (trigger2) => {
      if (Array.isArray(trigger2)) {
        trigger2.forEach(registerTrigger);
      } else {
        this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger2.name, trigger2);
      }
    };
    const animationTriggers = type2.data["animation"];
    animationTriggers.forEach(registerTrigger);
    return new AnimationRenderer(this, namespaceId, delegate, this.engine);
  }
  begin() {
    this._cdRecurDepth++;
    if (this.delegate.begin) {
      this.delegate.begin();
    }
  }
  _scheduleCountTask() {
    queueMicrotask(() => {
      this._microtaskId++;
    });
  }
  /** @internal */
  scheduleListenerCallback(count3, fn, data) {
    if (count3 >= 0 && count3 < this._microtaskId) {
      this._zone.run(() => fn(data));
      return;
    }
    const animationCallbacksBuffer = this._animationCallbacksBuffer;
    if (animationCallbacksBuffer.length == 0) {
      queueMicrotask(() => {
        this._zone.run(() => {
          animationCallbacksBuffer.forEach((tuple) => {
            const [fn2, data2] = tuple;
            fn2(data2);
          });
          this._animationCallbacksBuffer = [];
        });
      });
    }
    animationCallbacksBuffer.push([fn, data]);
  }
  end() {
    this._cdRecurDepth--;
    if (this._cdRecurDepth == 0) {
      this._zone.runOutsideAngular(() => {
        this._scheduleCountTask();
        this.engine.flush(this._microtaskId);
      });
    }
    if (this.delegate.end) {
      this.delegate.end();
    }
  }
  whenRenderingDone() {
    return this.engine.whenRenderingDone();
  }
};

// node_modules/@angular/platform-browser/fesm2022/animations.mjs
var InjectableAnimationEngine = class _InjectableAnimationEngine extends AnimationEngine {
  // The `ApplicationRef` is injected here explicitly to force the dependency ordering.
  // Since the `ApplicationRef` should be created earlier before the `AnimationEngine`, they
  // both have `ngOnDestroy` hooks and `flush()` must be called after all views are destroyed.
  constructor(doc, driver, normalizer) {
    super(doc, driver, normalizer);
  }
  ngOnDestroy() {
    this.flush();
  }
  static \u0275fac = function InjectableAnimationEngine_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InjectableAnimationEngine)(\u0275\u0275inject(DOCUMENT2), \u0275\u0275inject(AnimationDriver), \u0275\u0275inject(AnimationStyleNormalizer));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _InjectableAnimationEngine,
    factory: _InjectableAnimationEngine.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InjectableAnimationEngine, [{
    type: Injectable
  }], () => [{
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }]
  }, {
    type: AnimationDriver
  }, {
    type: AnimationStyleNormalizer
  }], null);
})();
function instantiateDefaultStyleNormalizer() {
  return new WebAnimationsStyleNormalizer();
}
function instantiateRendererFactory(renderer, engine, zone) {
  return new AnimationRendererFactory(renderer, engine, zone);
}
var SHARED_ANIMATION_PROVIDERS = [{
  provide: AnimationStyleNormalizer,
  useFactory: instantiateDefaultStyleNormalizer
}, {
  provide: AnimationEngine,
  useClass: InjectableAnimationEngine
}, {
  provide: RendererFactory2,
  useFactory: instantiateRendererFactory,
  deps: [DomRendererFactory2, AnimationEngine, NgZone]
}];
var BROWSER_ANIMATIONS_PROVIDERS = [{
  provide: AnimationDriver,
  useFactory: () => new WebAnimationsDriver()
}, {
  provide: ANIMATION_MODULE_TYPE,
  useValue: "BrowserAnimations"
}, ...SHARED_ANIMATION_PROVIDERS];
var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{
  provide: AnimationDriver,
  useClass: NoopAnimationDriver
}, {
  provide: ANIMATION_MODULE_TYPE,
  useValue: "NoopAnimations"
}, ...SHARED_ANIMATION_PROVIDERS];
var BrowserAnimationsModule = class _BrowserAnimationsModule {
  /**
   * Configures the module based on the specified object.
   *
   * @param config Object used to configure the behavior of the `BrowserAnimationsModule`.
   * @see {@link BrowserAnimationsModuleConfig}
   *
   * @usageNotes
   * When registering the `BrowserAnimationsModule`, you can use the `withConfig`
   * function as follows:
   * ```
   * @NgModule({
   *   imports: [BrowserAnimationsModule.withConfig(config)]
   * })
   * class MyNgModule {}
   * ```
   */
  static withConfig(config3) {
    return {
      ngModule: _BrowserAnimationsModule,
      providers: config3.disableAnimations ? BROWSER_NOOP_ANIMATIONS_PROVIDERS : BROWSER_ANIMATIONS_PROVIDERS
    };
  }
  static \u0275fac = function BrowserAnimationsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserAnimationsModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _BrowserAnimationsModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: BROWSER_ANIMATIONS_PROVIDERS,
    imports: [BrowserModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserAnimationsModule, [{
    type: NgModule,
    args: [{
      exports: [BrowserModule],
      providers: BROWSER_ANIMATIONS_PROVIDERS
    }]
  }], null, null);
})();
var NoopAnimationsModule = class _NoopAnimationsModule {
  static \u0275fac = function NoopAnimationsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoopAnimationsModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _NoopAnimationsModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
    imports: [BrowserModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoopAnimationsModule, [{
    type: NgModule,
    args: [{
      exports: [BrowserModule],
      providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS
    }]
  }], null, null);
})();

// src/app/shared/shared.module.ts
var _SharedModule = class _SharedModule {
};
_SharedModule.\u0275fac = function SharedModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _SharedModule)();
};
_SharedModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _SharedModule });
_SharedModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [
  CommonModule,
  FaIconComponent
] });
var SharedModule = _SharedModule;

// src/app/order/order.module.ts
var _OrderModule = class _OrderModule {
};
_OrderModule.\u0275fac = function OrderModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _OrderModule)();
};
_OrderModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _OrderModule });
_OrderModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [
  CommonModule,
  SharedModule,
  FaIconComponent,
  NgxSpinnerModule
] });
var OrderModule = _OrderModule;

// src/app/genericconfig/generic-config-list-filter/generic-config-list-filter.component.ts
var ModuleEnum7 = GenericConfigKeyDto.ModuleEnum;
function GenericConfigListFilterComponent_option_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "option", 4);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const module_r1 = ctx.$implicit;
    \u0275\u0275property("ngValue", module_r1);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", module_r1, " ");
  }
}
var _GenericConfigListFilterComponent = class _GenericConfigListFilterComponent {
  constructor() {
    this.selectedModule = null;
    this.availableModules = Object.values(ModuleEnum7);
    this.selectedModuleEvent = new EventEmitter();
  }
  fireSelectChangedEvent() {
    console.log("Fired event" + this.selectedModule);
    this.selectedModuleEvent.emit(this.selectedModule);
  }
};
_GenericConfigListFilterComponent.\u0275fac = function GenericConfigListFilterComponent_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GenericConfigListFilterComponent)();
};
_GenericConfigListFilterComponent.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GenericConfigListFilterComponent, selectors: [["app-generic-config-list-filter"]], inputs: { selectedModule: "selectedModule" }, outputs: { selectedModuleEvent: "selectedModuleEvent" }, standalone: false, decls: 5, vars: 2, consts: [[1, "input-group", "mt-3", "mb-3", "w-50", "text-center"], ["for", "module-input"], ["id", "module-input", 1, "form-select", "form-select-md", 3, "ngModelChange", "ngModel"], [3, "ngValue", 4, "ngFor", "ngForOf"], [3, "ngValue"]], template: function GenericConfigListFilterComponent_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "label", 1);
    \u0275\u0275text(2, "Module");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "select", 2);
    \u0275\u0275twoWayListener("ngModelChange", function GenericConfigListFilterComponent_Template_select_ngModelChange_3_listener($event) {
      \u0275\u0275twoWayBindingSet(ctx.selectedModule, $event) || (ctx.selectedModule = $event);
      return $event;
    });
    \u0275\u0275listener("ngModelChange", function GenericConfigListFilterComponent_Template_select_ngModelChange_3_listener() {
      return ctx.fireSelectChangedEvent();
    });
    \u0275\u0275template(4, GenericConfigListFilterComponent_option_4_Template, 2, 2, "option", 3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    \u0275\u0275advance(3);
    \u0275\u0275twoWayProperty("ngModel", ctx.selectedModule);
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx.availableModules);
  }
}, dependencies: [NgForOf, NgSelectOption, \u0275NgSelectMultipleOption, SelectControlValueAccessor, NgControlStatus, NgModel], encapsulation: 2 });
var GenericConfigListFilterComponent = _GenericConfigListFilterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GenericConfigListFilterComponent, { className: "GenericConfigListFilterComponent", filePath: "src/app/genericconfig/generic-config-list-filter/generic-config-list-filter.component.ts", lineNumber: 11 });
})();

// src/app/genericconfig/generic-config.module.ts
var _GenericConfigModule = class _GenericConfigModule {
};
_GenericConfigModule.\u0275fac = function GenericConfigModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _GenericConfigModule)();
};
_GenericConfigModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _GenericConfigModule });
_GenericConfigModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [
  CommonModule,
  SharedModule,
  FormsModule,
  NgxSpinnerModule,
  FaIconComponent
] });
var GenericConfigModule = _GenericConfigModule;

// src/app/category/category.module.ts
var _CategoryModule = class _CategoryModule {
};
_CategoryModule.\u0275fac = function CategoryModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _CategoryModule)();
};
_CategoryModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _CategoryModule });
_CategoryModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [
  CommonModule,
  FaIconComponent,
  SharedModule,
  NgxSpinnerModule,
  FormsModule
] });
var CategoryModule = _CategoryModule;

// src/app/account/account.module.ts
var _AccountModule = class _AccountModule {
};
_AccountModule.\u0275fac = function AccountModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AccountModule)();
};
_AccountModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _AccountModule });
_AccountModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [
  CommonModule,
  SharedModule,
  FormsModule,
  NgxSpinnerModule,
  FaIconComponent
] });
var AccountModule = _AccountModule;

// src/app/product/product.module.ts
var _ProductModule = class _ProductModule {
};
_ProductModule.\u0275fac = function ProductModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _ProductModule)();
};
_ProductModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _ProductModule });
_ProductModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [
  CommonModule,
  SharedModule,
  FormsModule,
  NgxSpinnerModule,
  FaIconComponent,
  AngularEditorModule
] });
var ProductModule = _ProductModule;

// src/app/app.module.ts
var _AppModule = class _AppModule {
};
_AppModule.\u0275fac = function AppModule_Factory(__ngFactoryType__) {
  return new (__ngFactoryType__ || _AppModule)();
};
_AppModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _AppModule, bootstrap: [AppComponent] });
_AppModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ providers: [authInterceptorProviders, errorInterceptorProviders, ThemeService, provideHttpClient(withInterceptorsFromDi())], imports: [
  CommonModule,
  BrowserModule,
  AppRoutingModule,
  BrowserAnimationsModule,
  NgxPopperjsModule,
  NgxSpinnerModule,
  FontAwesomeModule,
  FormsModule,
  AngularEditorModule,
  NgToggleModule.forRoot(),
  ToastrModule.forRoot({
    timeOut: 3e3,
    positionClass: "toast-top-right",
    progressBar: true,
    progressAnimation: "increasing"
  }),
  ReactiveFormsModule,
  NgxChartsModule,
  SharedModule,
  ProductModule,
  AccountModule,
  GenericConfigModule,
  CategoryModule,
  OrderModule,
  CommonModule,
  FontAwesomeModule,
  NgToggleModule
] });
var AppModule = _AppModule;

// src/environments/environment.ts
var environment = {
  production: false
};

// src/main.ts
if (environment.production) {
  enableProdMode();
}
platformBrowser().bootstrapModule(AppModule).catch((err) => console.error(err));
/*! Bundled license information:

@angular/core/fesm2022/primitives/signals.mjs:
  (**
   * @license Angular v19.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/core.mjs:
  (**
   * @license Angular v19.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)

@angular/core/fesm2022/core.mjs:
  (*!
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)

@angular/common/fesm2022/common.mjs:
  (**
   * @license Angular v19.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/common/fesm2022/http.mjs:
  (**
   * @license Angular v19.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/platform-browser/fesm2022/platform-browser.mjs:
  (**
   * @license Angular v19.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v19.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@fortawesome/free-solid-svg-icons/index.mjs:
  (*!
   * Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2024 Fonticons, Inc.
   *)

@angular/router/fesm2022/router.mjs:
  (**
   * @license Angular v19.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@fortawesome/fontawesome-svg-core/index.mjs:
  (*!
   * Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2024 Fonticons, Inc.
   *)

@angular/animations/fesm2022/animations.mjs:
  (**
   * @license Angular v19.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/animations/fesm2022/browser.mjs:
  (**
   * @license Angular v19.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/platform-browser/fesm2022/animations.mjs:
  (**
   * @license Angular v19.0.1
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=main.js.map
